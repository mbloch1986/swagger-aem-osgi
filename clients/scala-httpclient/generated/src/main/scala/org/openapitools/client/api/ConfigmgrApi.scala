/**
 * Adobe Experience Manager OSGI config (AEM) API
 * Swagger AEM OSGI is an OpenAPI specification for Adobe Experience Manager (AEM) OSGI Configurations API
 *
 * OpenAPI spec version: 1.0.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api

import java.text.SimpleDateFormat

import org.openapitools.client.model.AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo
import org.openapitools.client.model.AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo
import org.openapitools.client.model.AnalyticsComponentQueryCacheServiceInfo
import org.openapitools.client.model.ApacheSlingHealthCheckResultHTMLSerializerInfo
import org.openapitools.client.model.ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo
import org.openapitools.client.model.ComAdobeAemTransactionCoreImplTransactionRecorderInfo
import org.openapitools.client.model.ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo
import org.openapitools.client.model.ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo
import org.openapitools.client.model.ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo
import org.openapitools.client.model.ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo
import org.openapitools.client.model.ComAdobeCqAccountApiAccountManagementServiceInfo
import org.openapitools.client.model.ComAdobeCqAccountImplAccountManagementServletInfo
import org.openapitools.client.model.ComAdobeCqAddressImplLocationLocationListServletInfo
import org.openapitools.client.model.ComAdobeCqAuditPurgeDamInfo
import org.openapitools.client.model.ComAdobeCqAuditPurgePagesInfo
import org.openapitools.client.model.ComAdobeCqAuditPurgeReplicationInfo
import org.openapitools.client.model.ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo
import org.openapitools.client.model.ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo
import org.openapitools.client.model.ComAdobeCqCdnRewriterImplCDNRewriterInfo
import org.openapitools.client.model.ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo
import org.openapitools.client.model.ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo
import org.openapitools.client.model.ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo
import org.openapitools.client.model.ComAdobeCqCommerceImplAssetStaticImageHandlerInfo
import org.openapitools.client.model.ComAdobeCqCommerceImplAssetVideoHandlerInfo
import org.openapitools.client.model.ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo
import org.openapitools.client.model.ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo
import org.openapitools.client.model.ComAdobeCqCommercePimImplPageEventListenerInfo
import org.openapitools.client.model.ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo
import org.openapitools.client.model.ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo
import org.openapitools.client.model.ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo
import org.openapitools.client.model.ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo
import org.openapitools.client.model.ComAdobeCqDamCfmImplComponentComponentConfigImplInfo
import org.openapitools.client.model.ComAdobeCqDamCfmImplConfFeatureConfigImplInfo
import org.openapitools.client.model.ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo
import org.openapitools.client.model.ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo
import org.openapitools.client.model.ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo
import org.openapitools.client.model.ComAdobeCqDamDmProcessImagePTiffManagerImplInfo
import org.openapitools.client.model.ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo
import org.openapitools.client.model.ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo
import org.openapitools.client.model.ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo
import org.openapitools.client.model.ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo
import org.openapitools.client.model.ComAdobeCqDamS7imagingImplIsImageServerComponentInfo
import org.openapitools.client.model.ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo
import org.openapitools.client.model.ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo
import org.openapitools.client.model.ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo
import org.openapitools.client.model.ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo
import org.openapitools.client.model.ComAdobeCqDeserfwImplDeserializationFirewallImplInfo
import org.openapitools.client.model.ComAdobeCqDtmImplServiceDTMWebServiceImplInfo
import org.openapitools.client.model.ComAdobeCqDtmImplServletsDTMDeployHookServletInfo
import org.openapitools.client.model.ComAdobeCqDtmReactorImplServiceWebServiceImplInfo
import org.openapitools.client.model.ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo
import org.openapitools.client.model.ComAdobeCqHcContentPackagesHealthCheckInfo
import org.openapitools.client.model.ComAdobeCqHistoryImplHistoryRequestFilterInfo
import org.openapitools.client.model.ComAdobeCqHistoryImplHistoryServiceImplInfo
import org.openapitools.client.model.ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo
import org.openapitools.client.model.ComAdobeCqProjectsImplServletProjectImageServletInfo
import org.openapitools.client.model.ComAdobeCqProjectsPurgeSchedulerInfo
import org.openapitools.client.model.ComAdobeCqScheduledExporterImplScheduledExporterImplInfo
import org.openapitools.client.model.ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo
import org.openapitools.client.model.ComAdobeCqScreensDeviceImplDeviceServiceInfo
import org.openapitools.client.model.ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo
import org.openapitools.client.model.ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo
import org.openapitools.client.model.ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo
import org.openapitools.client.model.ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo
import org.openapitools.client.model.ComAdobeCqScreensImplScreensChannelPostProcessorInfo
import org.openapitools.client.model.ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo
import org.openapitools.client.model.ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo
import org.openapitools.client.model.ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo
import org.openapitools.client.model.ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo
import org.openapitools.client.model.ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo
import org.openapitools.client.model.ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo
import org.openapitools.client.model.ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo
import org.openapitools.client.model.ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo
import org.openapitools.client.model.ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo
import org.openapitools.client.model.ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo
import org.openapitools.client.model.ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo
import org.openapitools.client.model.ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo
import org.openapitools.client.model.ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo
import org.openapitools.client.model.ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo
import org.openapitools.client.model.ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo
import org.openapitools.client.model.ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo
import org.openapitools.client.model.ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo
import org.openapitools.client.model.ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo
import org.openapitools.client.model.ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo
import org.openapitools.client.model.ComAdobeCqSocialCalendarServletsTimeZoneServletInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo
import org.openapitools.client.model.ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo
import org.openapitools.client.model.ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo
import org.openapitools.client.model.ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo
import org.openapitools.client.model.ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo
import org.openapitools.client.model.ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo
import org.openapitools.client.model.ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo
import org.openapitools.client.model.ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo
import org.openapitools.client.model.ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo
import org.openapitools.client.model.ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo
import org.openapitools.client.model.ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo
import org.openapitools.client.model.ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo
import org.openapitools.client.model.ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo
import org.openapitools.client.model.ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo
import org.openapitools.client.model.ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo
import org.openapitools.client.model.ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo
import org.openapitools.client.model.ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo
import org.openapitools.client.model.ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo
import org.openapitools.client.model.ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo
import org.openapitools.client.model.ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo
import org.openapitools.client.model.ComAdobeCqSocialGroupImplGroupServiceImplInfo
import org.openapitools.client.model.ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo
import org.openapitools.client.model.ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo
import org.openapitools.client.model.ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo
import org.openapitools.client.model.ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo
import org.openapitools.client.model.ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo
import org.openapitools.client.model.ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo
import org.openapitools.client.model.ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo
import org.openapitools.client.model.ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo
import org.openapitools.client.model.ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo
import org.openapitools.client.model.ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo
import org.openapitools.client.model.ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo
import org.openapitools.client.model.ComAdobeCqSocialNotificationsImplMentionsRouterInfo
import org.openapitools.client.model.ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo
import org.openapitools.client.model.ComAdobeCqSocialNotificationsImplNotificationsRouterInfo
import org.openapitools.client.model.ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo
import org.openapitools.client.model.ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo
import org.openapitools.client.model.ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo
import org.openapitools.client.model.ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo
import org.openapitools.client.model.ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo
import org.openapitools.client.model.ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo
import org.openapitools.client.model.ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo
import org.openapitools.client.model.ComAdobeCqSocialScoringImplScoringEventListenerInfo
import org.openapitools.client.model.ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo
import org.openapitools.client.model.ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo
import org.openapitools.client.model.ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo
import org.openapitools.client.model.ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo
import org.openapitools.client.model.ComAdobeCqSocialSrpImplSocialSolrConnectorInfo
import org.openapitools.client.model.ComAdobeCqSocialSyncImplDiffChangesObserverInfo
import org.openapitools.client.model.ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo
import org.openapitools.client.model.ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo
import org.openapitools.client.model.ComAdobeCqSocialSyncImplUserSyncListenerImplInfo
import org.openapitools.client.model.ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo
import org.openapitools.client.model.ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo
import org.openapitools.client.model.ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo
import org.openapitools.client.model.ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo
import org.openapitools.client.model.ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo
import org.openapitools.client.model.ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo
import org.openapitools.client.model.ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo
import org.openapitools.client.model.ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo
import org.openapitools.client.model.ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo
import org.openapitools.client.model.ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo
import org.openapitools.client.model.ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo
import org.openapitools.client.model.ComAdobeCqSocialUserImplTransportHttpToPublisherInfo
import org.openapitools.client.model.ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo
import org.openapitools.client.model.ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo
import org.openapitools.client.model.ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo
import org.openapitools.client.model.ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo
import org.openapitools.client.model.ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo
import org.openapitools.client.model.ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo
import org.openapitools.client.model.ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo
import org.openapitools.client.model.ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo
import org.openapitools.client.model.ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo
import org.openapitools.client.model.ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo
import org.openapitools.client.model.ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo
import org.openapitools.client.model.ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo
import org.openapitools.client.model.ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo
import org.openapitools.client.model.ComAdobeFormsCommonServiceImplDefaultDataProviderInfo
import org.openapitools.client.model.ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo
import org.openapitools.client.model.ComAdobeFormsCommonServletTempCleanUpTaskInfo
import org.openapitools.client.model.ComAdobeGraniteAcpPlatformPlatformServletInfo
import org.openapitools.client.model.ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo
import org.openapitools.client.model.ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo
import org.openapitools.client.model.ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo
import org.openapitools.client.model.ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo
import org.openapitools.client.model.ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo
import org.openapitools.client.model.ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo
import org.openapitools.client.model.ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo
import org.openapitools.client.model.ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo
import org.openapitools.client.model.ComAdobeGraniteAuthImsImplIMSProviderImplInfo
import org.openapitools.client.model.ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo
import org.openapitools.client.model.ComAdobeGraniteAuthImsInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthAccesstokenProviderInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthImplGithubProviderImplInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthImplGraniteProviderInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo
import org.openapitools.client.model.ComAdobeGraniteAuthOauthProviderInfo
import org.openapitools.client.model.ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo
import org.openapitools.client.model.ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo
import org.openapitools.client.model.ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo
import org.openapitools.client.model.ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo
import org.openapitools.client.model.ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo
import org.openapitools.client.model.ComAdobeGraniteCompatrouterImplRoutingConfigInfo
import org.openapitools.client.model.ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo
import org.openapitools.client.model.ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo
import org.openapitools.client.model.ComAdobeGraniteContexthubImplContextHubImplInfo
import org.openapitools.client.model.ComAdobeGraniteCorsImplCORSPolicyImplInfo
import org.openapitools.client.model.ComAdobeGraniteCsrfImplCSRFFilterInfo
import org.openapitools.client.model.ComAdobeGraniteCsrfImplCSRFServletInfo
import org.openapitools.client.model.ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo
import org.openapitools.client.model.ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo
import org.openapitools.client.model.ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo
import org.openapitools.client.model.ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo
import org.openapitools.client.model.ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo
import org.openapitools.client.model.ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo
import org.openapitools.client.model.ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo
import org.openapitools.client.model.ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo
import org.openapitools.client.model.ComAdobeGraniteFragsImplRandomFeatureInfo
import org.openapitools.client.model.ComAdobeGraniteHttpcacheFileFileCacheStoreInfo
import org.openapitools.client.model.ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo
import org.openapitools.client.model.ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo
import org.openapitools.client.model.ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo
import org.openapitools.client.model.ComAdobeGraniteInfocollectorInfoCollectorInfo
import org.openapitools.client.model.ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo
import org.openapitools.client.model.ComAdobeGraniteLicenseImplLicenseCheckFilterInfo
import org.openapitools.client.model.ComAdobeGraniteLoggingImplLogAnalyserImplInfo
import org.openapitools.client.model.ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo
import org.openapitools.client.model.ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo
import org.openapitools.client.model.ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo
import org.openapitools.client.model.ComAdobeGraniteMonitoringImplScriptConfigImplInfo
import org.openapitools.client.model.ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo
import org.openapitools.client.model.ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo
import org.openapitools.client.model.ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo
import org.openapitools.client.model.ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo
import org.openapitools.client.model.ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo
import org.openapitools.client.model.ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo
import org.openapitools.client.model.ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo
import org.openapitools.client.model.ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo
import org.openapitools.client.model.ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo
import org.openapitools.client.model.ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo
import org.openapitools.client.model.ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo
import org.openapitools.client.model.ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo
import org.openapitools.client.model.ComAdobeGraniteOptoutImplOptOutServiceImplInfo
import org.openapitools.client.model.ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo
import org.openapitools.client.model.ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo
import org.openapitools.client.model.ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo
import org.openapitools.client.model.ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo
import org.openapitools.client.model.ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo
import org.openapitools.client.model.ComAdobeGraniteRepositoryImplCommitStatsConfigInfo
import org.openapitools.client.model.ComAdobeGraniteRepositoryServiceUserConfigurationInfo
import org.openapitools.client.model.ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo
import org.openapitools.client.model.ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo
import org.openapitools.client.model.ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo
import org.openapitools.client.model.ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo
import org.openapitools.client.model.ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo
import org.openapitools.client.model.ComAdobeGraniteRestImplServletDefaultGETServletInfo
import org.openapitools.client.model.ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo
import org.openapitools.client.model.ComAdobeGraniteSecurityUserUserPropertiesServiceInfo
import org.openapitools.client.model.ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo
import org.openapitools.client.model.ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo
import org.openapitools.client.model.ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo
import org.openapitools.client.model.ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo
import org.openapitools.client.model.ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo
import org.openapitools.client.model.ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo
import org.openapitools.client.model.ComAdobeGraniteThreaddumpThreadDumpCollectorInfo
import org.openapitools.client.model.ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo
import org.openapitools.client.model.ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo
import org.openapitools.client.model.ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowCoreJobJobHandlerInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowCorePayloadMapCacheInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowCoreWorkflowConfigInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo
import org.openapitools.client.model.ComAdobeGraniteWorkflowPurgeSchedulerInfo
import org.openapitools.client.model.ComAdobeOctopusNcommBootstrapInfo
import org.openapitools.client.model.ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo
import org.openapitools.client.model.ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo
import org.openapitools.client.model.ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo
import org.openapitools.client.model.ComDayCommonsHttpclientInfo
import org.openapitools.client.model.ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo
import org.openapitools.client.model.ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo
import org.openapitools.client.model.ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo
import org.openapitools.client.model.ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo
import org.openapitools.client.model.ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo
import org.openapitools.client.model.ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo
import org.openapitools.client.model.ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo
import org.openapitools.client.model.ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo
import org.openapitools.client.model.ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo
import org.openapitools.client.model.ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo
import org.openapitools.client.model.ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo
import org.openapitools.client.model.ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo
import org.openapitools.client.model.ComDayCqAuthImplCugCugSupportImplInfo
import org.openapitools.client.model.ComDayCqAuthImplLoginSelectorHandlerInfo
import org.openapitools.client.model.ComDayCqCommonsImplExternalizerImplInfo
import org.openapitools.client.model.ComDayCqCommonsServletsRootMappingServletInfo
import org.openapitools.client.model.ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo
import org.openapitools.client.model.ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo
import org.openapitools.client.model.ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo
import org.openapitools.client.model.ComDayCqContentsyncImplContentSyncManagerImplInfo
import org.openapitools.client.model.ComDayCqDamCommonsHandlerStandardImageHandlerInfo
import org.openapitools.client.model.ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo
import org.openapitools.client.model.ComDayCqDamCommonsUtilImplAssetCacheImplInfo
import org.openapitools.client.model.ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo
import org.openapitools.client.model.ComDayCqDamCoreImplAssetMoveListenerInfo
import org.openapitools.client.model.ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo
import org.openapitools.client.model.ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo
import org.openapitools.client.model.ComDayCqDamCoreImplDamChangeEventListenerInfo
import org.openapitools.client.model.ComDayCqDamCoreImplDamEventPurgeServiceInfo
import org.openapitools.client.model.ComDayCqDamCoreImplDamEventRecorderImplInfo
import org.openapitools.client.model.ComDayCqDamCoreImplEventDamEventAuditListenerInfo
import org.openapitools.client.model.ComDayCqDamCoreImplExpiryNotificationJobImplInfo
import org.openapitools.client.model.ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo
import org.openapitools.client.model.ComDayCqDamCoreImplGfxCommonsGfxRendererInfo
import org.openapitools.client.model.ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo
import org.openapitools.client.model.ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo
import org.openapitools.client.model.ComDayCqDamCoreImplHandlerJpegHandlerInfo
import org.openapitools.client.model.ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo
import org.openapitools.client.model.ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo
import org.openapitools.client.model.ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo
import org.openapitools.client.model.ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo
import org.openapitools.client.model.ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo
import org.openapitools.client.model.ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo
import org.openapitools.client.model.ComDayCqDamCoreImplLightboxLightboxServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo
import org.openapitools.client.model.ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo
import org.openapitools.client.model.ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo
import org.openapitools.client.model.ComDayCqDamCoreImplMissingMetadataNotificationJobInfo
import org.openapitools.client.model.ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo
import org.openapitools.client.model.ComDayCqDamCoreImplProcessTextExtractionProcessInfo
import org.openapitools.client.model.ComDayCqDamCoreImplRenditionMakerImplInfo
import org.openapitools.client.model.ComDayCqDamCoreImplReportsReportExportServiceInfo
import org.openapitools.client.model.ComDayCqDamCoreImplReportsReportPurgeServiceInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletAssetDownloadServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletAssetStatusServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletAssetXMPSearchServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletBatchMetadataServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletBinaryProviderServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletCollectionServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletCollectionsServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletCompanionServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletCreateAssetServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletDamContentDispositionFilterInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletGuidLookupFilterInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletHealthCheckServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletMetadataGetServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplServletResourceCollectionServletInfo
import org.openapitools.client.model.ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo
import org.openapitools.client.model.ComDayCqDamCoreImplUnzipUnzipConfigInfo
import org.openapitools.client.model.ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo
import org.openapitools.client.model.ComDayCqDamCoreProcessExtractMetadataProcessInfo
import org.openapitools.client.model.ComDayCqDamCoreProcessMetadataProcessorProcessInfo
import org.openapitools.client.model.ComDayCqDamHandlerFfmpegLocatorImplInfo
import org.openapitools.client.model.ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo
import org.openapitools.client.model.ComDayCqDamHandlerStandardPdfPdfHandlerInfo
import org.openapitools.client.model.ComDayCqDamHandlerStandardPsPostScriptHandlerInfo
import org.openapitools.client.model.ComDayCqDamHandlerStandardPsdPsdHandlerInfo
import org.openapitools.client.model.ComDayCqDamIdsImplIDSJobProcessorInfo
import org.openapitools.client.model.ComDayCqDamIdsImplIDSPoolManagerImplInfo
import org.openapitools.client.model.ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo
import org.openapitools.client.model.ComDayCqDamInddImplServletSnippetCreationServletInfo
import org.openapitools.client.model.ComDayCqDamInddProcessINDDMediaExtractProcessInfo
import org.openapitools.client.model.ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo
import org.openapitools.client.model.ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo
import org.openapitools.client.model.ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo
import org.openapitools.client.model.ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo
import org.openapitools.client.model.ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo
import org.openapitools.client.model.ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo
import org.openapitools.client.model.ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo
import org.openapitools.client.model.ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo
import org.openapitools.client.model.ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo
import org.openapitools.client.model.ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo
import org.openapitools.client.model.ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo
import org.openapitools.client.model.ComDayCqDamScene7ImplScene7APIClientImplInfo
import org.openapitools.client.model.ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo
import org.openapitools.client.model.ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo
import org.openapitools.client.model.ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo
import org.openapitools.client.model.ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo
import org.openapitools.client.model.ComDayCqDamScene7ImplScene7UploadServiceImplInfo
import org.openapitools.client.model.ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo
import org.openapitools.client.model.ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo
import org.openapitools.client.model.ComDayCqDamVideoImplServletVideoTestServletInfo
import org.openapitools.client.model.ComDayCqExtwidgetServletsImageSpriteServletInfo
import org.openapitools.client.model.ComDayCqImageInternalFontFontHelperInfo
import org.openapitools.client.model.ComDayCqJcrclustersupportClusterStartLevelControllerInfo
import org.openapitools.client.model.ComDayCqMailerDefaultMailServiceInfo
import org.openapitools.client.model.ComDayCqMailerImplCqMailingServiceInfo
import org.openapitools.client.model.ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo
import org.openapitools.client.model.ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo
import org.openapitools.client.model.ComDayCqMcmCampaignImplIntegrationConfigImplInfo
import org.openapitools.client.model.ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo
import org.openapitools.client.model.ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo
import org.openapitools.client.model.ComDayCqMcmImplMCMConfigurationInfo
import org.openapitools.client.model.ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo
import org.openapitools.client.model.ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo
import org.openapitools.client.model.ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo
import org.openapitools.client.model.ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo
import org.openapitools.client.model.ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo
import org.openapitools.client.model.ComDayCqNotificationImplNotificationServiceImplInfo
import org.openapitools.client.model.ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo
import org.openapitools.client.model.ComDayCqPollingImporterImplManagedPollConfigImplInfo
import org.openapitools.client.model.ComDayCqPollingImporterImplManagedPollingImporterImplInfo
import org.openapitools.client.model.ComDayCqPollingImporterImplPollingImporterImplInfo
import org.openapitools.client.model.ComDayCqReplicationAuditReplicationEventListenerInfo
import org.openapitools.client.model.ComDayCqReplicationContentStaticContentBuilderInfo
import org.openapitools.client.model.ComDayCqReplicationImplAgentManagerImplInfo
import org.openapitools.client.model.ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo
import org.openapitools.client.model.ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo
import org.openapitools.client.model.ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo
import org.openapitools.client.model.ComDayCqReplicationImplReplicationReceiverImplInfo
import org.openapitools.client.model.ComDayCqReplicationImplReplicatorImplInfo
import org.openapitools.client.model.ComDayCqReplicationImplReverseReplicatorInfo
import org.openapitools.client.model.ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo
import org.openapitools.client.model.ComDayCqReplicationImplTransportHttpInfo
import org.openapitools.client.model.ComDayCqReportingImplCacheCacheImplInfo
import org.openapitools.client.model.ComDayCqReportingImplConfigServiceImplInfo
import org.openapitools.client.model.ComDayCqReportingImplRLogAnalyzerInfo
import org.openapitools.client.model.ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo
import org.openapitools.client.model.ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo
import org.openapitools.client.model.ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo
import org.openapitools.client.model.ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo
import org.openapitools.client.model.ComDayCqRewriterProcessorImplHtmlParserFactoryInfo
import org.openapitools.client.model.ComDayCqSearchImplBuilderQueryBuilderImplInfo
import org.openapitools.client.model.ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo
import org.openapitools.client.model.ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo
import org.openapitools.client.model.ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo
import org.openapitools.client.model.ComDayCqSecurityACLSetupInfo
import org.openapitools.client.model.ComDayCqStatisticsImplStatisticsServiceImplInfo
import org.openapitools.client.model.ComDayCqTaggingImplJcrTagManagerFactoryImplInfo
import org.openapitools.client.model.ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo
import org.openapitools.client.model.ComDayCqTaggingImplTagGarbageCollectorInfo
import org.openapitools.client.model.ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo
import org.openapitools.client.model.ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplCommandsWCMCommandServletInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplEventPageEventAuditListenerInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplEventPagePostProcessorInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplEventTemplatePostProcessorInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplLanguageManagerImplInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplServletsFindReplaceServletInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplServletsReferenceSearchServletInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplServletsThumbnailServletInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplVersionManagerImplInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplVersionPurgeTaskInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplWCMDebugFilterInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo
import org.openapitools.client.model.ComDayCqWcmCoreImplWarpTimeWarpFilterInfo
import org.openapitools.client.model.ComDayCqWcmCoreMvtMVTStatisticsImplInfo
import org.openapitools.client.model.ComDayCqWcmCoreStatsPageViewStatisticsImplInfo
import org.openapitools.client.model.ComDayCqWcmCoreWCMRequestFilterInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterDesignPackageImporterInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo
import org.openapitools.client.model.ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo
import org.openapitools.client.model.ComDayCqWcmFoundationFormsImplFormChooserServletInfo
import org.openapitools.client.model.ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo
import org.openapitools.client.model.ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo
import org.openapitools.client.model.ComDayCqWcmFoundationFormsImplMailServletInfo
import org.openapitools.client.model.ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo
import org.openapitools.client.model.ComDayCqWcmFoundationImplHTTPAuthHandlerInfo
import org.openapitools.client.model.ComDayCqWcmFoundationImplPageImpressionsTrackerInfo
import org.openapitools.client.model.ComDayCqWcmFoundationImplPageRedirectServletInfo
import org.openapitools.client.model.ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo
import org.openapitools.client.model.ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo
import org.openapitools.client.model.ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo
import org.openapitools.client.model.ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo
import org.openapitools.client.model.ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo
import org.openapitools.client.model.ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo
import org.openapitools.client.model.ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo
import org.openapitools.client.model.ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo
import org.openapitools.client.model.ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo
import org.openapitools.client.model.ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo
import org.openapitools.client.model.ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo
import org.openapitools.client.model.ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo
import org.openapitools.client.model.ComDayCqWcmMsmImplRolloutManagerImplInfo
import org.openapitools.client.model.ComDayCqWcmMsmImplServletsAuditLogServletInfo
import org.openapitools.client.model.ComDayCqWcmNotificationEmailImplEmailChannelInfo
import org.openapitools.client.model.ComDayCqWcmNotificationImplNotificationManagerImplInfo
import org.openapitools.client.model.ComDayCqWcmScriptingImplBVPManagerInfo
import org.openapitools.client.model.ComDayCqWcmUndoUndoConfigInfo
import org.openapitools.client.model.ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo
import org.openapitools.client.model.ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo
import org.openapitools.client.model.ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo
import org.openapitools.client.model.ComDayCqWidgetImplHtmlLibraryManagerImplInfo
import org.openapitools.client.model.ComDayCqWidgetImplWidgetExtensionProviderImplInfo
import org.openapitools.client.model.ComDayCqWorkflowImplEmailEMailNotificationServiceInfo
import org.openapitools.client.model.ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo
import org.openapitools.client.model.ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo
import org.openapitools.client.model.ComDayCrxSecurityTokenImplTokenCleanupTaskInfo
import org.openapitools.client.model.GuideLocalizationServiceInfo
import org.openapitools.client.model.MessagingUserComponentFactoryInfo
import org.openapitools.client.model.Number
import org.openapitools.client.model.OrgApacheAriesJmxFrameworkStateConfigInfo
import org.openapitools.client.model.OrgApacheFelixEventadminImplEventAdminInfo
import org.openapitools.client.model.OrgApacheFelixHttpInfo
import org.openapitools.client.model.OrgApacheFelixHttpSslfilterSslFilterInfo
import org.openapitools.client.model.OrgApacheFelixJaasConfigurationFactoryInfo
import org.openapitools.client.model.OrgApacheFelixJaasConfigurationSpiInfo
import org.openapitools.client.model.OrgApacheFelixScrScrServiceInfo
import org.openapitools.client.model.OrgApacheFelixSystemreadyImplComponentsCheckInfo
import org.openapitools.client.model.OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo
import org.openapitools.client.model.OrgApacheFelixSystemreadyImplServicesCheckInfo
import org.openapitools.client.model.OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo
import org.openapitools.client.model.OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo
import org.openapitools.client.model.OrgApacheFelixSystemreadySystemReadyMonitorInfo
import org.openapitools.client.model.OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo
import org.openapitools.client.model.OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo
import org.openapitools.client.model.OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo
import org.openapitools.client.model.OrgApacheHttpProxyconfiguratorInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo
import org.openapitools.client.model.OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo
import org.openapitools.client.model.OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo
import org.openapitools.client.model.OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo
import org.openapitools.client.model.OrgApacheSlingAuthCoreImplLogoutServletInfo
import org.openapitools.client.model.OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo
import org.openapitools.client.model.OrgApacheSlingCaconfigImplConfigurationResolverImplInfo
import org.openapitools.client.model.OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo
import org.openapitools.client.model.OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo
import org.openapitools.client.model.OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo
import org.openapitools.client.model.OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo
import org.openapitools.client.model.OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo
import org.openapitools.client.model.OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo
import org.openapitools.client.model.OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo
import org.openapitools.client.model.OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo
import org.openapitools.client.model.OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo
import org.openapitools.client.model.OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo
import org.openapitools.client.model.OrgApacheSlingCommonsLogLogManagerInfo
import org.openapitools.client.model.OrgApacheSlingCommonsMetricsInternalLogReporterInfo
import org.openapitools.client.model.OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo
import org.openapitools.client.model.OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo
import org.openapitools.client.model.OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo
import org.openapitools.client.model.OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo
import org.openapitools.client.model.OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo
import org.openapitools.client.model.OrgApacheSlingDatasourceDataSourceFactoryInfo
import org.openapitools.client.model.OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo
import org.openapitools.client.model.OrgApacheSlingDiscoveryOakConfigInfo
import org.openapitools.client.model.OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo
import org.openapitools.client.model.OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo
import org.openapitools.client.model.OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo
import org.openapitools.client.model.OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo
import org.openapitools.client.model.OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo
import org.openapitools.client.model.OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo
import org.openapitools.client.model.OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo
import org.openapitools.client.model.OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo
import org.openapitools.client.model.OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo
import org.openapitools.client.model.OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo
import org.openapitools.client.model.OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo
import org.openapitools.client.model.OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo
import org.openapitools.client.model.OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo
import org.openapitools.client.model.OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo
import org.openapitools.client.model.OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo
import org.openapitools.client.model.OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo
import org.openapitools.client.model.OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo
import org.openapitools.client.model.OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo
import org.openapitools.client.model.OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo
import org.openapitools.client.model.OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo
import org.openapitools.client.model.OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo
import org.openapitools.client.model.OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo
import org.openapitools.client.model.OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo
import org.openapitools.client.model.OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo
import org.openapitools.client.model.OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo
import org.openapitools.client.model.OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo
import org.openapitools.client.model.OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo
import org.openapitools.client.model.OrgApacheSlingEngineImplLogRequestLoggerInfo
import org.openapitools.client.model.OrgApacheSlingEngineImplLogRequestLoggerServiceInfo
import org.openapitools.client.model.OrgApacheSlingEngineImplSlingMainServletInfo
import org.openapitools.client.model.OrgApacheSlingEngineParametersInfo
import org.openapitools.client.model.OrgApacheSlingEventImplEventingThreadPoolInfo
import org.openapitools.client.model.OrgApacheSlingEventImplJobsDefaultJobManagerInfo
import org.openapitools.client.model.OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo
import org.openapitools.client.model.OrgApacheSlingEventImplJobsJobConsumerManagerInfo
import org.openapitools.client.model.OrgApacheSlingEventJobsQueueConfigurationInfo
import org.openapitools.client.model.OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo
import org.openapitools.client.model.OrgApacheSlingFeatureflagsFeatureInfo
import org.openapitools.client.model.OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo
import org.openapitools.client.model.OrgApacheSlingHapiImplHApiUtilImplInfo
import org.openapitools.client.model.OrgApacheSlingHcCoreImplCompositeHealthCheckInfo
import org.openapitools.client.model.OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo
import org.openapitools.client.model.OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo
import org.openapitools.client.model.OrgApacheSlingHcCoreImplScriptableHealthCheckInfo
import org.openapitools.client.model.OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo
import org.openapitools.client.model.OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo
import org.openapitools.client.model.OrgApacheSlingI18nImplI18NFilterInfo
import org.openapitools.client.model.OrgApacheSlingI18nImplJcrResourceBundleProviderInfo
import org.openapitools.client.model.OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo
import org.openapitools.client.model.OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo
import org.openapitools.client.model.OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo
import org.openapitools.client.model.OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo
import org.openapitools.client.model.OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo
import org.openapitools.client.model.OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo
import org.openapitools.client.model.OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo
import org.openapitools.client.model.OrgApacheSlingJcrRepoinitRepositoryInitializerInfo
import org.openapitools.client.model.OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo
import org.openapitools.client.model.OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo
import org.openapitools.client.model.OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo
import org.openapitools.client.model.OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo
import org.openapitools.client.model.OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo
import org.openapitools.client.model.OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo
import org.openapitools.client.model.OrgApacheSlingJmxProviderImplJMXResourceProviderInfo
import org.openapitools.client.model.OrgApacheSlingModelsImplModelAdapterFactoryInfo
import org.openapitools.client.model.OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo
import org.openapitools.client.model.OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo
import org.openapitools.client.model.OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo
import org.openapitools.client.model.OrgApacheSlingResourcemergerPickerOverridingInfo
import org.openapitools.client.model.OrgApacheSlingScriptingCoreImplScriptCacheImplInfo
import org.openapitools.client.model.OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo
import org.openapitools.client.model.OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo
import org.openapitools.client.model.OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo
import org.openapitools.client.model.OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo
import org.openapitools.client.model.OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo
import org.openapitools.client.model.OrgApacheSlingSecurityImplContentDispositionFilterInfo
import org.openapitools.client.model.OrgApacheSlingSecurityImplReferrerFilterInfo
import org.openapitools.client.model.OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo
import org.openapitools.client.model.OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo
import org.openapitools.client.model.OrgApacheSlingServletsGetDefaultGetServletInfo
import org.openapitools.client.model.OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo
import org.openapitools.client.model.OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo
import org.openapitools.client.model.OrgApacheSlingServletsPostImplSlingPostServletInfo
import org.openapitools.client.model.OrgApacheSlingServletsResolverSlingServletResolverInfo
import org.openapitools.client.model.OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo
import org.openapitools.client.model.OrgApacheSlingStartupfilterImplStartupFilterImplInfo
import org.openapitools.client.model.OrgApacheSlingTenantInternalTenantProviderImplInfo
import org.openapitools.client.model.OrgApacheSlingTracerInternalLogTracerInfo
import org.openapitools.client.model.OrgApacheSlingXssImplXSSFilterImplInfo
import org.openapitools.client.{ApiInvoker, ApiException}

import collection.mutable
import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart
import com.wordnik.swagger.client._
import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import java.net.URI
import java.io.File
import java.util.Date
import java.util.TimeZone
import javax.ws.rs.core.MediaType

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.collection.mutable.HashMap
import scala.util.{Failure, Success, Try}

import org.json4s._

class ConfigmgrApi(
  val defBasePath: String = "http://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new ConfigmgrApiAsyncHelper(client, config)

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param showPlaceholder  (optional)
   * @param maximumCacheEntries  (optional)
   * @param afScriptingCompatversion  (optional)
   * @param makeFileNameUnique  (optional)
   * @param generatingCompliantData  (optional)
   * @return AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo
   */
  def adaptiveFormAndInteractiveCommunicationWebChannelConfiguration(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, showPlaceholder: Option[Boolean] = None, maximumCacheEntries: Option[Integer] = None, afScriptingCompatversion: Option[String] = None, makeFileNameUnique: Option[Boolean] = None, generatingCompliantData: Option[Boolean] = None): Option[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo] = {
    val await = Try(Await.result(adaptiveFormAndInteractiveCommunicationWebChannelConfigurationAsync(post, apply, delete, action, location, propertylist, showPlaceholder, maximumCacheEntries, afScriptingCompatversion, makeFileNameUnique, generatingCompliantData), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param showPlaceholder  (optional)
   * @param maximumCacheEntries  (optional)
   * @param afScriptingCompatversion  (optional)
   * @param makeFileNameUnique  (optional)
   * @param generatingCompliantData  (optional)
   * @return Future(AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo)
   */
  def adaptiveFormAndInteractiveCommunicationWebChannelConfigurationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, showPlaceholder: Option[Boolean] = None, maximumCacheEntries: Option[Integer] = None, afScriptingCompatversion: Option[String] = None, makeFileNameUnique: Option[Boolean] = None, generatingCompliantData: Option[Boolean] = None): Future[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo] = {
      helper.adaptiveFormAndInteractiveCommunicationWebChannelConfiguration(post, apply, delete, action, location, propertylist, showPlaceholder, maximumCacheEntries, afScriptingCompatversion, makeFileNameUnique, generatingCompliantData)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fontList  (optional)
   * @return AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo
   */
  def adaptiveFormAndInteractiveCommunicationWebChannelThemeConfigur(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fontList: Option[List[String]] = None): Option[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo] = {
    val await = Try(Await.result(adaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurAsync(post, apply, delete, action, location, propertylist, fontList), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fontList  (optional)
   * @return Future(AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo)
   */
  def adaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fontList: Option[List[String]] = None): Future[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo] = {
      helper.adaptiveFormAndInteractiveCommunicationWebChannelThemeConfigur(post, apply, delete, action, location, propertylist, fontList)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsComponentQueryCacheSize  (optional)
   * @return AnalyticsComponentQueryCacheServiceInfo
   */
  def analyticsComponentQueryCacheService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsComponentQueryCacheSize: Option[Integer] = None): Option[AnalyticsComponentQueryCacheServiceInfo] = {
    val await = Try(Await.result(analyticsComponentQueryCacheServiceAsync(post, apply, delete, action, location, propertylist, cqAnalyticsComponentQueryCacheSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsComponentQueryCacheSize  (optional)
   * @return Future(AnalyticsComponentQueryCacheServiceInfo)
   */
  def analyticsComponentQueryCacheServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsComponentQueryCacheSize: Option[Integer] = None): Future[AnalyticsComponentQueryCacheServiceInfo] = {
      helper.analyticsComponentQueryCacheService(post, apply, delete, action, location, propertylist, cqAnalyticsComponentQueryCacheSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param styleString  (optional)
   * @return ApacheSlingHealthCheckResultHTMLSerializerInfo
   */
  def apacheSlingHealthCheckResultHTMLSerializer(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, styleString: Option[String] = None): Option[ApacheSlingHealthCheckResultHTMLSerializerInfo] = {
    val await = Try(Await.result(apacheSlingHealthCheckResultHTMLSerializerAsync(post, apply, delete, action, location, propertylist, styleString), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param styleString  (optional)
   * @return Future(ApacheSlingHealthCheckResultHTMLSerializerInfo)
   */
  def apacheSlingHealthCheckResultHTMLSerializerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, styleString: Option[String] = None): Future[ApacheSlingHealthCheckResultHTMLSerializerInfo] = {
      helper.apacheSlingHealthCheckResultHTMLSerializer(post, apply, delete, action, location, propertylist, styleString)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param formsManagerConfigIncludeOOTBTemplates  (optional)
   * @param formsManagerConfigIncludeDeprecatedTemplates  (optional)
   * @return ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo
   */
  def comAdobeAemFormsndocumentsConfigAEMFormsManagerConfiguration(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, formsManagerConfigIncludeOOTBTemplates: Option[Boolean] = None, formsManagerConfigIncludeDeprecatedTemplates: Option[Boolean] = None): Option[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo] = {
    val await = Try(Await.result(comAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationAsync(post, apply, delete, action, location, propertylist, formsManagerConfigIncludeOOTBTemplates, formsManagerConfigIncludeDeprecatedTemplates), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param formsManagerConfigIncludeOOTBTemplates  (optional)
   * @param formsManagerConfigIncludeDeprecatedTemplates  (optional)
   * @return Future(ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo)
   */
  def comAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, formsManagerConfigIncludeOOTBTemplates: Option[Boolean] = None, formsManagerConfigIncludeDeprecatedTemplates: Option[Boolean] = None): Future[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo] = {
      helper.comAdobeAemFormsndocumentsConfigAEMFormsManagerConfiguration(post, apply, delete, action, location, propertylist, formsManagerConfigIncludeOOTBTemplates, formsManagerConfigIncludeDeprecatedTemplates)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isTransactionRecordingEnabled  (optional)
   * @return ComAdobeAemTransactionCoreImplTransactionRecorderInfo
   */
  def comAdobeAemTransactionCoreImplTransactionRecorder(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isTransactionRecordingEnabled: Option[Boolean] = None): Option[ComAdobeAemTransactionCoreImplTransactionRecorderInfo] = {
    val await = Try(Await.result(comAdobeAemTransactionCoreImplTransactionRecorderAsync(post, apply, delete, action, location, propertylist, isTransactionRecordingEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isTransactionRecordingEnabled  (optional)
   * @return Future(ComAdobeAemTransactionCoreImplTransactionRecorderInfo)
   */
  def comAdobeAemTransactionCoreImplTransactionRecorderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isTransactionRecordingEnabled: Option[Boolean] = None): Future[ComAdobeAemTransactionCoreImplTransactionRecorderInfo] = {
      helper.comAdobeAemTransactionCoreImplTransactionRecorder(post, apply, delete, action, location, propertylist, isTransactionRecordingEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @return ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo
   */
  def comAdobeAemUpgradePrechecksHcImplDeprecateIndexesHC(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None): Option[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo] = {
    val await = Try(Await.result(comAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCAsync(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @return Future(ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo)
   */
  def comAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None): Future[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo] = {
      helper.comAdobeAemUpgradePrechecksHcImplDeprecateIndexesHC(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @return ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo
   */
  def comAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHC(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None): Option[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo] = {
    val await = Try(Await.result(comAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCAsync(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @return Future(ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo)
   */
  def comAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None): Future[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo] = {
      helper.comAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHC(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param preUpgradeMaintenanceTasks  (optional)
   * @param preUpgradeHcTags  (optional)
   * @return ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo
   */
  def comAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, preUpgradeMaintenanceTasks: Option[List[String]] = None, preUpgradeHcTags: Option[List[String]] = None): Option[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo] = {
    val await = Try(Await.result(comAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplAsync(post, apply, delete, action, location, propertylist, preUpgradeMaintenanceTasks, preUpgradeHcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param preUpgradeMaintenanceTasks  (optional)
   * @param preUpgradeHcTags  (optional)
   * @return Future(ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo)
   */
  def comAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, preUpgradeMaintenanceTasks: Option[List[String]] = None, preUpgradeHcTags: Option[List[String]] = None): Future[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo] = {
      helper.comAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImpl(post, apply, delete, action, location, propertylist, preUpgradeMaintenanceTasks, preUpgradeHcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param rootPath  (optional)
   * @param fixInconsistencies  (optional)
   * @return ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo
   */
  def comAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, rootPath: Option[String] = None, fixInconsistencies: Option[Boolean] = None): Option[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo] = {
    val await = Try(Await.result(comAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplAsync(post, apply, delete, action, location, propertylist, rootPath, fixInconsistencies), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param rootPath  (optional)
   * @param fixInconsistencies  (optional)
   * @return Future(ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo)
   */
  def comAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, rootPath: Option[String] = None, fixInconsistencies: Option[Boolean] = None): Future[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo] = {
      helper.comAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImpl(post, apply, delete, action, location, propertylist, rootPath, fixInconsistencies)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAccountmanagerTokenValidityPeriod  (optional)
   * @param cqAccountmanagerConfigRequestnewaccountMail  (optional)
   * @param cqAccountmanagerConfigRequestnewpwdMail  (optional)
   * @return ComAdobeCqAccountApiAccountManagementServiceInfo
   */
  def comAdobeCqAccountApiAccountManagementService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAccountmanagerTokenValidityPeriod: Option[Integer] = None, cqAccountmanagerConfigRequestnewaccountMail: Option[String] = None, cqAccountmanagerConfigRequestnewpwdMail: Option[String] = None): Option[ComAdobeCqAccountApiAccountManagementServiceInfo] = {
    val await = Try(Await.result(comAdobeCqAccountApiAccountManagementServiceAsync(post, apply, delete, action, location, propertylist, cqAccountmanagerTokenValidityPeriod, cqAccountmanagerConfigRequestnewaccountMail, cqAccountmanagerConfigRequestnewpwdMail), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAccountmanagerTokenValidityPeriod  (optional)
   * @param cqAccountmanagerConfigRequestnewaccountMail  (optional)
   * @param cqAccountmanagerConfigRequestnewpwdMail  (optional)
   * @return Future(ComAdobeCqAccountApiAccountManagementServiceInfo)
   */
  def comAdobeCqAccountApiAccountManagementServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAccountmanagerTokenValidityPeriod: Option[Integer] = None, cqAccountmanagerConfigRequestnewaccountMail: Option[String] = None, cqAccountmanagerConfigRequestnewpwdMail: Option[String] = None): Future[ComAdobeCqAccountApiAccountManagementServiceInfo] = {
      helper.comAdobeCqAccountApiAccountManagementService(post, apply, delete, action, location, propertylist, cqAccountmanagerTokenValidityPeriod, cqAccountmanagerConfigRequestnewaccountMail, cqAccountmanagerConfigRequestnewpwdMail)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAccountmanagerConfigInformnewaccountMail  (optional)
   * @param cqAccountmanagerConfigInformnewpwdMail  (optional)
   * @return ComAdobeCqAccountImplAccountManagementServletInfo
   */
  def comAdobeCqAccountImplAccountManagementServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAccountmanagerConfigInformnewaccountMail: Option[String] = None, cqAccountmanagerConfigInformnewpwdMail: Option[String] = None): Option[ComAdobeCqAccountImplAccountManagementServletInfo] = {
    val await = Try(Await.result(comAdobeCqAccountImplAccountManagementServletAsync(post, apply, delete, action, location, propertylist, cqAccountmanagerConfigInformnewaccountMail, cqAccountmanagerConfigInformnewpwdMail), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAccountmanagerConfigInformnewaccountMail  (optional)
   * @param cqAccountmanagerConfigInformnewpwdMail  (optional)
   * @return Future(ComAdobeCqAccountImplAccountManagementServletInfo)
   */
  def comAdobeCqAccountImplAccountManagementServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAccountmanagerConfigInformnewaccountMail: Option[String] = None, cqAccountmanagerConfigInformnewpwdMail: Option[String] = None): Future[ComAdobeCqAccountImplAccountManagementServletInfo] = {
      helper.comAdobeCqAccountImplAccountManagementServlet(post, apply, delete, action, location, propertylist, cqAccountmanagerConfigInformnewaccountMail, cqAccountmanagerConfigInformnewpwdMail)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAddressLocationDefaultMaxResults  (optional)
   * @return ComAdobeCqAddressImplLocationLocationListServletInfo
   */
  def comAdobeCqAddressImplLocationLocationListServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAddressLocationDefaultMaxResults: Option[Integer] = None): Option[ComAdobeCqAddressImplLocationLocationListServletInfo] = {
    val await = Try(Await.result(comAdobeCqAddressImplLocationLocationListServletAsync(post, apply, delete, action, location, propertylist, cqAddressLocationDefaultMaxResults), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAddressLocationDefaultMaxResults  (optional)
   * @return Future(ComAdobeCqAddressImplLocationLocationListServletInfo)
   */
  def comAdobeCqAddressImplLocationLocationListServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAddressLocationDefaultMaxResults: Option[Integer] = None): Future[ComAdobeCqAddressImplLocationLocationListServletInfo] = {
      helper.comAdobeCqAddressImplLocationLocationListServlet(post, apply, delete, action, location, propertylist, cqAddressLocationDefaultMaxResults)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param auditlogRuleName  (optional)
   * @param auditlogRuleContentpath  (optional)
   * @param auditlogRuleMinimumage  (optional)
   * @param auditlogRuleTypes  (optional)
   * @return ComAdobeCqAuditPurgeDamInfo
   */
  def comAdobeCqAuditPurgeDam(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, auditlogRuleName: Option[String] = None, auditlogRuleContentpath: Option[String] = None, auditlogRuleMinimumage: Option[Integer] = None, auditlogRuleTypes: Option[String] = None): Option[ComAdobeCqAuditPurgeDamInfo] = {
    val await = Try(Await.result(comAdobeCqAuditPurgeDamAsync(post, apply, delete, action, location, propertylist, auditlogRuleName, auditlogRuleContentpath, auditlogRuleMinimumage, auditlogRuleTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param auditlogRuleName  (optional)
   * @param auditlogRuleContentpath  (optional)
   * @param auditlogRuleMinimumage  (optional)
   * @param auditlogRuleTypes  (optional)
   * @return Future(ComAdobeCqAuditPurgeDamInfo)
   */
  def comAdobeCqAuditPurgeDamAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, auditlogRuleName: Option[String] = None, auditlogRuleContentpath: Option[String] = None, auditlogRuleMinimumage: Option[Integer] = None, auditlogRuleTypes: Option[String] = None): Future[ComAdobeCqAuditPurgeDamInfo] = {
      helper.comAdobeCqAuditPurgeDam(post, apply, delete, action, location, propertylist, auditlogRuleName, auditlogRuleContentpath, auditlogRuleMinimumage, auditlogRuleTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param auditlogRuleName  (optional)
   * @param auditlogRuleContentpath  (optional)
   * @param auditlogRuleMinimumage  (optional)
   * @param auditlogRuleTypes  (optional)
   * @return ComAdobeCqAuditPurgePagesInfo
   */
  def comAdobeCqAuditPurgePages(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, auditlogRuleName: Option[String] = None, auditlogRuleContentpath: Option[String] = None, auditlogRuleMinimumage: Option[Integer] = None, auditlogRuleTypes: Option[String] = None): Option[ComAdobeCqAuditPurgePagesInfo] = {
    val await = Try(Await.result(comAdobeCqAuditPurgePagesAsync(post, apply, delete, action, location, propertylist, auditlogRuleName, auditlogRuleContentpath, auditlogRuleMinimumage, auditlogRuleTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param auditlogRuleName  (optional)
   * @param auditlogRuleContentpath  (optional)
   * @param auditlogRuleMinimumage  (optional)
   * @param auditlogRuleTypes  (optional)
   * @return Future(ComAdobeCqAuditPurgePagesInfo)
   */
  def comAdobeCqAuditPurgePagesAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, auditlogRuleName: Option[String] = None, auditlogRuleContentpath: Option[String] = None, auditlogRuleMinimumage: Option[Integer] = None, auditlogRuleTypes: Option[String] = None): Future[ComAdobeCqAuditPurgePagesInfo] = {
      helper.comAdobeCqAuditPurgePages(post, apply, delete, action, location, propertylist, auditlogRuleName, auditlogRuleContentpath, auditlogRuleMinimumage, auditlogRuleTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param auditlogRuleName  (optional)
   * @param auditlogRuleContentpath  (optional)
   * @param auditlogRuleMinimumage  (optional)
   * @param auditlogRuleTypes  (optional)
   * @return ComAdobeCqAuditPurgeReplicationInfo
   */
  def comAdobeCqAuditPurgeReplication(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, auditlogRuleName: Option[String] = None, auditlogRuleContentpath: Option[String] = None, auditlogRuleMinimumage: Option[Integer] = None, auditlogRuleTypes: Option[String] = None): Option[ComAdobeCqAuditPurgeReplicationInfo] = {
    val await = Try(Await.result(comAdobeCqAuditPurgeReplicationAsync(post, apply, delete, action, location, propertylist, auditlogRuleName, auditlogRuleContentpath, auditlogRuleMinimumage, auditlogRuleTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param auditlogRuleName  (optional)
   * @param auditlogRuleContentpath  (optional)
   * @param auditlogRuleMinimumage  (optional)
   * @param auditlogRuleTypes  (optional)
   * @return Future(ComAdobeCqAuditPurgeReplicationInfo)
   */
  def comAdobeCqAuditPurgeReplicationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, auditlogRuleName: Option[String] = None, auditlogRuleContentpath: Option[String] = None, auditlogRuleMinimumage: Option[Integer] = None, auditlogRuleTypes: Option[String] = None): Future[ComAdobeCqAuditPurgeReplicationInfo] = {
      helper.comAdobeCqAuditPurgeReplication(post, apply, delete, action, location, propertylist, auditlogRuleName, auditlogRuleContentpath, auditlogRuleMinimumage, auditlogRuleTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param keypairId  (optional)
   * @param keypairAlias  (optional)
   * @param cdnrewriterAttributes  (optional)
   * @param cdnRewriterDistributionDomain  (optional)
   * @return ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo
   */
  def comAdobeCqCdnRewriterImplAWSCloudFrontRewriter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, keypairId: Option[String] = None, keypairAlias: Option[String] = None, cdnrewriterAttributes: Option[List[String]] = None, cdnRewriterDistributionDomain: Option[String] = None): Option[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo] = {
    val await = Try(Await.result(comAdobeCqCdnRewriterImplAWSCloudFrontRewriterAsync(post, apply, delete, action, location, propertylist, serviceRanking, keypairId, keypairAlias, cdnrewriterAttributes, cdnRewriterDistributionDomain), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param keypairId  (optional)
   * @param keypairAlias  (optional)
   * @param cdnrewriterAttributes  (optional)
   * @param cdnRewriterDistributionDomain  (optional)
   * @return Future(ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo)
   */
  def comAdobeCqCdnRewriterImplAWSCloudFrontRewriterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, keypairId: Option[String] = None, keypairAlias: Option[String] = None, cdnrewriterAttributes: Option[List[String]] = None, cdnRewriterDistributionDomain: Option[String] = None): Future[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo] = {
      helper.comAdobeCqCdnRewriterImplAWSCloudFrontRewriter(post, apply, delete, action, location, propertylist, serviceRanking, keypairId, keypairAlias, cdnrewriterAttributes, cdnRewriterDistributionDomain)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cdnConfigDistributionDomain  (optional)
   * @param cdnConfigEnableRewriting  (optional)
   * @param cdnConfigPathPrefixes  (optional)
   * @param cdnConfigCdnttl  (optional)
   * @param cdnConfigApplicationProtocol  (optional)
   * @return ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo
   */
  def comAdobeCqCdnRewriterImplCDNConfigServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cdnConfigDistributionDomain: Option[String] = None, cdnConfigEnableRewriting: Option[Boolean] = None, cdnConfigPathPrefixes: Option[List[String]] = None, cdnConfigCdnttl: Option[Integer] = None, cdnConfigApplicationProtocol: Option[String] = None): Option[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqCdnRewriterImplCDNConfigServiceImplAsync(post, apply, delete, action, location, propertylist, cdnConfigDistributionDomain, cdnConfigEnableRewriting, cdnConfigPathPrefixes, cdnConfigCdnttl, cdnConfigApplicationProtocol), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cdnConfigDistributionDomain  (optional)
   * @param cdnConfigEnableRewriting  (optional)
   * @param cdnConfigPathPrefixes  (optional)
   * @param cdnConfigCdnttl  (optional)
   * @param cdnConfigApplicationProtocol  (optional)
   * @return Future(ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo)
   */
  def comAdobeCqCdnRewriterImplCDNConfigServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cdnConfigDistributionDomain: Option[String] = None, cdnConfigEnableRewriting: Option[Boolean] = None, cdnConfigPathPrefixes: Option[List[String]] = None, cdnConfigCdnttl: Option[Integer] = None, cdnConfigApplicationProtocol: Option[String] = None): Future[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo] = {
      helper.comAdobeCqCdnRewriterImplCDNConfigServiceImpl(post, apply, delete, action, location, propertylist, cdnConfigDistributionDomain, cdnConfigEnableRewriting, cdnConfigPathPrefixes, cdnConfigCdnttl, cdnConfigApplicationProtocol)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param cdnrewriterAttributes  (optional)
   * @param cdnRewriterDistributionDomain  (optional)
   * @return ComAdobeCqCdnRewriterImplCDNRewriterInfo
   */
  def comAdobeCqCdnRewriterImplCDNRewriter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, cdnrewriterAttributes: Option[List[String]] = None, cdnRewriterDistributionDomain: Option[String] = None): Option[ComAdobeCqCdnRewriterImplCDNRewriterInfo] = {
    val await = Try(Await.result(comAdobeCqCdnRewriterImplCDNRewriterAsync(post, apply, delete, action, location, propertylist, serviceRanking, cdnrewriterAttributes, cdnRewriterDistributionDomain), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param cdnrewriterAttributes  (optional)
   * @param cdnRewriterDistributionDomain  (optional)
   * @return Future(ComAdobeCqCdnRewriterImplCDNRewriterInfo)
   */
  def comAdobeCqCdnRewriterImplCDNRewriterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, cdnrewriterAttributes: Option[List[String]] = None, cdnRewriterDistributionDomain: Option[String] = None): Future[ComAdobeCqCdnRewriterImplCDNRewriterInfo] = {
      helper.comAdobeCqCdnRewriterImplCDNRewriter(post, apply, delete, action, location, propertylist, serviceRanking, cdnrewriterAttributes, cdnRewriterDistributionDomain)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param flushAgents  (optional)
   * @return ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo
   */
  def comAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandle(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, flushAgents: Option[List[String]] = None): Option[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo] = {
    val await = Try(Await.result(comAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleAsync(post, apply, delete, action, location, propertylist, flushAgents), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param flushAgents  (optional)
   * @return Future(ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo)
   */
  def comAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, flushAgents: Option[List[String]] = None): Future[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo] = {
      helper.comAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandle(post, apply, delete, action, location, propertylist, flushAgents)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommerceAssetHandlerActive  (optional)
   * @param cqCommerceAssetHandlerName  (optional)
   * @return ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo
   */
  def comAdobeCqCommerceImplAssetDynamicImageHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommerceAssetHandlerActive: Option[Boolean] = None, cqCommerceAssetHandlerName: Option[String] = None): Option[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo] = {
    val await = Try(Await.result(comAdobeCqCommerceImplAssetDynamicImageHandlerAsync(post, apply, delete, action, location, propertylist, cqCommerceAssetHandlerActive, cqCommerceAssetHandlerName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommerceAssetHandlerActive  (optional)
   * @param cqCommerceAssetHandlerName  (optional)
   * @return Future(ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo)
   */
  def comAdobeCqCommerceImplAssetDynamicImageHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommerceAssetHandlerActive: Option[Boolean] = None, cqCommerceAssetHandlerName: Option[String] = None): Future[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo] = {
      helper.comAdobeCqCommerceImplAssetDynamicImageHandler(post, apply, delete, action, location, propertylist, cqCommerceAssetHandlerActive, cqCommerceAssetHandlerName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommerceAssetHandlerFallback  (optional)
   * @return ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo
   */
  def comAdobeCqCommerceImplAssetProductAssetHandlerProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommerceAssetHandlerFallback: Option[String] = None): Option[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo] = {
    val await = Try(Await.result(comAdobeCqCommerceImplAssetProductAssetHandlerProviderImplAsync(post, apply, delete, action, location, propertylist, cqCommerceAssetHandlerFallback), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommerceAssetHandlerFallback  (optional)
   * @return Future(ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo)
   */
  def comAdobeCqCommerceImplAssetProductAssetHandlerProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommerceAssetHandlerFallback: Option[String] = None): Future[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo] = {
      helper.comAdobeCqCommerceImplAssetProductAssetHandlerProviderImpl(post, apply, delete, action, location, propertylist, cqCommerceAssetHandlerFallback)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommerceAssetHandlerActive  (optional)
   * @param cqCommerceAssetHandlerName  (optional)
   * @return ComAdobeCqCommerceImplAssetStaticImageHandlerInfo
   */
  def comAdobeCqCommerceImplAssetStaticImageHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommerceAssetHandlerActive: Option[Boolean] = None, cqCommerceAssetHandlerName: Option[String] = None): Option[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo] = {
    val await = Try(Await.result(comAdobeCqCommerceImplAssetStaticImageHandlerAsync(post, apply, delete, action, location, propertylist, cqCommerceAssetHandlerActive, cqCommerceAssetHandlerName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommerceAssetHandlerActive  (optional)
   * @param cqCommerceAssetHandlerName  (optional)
   * @return Future(ComAdobeCqCommerceImplAssetStaticImageHandlerInfo)
   */
  def comAdobeCqCommerceImplAssetStaticImageHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommerceAssetHandlerActive: Option[Boolean] = None, cqCommerceAssetHandlerName: Option[String] = None): Future[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo] = {
      helper.comAdobeCqCommerceImplAssetStaticImageHandler(post, apply, delete, action, location, propertylist, cqCommerceAssetHandlerActive, cqCommerceAssetHandlerName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommerceAssetHandlerActive  (optional)
   * @param cqCommerceAssetHandlerName  (optional)
   * @return ComAdobeCqCommerceImplAssetVideoHandlerInfo
   */
  def comAdobeCqCommerceImplAssetVideoHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommerceAssetHandlerActive: Option[Boolean] = None, cqCommerceAssetHandlerName: Option[String] = None): Option[ComAdobeCqCommerceImplAssetVideoHandlerInfo] = {
    val await = Try(Await.result(comAdobeCqCommerceImplAssetVideoHandlerAsync(post, apply, delete, action, location, propertylist, cqCommerceAssetHandlerActive, cqCommerceAssetHandlerName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommerceAssetHandlerActive  (optional)
   * @param cqCommerceAssetHandlerName  (optional)
   * @return Future(ComAdobeCqCommerceImplAssetVideoHandlerInfo)
   */
  def comAdobeCqCommerceImplAssetVideoHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommerceAssetHandlerActive: Option[Boolean] = None, cqCommerceAssetHandlerName: Option[String] = None): Future[ComAdobeCqCommerceImplAssetVideoHandlerInfo] = {
      helper.comAdobeCqCommerceImplAssetVideoHandler(post, apply, delete, action, location, propertylist, cqCommerceAssetHandlerActive, cqCommerceAssetHandlerName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommercePromotionRoot  (optional)
   * @return ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo
   */
  def comAdobeCqCommerceImplPromotionPromotionManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommercePromotionRoot: Option[String] = None): Option[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo] = {
    val await = Try(Await.result(comAdobeCqCommerceImplPromotionPromotionManagerImplAsync(post, apply, delete, action, location, propertylist, cqCommercePromotionRoot), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommercePromotionRoot  (optional)
   * @return Future(ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo)
   */
  def comAdobeCqCommerceImplPromotionPromotionManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommercePromotionRoot: Option[String] = None): Future[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo] = {
      helper.comAdobeCqCommerceImplPromotionPromotionManagerImpl(post, apply, delete, action, location, propertylist, cqCommercePromotionRoot)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommerceCataloggeneratorBucketsize  (optional)
   * @param cqCommerceCataloggeneratorBucketname  (optional)
   * @param cqCommerceCataloggeneratorExcludedtemplateproperties  (optional)
   * @return ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo
   */
  def comAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommerceCataloggeneratorBucketsize: Option[Integer] = None, cqCommerceCataloggeneratorBucketname: Option[String] = None, cqCommerceCataloggeneratorExcludedtemplateproperties: Option[List[String]] = None): Option[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo] = {
    val await = Try(Await.result(comAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplAsync(post, apply, delete, action, location, propertylist, cqCommerceCataloggeneratorBucketsize, cqCommerceCataloggeneratorBucketname, cqCommerceCataloggeneratorExcludedtemplateproperties), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommerceCataloggeneratorBucketsize  (optional)
   * @param cqCommerceCataloggeneratorBucketname  (optional)
   * @param cqCommerceCataloggeneratorExcludedtemplateproperties  (optional)
   * @return Future(ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo)
   */
  def comAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommerceCataloggeneratorBucketsize: Option[Integer] = None, cqCommerceCataloggeneratorBucketname: Option[String] = None, cqCommerceCataloggeneratorExcludedtemplateproperties: Option[List[String]] = None): Future[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo] = {
      helper.comAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImpl(post, apply, delete, action, location, propertylist, cqCommerceCataloggeneratorBucketsize, cqCommerceCataloggeneratorBucketname, cqCommerceCataloggeneratorExcludedtemplateproperties)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommercePageeventlistenerEnabled  (optional)
   * @return ComAdobeCqCommercePimImplPageEventListenerInfo
   */
  def comAdobeCqCommercePimImplPageEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommercePageeventlistenerEnabled: Option[Boolean] = None): Option[ComAdobeCqCommercePimImplPageEventListenerInfo] = {
    val await = Try(Await.result(comAdobeCqCommercePimImplPageEventListenerAsync(post, apply, delete, action, location, propertylist, cqCommercePageeventlistenerEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqCommercePageeventlistenerEnabled  (optional)
   * @return Future(ComAdobeCqCommercePimImplPageEventListenerInfo)
   */
  def comAdobeCqCommercePimImplPageEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqCommercePageeventlistenerEnabled: Option[Boolean] = None): Future[ComAdobeCqCommercePimImplPageEventListenerInfo] = {
      helper.comAdobeCqCommercePimImplPageEventListener(post, apply, delete, action, location, propertylist, cqCommercePageeventlistenerEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param feedGeneratorAlgorithm  (optional)
   * @return ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo
   */
  def comAdobeCqCommercePimImplProductfeedProductFeedServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, feedGeneratorAlgorithm: Option[String] = None): Option[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqCommercePimImplProductfeedProductFeedServiceImplAsync(post, apply, delete, action, location, propertylist, feedGeneratorAlgorithm), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param feedGeneratorAlgorithm  (optional)
   * @return Future(ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo)
   */
  def comAdobeCqCommercePimImplProductfeedProductFeedServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, feedGeneratorAlgorithm: Option[String] = None): Future[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo] = {
      helper.comAdobeCqCommercePimImplProductfeedProductFeedServiceImpl(post, apply, delete, action, location, propertylist, feedGeneratorAlgorithm)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param reportingservicesUrl  (optional)
   * @return ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo
   */
  def comAdobeCqContentinsightImplReportingServicesSettingsProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, reportingservicesUrl: Option[String] = None): Option[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo] = {
    val await = Try(Await.result(comAdobeCqContentinsightImplReportingServicesSettingsProviderAsync(post, apply, delete, action, location, propertylist, reportingservicesUrl), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param reportingservicesUrl  (optional)
   * @return Future(ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo)
   */
  def comAdobeCqContentinsightImplReportingServicesSettingsProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, reportingservicesUrl: Option[String] = None): Future[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo] = {
      helper.comAdobeCqContentinsightImplReportingServicesSettingsProvider(post, apply, delete, action, location, propertylist, reportingservicesUrl)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param brightedgeUrl  (optional)
   * @return ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo
   */
  def comAdobeCqContentinsightImplServletsBrightEdgeProxyServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, brightedgeUrl: Option[String] = None): Option[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo] = {
    val await = Try(Await.result(comAdobeCqContentinsightImplServletsBrightEdgeProxyServletAsync(post, apply, delete, action, location, propertylist, brightedgeUrl), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param brightedgeUrl  (optional)
   * @return Future(ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo)
   */
  def comAdobeCqContentinsightImplServletsBrightEdgeProxyServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, brightedgeUrl: Option[String] = None): Future[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo] = {
      helper.comAdobeCqContentinsightImplServletsBrightEdgeProxyServlet(post, apply, delete, action, location, propertylist, brightedgeUrl)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param reportingservicesProxyWhitelist  (optional)
   * @return ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo
   */
  def comAdobeCqContentinsightImplServletsReportingServicesProxyServle(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, reportingservicesProxyWhitelist: Option[List[String]] = None): Option[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo] = {
    val await = Try(Await.result(comAdobeCqContentinsightImplServletsReportingServicesProxyServleAsync(post, apply, delete, action, location, propertylist, reportingservicesProxyWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param reportingservicesProxyWhitelist  (optional)
   * @return Future(ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo)
   */
  def comAdobeCqContentinsightImplServletsReportingServicesProxyServleAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, reportingservicesProxyWhitelist: Option[List[String]] = None): Future[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo] = {
      helper.comAdobeCqContentinsightImplServletsReportingServicesProxyServle(post, apply, delete, action, location, propertylist, reportingservicesProxyWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param damCfmComponentResourceType  (optional)
   * @param damCfmComponentFileReferenceProp  (optional)
   * @param damCfmComponentElementsProp  (optional)
   * @param damCfmComponentVariationProp  (optional)
   * @return ComAdobeCqDamCfmImplComponentComponentConfigImplInfo
   */
  def comAdobeCqDamCfmImplComponentComponentConfigImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, damCfmComponentResourceType: Option[String] = None, damCfmComponentFileReferenceProp: Option[String] = None, damCfmComponentElementsProp: Option[String] = None, damCfmComponentVariationProp: Option[String] = None): Option[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo] = {
    val await = Try(Await.result(comAdobeCqDamCfmImplComponentComponentConfigImplAsync(post, apply, delete, action, location, propertylist, damCfmComponentResourceType, damCfmComponentFileReferenceProp, damCfmComponentElementsProp, damCfmComponentVariationProp), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param damCfmComponentResourceType  (optional)
   * @param damCfmComponentFileReferenceProp  (optional)
   * @param damCfmComponentElementsProp  (optional)
   * @param damCfmComponentVariationProp  (optional)
   * @return Future(ComAdobeCqDamCfmImplComponentComponentConfigImplInfo)
   */
  def comAdobeCqDamCfmImplComponentComponentConfigImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, damCfmComponentResourceType: Option[String] = None, damCfmComponentFileReferenceProp: Option[String] = None, damCfmComponentElementsProp: Option[String] = None, damCfmComponentVariationProp: Option[String] = None): Future[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo] = {
      helper.comAdobeCqDamCfmImplComponentComponentConfigImpl(post, apply, delete, action, location, propertylist, damCfmComponentResourceType, damCfmComponentFileReferenceProp, damCfmComponentElementsProp, damCfmComponentVariationProp)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param damCfmResourceTypes  (optional)
   * @param damCfmReferenceProperties  (optional)
   * @return ComAdobeCqDamCfmImplConfFeatureConfigImplInfo
   */
  def comAdobeCqDamCfmImplConfFeatureConfigImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, damCfmResourceTypes: Option[List[String]] = None, damCfmReferenceProperties: Option[List[String]] = None): Option[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo] = {
    val await = Try(Await.result(comAdobeCqDamCfmImplConfFeatureConfigImplAsync(post, apply, delete, action, location, propertylist, damCfmResourceTypes, damCfmReferenceProperties), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param damCfmResourceTypes  (optional)
   * @param damCfmReferenceProperties  (optional)
   * @return Future(ComAdobeCqDamCfmImplConfFeatureConfigImplInfo)
   */
  def comAdobeCqDamCfmImplConfFeatureConfigImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, damCfmResourceTypes: Option[List[String]] = None, damCfmReferenceProperties: Option[List[String]] = None): Future[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo] = {
      helper.comAdobeCqDamCfmImplConfFeatureConfigImpl(post, apply, delete, action, location, propertylist, damCfmResourceTypes, damCfmReferenceProperties)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pipelineType  (optional)
   * @return ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo
   */
  def comAdobeCqDamCfmImplContentRewriterAssetProcessor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pipelineType: Option[String] = None): Option[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo] = {
    val await = Try(Await.result(comAdobeCqDamCfmImplContentRewriterAssetProcessorAsync(post, apply, delete, action, location, propertylist, pipelineType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pipelineType  (optional)
   * @return Future(ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo)
   */
  def comAdobeCqDamCfmImplContentRewriterAssetProcessorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pipelineType: Option[String] = None): Future[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo] = {
      helper.comAdobeCqDamCfmImplContentRewriterAssetProcessor(post, apply, delete, action, location, propertylist, pipelineType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pipelineType  (optional)
   * @return ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo
   */
  def comAdobeCqDamCfmImplContentRewriterParRangeFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pipelineType: Option[String] = None): Option[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo] = {
    val await = Try(Await.result(comAdobeCqDamCfmImplContentRewriterParRangeFilterAsync(post, apply, delete, action, location, propertylist, pipelineType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pipelineType  (optional)
   * @return Future(ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo)
   */
  def comAdobeCqDamCfmImplContentRewriterParRangeFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pipelineType: Option[String] = None): Future[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo] = {
      helper.comAdobeCqDamCfmImplContentRewriterParRangeFilter(post, apply, delete, action, location, propertylist, pipelineType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pipelineType  (optional)
   * @return ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo
   */
  def comAdobeCqDamCfmImplContentRewriterPayloadFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pipelineType: Option[String] = None): Option[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo] = {
    val await = Try(Await.result(comAdobeCqDamCfmImplContentRewriterPayloadFilterAsync(post, apply, delete, action, location, propertylist, pipelineType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pipelineType  (optional)
   * @return Future(ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo)
   */
  def comAdobeCqDamCfmImplContentRewriterPayloadFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pipelineType: Option[String] = None): Future[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo] = {
      helper.comAdobeCqDamCfmImplContentRewriterPayloadFilter(post, apply, delete, action, location, propertylist, pipelineType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxMemory  (optional)
   * @return ComAdobeCqDamDmProcessImagePTiffManagerImplInfo
   */
  def comAdobeCqDamDmProcessImagePTiffManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxMemory: Option[Integer] = None): Option[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo] = {
    val await = Try(Await.result(comAdobeCqDamDmProcessImagePTiffManagerImplAsync(post, apply, delete, action, location, propertylist, maxMemory), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxMemory  (optional)
   * @return Future(ComAdobeCqDamDmProcessImagePTiffManagerImplInfo)
   */
  def comAdobeCqDamDmProcessImagePTiffManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxMemory: Option[Integer] = None): Future[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo] = {
      helper.comAdobeCqDamDmProcessImagePTiffManagerImpl(post, apply, delete, action, location, propertylist, maxMemory)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param dmreplicateonmodifyEnabled  (optional)
   * @param dmreplicateonmodifyForcesyncdeletes  (optional)
   * @return ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo
   */
  def comAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorker(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, dmreplicateonmodifyEnabled: Option[Boolean] = None, dmreplicateonmodifyForcesyncdeletes: Option[Boolean] = None): Option[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo] = {
    val await = Try(Await.result(comAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerAsync(post, apply, delete, action, location, propertylist, dmreplicateonmodifyEnabled, dmreplicateonmodifyForcesyncdeletes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param dmreplicateonmodifyEnabled  (optional)
   * @param dmreplicateonmodifyForcesyncdeletes  (optional)
   * @return Future(ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo)
   */
  def comAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, dmreplicateonmodifyEnabled: Option[Boolean] = None, dmreplicateonmodifyForcesyncdeletes: Option[Boolean] = None): Future[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo] = {
      helper.comAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorker(post, apply, delete, action, location, propertylist, dmreplicateonmodifyEnabled, dmreplicateonmodifyForcesyncdeletes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeDamMacSyncClientSoTimeout  (optional)
   * @return ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo
   */
  def comAdobeCqDamMacSyncHelperImplMACSyncClientImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeDamMacSyncClientSoTimeout: Option[Integer] = None): Option[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo] = {
    val await = Try(Await.result(comAdobeCqDamMacSyncHelperImplMACSyncClientImplAsync(post, apply, delete, action, location, propertylist, comAdobeDamMacSyncClientSoTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeDamMacSyncClientSoTimeout  (optional)
   * @return Future(ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo)
   */
  def comAdobeCqDamMacSyncHelperImplMACSyncClientImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeDamMacSyncClientSoTimeout: Option[Integer] = None): Future[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo] = {
      helper.comAdobeCqDamMacSyncHelperImplMACSyncClientImpl(post, apply, delete, action, location, propertylist, comAdobeDamMacSyncClientSoTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths  (optional)
   * @param comAdobeCqDamMacSyncDamsyncserviceSyncRenditions  (optional)
   * @param comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs  (optional)
   * @param comAdobeCqDamMacSyncDamsyncservicePlatform  (optional)
   * @return ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo
   */
  def comAdobeCqDamMacSyncImplDAMSyncServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths: Option[List[String]] = None, comAdobeCqDamMacSyncDamsyncserviceSyncRenditions: Option[Boolean] = None, comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs: Option[Integer] = None, comAdobeCqDamMacSyncDamsyncservicePlatform: Option[String] = None): Option[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqDamMacSyncImplDAMSyncServiceImplAsync(post, apply, delete, action, location, propertylist, comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths, comAdobeCqDamMacSyncDamsyncserviceSyncRenditions, comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs, comAdobeCqDamMacSyncDamsyncservicePlatform), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths  (optional)
   * @param comAdobeCqDamMacSyncDamsyncserviceSyncRenditions  (optional)
   * @param comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs  (optional)
   * @param comAdobeCqDamMacSyncDamsyncservicePlatform  (optional)
   * @return Future(ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo)
   */
  def comAdobeCqDamMacSyncImplDAMSyncServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths: Option[List[String]] = None, comAdobeCqDamMacSyncDamsyncserviceSyncRenditions: Option[Boolean] = None, comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs: Option[Integer] = None, comAdobeCqDamMacSyncDamsyncservicePlatform: Option[String] = None): Future[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo] = {
      helper.comAdobeCqDamMacSyncImplDAMSyncServiceImpl(post, apply, delete, action, location, propertylist, comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths, comAdobeCqDamMacSyncDamsyncserviceSyncRenditions, comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs, comAdobeCqDamMacSyncDamsyncservicePlatform)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param nuiEnabled  (optional)
   * @param nuiServiceUrl  (optional)
   * @param nuiApiKey  (optional)
   * @return ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo
   */
  def comAdobeCqDamProcessorNuiImplNuiAssetProcessor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, nuiEnabled: Option[Boolean] = None, nuiServiceUrl: Option[String] = None, nuiApiKey: Option[String] = None): Option[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo] = {
    val await = Try(Await.result(comAdobeCqDamProcessorNuiImplNuiAssetProcessorAsync(post, apply, delete, action, location, propertylist, nuiEnabled, nuiServiceUrl, nuiApiKey), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param nuiEnabled  (optional)
   * @param nuiServiceUrl  (optional)
   * @param nuiApiKey  (optional)
   * @return Future(ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo)
   */
  def comAdobeCqDamProcessorNuiImplNuiAssetProcessorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, nuiEnabled: Option[Boolean] = None, nuiServiceUrl: Option[String] = None, nuiApiKey: Option[String] = None): Future[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo] = {
      helper.comAdobeCqDamProcessorNuiImplNuiAssetProcessor(post, apply, delete, action, location, propertylist, nuiEnabled, nuiServiceUrl, nuiApiKey)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param tcpPort  (optional)
   * @param allowRemoteAccess  (optional)
   * @param maxRenderRgnPixels  (optional)
   * @param maxMessageSize  (optional)
   * @param randomAccessUrlTimeout  (optional)
   * @param workerThreads  (optional)
   * @return ComAdobeCqDamS7imagingImplIsImageServerComponentInfo
   */
  def comAdobeCqDamS7imagingImplIsImageServerComponent(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, tcpPort: Option[String] = None, allowRemoteAccess: Option[Boolean] = None, maxRenderRgnPixels: Option[String] = None, maxMessageSize: Option[String] = None, randomAccessUrlTimeout: Option[Integer] = None, workerThreads: Option[Integer] = None): Option[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo] = {
    val await = Try(Await.result(comAdobeCqDamS7imagingImplIsImageServerComponentAsync(post, apply, delete, action, location, propertylist, tcpPort, allowRemoteAccess, maxRenderRgnPixels, maxMessageSize, randomAccessUrlTimeout, workerThreads), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param tcpPort  (optional)
   * @param allowRemoteAccess  (optional)
   * @param maxRenderRgnPixels  (optional)
   * @param maxMessageSize  (optional)
   * @param randomAccessUrlTimeout  (optional)
   * @param workerThreads  (optional)
   * @return Future(ComAdobeCqDamS7imagingImplIsImageServerComponentInfo)
   */
  def comAdobeCqDamS7imagingImplIsImageServerComponentAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, tcpPort: Option[String] = None, allowRemoteAccess: Option[Boolean] = None, maxRenderRgnPixels: Option[String] = None, maxMessageSize: Option[String] = None, randomAccessUrlTimeout: Option[Integer] = None, workerThreads: Option[Integer] = None): Future[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo] = {
      helper.comAdobeCqDamS7imagingImplIsImageServerComponent(post, apply, delete, action, location, propertylist, tcpPort, allowRemoteAccess, maxRenderRgnPixels, maxMessageSize, randomAccessUrlTimeout, workerThreads)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cacheEnable  (optional)
   * @param cacheRootPaths  (optional)
   * @param cacheMaxSize  (optional)
   * @param cacheMaxEntries  (optional)
   * @return ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo
   */
  def comAdobeCqDamS7imagingImplPsPlatformServerServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cacheEnable: Option[Boolean] = None, cacheRootPaths: Option[List[String]] = None, cacheMaxSize: Option[Integer] = None, cacheMaxEntries: Option[Integer] = None): Option[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo] = {
    val await = Try(Await.result(comAdobeCqDamS7imagingImplPsPlatformServerServletAsync(post, apply, delete, action, location, propertylist, cacheEnable, cacheRootPaths, cacheMaxSize, cacheMaxEntries), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cacheEnable  (optional)
   * @param cacheRootPaths  (optional)
   * @param cacheMaxSize  (optional)
   * @param cacheMaxEntries  (optional)
   * @return Future(ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo)
   */
  def comAdobeCqDamS7imagingImplPsPlatformServerServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cacheEnable: Option[Boolean] = None, cacheRootPaths: Option[List[String]] = None, cacheMaxSize: Option[Integer] = None, cacheMaxEntries: Option[Integer] = None): Future[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo] = {
      helper.comAdobeCqDamS7imagingImplPsPlatformServerServlet(post, apply, delete, action, location, propertylist, cacheEnable, cacheRootPaths, cacheMaxSize, cacheMaxEntries)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param pathPrefix  (optional)
   * @param createVersion  (optional)
   * @return ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo
   */
  def comAdobeCqDamWebdavImplIoAssetIOHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, pathPrefix: Option[String] = None, createVersion: Option[Boolean] = None): Option[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo] = {
    val await = Try(Await.result(comAdobeCqDamWebdavImplIoAssetIOHandlerAsync(post, apply, delete, action, location, propertylist, serviceRanking, pathPrefix, createVersion), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param pathPrefix  (optional)
   * @param createVersion  (optional)
   * @return Future(ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo)
   */
  def comAdobeCqDamWebdavImplIoAssetIOHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, pathPrefix: Option[String] = None, createVersion: Option[Boolean] = None): Future[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo] = {
      helper.comAdobeCqDamWebdavImplIoAssetIOHandler(post, apply, delete, action, location, propertylist, serviceRanking, pathPrefix, createVersion)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamWebdavVersionLinkingEnable  (optional)
   * @param cqDamWebdavVersionLinkingSchedulerPeriod  (optional)
   * @param cqDamWebdavVersionLinkingStagingTimeout  (optional)
   * @return ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo
   */
  def comAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJob(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamWebdavVersionLinkingEnable: Option[Boolean] = None, cqDamWebdavVersionLinkingSchedulerPeriod: Option[Integer] = None, cqDamWebdavVersionLinkingStagingTimeout: Option[Integer] = None): Option[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo] = {
    val await = Try(Await.result(comAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobAsync(post, apply, delete, action, location, propertylist, cqDamWebdavVersionLinkingEnable, cqDamWebdavVersionLinkingSchedulerPeriod, cqDamWebdavVersionLinkingStagingTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamWebdavVersionLinkingEnable  (optional)
   * @param cqDamWebdavVersionLinkingSchedulerPeriod  (optional)
   * @param cqDamWebdavVersionLinkingStagingTimeout  (optional)
   * @return Future(ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo)
   */
  def comAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamWebdavVersionLinkingEnable: Option[Boolean] = None, cqDamWebdavVersionLinkingSchedulerPeriod: Option[Integer] = None, cqDamWebdavVersionLinkingStagingTimeout: Option[Integer] = None): Future[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo] = {
      helper.comAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJob(post, apply, delete, action, location, propertylist, cqDamWebdavVersionLinkingEnable, cqDamWebdavVersionLinkingSchedulerPeriod, cqDamWebdavVersionLinkingStagingTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters  (optional)
   * @return ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo
   */
  def comAdobeCqDamWebdavImplIoSpecialFilesHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters: Option[List[String]] = None): Option[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo] = {
    val await = Try(Await.result(comAdobeCqDamWebdavImplIoSpecialFilesHandlerAsync(post, apply, delete, action, location, propertylist, comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters  (optional)
   * @return Future(ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo)
   */
  def comAdobeCqDamWebdavImplIoSpecialFilesHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters: Option[List[String]] = None): Future[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo] = {
      helper.comAdobeCqDamWebdavImplIoSpecialFilesHandler(post, apply, delete, action, location, propertylist, comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param firewallDeserializationWhitelist  (optional)
   * @param firewallDeserializationBlacklist  (optional)
   * @param firewallDeserializationDiagnostics  (optional)
   * @return ComAdobeCqDeserfwImplDeserializationFirewallImplInfo
   */
  def comAdobeCqDeserfwImplDeserializationFirewallImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, firewallDeserializationWhitelist: Option[List[String]] = None, firewallDeserializationBlacklist: Option[List[String]] = None, firewallDeserializationDiagnostics: Option[String] = None): Option[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo] = {
    val await = Try(Await.result(comAdobeCqDeserfwImplDeserializationFirewallImplAsync(post, apply, delete, action, location, propertylist, firewallDeserializationWhitelist, firewallDeserializationBlacklist, firewallDeserializationDiagnostics), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param firewallDeserializationWhitelist  (optional)
   * @param firewallDeserializationBlacklist  (optional)
   * @param firewallDeserializationDiagnostics  (optional)
   * @return Future(ComAdobeCqDeserfwImplDeserializationFirewallImplInfo)
   */
  def comAdobeCqDeserfwImplDeserializationFirewallImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, firewallDeserializationWhitelist: Option[List[String]] = None, firewallDeserializationBlacklist: Option[List[String]] = None, firewallDeserializationDiagnostics: Option[String] = None): Future[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo] = {
      helper.comAdobeCqDeserfwImplDeserializationFirewallImpl(post, apply, delete, action, location, propertylist, firewallDeserializationWhitelist, firewallDeserializationBlacklist, firewallDeserializationDiagnostics)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param connectionTimeout  (optional)
   * @param socketTimeout  (optional)
   * @return ComAdobeCqDtmImplServiceDTMWebServiceImplInfo
   */
  def comAdobeCqDtmImplServiceDTMWebServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, connectionTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None): Option[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqDtmImplServiceDTMWebServiceImplAsync(post, apply, delete, action, location, propertylist, connectionTimeout, socketTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param connectionTimeout  (optional)
   * @param socketTimeout  (optional)
   * @return Future(ComAdobeCqDtmImplServiceDTMWebServiceImplInfo)
   */
  def comAdobeCqDtmImplServiceDTMWebServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, connectionTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None): Future[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo] = {
      helper.comAdobeCqDtmImplServiceDTMWebServiceImpl(post, apply, delete, action, location, propertylist, connectionTimeout, socketTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param dtmStagingIpWhitelist  (optional)
   * @param dtmProductionIpWhitelist  (optional)
   * @return ComAdobeCqDtmImplServletsDTMDeployHookServletInfo
   */
  def comAdobeCqDtmImplServletsDTMDeployHookServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, dtmStagingIpWhitelist: Option[List[String]] = None, dtmProductionIpWhitelist: Option[List[String]] = None): Option[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo] = {
    val await = Try(Await.result(comAdobeCqDtmImplServletsDTMDeployHookServletAsync(post, apply, delete, action, location, propertylist, dtmStagingIpWhitelist, dtmProductionIpWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param dtmStagingIpWhitelist  (optional)
   * @param dtmProductionIpWhitelist  (optional)
   * @return Future(ComAdobeCqDtmImplServletsDTMDeployHookServletInfo)
   */
  def comAdobeCqDtmImplServletsDTMDeployHookServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, dtmStagingIpWhitelist: Option[List[String]] = None, dtmProductionIpWhitelist: Option[List[String]] = None): Future[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo] = {
      helper.comAdobeCqDtmImplServletsDTMDeployHookServlet(post, apply, delete, action, location, propertylist, dtmStagingIpWhitelist, dtmProductionIpWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param endpointUri  (optional)
   * @param connectionTimeout  (optional)
   * @param socketTimeout  (optional)
   * @return ComAdobeCqDtmReactorImplServiceWebServiceImplInfo
   */
  def comAdobeCqDtmReactorImplServiceWebServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, endpointUri: Option[String] = None, connectionTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None): Option[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqDtmReactorImplServiceWebServiceImplAsync(post, apply, delete, action, location, propertylist, endpointUri, connectionTimeout, socketTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param endpointUri  (optional)
   * @param connectionTimeout  (optional)
   * @param socketTimeout  (optional)
   * @return Future(ComAdobeCqDtmReactorImplServiceWebServiceImplInfo)
   */
  def comAdobeCqDtmReactorImplServiceWebServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, endpointUri: Option[String] = None, connectionTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None): Future[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo] = {
      helper.comAdobeCqDtmReactorImplServiceWebServiceImpl(post, apply, delete, action, location, propertylist, endpointUri, connectionTimeout, socketTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param disabledForGroups  (optional)
   * @return ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo
   */
  def comAdobeCqExperiencelogImplExperienceLogConfigServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, disabledForGroups: Option[List[String]] = None): Option[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo] = {
    val await = Try(Await.result(comAdobeCqExperiencelogImplExperienceLogConfigServletAsync(post, apply, delete, action, location, propertylist, enabled, disabledForGroups), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param disabledForGroups  (optional)
   * @return Future(ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo)
   */
  def comAdobeCqExperiencelogImplExperienceLogConfigServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, disabledForGroups: Option[List[String]] = None): Future[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo] = {
      helper.comAdobeCqExperiencelogImplExperienceLogConfigServlet(post, apply, delete, action, location, propertylist, enabled, disabledForGroups)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @param packageNames  (optional)
   * @return ComAdobeCqHcContentPackagesHealthCheckInfo
   */
  def comAdobeCqHcContentPackagesHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None, packageNames: Option[List[String]] = None): Option[ComAdobeCqHcContentPackagesHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeCqHcContentPackagesHealthCheckAsync(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName, packageNames), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @param packageNames  (optional)
   * @return Future(ComAdobeCqHcContentPackagesHealthCheckInfo)
   */
  def comAdobeCqHcContentPackagesHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None, packageNames: Option[List[String]] = None): Future[ComAdobeCqHcContentPackagesHealthCheckInfo] = {
      helper.comAdobeCqHcContentPackagesHealthCheck(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName, packageNames)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param historyRequestFilterExcludedSelectors  (optional)
   * @param historyRequestFilterExcludedExtensions  (optional)
   * @return ComAdobeCqHistoryImplHistoryRequestFilterInfo
   */
  def comAdobeCqHistoryImplHistoryRequestFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, historyRequestFilterExcludedSelectors: Option[List[String]] = None, historyRequestFilterExcludedExtensions: Option[List[String]] = None): Option[ComAdobeCqHistoryImplHistoryRequestFilterInfo] = {
    val await = Try(Await.result(comAdobeCqHistoryImplHistoryRequestFilterAsync(post, apply, delete, action, location, propertylist, historyRequestFilterExcludedSelectors, historyRequestFilterExcludedExtensions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param historyRequestFilterExcludedSelectors  (optional)
   * @param historyRequestFilterExcludedExtensions  (optional)
   * @return Future(ComAdobeCqHistoryImplHistoryRequestFilterInfo)
   */
  def comAdobeCqHistoryImplHistoryRequestFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, historyRequestFilterExcludedSelectors: Option[List[String]] = None, historyRequestFilterExcludedExtensions: Option[List[String]] = None): Future[ComAdobeCqHistoryImplHistoryRequestFilterInfo] = {
      helper.comAdobeCqHistoryImplHistoryRequestFilter(post, apply, delete, action, location, propertylist, historyRequestFilterExcludedSelectors, historyRequestFilterExcludedExtensions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param historyServiceResourceTypes  (optional)
   * @param historyServicePathFilter  (optional)
   * @return ComAdobeCqHistoryImplHistoryServiceImplInfo
   */
  def comAdobeCqHistoryImplHistoryServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, historyServiceResourceTypes: Option[List[String]] = None, historyServicePathFilter: Option[List[String]] = None): Option[ComAdobeCqHistoryImplHistoryServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqHistoryImplHistoryServiceImplAsync(post, apply, delete, action, location, propertylist, historyServiceResourceTypes, historyServicePathFilter), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param historyServiceResourceTypes  (optional)
   * @param historyServicePathFilter  (optional)
   * @return Future(ComAdobeCqHistoryImplHistoryServiceImplInfo)
   */
  def comAdobeCqHistoryImplHistoryServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, historyServiceResourceTypes: Option[List[String]] = None, historyServicePathFilter: Option[List[String]] = None): Future[ComAdobeCqHistoryImplHistoryServiceImplInfo] = {
      helper.comAdobeCqHistoryImplHistoryServiceImpl(post, apply, delete, action, location, propertylist, historyServiceResourceTypes, historyServicePathFilter)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param inboxImplTypeproviderRegistrypaths  (optional)
   * @param inboxImplTypeproviderLegacypaths  (optional)
   * @param inboxImplTypeproviderDefaulturlFailureitem  (optional)
   * @param inboxImplTypeproviderDefaulturlWorkitem  (optional)
   * @param inboxImplTypeproviderDefaulturlTask  (optional)
   * @return ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo
   */
  def comAdobeCqInboxImplTypeproviderItemTypeProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, inboxImplTypeproviderRegistrypaths: Option[List[String]] = None, inboxImplTypeproviderLegacypaths: Option[List[String]] = None, inboxImplTypeproviderDefaulturlFailureitem: Option[String] = None, inboxImplTypeproviderDefaulturlWorkitem: Option[String] = None, inboxImplTypeproviderDefaulturlTask: Option[String] = None): Option[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo] = {
    val await = Try(Await.result(comAdobeCqInboxImplTypeproviderItemTypeProviderAsync(post, apply, delete, action, location, propertylist, inboxImplTypeproviderRegistrypaths, inboxImplTypeproviderLegacypaths, inboxImplTypeproviderDefaulturlFailureitem, inboxImplTypeproviderDefaulturlWorkitem, inboxImplTypeproviderDefaulturlTask), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param inboxImplTypeproviderRegistrypaths  (optional)
   * @param inboxImplTypeproviderLegacypaths  (optional)
   * @param inboxImplTypeproviderDefaulturlFailureitem  (optional)
   * @param inboxImplTypeproviderDefaulturlWorkitem  (optional)
   * @param inboxImplTypeproviderDefaulturlTask  (optional)
   * @return Future(ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo)
   */
  def comAdobeCqInboxImplTypeproviderItemTypeProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, inboxImplTypeproviderRegistrypaths: Option[List[String]] = None, inboxImplTypeproviderLegacypaths: Option[List[String]] = None, inboxImplTypeproviderDefaulturlFailureitem: Option[String] = None, inboxImplTypeproviderDefaulturlWorkitem: Option[String] = None, inboxImplTypeproviderDefaulturlTask: Option[String] = None): Future[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo] = {
      helper.comAdobeCqInboxImplTypeproviderItemTypeProvider(post, apply, delete, action, location, propertylist, inboxImplTypeproviderRegistrypaths, inboxImplTypeproviderLegacypaths, inboxImplTypeproviderDefaulturlFailureitem, inboxImplTypeproviderDefaulturlWorkitem, inboxImplTypeproviderDefaulturlTask)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param imageQuality  (optional)
   * @param imageSupportedResolutions  (optional)
   * @return ComAdobeCqProjectsImplServletProjectImageServletInfo
   */
  def comAdobeCqProjectsImplServletProjectImageServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, imageQuality: Option[String] = None, imageSupportedResolutions: Option[String] = None): Option[ComAdobeCqProjectsImplServletProjectImageServletInfo] = {
    val await = Try(Await.result(comAdobeCqProjectsImplServletProjectImageServletAsync(post, apply, delete, action, location, propertylist, imageQuality, imageSupportedResolutions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param imageQuality  (optional)
   * @param imageSupportedResolutions  (optional)
   * @return Future(ComAdobeCqProjectsImplServletProjectImageServletInfo)
   */
  def comAdobeCqProjectsImplServletProjectImageServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, imageQuality: Option[String] = None, imageSupportedResolutions: Option[String] = None): Future[ComAdobeCqProjectsImplServletProjectImageServletInfo] = {
      helper.comAdobeCqProjectsImplServletProjectImageServlet(post, apply, delete, action, location, propertylist, imageQuality, imageSupportedResolutions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param scheduledpurgeName  (optional)
   * @param scheduledpurgePurgeActive  (optional)
   * @param scheduledpurgeTemplates  (optional)
   * @param scheduledpurgePurgeGroups  (optional)
   * @param scheduledpurgePurgeAssets  (optional)
   * @param scheduledpurgeTerminateRunningWorkflows  (optional)
   * @param scheduledpurgeDaysold  (optional)
   * @param scheduledpurgeSaveThreshold  (optional)
   * @return ComAdobeCqProjectsPurgeSchedulerInfo
   */
  def comAdobeCqProjectsPurgeScheduler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, scheduledpurgeName: Option[String] = None, scheduledpurgePurgeActive: Option[Boolean] = None, scheduledpurgeTemplates: Option[List[String]] = None, scheduledpurgePurgeGroups: Option[Boolean] = None, scheduledpurgePurgeAssets: Option[Boolean] = None, scheduledpurgeTerminateRunningWorkflows: Option[Boolean] = None, scheduledpurgeDaysold: Option[Integer] = None, scheduledpurgeSaveThreshold: Option[Integer] = None): Option[ComAdobeCqProjectsPurgeSchedulerInfo] = {
    val await = Try(Await.result(comAdobeCqProjectsPurgeSchedulerAsync(post, apply, delete, action, location, propertylist, scheduledpurgeName, scheduledpurgePurgeActive, scheduledpurgeTemplates, scheduledpurgePurgeGroups, scheduledpurgePurgeAssets, scheduledpurgeTerminateRunningWorkflows, scheduledpurgeDaysold, scheduledpurgeSaveThreshold), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param scheduledpurgeName  (optional)
   * @param scheduledpurgePurgeActive  (optional)
   * @param scheduledpurgeTemplates  (optional)
   * @param scheduledpurgePurgeGroups  (optional)
   * @param scheduledpurgePurgeAssets  (optional)
   * @param scheduledpurgeTerminateRunningWorkflows  (optional)
   * @param scheduledpurgeDaysold  (optional)
   * @param scheduledpurgeSaveThreshold  (optional)
   * @return Future(ComAdobeCqProjectsPurgeSchedulerInfo)
   */
  def comAdobeCqProjectsPurgeSchedulerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, scheduledpurgeName: Option[String] = None, scheduledpurgePurgeActive: Option[Boolean] = None, scheduledpurgeTemplates: Option[List[String]] = None, scheduledpurgePurgeGroups: Option[Boolean] = None, scheduledpurgePurgeAssets: Option[Boolean] = None, scheduledpurgeTerminateRunningWorkflows: Option[Boolean] = None, scheduledpurgeDaysold: Option[Integer] = None, scheduledpurgeSaveThreshold: Option[Integer] = None): Future[ComAdobeCqProjectsPurgeSchedulerInfo] = {
      helper.comAdobeCqProjectsPurgeScheduler(post, apply, delete, action, location, propertylist, scheduledpurgeName, scheduledpurgePurgeActive, scheduledpurgeTemplates, scheduledpurgePurgeGroups, scheduledpurgePurgeAssets, scheduledpurgeTerminateRunningWorkflows, scheduledpurgeDaysold, scheduledpurgeSaveThreshold)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param includePaths  (optional)
   * @param exporterUser  (optional)
   * @return ComAdobeCqScheduledExporterImplScheduledExporterImplInfo
   */
  def comAdobeCqScheduledExporterImplScheduledExporterImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, includePaths: Option[List[String]] = None, exporterUser: Option[String] = None): Option[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo] = {
    val await = Try(Await.result(comAdobeCqScheduledExporterImplScheduledExporterImplAsync(post, apply, delete, action, location, propertylist, includePaths, exporterUser), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param includePaths  (optional)
   * @param exporterUser  (optional)
   * @return Future(ComAdobeCqScheduledExporterImplScheduledExporterImplInfo)
   */
  def comAdobeCqScheduledExporterImplScheduledExporterImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, includePaths: Option[List[String]] = None, exporterUser: Option[String] = None): Future[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo] = {
      helper.comAdobeCqScheduledExporterImplScheduledExporterImpl(post, apply, delete, action, location, propertylist, includePaths, exporterUser)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeCqScreensAnalyticsImplUrl  (optional)
   * @param comAdobeCqScreensAnalyticsImplApikey  (optional)
   * @param comAdobeCqScreensAnalyticsImplProject  (optional)
   * @param comAdobeCqScreensAnalyticsImplEnvironment  (optional)
   * @param comAdobeCqScreensAnalyticsImplSendFrequency  (optional)
   * @return ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo
   */
  def comAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeCqScreensAnalyticsImplUrl: Option[String] = None, comAdobeCqScreensAnalyticsImplApikey: Option[String] = None, comAdobeCqScreensAnalyticsImplProject: Option[String] = None, comAdobeCqScreensAnalyticsImplEnvironment: Option[String] = None, comAdobeCqScreensAnalyticsImplSendFrequency: Option[Integer] = None): Option[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplAsync(post, apply, delete, action, location, propertylist, comAdobeCqScreensAnalyticsImplUrl, comAdobeCqScreensAnalyticsImplApikey, comAdobeCqScreensAnalyticsImplProject, comAdobeCqScreensAnalyticsImplEnvironment, comAdobeCqScreensAnalyticsImplSendFrequency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeCqScreensAnalyticsImplUrl  (optional)
   * @param comAdobeCqScreensAnalyticsImplApikey  (optional)
   * @param comAdobeCqScreensAnalyticsImplProject  (optional)
   * @param comAdobeCqScreensAnalyticsImplEnvironment  (optional)
   * @param comAdobeCqScreensAnalyticsImplSendFrequency  (optional)
   * @return Future(ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo)
   */
  def comAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeCqScreensAnalyticsImplUrl: Option[String] = None, comAdobeCqScreensAnalyticsImplApikey: Option[String] = None, comAdobeCqScreensAnalyticsImplProject: Option[String] = None, comAdobeCqScreensAnalyticsImplEnvironment: Option[String] = None, comAdobeCqScreensAnalyticsImplSendFrequency: Option[Integer] = None): Future[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo] = {
      helper.comAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImpl(post, apply, delete, action, location, propertylist, comAdobeCqScreensAnalyticsImplUrl, comAdobeCqScreensAnalyticsImplApikey, comAdobeCqScreensAnalyticsImplProject, comAdobeCqScreensAnalyticsImplEnvironment, comAdobeCqScreensAnalyticsImplSendFrequency)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeAemScreensPlayerPingfrequency  (optional)
   * @param comAdobeAemScreensDevicePaswordSpecialchars  (optional)
   * @param comAdobeAemScreensDevicePaswordMinlowercasechars  (optional)
   * @param comAdobeAemScreensDevicePaswordMinuppercasechars  (optional)
   * @param comAdobeAemScreensDevicePaswordMinnumberchars  (optional)
   * @param comAdobeAemScreensDevicePaswordMinspecialchars  (optional)
   * @param comAdobeAemScreensDevicePaswordMinlength  (optional)
   * @return ComAdobeCqScreensDeviceImplDeviceServiceInfo
   */
  def comAdobeCqScreensDeviceImplDeviceService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeAemScreensPlayerPingfrequency: Option[Integer] = None, comAdobeAemScreensDevicePaswordSpecialchars: Option[String] = None, comAdobeAemScreensDevicePaswordMinlowercasechars: Option[Integer] = None, comAdobeAemScreensDevicePaswordMinuppercasechars: Option[Integer] = None, comAdobeAemScreensDevicePaswordMinnumberchars: Option[Integer] = None, comAdobeAemScreensDevicePaswordMinspecialchars: Option[Integer] = None, comAdobeAemScreensDevicePaswordMinlength: Option[Integer] = None): Option[ComAdobeCqScreensDeviceImplDeviceServiceInfo] = {
    val await = Try(Await.result(comAdobeCqScreensDeviceImplDeviceServiceAsync(post, apply, delete, action, location, propertylist, comAdobeAemScreensPlayerPingfrequency, comAdobeAemScreensDevicePaswordSpecialchars, comAdobeAemScreensDevicePaswordMinlowercasechars, comAdobeAemScreensDevicePaswordMinuppercasechars, comAdobeAemScreensDevicePaswordMinnumberchars, comAdobeAemScreensDevicePaswordMinspecialchars, comAdobeAemScreensDevicePaswordMinlength), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeAemScreensPlayerPingfrequency  (optional)
   * @param comAdobeAemScreensDevicePaswordSpecialchars  (optional)
   * @param comAdobeAemScreensDevicePaswordMinlowercasechars  (optional)
   * @param comAdobeAemScreensDevicePaswordMinuppercasechars  (optional)
   * @param comAdobeAemScreensDevicePaswordMinnumberchars  (optional)
   * @param comAdobeAemScreensDevicePaswordMinspecialchars  (optional)
   * @param comAdobeAemScreensDevicePaswordMinlength  (optional)
   * @return Future(ComAdobeCqScreensDeviceImplDeviceServiceInfo)
   */
  def comAdobeCqScreensDeviceImplDeviceServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeAemScreensPlayerPingfrequency: Option[Integer] = None, comAdobeAemScreensDevicePaswordSpecialchars: Option[String] = None, comAdobeAemScreensDevicePaswordMinlowercasechars: Option[Integer] = None, comAdobeAemScreensDevicePaswordMinuppercasechars: Option[Integer] = None, comAdobeAemScreensDevicePaswordMinnumberchars: Option[Integer] = None, comAdobeAemScreensDevicePaswordMinspecialchars: Option[Integer] = None, comAdobeAemScreensDevicePaswordMinlength: Option[Integer] = None): Future[ComAdobeCqScreensDeviceImplDeviceServiceInfo] = {
      helper.comAdobeCqScreensDeviceImplDeviceService(post, apply, delete, action, location, propertylist, comAdobeAemScreensPlayerPingfrequency, comAdobeAemScreensDevicePaswordSpecialchars, comAdobeAemScreensDevicePaswordMinlowercasechars, comAdobeAemScreensDevicePaswordMinuppercasechars, comAdobeAemScreensDevicePaswordMinnumberchars, comAdobeAemScreensDevicePaswordMinspecialchars, comAdobeAemScreensDevicePaswordMinlength)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param deviceRegistrationTimeout  (optional)
   * @return ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo
   */
  def comAdobeCqScreensDeviceRegistrationImplRegistrationServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, deviceRegistrationTimeout: Option[Integer] = None): Option[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplAsync(post, apply, delete, action, location, propertylist, deviceRegistrationTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param deviceRegistrationTimeout  (optional)
   * @return Future(ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo)
   */
  def comAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, deviceRegistrationTimeout: Option[Integer] = None): Future[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo] = {
      helper.comAdobeCqScreensDeviceRegistrationImplRegistrationServiceImpl(post, apply, delete, action, location, propertylist, deviceRegistrationTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqPagesupdatehandlerImageresourcetypes  (optional)
   * @param cqPagesupdatehandlerProductresourcetypes  (optional)
   * @param cqPagesupdatehandlerVideoresourcetypes  (optional)
   * @param cqPagesupdatehandlerDynamicsequenceresourcetypes  (optional)
   * @param cqPagesupdatehandlerPreviewmodepaths  (optional)
   * @return ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo
   */
  def comAdobeCqScreensImplHandlerChannelsUpdateHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqPagesupdatehandlerImageresourcetypes: Option[List[String]] = None, cqPagesupdatehandlerProductresourcetypes: Option[List[String]] = None, cqPagesupdatehandlerVideoresourcetypes: Option[List[String]] = None, cqPagesupdatehandlerDynamicsequenceresourcetypes: Option[List[String]] = None, cqPagesupdatehandlerPreviewmodepaths: Option[List[String]] = None): Option[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo] = {
    val await = Try(Await.result(comAdobeCqScreensImplHandlerChannelsUpdateHandlerAsync(post, apply, delete, action, location, propertylist, cqPagesupdatehandlerImageresourcetypes, cqPagesupdatehandlerProductresourcetypes, cqPagesupdatehandlerVideoresourcetypes, cqPagesupdatehandlerDynamicsequenceresourcetypes, cqPagesupdatehandlerPreviewmodepaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqPagesupdatehandlerImageresourcetypes  (optional)
   * @param cqPagesupdatehandlerProductresourcetypes  (optional)
   * @param cqPagesupdatehandlerVideoresourcetypes  (optional)
   * @param cqPagesupdatehandlerDynamicsequenceresourcetypes  (optional)
   * @param cqPagesupdatehandlerPreviewmodepaths  (optional)
   * @return Future(ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo)
   */
  def comAdobeCqScreensImplHandlerChannelsUpdateHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqPagesupdatehandlerImageresourcetypes: Option[List[String]] = None, cqPagesupdatehandlerProductresourcetypes: Option[List[String]] = None, cqPagesupdatehandlerVideoresourcetypes: Option[List[String]] = None, cqPagesupdatehandlerDynamicsequenceresourcetypes: Option[List[String]] = None, cqPagesupdatehandlerPreviewmodepaths: Option[List[String]] = None): Future[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo] = {
      helper.comAdobeCqScreensImplHandlerChannelsUpdateHandler(post, apply, delete, action, location, propertylist, cqPagesupdatehandlerImageresourcetypes, cqPagesupdatehandlerProductresourcetypes, cqPagesupdatehandlerVideoresourcetypes, cqPagesupdatehandlerDynamicsequenceresourcetypes, cqPagesupdatehandlerPreviewmodepaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @return ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo
   */
  def comAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJob(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None): Option[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo] = {
    val await = Try(Await.result(comAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobAsync(post, apply, delete, action, location, propertylist, schedulerExpression), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @return Future(ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo)
   */
  def comAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None): Future[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo] = {
      helper.comAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJob(post, apply, delete, action, location, propertylist, schedulerExpression)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeAemScreensImplRemoteRequestTimeout  (optional)
   * @return ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo
   */
  def comAdobeCqScreensImplRemoteImplDistributedHttpClientImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeAemScreensImplRemoteRequestTimeout: Option[Integer] = None): Option[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo] = {
    val await = Try(Await.result(comAdobeCqScreensImplRemoteImplDistributedHttpClientImplAsync(post, apply, delete, action, location, propertylist, comAdobeAemScreensImplRemoteRequestTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeAemScreensImplRemoteRequestTimeout  (optional)
   * @return Future(ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo)
   */
  def comAdobeCqScreensImplRemoteImplDistributedHttpClientImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeAemScreensImplRemoteRequestTimeout: Option[Integer] = None): Future[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo] = {
      helper.comAdobeCqScreensImplRemoteImplDistributedHttpClientImpl(post, apply, delete, action, location, propertylist, comAdobeAemScreensImplRemoteRequestTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param screensChannelsPropertiesToRemove  (optional)
   * @return ComAdobeCqScreensImplScreensChannelPostProcessorInfo
   */
  def comAdobeCqScreensImplScreensChannelPostProcessor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, screensChannelsPropertiesToRemove: Option[List[String]] = None): Option[ComAdobeCqScreensImplScreensChannelPostProcessorInfo] = {
    val await = Try(Await.result(comAdobeCqScreensImplScreensChannelPostProcessorAsync(post, apply, delete, action, location, propertylist, screensChannelsPropertiesToRemove), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param screensChannelsPropertiesToRemove  (optional)
   * @return Future(ComAdobeCqScreensImplScreensChannelPostProcessorInfo)
   */
  def comAdobeCqScreensImplScreensChannelPostProcessorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, screensChannelsPropertiesToRemove: Option[List[String]] = None): Future[ComAdobeCqScreensImplScreensChannelPostProcessorInfo] = {
      helper.comAdobeCqScreensImplScreensChannelPostProcessor(post, apply, delete, action, location, propertylist, screensChannelsPropertiesToRemove)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword  (optional)
   * @return ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo
   */
  def comAdobeCqScreensMonitoringImplScreensMonitoringServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath: Option[List[String]] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency: Option[String] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout: Option[Integer] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients: Option[String] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver: Option[String] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport: Option[Integer] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls: Option[Boolean] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername: Option[String] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword: Option[String] = None): Option[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplAsync(post, apply, delete, action, location, propertylist, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername  (optional)
   * @param comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword  (optional)
   * @return Future(ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo)
   */
  def comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath: Option[List[String]] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency: Option[String] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout: Option[Integer] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients: Option[String] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver: Option[String] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport: Option[Integer] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls: Option[Boolean] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername: Option[String] = None, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword: Option[String] = None): Future[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo] = {
      helper.comAdobeCqScreensMonitoringImplScreensMonitoringServiceImpl(post, apply, delete, action, location, propertylist, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername, comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param globalSize  (optional)
   * @param maxDiskUsage  (optional)
   * @param persistenceEnabled  (optional)
   * @param threadPoolMaxSize  (optional)
   * @param scheduledThreadPoolMaxSize  (optional)
   * @param gracefulShutdownTimeout  (optional)
   * @param queues  (optional)
   * @param topics  (optional)
   * @param addressesMaxDeliveryAttempts  (optional)
   * @param addressesExpiryDelay  (optional)
   * @param addressesAddressFullMessagePolicy  (optional)
   * @param addressesMaxSizeBytes  (optional)
   * @param addressesPageSizeBytes  (optional)
   * @param addressesPageCacheMaxSize  (optional)
   * @param clusterUser  (optional)
   * @param clusterPassword  (optional)
   * @param clusterCallTimeout  (optional)
   * @param clusterCallFailoverTimeout  (optional)
   * @param clusterClientFailureCheckPeriod  (optional)
   * @param clusterNotificationAttempts  (optional)
   * @param clusterNotificationInterval  (optional)
   * @param idCacheSize  (optional)
   * @param clusterConfirmationWindowSize  (optional)
   * @param clusterConnectionTtl  (optional)
   * @param clusterDuplicateDetection  (optional)
   * @param clusterInitialConnectAttempts  (optional)
   * @param clusterMaxRetryInterval  (optional)
   * @param clusterMinLargeMessageSize  (optional)
   * @param clusterProducerWindowSize  (optional)
   * @param clusterReconnectAttempts  (optional)
   * @param clusterRetryInterval  (optional)
   * @param clusterRetryIntervalMultiplier  (optional)
   * @return ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo
   */
  def comAdobeCqScreensMqActivemqImplArtemisJMSProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, globalSize: Option[Integer] = None, maxDiskUsage: Option[Integer] = None, persistenceEnabled: Option[Boolean] = None, threadPoolMaxSize: Option[Integer] = None, scheduledThreadPoolMaxSize: Option[Integer] = None, gracefulShutdownTimeout: Option[Integer] = None, queues: Option[List[String]] = None, topics: Option[List[String]] = None, addressesMaxDeliveryAttempts: Option[Integer] = None, addressesExpiryDelay: Option[Integer] = None, addressesAddressFullMessagePolicy: Option[String] = None, addressesMaxSizeBytes: Option[Integer] = None, addressesPageSizeBytes: Option[Integer] = None, addressesPageCacheMaxSize: Option[Integer] = None, clusterUser: Option[String] = None, clusterPassword: Option[String] = None, clusterCallTimeout: Option[Integer] = None, clusterCallFailoverTimeout: Option[Integer] = None, clusterClientFailureCheckPeriod: Option[Integer] = None, clusterNotificationAttempts: Option[Integer] = None, clusterNotificationInterval: Option[Integer] = None, idCacheSize: Option[Integer] = None, clusterConfirmationWindowSize: Option[Integer] = None, clusterConnectionTtl: Option[Integer] = None, clusterDuplicateDetection: Option[Boolean] = None, clusterInitialConnectAttempts: Option[Integer] = None, clusterMaxRetryInterval: Option[Integer] = None, clusterMinLargeMessageSize: Option[Integer] = None, clusterProducerWindowSize: Option[Integer] = None, clusterReconnectAttempts: Option[Integer] = None, clusterRetryInterval: Option[Integer] = None, clusterRetryIntervalMultiplier: Option[Number] = None): Option[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo] = {
    val await = Try(Await.result(comAdobeCqScreensMqActivemqImplArtemisJMSProviderAsync(post, apply, delete, action, location, propertylist, serviceRanking, globalSize, maxDiskUsage, persistenceEnabled, threadPoolMaxSize, scheduledThreadPoolMaxSize, gracefulShutdownTimeout, queues, topics, addressesMaxDeliveryAttempts, addressesExpiryDelay, addressesAddressFullMessagePolicy, addressesMaxSizeBytes, addressesPageSizeBytes, addressesPageCacheMaxSize, clusterUser, clusterPassword, clusterCallTimeout, clusterCallFailoverTimeout, clusterClientFailureCheckPeriod, clusterNotificationAttempts, clusterNotificationInterval, idCacheSize, clusterConfirmationWindowSize, clusterConnectionTtl, clusterDuplicateDetection, clusterInitialConnectAttempts, clusterMaxRetryInterval, clusterMinLargeMessageSize, clusterProducerWindowSize, clusterReconnectAttempts, clusterRetryInterval, clusterRetryIntervalMultiplier), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param globalSize  (optional)
   * @param maxDiskUsage  (optional)
   * @param persistenceEnabled  (optional)
   * @param threadPoolMaxSize  (optional)
   * @param scheduledThreadPoolMaxSize  (optional)
   * @param gracefulShutdownTimeout  (optional)
   * @param queues  (optional)
   * @param topics  (optional)
   * @param addressesMaxDeliveryAttempts  (optional)
   * @param addressesExpiryDelay  (optional)
   * @param addressesAddressFullMessagePolicy  (optional)
   * @param addressesMaxSizeBytes  (optional)
   * @param addressesPageSizeBytes  (optional)
   * @param addressesPageCacheMaxSize  (optional)
   * @param clusterUser  (optional)
   * @param clusterPassword  (optional)
   * @param clusterCallTimeout  (optional)
   * @param clusterCallFailoverTimeout  (optional)
   * @param clusterClientFailureCheckPeriod  (optional)
   * @param clusterNotificationAttempts  (optional)
   * @param clusterNotificationInterval  (optional)
   * @param idCacheSize  (optional)
   * @param clusterConfirmationWindowSize  (optional)
   * @param clusterConnectionTtl  (optional)
   * @param clusterDuplicateDetection  (optional)
   * @param clusterInitialConnectAttempts  (optional)
   * @param clusterMaxRetryInterval  (optional)
   * @param clusterMinLargeMessageSize  (optional)
   * @param clusterProducerWindowSize  (optional)
   * @param clusterReconnectAttempts  (optional)
   * @param clusterRetryInterval  (optional)
   * @param clusterRetryIntervalMultiplier  (optional)
   * @return Future(ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo)
   */
  def comAdobeCqScreensMqActivemqImplArtemisJMSProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, globalSize: Option[Integer] = None, maxDiskUsage: Option[Integer] = None, persistenceEnabled: Option[Boolean] = None, threadPoolMaxSize: Option[Integer] = None, scheduledThreadPoolMaxSize: Option[Integer] = None, gracefulShutdownTimeout: Option[Integer] = None, queues: Option[List[String]] = None, topics: Option[List[String]] = None, addressesMaxDeliveryAttempts: Option[Integer] = None, addressesExpiryDelay: Option[Integer] = None, addressesAddressFullMessagePolicy: Option[String] = None, addressesMaxSizeBytes: Option[Integer] = None, addressesPageSizeBytes: Option[Integer] = None, addressesPageCacheMaxSize: Option[Integer] = None, clusterUser: Option[String] = None, clusterPassword: Option[String] = None, clusterCallTimeout: Option[Integer] = None, clusterCallFailoverTimeout: Option[Integer] = None, clusterClientFailureCheckPeriod: Option[Integer] = None, clusterNotificationAttempts: Option[Integer] = None, clusterNotificationInterval: Option[Integer] = None, idCacheSize: Option[Integer] = None, clusterConfirmationWindowSize: Option[Integer] = None, clusterConnectionTtl: Option[Integer] = None, clusterDuplicateDetection: Option[Boolean] = None, clusterInitialConnectAttempts: Option[Integer] = None, clusterMaxRetryInterval: Option[Integer] = None, clusterMinLargeMessageSize: Option[Integer] = None, clusterProducerWindowSize: Option[Integer] = None, clusterReconnectAttempts: Option[Integer] = None, clusterRetryInterval: Option[Integer] = None, clusterRetryIntervalMultiplier: Option[Number] = None): Future[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo] = {
      helper.comAdobeCqScreensMqActivemqImplArtemisJMSProvider(post, apply, delete, action, location, propertylist, serviceRanking, globalSize, maxDiskUsage, persistenceEnabled, threadPoolMaxSize, scheduledThreadPoolMaxSize, gracefulShutdownTimeout, queues, topics, addressesMaxDeliveryAttempts, addressesExpiryDelay, addressesAddressFullMessagePolicy, addressesMaxSizeBytes, addressesPageSizeBytes, addressesPageCacheMaxSize, clusterUser, clusterPassword, clusterCallTimeout, clusterCallFailoverTimeout, clusterClientFailureCheckPeriod, clusterNotificationAttempts, clusterNotificationInterval, idCacheSize, clusterConfirmationWindowSize, clusterConnectionTtl, clusterDuplicateDetection, clusterInitialConnectAttempts, clusterMaxRetryInterval, clusterMinLargeMessageSize, clusterProducerWindowSize, clusterReconnectAttempts, clusterRetryInterval, clusterRetryIntervalMultiplier)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath  (optional)
   * @param comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency  (optional)
   * @return ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo
   */
  def comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath: Option[List[String]] = None, comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency: Option[String] = None): Option[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplAsync(post, apply, delete, action, location, propertylist, comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath, comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath  (optional)
   * @param comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency  (optional)
   * @return Future(ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo)
   */
  def comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath: Option[List[String]] = None, comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency: Option[String] = None): Future[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo] = {
      helper.comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImpl(post, apply, delete, action, location, propertylist, comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath, comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disableSmartSync  (optional)
   * @return ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo
   */
  def comAdobeCqScreensOfflinecontentImplOfflineContentServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disableSmartSync: Option[Boolean] = None): Option[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqScreensOfflinecontentImplOfflineContentServiceImplAsync(post, apply, delete, action, location, propertylist, disableSmartSync), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disableSmartSync  (optional)
   * @return Future(ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo)
   */
  def comAdobeCqScreensOfflinecontentImplOfflineContentServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disableSmartSync: Option[Boolean] = None): Future[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo] = {
      helper.comAdobeCqScreensOfflinecontentImplOfflineContentServiceImpl(post, apply, delete, action, location, propertylist, disableSmartSync)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enableDataTriggeredContent  (optional)
   * @return ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo
   */
  def comAdobeCqScreensSegmentationImplSegmentationFeatureFlag(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enableDataTriggeredContent: Option[Boolean] = None): Option[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo] = {
    val await = Try(Await.result(comAdobeCqScreensSegmentationImplSegmentationFeatureFlagAsync(post, apply, delete, action, location, propertylist, enableDataTriggeredContent), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enableDataTriggeredContent  (optional)
   * @return Future(ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo)
   */
  def comAdobeCqScreensSegmentationImplSegmentationFeatureFlagAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enableDataTriggeredContent: Option[Boolean] = None): Future[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo] = {
      helper.comAdobeCqScreensSegmentationImplSegmentationFeatureFlag(post, apply, delete, action, location, propertylist, enableDataTriggeredContent)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo
   */
  def comAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthCh(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo] = {
    val await = Try(Await.result(comAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo)
   */
  def comAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo] = {
      helper.comAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthCh(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo
   */
  def comAdobeCqSecurityHcBundlesImplWcmFilterHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo)
   */
  def comAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo] = {
      helper.comAdobeCqSecurityHcBundlesImplWcmFilterHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param dispatcherAddress  (optional)
   * @param dispatcherFilterAllowed  (optional)
   * @param dispatcherFilterBlocked  (optional)
   * @return ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo
   */
  def comAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, dispatcherAddress: Option[String] = None, dispatcherFilterAllowed: Option[List[String]] = None, dispatcherFilterBlocked: Option[List[String]] = None): Option[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags, dispatcherAddress, dispatcherFilterAllowed, dispatcherFilterBlocked), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param dispatcherAddress  (optional)
   * @param dispatcherFilterAllowed  (optional)
   * @param dispatcherFilterBlocked  (optional)
   * @return Future(ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo)
   */
  def comAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, dispatcherAddress: Option[String] = None, dispatcherFilterAllowed: Option[List[String]] = None, dispatcherFilterBlocked: Option[List[String]] = None): Future[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo] = {
      helper.comAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheck(post, apply, delete, action, location, propertylist, hcTags, dispatcherAddress, dispatcherFilterAllowed, dispatcherFilterBlocked)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo
   */
  def comAdobeCqSecurityHcPackagesImplExampleContentHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeCqSecurityHcPackagesImplExampleContentHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo)
   */
  def comAdobeCqSecurityHcPackagesImplExampleContentHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo] = {
      helper.comAdobeCqSecurityHcPackagesImplExampleContentHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param webserverAddress  (optional)
   * @return ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo
   */
  def comAdobeCqSecurityHcWebserverImplClickjackingHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, webserverAddress: Option[String] = None): Option[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeCqSecurityHcWebserverImplClickjackingHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags, webserverAddress), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param webserverAddress  (optional)
   * @return Future(ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo)
   */
  def comAdobeCqSecurityHcWebserverImplClickjackingHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, webserverAddress: Option[String] = None): Future[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo] = {
      helper.comAdobeCqSecurityHcWebserverImplClickjackingHealthCheck(post, apply, delete, action, location, propertylist, hcTags, webserverAddress)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enable  (optional)
   * @param ttl1  (optional)
   * @param ttl2  (optional)
   * @return ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo
   */
  def comAdobeCqSocialAccountverificationImplAccountManagementConfigIm(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enable: Option[Boolean] = None, ttl1: Option[Integer] = None, ttl2: Option[Integer] = None): Option[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo] = {
    val await = Try(Await.result(comAdobeCqSocialAccountverificationImplAccountManagementConfigImAsync(post, apply, delete, action, location, propertylist, enable, ttl1, ttl2), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enable  (optional)
   * @param ttl1  (optional)
   * @param ttl2  (optional)
   * @return Future(ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo)
   */
  def comAdobeCqSocialAccountverificationImplAccountManagementConfigImAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enable: Option[Boolean] = None, ttl1: Option[Integer] = None, ttl2: Option[Integer] = None): Future[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo] = {
      helper.comAdobeCqSocialAccountverificationImplAccountManagementConfigIm(post, apply, delete, action, location, propertylist, enable, ttl1, ttl2)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priority  (optional)
   * @return ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo
   */
  def comAdobeCqSocialActivitystreamsClientImplSocialActivityComponen(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priority: Option[Integer] = None): Option[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo] = {
    val await = Try(Await.result(comAdobeCqSocialActivitystreamsClientImplSocialActivityComponenAsync(post, apply, delete, action, location, propertylist, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priority  (optional)
   * @return Future(ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo)
   */
  def comAdobeCqSocialActivitystreamsClientImplSocialActivityComponenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priority: Option[Integer] = None): Future[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo] = {
      helper.comAdobeCqSocialActivitystreamsClientImplSocialActivityComponen(post, apply, delete, action, location, propertylist, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priority  (optional)
   * @return ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo
   */
  def comAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCo(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priority: Option[Integer] = None): Option[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo] = {
    val await = Try(Await.result(comAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoAsync(post, apply, delete, action, location, propertylist, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priority  (optional)
   * @return Future(ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo)
   */
  def comAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priority: Option[Integer] = None): Future[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo] = {
      helper.comAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCo(post, apply, delete, action, location, propertylist, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @return ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo
   */
  def comAdobeCqSocialActivitystreamsListenerImplEventListenerHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None): Option[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo] = {
    val await = Try(Await.result(comAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerAsync(post, apply, delete, action, location, propertylist, eventTopics, eventFilter), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @return Future(ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo)
   */
  def comAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None): Future[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo] = {
      helper.comAdobeCqSocialActivitystreamsListenerImplEventListenerHandler(post, apply, delete, action, location, propertylist, eventTopics, eventFilter)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param accepted  (optional)
   * @param ranked  (optional)
   * @return ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo
   */
  def comAdobeCqSocialActivitystreamsListenerImplModerationEventExten(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, accepted: Option[Boolean] = None, ranked: Option[Integer] = None): Option[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo] = {
    val await = Try(Await.result(comAdobeCqSocialActivitystreamsListenerImplModerationEventExtenAsync(post, apply, delete, action, location, propertylist, accepted, ranked), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param accepted  (optional)
   * @param ranked  (optional)
   * @return Future(ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo)
   */
  def comAdobeCqSocialActivitystreamsListenerImplModerationEventExtenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, accepted: Option[Boolean] = None, ranked: Option[Integer] = None): Future[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo] = {
      helper.comAdobeCqSocialActivitystreamsListenerImplModerationEventExten(post, apply, delete, action, location, propertylist, accepted, ranked)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param ranking  (optional)
   * @param enable  (optional)
   * @return ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo
   */
  def comAdobeCqSocialActivitystreamsListenerImplRatingEventActivityS(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, ranking: Option[Integer] = None, enable: Option[Boolean] = None): Option[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo] = {
    val await = Try(Await.result(comAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySAsync(post, apply, delete, action, location, propertylist, ranking, enable), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param ranking  (optional)
   * @param enable  (optional)
   * @return Future(ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo)
   */
  def comAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, ranking: Option[Integer] = None, enable: Option[Boolean] = None): Future[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo] = {
      helper.comAdobeCqSocialActivitystreamsListenerImplRatingEventActivityS(post, apply, delete, action, location, propertylist, ranking, enable)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param streamPath  (optional)
   * @param streamName  (optional)
   * @return ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo
   */
  def comAdobeCqSocialActivitystreamsListenerImplResourceActivityStre(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, streamPath: Option[String] = None, streamName: Option[String] = None): Option[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo] = {
    val await = Try(Await.result(comAdobeCqSocialActivitystreamsListenerImplResourceActivityStreAsync(post, apply, delete, action, location, propertylist, streamPath, streamName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param streamPath  (optional)
   * @param streamName  (optional)
   * @return Future(ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo)
   */
  def comAdobeCqSocialActivitystreamsListenerImplResourceActivityStreAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, streamPath: Option[String] = None, streamName: Option[String] = None): Future[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo] = {
      helper.comAdobeCqSocialActivitystreamsListenerImplResourceActivityStre(post, apply, delete, action, location, propertylist, streamPath, streamName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxRetry  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo
   */
  def comAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsI(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxRetry: Option[Integer] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Option[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIAsync(post, apply, delete, action, location, propertylist, maxRetry, fieldWhitelist, attachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxRetry  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return Future(ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo)
   */
  def comAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxRetry: Option[Integer] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Future[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo] = {
      helper.comAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsI(post, apply, delete, action, location, propertylist, maxRetry, fieldWhitelist, attachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @param extensionOrder  (optional)
   * @return ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo
   */
  def comAdobeCqSocialCalendarClientOperationextensionsEventAttachmen(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, attachmentTypeBlacklist: Option[String] = None, extensionOrder: Option[Integer] = None): Option[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCalendarClientOperationextensionsEventAttachmenAsync(post, apply, delete, action, location, propertylist, attachmentTypeBlacklist, extensionOrder), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @param extensionOrder  (optional)
   * @return Future(ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo)
   */
  def comAdobeCqSocialCalendarClientOperationextensionsEventAttachmenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, attachmentTypeBlacklist: Option[String] = None, extensionOrder: Option[Integer] = None): Future[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo] = {
      helper.comAdobeCqSocialCalendarClientOperationextensionsEventAttachmen(post, apply, delete, action, location, propertylist, attachmentTypeBlacklist, extensionOrder)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param timezonesExpirytime  (optional)
   * @return ComAdobeCqSocialCalendarServletsTimeZoneServletInfo
   */
  def comAdobeCqSocialCalendarServletsTimeZoneServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, timezonesExpirytime: Option[Integer] = None): Option[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCalendarServletsTimeZoneServletAsync(post, apply, delete, action, location, propertylist, timezonesExpirytime), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param timezonesExpirytime  (optional)
   * @return Future(ComAdobeCqSocialCalendarServletsTimeZoneServletInfo)
   */
  def comAdobeCqSocialCalendarServletsTimeZoneServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, timezonesExpirytime: Option[Integer] = None): Future[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo] = {
      helper.comAdobeCqSocialCalendarServletsTimeZoneServlet(post, apply, delete, action, location, propertylist, timezonesExpirytime)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param ranking  (optional)
   * @return ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo
   */
  def comAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEvent(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, ranking: Option[Integer] = None): Option[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventAsync(post, apply, delete, action, location, propertylist, ranking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param ranking  (optional)
   * @return Future(ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo)
   */
  def comAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, ranking: Option[Integer] = None): Future[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo] = {
      helper.comAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEvent(post, apply, delete, action, location, propertylist, ranking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo
   */
  def comAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSe(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeAsync(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return Future(ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo)
   */
  def comAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo] = {
      helper.comAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSe(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo
   */
  def comAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperati(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiAsync(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return Future(ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo)
   */
  def comAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo] = {
      helper.comAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperati(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param numUserLimit  (optional)
   * @return ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo
   */
  def comAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialC(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, numUserLimit: Option[Integer] = None): Option[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCAsync(post, apply, delete, action, location, propertylist, numUserLimit), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param numUserLimit  (optional)
   * @return Future(ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo)
   */
  def comAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, numUserLimit: Option[Integer] = None): Future[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo] = {
      helper.comAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialC(post, apply, delete, action, location, propertylist, numUserLimit)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enableScheduledPostsSearch  (optional)
   * @param numberOfMinutes  (optional)
   * @param maxSearchLimit  (optional)
   * @return ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo
   */
  def comAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPos(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enableScheduledPostsSearch: Option[Boolean] = None, numberOfMinutes: Option[Integer] = None, maxSearchLimit: Option[Integer] = None): Option[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosAsync(post, apply, delete, action, location, propertylist, enableScheduledPostsSearch, numberOfMinutes, maxSearchLimit), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enableScheduledPostsSearch  (optional)
   * @param numberOfMinutes  (optional)
   * @param maxSearchLimit  (optional)
   * @return Future(ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo)
   */
  def comAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enableScheduledPostsSearch: Option[Boolean] = None, numberOfMinutes: Option[Integer] = None, maxSearchLimit: Option[Integer] = None): Future[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo] = {
      helper.comAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPos(post, apply, delete, action, location, propertylist, enableScheduledPostsSearch, numberOfMinutes, maxSearchLimit)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param corsEnabling  (optional)
   * @return ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo
   */
  def comAdobeCqSocialCommonsCorsCORSAuthenticationFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, corsEnabling: Option[Boolean] = None): Option[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsCorsCORSAuthenticationFilterAsync(post, apply, delete, action, location, propertylist, corsEnabling), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param corsEnabling  (optional)
   * @return Future(ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo)
   */
  def comAdobeCqSocialCommonsCorsCORSAuthenticationFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, corsEnabling: Option[Boolean] = None): Future[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo] = {
      helper.comAdobeCqSocialCommonsCorsCORSAuthenticationFilter(post, apply, delete, action, location, propertylist, corsEnabling)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderAsync(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProvider(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param contextPath  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, contextPath: Option[String] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplAsync(post, apply, delete, action, location, propertylist, contextPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param contextPath  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, contextPath: Option[String] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImpl(post, apply, delete, action, location, propertylist, contextPath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerAsync(post, apply, delete, action, location, propertylist, eventTopics), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListener(post, apply, delete, action, location, propertylist, eventTopics)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderAsync(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProvider(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param patternTime  (optional)
   * @param patternNewline  (optional)
   * @param patternDayOfMonth  (optional)
   * @param patternMonth  (optional)
   * @param patternYear  (optional)
   * @param patternDate  (optional)
   * @param patternDateTime  (optional)
   * @param patternEmail  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImp(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, patternTime: Option[String] = None, patternNewline: Option[String] = None, patternDayOfMonth: Option[String] = None, patternMonth: Option[String] = None, patternYear: Option[String] = None, patternDate: Option[String] = None, patternDateTime: Option[String] = None, patternEmail: Option[String] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpAsync(post, apply, delete, action, location, propertylist, patternTime, patternNewline, patternDayOfMonth, patternMonth, patternYear, patternDate, patternDateTime, patternEmail), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param patternTime  (optional)
   * @param patternNewline  (optional)
   * @param patternDayOfMonth  (optional)
   * @param patternMonth  (optional)
   * @param patternYear  (optional)
   * @param patternDate  (optional)
   * @param patternDateTime  (optional)
   * @param patternEmail  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, patternTime: Option[String] = None, patternNewline: Option[String] = None, patternDayOfMonth: Option[String] = None, patternMonth: Option[String] = None, patternYear: Option[String] = None, patternDate: Option[String] = None, patternDateTime: Option[String] = None, patternEmail: Option[String] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImp(post, apply, delete, action, location, propertylist, patternTime, patternNewline, patternDayOfMonth, patternMonth, patternYear, patternDate, patternDateTime, patternEmail)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param emailName  (optional)
   * @param emailCreatePostFromReply  (optional)
   * @param emailAddCommentIdTo  (optional)
   * @param emailSubjectMaximumLength  (optional)
   * @param emailReplyToAddress  (optional)
   * @param emailReplyToDelimiter  (optional)
   * @param emailTrackerIdPrefixInSubject  (optional)
   * @param emailTrackerIdPrefixInBody  (optional)
   * @param emailAsHTML  (optional)
   * @param emailDefaultUserName  (optional)
   * @param emailTemplatesRootPath  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImp(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, emailName: Option[String] = None, emailCreatePostFromReply: Option[Boolean] = None, emailAddCommentIdTo: Option[String] = None, emailSubjectMaximumLength: Option[Integer] = None, emailReplyToAddress: Option[String] = None, emailReplyToDelimiter: Option[String] = None, emailTrackerIdPrefixInSubject: Option[String] = None, emailTrackerIdPrefixInBody: Option[String] = None, emailAsHTML: Option[Boolean] = None, emailDefaultUserName: Option[String] = None, emailTemplatesRootPath: Option[String] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpAsync(post, apply, delete, action, location, propertylist, emailName, emailCreatePostFromReply, emailAddCommentIdTo, emailSubjectMaximumLength, emailReplyToAddress, emailReplyToDelimiter, emailTrackerIdPrefixInSubject, emailTrackerIdPrefixInBody, emailAsHTML, emailDefaultUserName, emailTemplatesRootPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param emailName  (optional)
   * @param emailCreatePostFromReply  (optional)
   * @param emailAddCommentIdTo  (optional)
   * @param emailSubjectMaximumLength  (optional)
   * @param emailReplyToAddress  (optional)
   * @param emailReplyToDelimiter  (optional)
   * @param emailTrackerIdPrefixInSubject  (optional)
   * @param emailTrackerIdPrefixInBody  (optional)
   * @param emailAsHTML  (optional)
   * @param emailDefaultUserName  (optional)
   * @param emailTemplatesRootPath  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, emailName: Option[String] = None, emailCreatePostFromReply: Option[Boolean] = None, emailAddCommentIdTo: Option[String] = None, emailSubjectMaximumLength: Option[Integer] = None, emailReplyToAddress: Option[String] = None, emailReplyToDelimiter: Option[String] = None, emailTrackerIdPrefixInSubject: Option[String] = None, emailTrackerIdPrefixInBody: Option[String] = None, emailAsHTML: Option[Boolean] = None, emailDefaultUserName: Option[String] = None, emailTemplatesRootPath: Option[String] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImp(post, apply, delete, action, location, propertylist, emailName, emailCreatePostFromReply, emailAddCommentIdTo, emailSubjectMaximumLength, emailReplyToAddress, emailReplyToDelimiter, emailTrackerIdPrefixInSubject, emailTrackerIdPrefixInBody, emailAsHTML, emailDefaultUserName, emailTemplatesRootPath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param connectProtocol  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplEmailReplyImporter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, connectProtocol: Option[String] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterAsync(post, apply, delete, action, location, propertylist, connectProtocol), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param connectProtocol  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, connectProtocol: Option[String] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplEmailReplyImporter(post, apply, delete, action, location, propertylist, connectProtocol)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderAsync(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProvider(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderAsync(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProvider(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderAsync(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProvider(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderAsync(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProvider(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param replyEmailPatterns  (optional)
   * @param priorityOrder  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, replyEmailPatterns: Option[List[String]] = None, priorityOrder: Option[Integer] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderAsync(post, apply, delete, action, location, propertylist, replyEmailPatterns, priorityOrder), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param replyEmailPatterns  (optional)
   * @param priorityOrder  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, replyEmailPatterns: Option[List[String]] = None, priorityOrder: Option[Integer] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProvider(post, apply, delete, action, location, propertylist, replyEmailPatterns, priorityOrder)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo
   */
  def comAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderAsync(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priorityOrder  (optional)
   * @param replyEmailPatterns  (optional)
   * @return Future(ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo)
   */
  def comAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priorityOrder: Option[Integer] = None, replyEmailPatterns: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo] = {
      helper.comAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProvider(post, apply, delete, action, location, propertylist, priorityOrder, replyEmailPatterns)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param numberOfDays  (optional)
   * @param ageOfFile  (optional)
   * @return ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo
   */
  def comAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUpload(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, numberOfDays: Option[Integer] = None, ageOfFile: Option[Integer] = None): Option[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadAsync(post, apply, delete, action, location, propertylist, numberOfDays, ageOfFile), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param numberOfDays  (optional)
   * @param ageOfFile  (optional)
   * @return Future(ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo)
   */
  def comAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, numberOfDays: Option[Integer] = None, ageOfFile: Option[Integer] = None): Future[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo] = {
      helper.comAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUpload(post, apply, delete, action, location, propertylist, numberOfDays, ageOfFile)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @param verbs  (optional)
   * @return ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo
   */
  def comAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None, verbs: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplAsync(post, apply, delete, action, location, propertylist, eventTopics, eventFilter, verbs), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @param verbs  (optional)
   * @return Future(ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo)
   */
  def comAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None, verbs: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo] = {
      helper.comAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImpl(post, apply, delete, action, location, propertylist, eventTopics, eventFilter, verbs)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enable  (optional)
   * @param uGCLimit  (optional)
   * @param ugcLimitDuration  (optional)
   * @param domains  (optional)
   * @param toList  (optional)
   * @return ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo
   */
  def comAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimit(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enable: Option[Boolean] = None, uGCLimit: Option[Integer] = None, ugcLimitDuration: Option[Integer] = None, domains: Option[List[String]] = None, toList: Option[List[String]] = None): Option[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo] = {
    val await = Try(Await.result(comAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitAsync(post, apply, delete, action, location, propertylist, enable, uGCLimit, ugcLimitDuration, domains, toList), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enable  (optional)
   * @param uGCLimit  (optional)
   * @param ugcLimitDuration  (optional)
   * @param domains  (optional)
   * @param toList  (optional)
   * @return Future(ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo)
   */
  def comAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enable: Option[Boolean] = None, uGCLimit: Option[Integer] = None, ugcLimitDuration: Option[Integer] = None, domains: Option[List[String]] = None, toList: Option[List[String]] = None): Future[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo] = {
      helper.comAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimit(post, apply, delete, action, location, propertylist, enable, uGCLimit, ugcLimitDuration, domains, toList)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @param oauthCloudConfigRoot  (optional)
   * @param providerConfigRoot  (optional)
   * @param providerConfigCreateTagsEnabled  (optional)
   * @param providerConfigUserFolder  (optional)
   * @param providerConfigFacebookFetchFields  (optional)
   * @param providerConfigFacebookFields  (optional)
   * @param providerConfigRefreshUserdataEnabled  (optional)
   * @return ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo
   */
  def comAdobeCqSocialConnectOauthImplFacebookProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None, oauthCloudConfigRoot: Option[String] = None, providerConfigRoot: Option[String] = None, providerConfigCreateTagsEnabled: Option[Boolean] = None, providerConfigUserFolder: Option[String] = None, providerConfigFacebookFetchFields: Option[Boolean] = None, providerConfigFacebookFields: Option[List[String]] = None, providerConfigRefreshUserdataEnabled: Option[Boolean] = None): Option[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialConnectOauthImplFacebookProviderImplAsync(post, apply, delete, action, location, propertylist, oauthProviderId, oauthCloudConfigRoot, providerConfigRoot, providerConfigCreateTagsEnabled, providerConfigUserFolder, providerConfigFacebookFetchFields, providerConfigFacebookFields, providerConfigRefreshUserdataEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @param oauthCloudConfigRoot  (optional)
   * @param providerConfigRoot  (optional)
   * @param providerConfigCreateTagsEnabled  (optional)
   * @param providerConfigUserFolder  (optional)
   * @param providerConfigFacebookFetchFields  (optional)
   * @param providerConfigFacebookFields  (optional)
   * @param providerConfigRefreshUserdataEnabled  (optional)
   * @return Future(ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo)
   */
  def comAdobeCqSocialConnectOauthImplFacebookProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None, oauthCloudConfigRoot: Option[String] = None, providerConfigRoot: Option[String] = None, providerConfigCreateTagsEnabled: Option[Boolean] = None, providerConfigUserFolder: Option[String] = None, providerConfigFacebookFetchFields: Option[Boolean] = None, providerConfigFacebookFields: Option[List[String]] = None, providerConfigRefreshUserdataEnabled: Option[Boolean] = None): Future[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo] = {
      helper.comAdobeCqSocialConnectOauthImplFacebookProviderImpl(post, apply, delete, action, location, propertylist, oauthProviderId, oauthCloudConfigRoot, providerConfigRoot, providerConfigCreateTagsEnabled, providerConfigUserFolder, providerConfigFacebookFetchFields, providerConfigFacebookFields, providerConfigRefreshUserdataEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param serviceRanking  (optional)
   * @return ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo
   */
  def comAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandle(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[List[String]] = None, serviceRanking: Option[Integer] = None): Option[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo] = {
    val await = Try(Await.result(comAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleAsync(post, apply, delete, action, location, propertylist, `path`, serviceRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param serviceRanking  (optional)
   * @return Future(ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo)
   */
  def comAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[List[String]] = None, serviceRanking: Option[Integer] = None): Future[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo] = {
      helper.comAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandle(post, apply, delete, action, location, propertylist, `path`, serviceRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param facebook  (optional)
   * @param twitter  (optional)
   * @param providerConfigUserFolder  (optional)
   * @return ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo
   */
  def comAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapper(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, facebook: Option[List[String]] = None, twitter: Option[List[String]] = None, providerConfigUserFolder: Option[String] = None): Option[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo] = {
    val await = Try(Await.result(comAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperAsync(post, apply, delete, action, location, propertylist, facebook, twitter, providerConfigUserFolder), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param facebook  (optional)
   * @param twitter  (optional)
   * @param providerConfigUserFolder  (optional)
   * @return Future(ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo)
   */
  def comAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, facebook: Option[List[String]] = None, twitter: Option[List[String]] = None, providerConfigUserFolder: Option[String] = None): Future[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo] = {
      helper.comAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapper(post, apply, delete, action, location, propertylist, facebook, twitter, providerConfigUserFolder)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @param oauthCloudConfigRoot  (optional)
   * @param providerConfigRoot  (optional)
   * @param providerConfigUserFolder  (optional)
   * @param providerConfigTwitterEnableParams  (optional)
   * @param providerConfigTwitterParams  (optional)
   * @param providerConfigRefreshUserdataEnabled  (optional)
   * @return ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo
   */
  def comAdobeCqSocialConnectOauthImplTwitterProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None, oauthCloudConfigRoot: Option[String] = None, providerConfigRoot: Option[String] = None, providerConfigUserFolder: Option[String] = None, providerConfigTwitterEnableParams: Option[Boolean] = None, providerConfigTwitterParams: Option[List[String]] = None, providerConfigRefreshUserdataEnabled: Option[Boolean] = None): Option[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialConnectOauthImplTwitterProviderImplAsync(post, apply, delete, action, location, propertylist, oauthProviderId, oauthCloudConfigRoot, providerConfigRoot, providerConfigUserFolder, providerConfigTwitterEnableParams, providerConfigTwitterParams, providerConfigRefreshUserdataEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @param oauthCloudConfigRoot  (optional)
   * @param providerConfigRoot  (optional)
   * @param providerConfigUserFolder  (optional)
   * @param providerConfigTwitterEnableParams  (optional)
   * @param providerConfigTwitterParams  (optional)
   * @param providerConfigRefreshUserdataEnabled  (optional)
   * @return Future(ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo)
   */
  def comAdobeCqSocialConnectOauthImplTwitterProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None, oauthCloudConfigRoot: Option[String] = None, providerConfigRoot: Option[String] = None, providerConfigUserFolder: Option[String] = None, providerConfigTwitterEnableParams: Option[Boolean] = None, providerConfigTwitterParams: Option[List[String]] = None, providerConfigRefreshUserdataEnabled: Option[Boolean] = None): Future[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo] = {
      helper.comAdobeCqSocialConnectOauthImplTwitterProviderImpl(post, apply, delete, action, location, propertylist, oauthProviderId, oauthCloudConfigRoot, providerConfigRoot, providerConfigUserFolder, providerConfigTwitterEnableParams, providerConfigTwitterParams, providerConfigRefreshUserdataEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSocialContentFragmentsServicesEnabled  (optional)
   * @param cqSocialContentFragmentsServicesWaitTimeSeconds  (optional)
   * @return ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo
   */
  def comAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmen(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSocialContentFragmentsServicesEnabled: Option[Boolean] = None, cqSocialContentFragmentsServicesWaitTimeSeconds: Option[Integer] = None): Option[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo] = {
    val await = Try(Await.result(comAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenAsync(post, apply, delete, action, location, propertylist, cqSocialContentFragmentsServicesEnabled, cqSocialContentFragmentsServicesWaitTimeSeconds), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSocialContentFragmentsServicesEnabled  (optional)
   * @param cqSocialContentFragmentsServicesWaitTimeSeconds  (optional)
   * @return Future(ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo)
   */
  def comAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSocialContentFragmentsServicesEnabled: Option[Boolean] = None, cqSocialContentFragmentsServicesWaitTimeSeconds: Option[Integer] = None): Future[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo] = {
      helper.comAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmen(post, apply, delete, action, location, propertylist, cqSocialContentFragmentsServicesEnabled, cqSocialContentFragmentsServicesWaitTimeSeconds)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param versionId  (optional)
   * @param cacheOn  (optional)
   * @param concurrencyLevel  (optional)
   * @param cacheStartSize  (optional)
   * @param cacheTtl  (optional)
   * @param cacheSize  (optional)
   * @param timeLimit  (optional)
   * @return ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo
   */
  def comAdobeCqSocialDatastoreAsImplASResourceProviderFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, versionId: Option[String] = None, cacheOn: Option[Boolean] = None, concurrencyLevel: Option[Integer] = None, cacheStartSize: Option[Integer] = None, cacheTtl: Option[Integer] = None, cacheSize: Option[Integer] = None, timeLimit: Option[Integer] = None): Option[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo] = {
    val await = Try(Await.result(comAdobeCqSocialDatastoreAsImplASResourceProviderFactoryAsync(post, apply, delete, action, location, propertylist, versionId, cacheOn, concurrencyLevel, cacheStartSize, cacheTtl, cacheSize, timeLimit), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param versionId  (optional)
   * @param cacheOn  (optional)
   * @param concurrencyLevel  (optional)
   * @param cacheStartSize  (optional)
   * @param cacheTtl  (optional)
   * @param cacheSize  (optional)
   * @param timeLimit  (optional)
   * @return Future(ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo)
   */
  def comAdobeCqSocialDatastoreAsImplASResourceProviderFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, versionId: Option[String] = None, cacheOn: Option[Boolean] = None, concurrencyLevel: Option[Integer] = None, cacheStartSize: Option[Integer] = None, cacheTtl: Option[Integer] = None, cacheSize: Option[Integer] = None, timeLimit: Option[Integer] = None): Future[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo] = {
      helper.comAdobeCqSocialDatastoreAsImplASResourceProviderFactory(post, apply, delete, action, location, propertylist, versionId, cacheOn, concurrencyLevel, cacheStartSize, cacheTtl, cacheSize, timeLimit)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param solrZkTimeout  (optional)
   * @param solrCommit  (optional)
   * @param cacheOn  (optional)
   * @param concurrencyLevel  (optional)
   * @param cacheStartSize  (optional)
   * @param cacheTtl  (optional)
   * @param cacheSize  (optional)
   * @return ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo
   */
  def comAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, solrZkTimeout: Option[String] = None, solrCommit: Option[String] = None, cacheOn: Option[Boolean] = None, concurrencyLevel: Option[Integer] = None, cacheStartSize: Option[Integer] = None, cacheTtl: Option[Integer] = None, cacheSize: Option[Integer] = None): Option[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo] = {
    val await = Try(Await.result(comAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryAsync(post, apply, delete, action, location, propertylist, solrZkTimeout, solrCommit, cacheOn, concurrencyLevel, cacheStartSize, cacheTtl, cacheSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param solrZkTimeout  (optional)
   * @param solrCommit  (optional)
   * @param cacheOn  (optional)
   * @param concurrencyLevel  (optional)
   * @param cacheStartSize  (optional)
   * @param cacheTtl  (optional)
   * @param cacheSize  (optional)
   * @return Future(ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo)
   */
  def comAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, solrZkTimeout: Option[String] = None, solrCommit: Option[String] = None, cacheOn: Option[Boolean] = None, concurrencyLevel: Option[Integer] = None, cacheStartSize: Option[Integer] = None, cacheTtl: Option[Integer] = None, cacheSize: Option[Integer] = None): Future[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo] = {
      helper.comAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactory(post, apply, delete, action, location, propertylist, solrZkTimeout, solrCommit, cacheOn, concurrencyLevel, cacheStartSize, cacheTtl, cacheSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param solrZkTimeout  (optional)
   * @param solrCommit  (optional)
   * @param cacheOn  (optional)
   * @param concurrencyLevel  (optional)
   * @param cacheStartSize  (optional)
   * @param cacheTtl  (optional)
   * @param cacheSize  (optional)
   * @return ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo
   */
  def comAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, solrZkTimeout: Option[String] = None, solrCommit: Option[String] = None, cacheOn: Option[Boolean] = None, concurrencyLevel: Option[Integer] = None, cacheStartSize: Option[Integer] = None, cacheTtl: Option[Integer] = None, cacheSize: Option[Integer] = None): Option[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo] = {
    val await = Try(Await.result(comAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorAsync(post, apply, delete, action, location, propertylist, solrZkTimeout, solrCommit, cacheOn, concurrencyLevel, cacheStartSize, cacheTtl, cacheSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param solrZkTimeout  (optional)
   * @param solrCommit  (optional)
   * @param cacheOn  (optional)
   * @param concurrencyLevel  (optional)
   * @param cacheStartSize  (optional)
   * @param cacheTtl  (optional)
   * @param cacheSize  (optional)
   * @return Future(ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo)
   */
  def comAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, solrZkTimeout: Option[String] = None, solrCommit: Option[String] = None, cacheOn: Option[Boolean] = None, concurrencyLevel: Option[Integer] = None, cacheStartSize: Option[Integer] = None, cacheTtl: Option[Integer] = None, cacheSize: Option[Integer] = None): Future[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo] = {
      helper.comAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactor(post, apply, delete, action, location, propertylist, solrZkTimeout, solrCommit, cacheOn, concurrencyLevel, cacheStartSize, cacheTtl, cacheSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isMemberCheck  (optional)
   * @return ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo
   */
  def comAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorF(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isMemberCheck: Option[Boolean] = None): Option[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo] = {
    val await = Try(Await.result(comAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFAsync(post, apply, delete, action, location, propertylist, isMemberCheck), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isMemberCheck  (optional)
   * @return Future(ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo)
   */
  def comAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isMemberCheck: Option[Boolean] = None): Future[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo] = {
      helper.comAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorF(post, apply, delete, action, location, propertylist, isMemberCheck)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isMemberCheck  (optional)
   * @return ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo
   */
  def comAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFacto(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isMemberCheck: Option[Boolean] = None): Option[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo] = {
    val await = Try(Await.result(comAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoAsync(post, apply, delete, action, location, propertylist, isMemberCheck), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isMemberCheck  (optional)
   * @return Future(ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo)
   */
  def comAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isMemberCheck: Option[Boolean] = None): Future[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo] = {
      helper.comAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFacto(post, apply, delete, action, location, propertylist, isMemberCheck)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @return ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo
   */
  def comAdobeCqSocialEnablementLearningpathEndpointsImplEnablementL(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None): Option[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo] = {
    val await = Try(Await.result(comAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLAsync(post, apply, delete, action, location, propertylist, fieldWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @return Future(ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo)
   */
  def comAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None): Future[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo] = {
      helper.comAdobeCqSocialEnablementLearningpathEndpointsImplEnablementL(post, apply, delete, action, location, propertylist, fieldWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @return ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo
   */
  def comAdobeCqSocialEnablementResourceEndpointsImplEnablementResou(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None): Option[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo] = {
    val await = Try(Await.result(comAdobeCqSocialEnablementResourceEndpointsImplEnablementResouAsync(post, apply, delete, action, location, propertylist, fieldWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @return Future(ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo)
   */
  def comAdobeCqSocialEnablementResourceEndpointsImplEnablementResouAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None): Future[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo] = {
      helper.comAdobeCqSocialEnablementResourceEndpointsImplEnablementResou(post, apply, delete, action, location, propertylist, fieldWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @return ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo
   */
  def comAdobeCqSocialEnablementServicesImplAuthorMarkerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None): Option[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialEnablementServicesImplAuthorMarkerImplAsync(post, apply, delete, action, location, propertylist, serviceRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @return Future(ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo)
   */
  def comAdobeCqSocialEnablementServicesImplAuthorMarkerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None): Future[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo] = {
      helper.comAdobeCqSocialEnablementServicesImplAuthorMarkerImpl(post, apply, delete, action, location, propertylist, serviceRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletSelectors  (optional)
   * @param slingServletExtensions  (optional)
   * @return ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo
   */
  def comAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGe(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletSelectors: Option[String] = None, slingServletExtensions: Option[String] = None): Option[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo] = {
    val await = Try(Await.result(comAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeAsync(post, apply, delete, action, location, propertylist, slingServletSelectors, slingServletExtensions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletSelectors  (optional)
   * @param slingServletExtensions  (optional)
   * @return Future(ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo)
   */
  def comAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletSelectors: Option[String] = None, slingServletExtensions: Option[String] = None): Future[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo] = {
      helper.comAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGe(post, apply, delete, action, location, propertylist, slingServletSelectors, slingServletExtensions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo
   */
  def comAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOpera(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Option[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo] = {
    val await = Try(Await.result(comAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaAsync(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return Future(ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo)
   */
  def comAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Future[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo] = {
      helper.comAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOpera(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo
   */
  def comAdobeCqSocialForumClientEndpointsImplForumOperationsService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Option[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo] = {
    val await = Try(Await.result(comAdobeCqSocialForumClientEndpointsImplForumOperationsServiceAsync(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return Future(ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo)
   */
  def comAdobeCqSocialForumClientEndpointsImplForumOperationsServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Future[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo] = {
      helper.comAdobeCqSocialForumClientEndpointsImplForumOperationsService(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param extensionOrder  (optional)
   * @param flushForumontopic  (optional)
   * @return ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo
   */
  def comAdobeCqSocialForumDispatcherImplFlushOperations(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, extensionOrder: Option[Integer] = None, flushForumontopic: Option[Boolean] = None): Option[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo] = {
    val await = Try(Await.result(comAdobeCqSocialForumDispatcherImplFlushOperationsAsync(post, apply, delete, action, location, propertylist, extensionOrder, flushForumontopic), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param extensionOrder  (optional)
   * @param flushForumontopic  (optional)
   * @return Future(ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo)
   */
  def comAdobeCqSocialForumDispatcherImplFlushOperationsAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, extensionOrder: Option[Integer] = None, flushForumontopic: Option[Boolean] = None): Future[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo] = {
      helper.comAdobeCqSocialForumDispatcherImplFlushOperations(post, apply, delete, action, location, propertylist, extensionOrder, flushForumontopic)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param groupListingPaginationEnable  (optional)
   * @param groupListingLazyloadingEnable  (optional)
   * @param pageSize  (optional)
   * @param priority  (optional)
   * @return ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo
   */
  def comAdobeCqSocialGroupClientImplCommunityGroupCollectionComponen(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, groupListingPaginationEnable: Option[Boolean] = None, groupListingLazyloadingEnable: Option[Boolean] = None, pageSize: Option[Integer] = None, priority: Option[Integer] = None): Option[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo] = {
    val await = Try(Await.result(comAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenAsync(post, apply, delete, action, location, propertylist, groupListingPaginationEnable, groupListingLazyloadingEnable, pageSize, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param groupListingPaginationEnable  (optional)
   * @param groupListingLazyloadingEnable  (optional)
   * @param pageSize  (optional)
   * @param priority  (optional)
   * @return Future(ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo)
   */
  def comAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, groupListingPaginationEnable: Option[Boolean] = None, groupListingLazyloadingEnable: Option[Boolean] = None, pageSize: Option[Integer] = None, priority: Option[Integer] = None): Future[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo] = {
      helper.comAdobeCqSocialGroupClientImplCommunityGroupCollectionComponen(post, apply, delete, action, location, propertylist, groupListingPaginationEnable, groupListingLazyloadingEnable, pageSize, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxWaitTime  (optional)
   * @param minWaitBetweenRetries  (optional)
   * @return ComAdobeCqSocialGroupImplGroupServiceImplInfo
   */
  def comAdobeCqSocialGroupImplGroupServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxWaitTime: Option[Integer] = None, minWaitBetweenRetries: Option[Integer] = None): Option[ComAdobeCqSocialGroupImplGroupServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialGroupImplGroupServiceImplAsync(post, apply, delete, action, location, propertylist, maxWaitTime, minWaitBetweenRetries), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxWaitTime  (optional)
   * @param minWaitBetweenRetries  (optional)
   * @return Future(ComAdobeCqSocialGroupImplGroupServiceImplInfo)
   */
  def comAdobeCqSocialGroupImplGroupServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxWaitTime: Option[Integer] = None, minWaitBetweenRetries: Option[Integer] = None): Future[ComAdobeCqSocialGroupImplGroupServiceImplInfo] = {
      helper.comAdobeCqSocialGroupImplGroupServiceImpl(post, apply, delete, action, location, propertylist, maxWaitTime, minWaitBetweenRetries)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param parameterGuavaCacheEnabled  (optional)
   * @param parameterGuavaCacheParams  (optional)
   * @param parameterGuavaCacheReload  (optional)
   * @param serviceRanking  (optional)
   * @return ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo
   */
  def comAdobeCqSocialHandlebarsGuavaTemplateCacheImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, parameterGuavaCacheEnabled: Option[Boolean] = None, parameterGuavaCacheParams: Option[String] = None, parameterGuavaCacheReload: Option[Boolean] = None, serviceRanking: Option[Integer] = None): Option[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialHandlebarsGuavaTemplateCacheImplAsync(post, apply, delete, action, location, propertylist, parameterGuavaCacheEnabled, parameterGuavaCacheParams, parameterGuavaCacheReload, serviceRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param parameterGuavaCacheEnabled  (optional)
   * @param parameterGuavaCacheParams  (optional)
   * @param parameterGuavaCacheReload  (optional)
   * @param serviceRanking  (optional)
   * @return Future(ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo)
   */
  def comAdobeCqSocialHandlebarsGuavaTemplateCacheImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, parameterGuavaCacheEnabled: Option[Boolean] = None, parameterGuavaCacheParams: Option[String] = None, parameterGuavaCacheReload: Option[Boolean] = None, serviceRanking: Option[Integer] = None): Future[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo] = {
      helper.comAdobeCqSocialHandlebarsGuavaTemplateCacheImpl(post, apply, delete, action, location, propertylist, parameterGuavaCacheEnabled, parameterGuavaCacheParams, parameterGuavaCacheReload, serviceRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo
   */
  def comAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsS(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Option[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo] = {
    val await = Try(Await.result(comAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSAsync(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return Future(ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo)
   */
  def comAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Future[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo] = {
      helper.comAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsS(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo
   */
  def comAdobeCqSocialJournalClientEndpointsImplJournalOperationsSer(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Option[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo] = {
    val await = Try(Await.result(comAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerAsync(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return Future(ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo)
   */
  def comAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Future[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo] = {
      helper.comAdobeCqSocialJournalClientEndpointsImplJournalOperationsSer(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @return ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo
   */
  def comAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfile(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None): Option[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo] = {
    val await = Try(Await.result(comAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileAsync(post, apply, delete, action, location, propertylist, fieldWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @return Future(ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo)
   */
  def comAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None): Future[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo] = {
      helper.comAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfile(post, apply, delete, action, location, propertylist, fieldWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @return ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo
   */
  def comAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileO(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None): Option[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo] = {
    val await = Try(Await.result(comAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOAsync(post, apply, delete, action, location, propertylist, fieldWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @return Future(ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo)
   */
  def comAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None): Future[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo] = {
      helper.comAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileO(post, apply, delete, action, location, propertylist, fieldWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param everyoneLimit  (optional)
   * @param priority  (optional)
   * @return ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo
   */
  def comAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentF(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, everyoneLimit: Option[Integer] = None, priority: Option[Integer] = None): Option[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo] = {
    val await = Try(Await.result(comAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFAsync(post, apply, delete, action, location, propertylist, everyoneLimit, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param everyoneLimit  (optional)
   * @param priority  (optional)
   * @return Future(ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo)
   */
  def comAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, everyoneLimit: Option[Integer] = None, priority: Option[Integer] = None): Future[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo] = {
      helper.comAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentF(post, apply, delete, action, location, propertylist, everyoneLimit, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param messageProperties  (optional)
   * @param messageBoxSizeLimit  (optional)
   * @param messageCountLimit  (optional)
   * @param notifyFailure  (optional)
   * @param failureMessageFrom  (optional)
   * @param failureTemplatePath  (optional)
   * @param maxRetries  (optional)
   * @param minWaitBetweenRetries  (optional)
   * @param countUpdatePoolSize  (optional)
   * @param inboxPath  (optional)
   * @param sentitemsPath  (optional)
   * @param supportAttachments  (optional)
   * @param supportGroupMessaging  (optional)
   * @param maxTotalRecipients  (optional)
   * @param batchSize  (optional)
   * @param maxTotalAttachmentSize  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @param allowedAttachmentTypes  (optional)
   * @param serviceSelector  (optional)
   * @param fieldWhitelist  (optional)
   * @return ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo
   */
  def comAdobeCqSocialMessagingClientEndpointsImplMessagingOperation(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, messageProperties: Option[List[String]] = None, messageBoxSizeLimit: Option[Integer] = None, messageCountLimit: Option[Integer] = None, notifyFailure: Option[Boolean] = None, failureMessageFrom: Option[String] = None, failureTemplatePath: Option[String] = None, maxRetries: Option[Integer] = None, minWaitBetweenRetries: Option[Integer] = None, countUpdatePoolSize: Option[Integer] = None, inboxPath: Option[String] = None, sentitemsPath: Option[String] = None, supportAttachments: Option[Boolean] = None, supportGroupMessaging: Option[Boolean] = None, maxTotalRecipients: Option[Integer] = None, batchSize: Option[Integer] = None, maxTotalAttachmentSize: Option[Integer] = None, attachmentTypeBlacklist: Option[List[String]] = None, allowedAttachmentTypes: Option[List[String]] = None, serviceSelector: Option[String] = None, fieldWhitelist: Option[List[String]] = None): Option[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo] = {
    val await = Try(Await.result(comAdobeCqSocialMessagingClientEndpointsImplMessagingOperationAsync(post, apply, delete, action, location, propertylist, messageProperties, messageBoxSizeLimit, messageCountLimit, notifyFailure, failureMessageFrom, failureTemplatePath, maxRetries, minWaitBetweenRetries, countUpdatePoolSize, inboxPath, sentitemsPath, supportAttachments, supportGroupMessaging, maxTotalRecipients, batchSize, maxTotalAttachmentSize, attachmentTypeBlacklist, allowedAttachmentTypes, serviceSelector, fieldWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param messageProperties  (optional)
   * @param messageBoxSizeLimit  (optional)
   * @param messageCountLimit  (optional)
   * @param notifyFailure  (optional)
   * @param failureMessageFrom  (optional)
   * @param failureTemplatePath  (optional)
   * @param maxRetries  (optional)
   * @param minWaitBetweenRetries  (optional)
   * @param countUpdatePoolSize  (optional)
   * @param inboxPath  (optional)
   * @param sentitemsPath  (optional)
   * @param supportAttachments  (optional)
   * @param supportGroupMessaging  (optional)
   * @param maxTotalRecipients  (optional)
   * @param batchSize  (optional)
   * @param maxTotalAttachmentSize  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @param allowedAttachmentTypes  (optional)
   * @param serviceSelector  (optional)
   * @param fieldWhitelist  (optional)
   * @return Future(ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo)
   */
  def comAdobeCqSocialMessagingClientEndpointsImplMessagingOperationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, messageProperties: Option[List[String]] = None, messageBoxSizeLimit: Option[Integer] = None, messageCountLimit: Option[Integer] = None, notifyFailure: Option[Boolean] = None, failureMessageFrom: Option[String] = None, failureTemplatePath: Option[String] = None, maxRetries: Option[Integer] = None, minWaitBetweenRetries: Option[Integer] = None, countUpdatePoolSize: Option[Integer] = None, inboxPath: Option[String] = None, sentitemsPath: Option[String] = None, supportAttachments: Option[Boolean] = None, supportGroupMessaging: Option[Boolean] = None, maxTotalRecipients: Option[Integer] = None, batchSize: Option[Integer] = None, maxTotalAttachmentSize: Option[Integer] = None, attachmentTypeBlacklist: Option[List[String]] = None, allowedAttachmentTypes: Option[List[String]] = None, serviceSelector: Option[String] = None, fieldWhitelist: Option[List[String]] = None): Future[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo] = {
      helper.comAdobeCqSocialMessagingClientEndpointsImplMessagingOperation(post, apply, delete, action, location, propertylist, messageProperties, messageBoxSizeLimit, messageCountLimit, notifyFailure, failureMessageFrom, failureTemplatePath, maxRetries, minWaitBetweenRetries, countUpdatePoolSize, inboxPath, sentitemsPath, supportAttachments, supportGroupMessaging, maxTotalRecipients, batchSize, maxTotalAttachmentSize, attachmentTypeBlacklist, allowedAttachmentTypes, serviceSelector, fieldWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param resourceTypeFilters  (optional)
   * @param priority  (optional)
   * @return ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo
   */
  def comAdobeCqSocialModerationDashboardApiFilterGroupSocialComponen(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, resourceTypeFilters: Option[List[String]] = None, priority: Option[Integer] = None): Option[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo] = {
    val await = Try(Await.result(comAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenAsync(post, apply, delete, action, location, propertylist, resourceTypeFilters, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param resourceTypeFilters  (optional)
   * @param priority  (optional)
   * @return Future(ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo)
   */
  def comAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, resourceTypeFilters: Option[List[String]] = None, priority: Option[Integer] = None): Future[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo] = {
      helper.comAdobeCqSocialModerationDashboardApiFilterGroupSocialComponen(post, apply, delete, action, location, propertylist, resourceTypeFilters, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priority  (optional)
   * @return ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo
   */
  def comAdobeCqSocialModerationDashboardApiModerationDashboardSocial(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priority: Option[Integer] = None): Option[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo] = {
    val await = Try(Await.result(comAdobeCqSocialModerationDashboardApiModerationDashboardSocialAsync(post, apply, delete, action, location, propertylist, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priority  (optional)
   * @return Future(ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo)
   */
  def comAdobeCqSocialModerationDashboardApiModerationDashboardSocialAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priority: Option[Integer] = None): Future[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo] = {
      helper.comAdobeCqSocialModerationDashboardApiModerationDashboardSocial(post, apply, delete, action, location, propertylist, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priority  (optional)
   * @return ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo
   */
  def comAdobeCqSocialModerationDashboardApiUserDetailsSocialComponen(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priority: Option[Integer] = None): Option[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo] = {
    val await = Try(Await.result(comAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenAsync(post, apply, delete, action, location, propertylist, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priority  (optional)
   * @return Future(ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo)
   */
  def comAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priority: Option[Integer] = None): Future[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo] = {
      helper.comAdobeCqSocialModerationDashboardApiUserDetailsSocialComponen(post, apply, delete, action, location, propertylist, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param resourceTypeFilters  (optional)
   * @param priority  (optional)
   * @return ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo
   */
  def comAdobeCqSocialModerationDashboardInternalImplFilterGroupSoci(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, resourceTypeFilters: Option[List[String]] = None, priority: Option[Integer] = None): Option[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo] = {
    val await = Try(Await.result(comAdobeCqSocialModerationDashboardInternalImplFilterGroupSociAsync(post, apply, delete, action, location, propertylist, resourceTypeFilters, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param resourceTypeFilters  (optional)
   * @param priority  (optional)
   * @return Future(ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo)
   */
  def comAdobeCqSocialModerationDashboardInternalImplFilterGroupSociAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, resourceTypeFilters: Option[List[String]] = None, priority: Option[Integer] = None): Future[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo] = {
      helper.comAdobeCqSocialModerationDashboardInternalImplFilterGroupSoci(post, apply, delete, action, location, propertylist, resourceTypeFilters, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @return ComAdobeCqSocialNotificationsImplMentionsRouterInfo
   */
  def comAdobeCqSocialNotificationsImplMentionsRouter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None): Option[ComAdobeCqSocialNotificationsImplMentionsRouterInfo] = {
    val await = Try(Await.result(comAdobeCqSocialNotificationsImplMentionsRouterAsync(post, apply, delete, action, location, propertylist, eventTopics, eventFilter), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @return Future(ComAdobeCqSocialNotificationsImplMentionsRouterInfo)
   */
  def comAdobeCqSocialNotificationsImplMentionsRouterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None): Future[ComAdobeCqSocialNotificationsImplMentionsRouterInfo] = {
      helper.comAdobeCqSocialNotificationsImplMentionsRouter(post, apply, delete, action, location, propertylist, eventTopics, eventFilter)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxUnreadNotificationCount  (optional)
   * @return ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo
   */
  def comAdobeCqSocialNotificationsImplNotificationManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxUnreadNotificationCount: Option[Integer] = None): Option[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialNotificationsImplNotificationManagerImplAsync(post, apply, delete, action, location, propertylist, maxUnreadNotificationCount), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxUnreadNotificationCount  (optional)
   * @return Future(ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo)
   */
  def comAdobeCqSocialNotificationsImplNotificationManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxUnreadNotificationCount: Option[Integer] = None): Future[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo] = {
      helper.comAdobeCqSocialNotificationsImplNotificationManagerImpl(post, apply, delete, action, location, propertylist, maxUnreadNotificationCount)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @return ComAdobeCqSocialNotificationsImplNotificationsRouterInfo
   */
  def comAdobeCqSocialNotificationsImplNotificationsRouter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None): Option[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo] = {
    val await = Try(Await.result(comAdobeCqSocialNotificationsImplNotificationsRouterAsync(post, apply, delete, action, location, propertylist, eventTopics, eventFilter), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @return Future(ComAdobeCqSocialNotificationsImplNotificationsRouterInfo)
   */
  def comAdobeCqSocialNotificationsImplNotificationsRouterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None): Future[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo] = {
      helper.comAdobeCqSocialNotificationsImplNotificationsRouter(post, apply, delete, action, location, propertylist, eventTopics, eventFilter)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo
   */
  def comAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServic(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Option[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo] = {
    val await = Try(Await.result(comAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicAsync(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return Future(ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo)
   */
  def comAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Future[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo] = {
      helper.comAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServic(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSocialReportingAnalyticsPollingImporterInterval  (optional)
   * @param cqSocialReportingAnalyticsPollingImporterPageSize  (optional)
   * @return ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo
   */
  def comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportI(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSocialReportingAnalyticsPollingImporterInterval: Option[Integer] = None, cqSocialReportingAnalyticsPollingImporterPageSize: Option[Integer] = None): Option[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo] = {
    val await = Try(Await.result(comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIAsync(post, apply, delete, action, location, propertylist, cqSocialReportingAnalyticsPollingImporterInterval, cqSocialReportingAnalyticsPollingImporterPageSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSocialReportingAnalyticsPollingImporterInterval  (optional)
   * @param cqSocialReportingAnalyticsPollingImporterPageSize  (optional)
   * @return Future(ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo)
   */
  def comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSocialReportingAnalyticsPollingImporterInterval: Option[Integer] = None, cqSocialReportingAnalyticsPollingImporterPageSize: Option[Integer] = None): Future[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo] = {
      helper.comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportI(post, apply, delete, action, location, propertylist, cqSocialReportingAnalyticsPollingImporterInterval, cqSocialReportingAnalyticsPollingImporterPageSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param reportFetchDelay  (optional)
   * @return ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo
   */
  def comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportM(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, reportFetchDelay: Option[Integer] = None): Option[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo] = {
    val await = Try(Await.result(comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMAsync(post, apply, delete, action, location, propertylist, reportFetchDelay), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param reportFetchDelay  (optional)
   * @return Future(ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo)
   */
  def comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, reportFetchDelay: Option[Integer] = None): Future[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo] = {
      helper.comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportM(post, apply, delete, action, location, propertylist, reportFetchDelay)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSocialConsoleAnalyticsSitesMapping  (optional)
   * @param priority  (optional)
   * @return ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo
   */
  def comAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportS(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSocialConsoleAnalyticsSitesMapping: Option[List[String]] = None, priority: Option[Integer] = None): Option[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo] = {
    val await = Try(Await.result(comAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSAsync(post, apply, delete, action, location, propertylist, cqSocialConsoleAnalyticsSitesMapping, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSocialConsoleAnalyticsSitesMapping  (optional)
   * @param priority  (optional)
   * @return Future(ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo)
   */
  def comAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSocialConsoleAnalyticsSitesMapping: Option[List[String]] = None, priority: Option[Integer] = None): Future[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo] = {
      helper.comAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportS(post, apply, delete, action, location, propertylist, cqSocialConsoleAnalyticsSitesMapping, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo
   */
  def comAdobeCqSocialReviewClientEndpointsImplReviewOperationsServi(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Option[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo] = {
    val await = Try(Await.result(comAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiAsync(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param attachmentTypeBlacklist  (optional)
   * @return Future(ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo)
   */
  def comAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, attachmentTypeBlacklist: Option[List[String]] = None): Future[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo] = {
      helper.comAdobeCqSocialReviewClientEndpointsImplReviewOperationsServi(post, apply, delete, action, location, propertylist, fieldWhitelist, attachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletSelectors  (optional)
   * @param slingServletExtensions  (optional)
   * @return ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo
   */
  def comAdobeCqSocialScfCoreOperationsImplSocialOperationsServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletSelectors: Option[String] = None, slingServletExtensions: Option[String] = None): Option[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo] = {
    val await = Try(Await.result(comAdobeCqSocialScfCoreOperationsImplSocialOperationsServletAsync(post, apply, delete, action, location, propertylist, slingServletSelectors, slingServletExtensions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletSelectors  (optional)
   * @param slingServletExtensions  (optional)
   * @return Future(ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo)
   */
  def comAdobeCqSocialScfCoreOperationsImplSocialOperationsServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletSelectors: Option[String] = None, slingServletExtensions: Option[String] = None): Future[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo] = {
      helper.comAdobeCqSocialScfCoreOperationsImplSocialOperationsServlet(post, apply, delete, action, location, propertylist, slingServletSelectors, slingServletExtensions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletSelectors  (optional)
   * @param slingServletExtensions  (optional)
   * @return ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo
   */
  def comAdobeCqSocialScfEndpointsImplDefaultSocialGetServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletSelectors: Option[List[String]] = None, slingServletExtensions: Option[String] = None): Option[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo] = {
    val await = Try(Await.result(comAdobeCqSocialScfEndpointsImplDefaultSocialGetServletAsync(post, apply, delete, action, location, propertylist, slingServletSelectors, slingServletExtensions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletSelectors  (optional)
   * @param slingServletExtensions  (optional)
   * @return Future(ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo)
   */
  def comAdobeCqSocialScfEndpointsImplDefaultSocialGetServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletSelectors: Option[List[String]] = None, slingServletExtensions: Option[String] = None): Future[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo] = {
      helper.comAdobeCqSocialScfEndpointsImplDefaultSocialGetServlet(post, apply, delete, action, location, propertylist, slingServletSelectors, slingServletExtensions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @return ComAdobeCqSocialScoringImplScoringEventListenerInfo
   */
  def comAdobeCqSocialScoringImplScoringEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None): Option[ComAdobeCqSocialScoringImplScoringEventListenerInfo] = {
    val await = Try(Await.result(comAdobeCqSocialScoringImplScoringEventListenerAsync(post, apply, delete, action, location, propertylist, eventTopics, eventFilter), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @return Future(ComAdobeCqSocialScoringImplScoringEventListenerInfo)
   */
  def comAdobeCqSocialScoringImplScoringEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None): Future[ComAdobeCqSocialScoringImplScoringEventListenerInfo] = {
      helper.comAdobeCqSocialScoringImplScoringEventListener(post, apply, delete, action, location, propertylist, eventTopics, eventFilter)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enableFallback  (optional)
   * @return ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo
   */
  def comAdobeCqSocialServiceusersInternalImplServiceUserWrapperImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enableFallback: Option[Boolean] = None): Option[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplAsync(post, apply, delete, action, location, propertylist, enableFallback), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enableFallback  (optional)
   * @return Future(ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo)
   */
  def comAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enableFallback: Option[Boolean] = None): Future[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo] = {
      helper.comAdobeCqSocialServiceusersInternalImplServiceUserWrapperImpl(post, apply, delete, action, location, propertylist, enableFallback)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param sitePathFilters  (optional)
   * @param sitePackageGroup  (optional)
   * @return ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo
   */
  def comAdobeCqSocialSiteEndpointsImplSiteOperationService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, sitePathFilters: Option[List[String]] = None, sitePackageGroup: Option[String] = None): Option[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo] = {
    val await = Try(Await.result(comAdobeCqSocialSiteEndpointsImplSiteOperationServiceAsync(post, apply, delete, action, location, propertylist, fieldWhitelist, sitePathFilters, sitePackageGroup), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fieldWhitelist  (optional)
   * @param sitePathFilters  (optional)
   * @param sitePackageGroup  (optional)
   * @return Future(ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo)
   */
  def comAdobeCqSocialSiteEndpointsImplSiteOperationServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fieldWhitelist: Option[List[String]] = None, sitePathFilters: Option[List[String]] = None, sitePackageGroup: Option[String] = None): Future[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo] = {
      helper.comAdobeCqSocialSiteEndpointsImplSiteOperationService(post, apply, delete, action, location, propertylist, fieldWhitelist, sitePathFilters, sitePackageGroup)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSocialConsoleAnalyticsComponents  (optional)
   * @return ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo
   */
  def comAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceIm(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSocialConsoleAnalyticsComponents: Option[List[String]] = None): Option[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo] = {
    val await = Try(Await.result(comAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImAsync(post, apply, delete, action, location, propertylist, cqSocialConsoleAnalyticsComponents), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSocialConsoleAnalyticsComponents  (optional)
   * @return Future(ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo)
   */
  def comAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSocialConsoleAnalyticsComponents: Option[List[String]] = None): Future[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo] = {
      helper.comAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceIm(post, apply, delete, action, location, propertylist, cqSocialConsoleAnalyticsComponents)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param componentsUsingTags  (optional)
   * @return ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo
   */
  def comAdobeCqSocialSiteImplSiteConfiguratorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, componentsUsingTags: Option[List[String]] = None): Option[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialSiteImplSiteConfiguratorImplAsync(post, apply, delete, action, location, propertylist, componentsUsingTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param componentsUsingTags  (optional)
   * @return Future(ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo)
   */
  def comAdobeCqSocialSiteImplSiteConfiguratorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, componentsUsingTags: Option[List[String]] = None): Future[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo] = {
      helper.comAdobeCqSocialSiteImplSiteConfiguratorImpl(post, apply, delete, action, location, propertylist, componentsUsingTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param srpType  (optional)
   * @return ComAdobeCqSocialSrpImplSocialSolrConnectorInfo
   */
  def comAdobeCqSocialSrpImplSocialSolrConnector(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, srpType: Option[String] = None): Option[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo] = {
    val await = Try(Await.result(comAdobeCqSocialSrpImplSocialSolrConnectorAsync(post, apply, delete, action, location, propertylist, srpType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param srpType  (optional)
   * @return Future(ComAdobeCqSocialSrpImplSocialSolrConnectorInfo)
   */
  def comAdobeCqSocialSrpImplSocialSolrConnectorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, srpType: Option[String] = None): Future[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo] = {
      helper.comAdobeCqSocialSrpImplSocialSolrConnector(post, apply, delete, action, location, propertylist, srpType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param agentName  (optional)
   * @param diffPath  (optional)
   * @param propertyNames  (optional)
   * @return ComAdobeCqSocialSyncImplDiffChangesObserverInfo
   */
  def comAdobeCqSocialSyncImplDiffChangesObserver(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, agentName: Option[String] = None, diffPath: Option[String] = None, propertyNames: Option[String] = None): Option[ComAdobeCqSocialSyncImplDiffChangesObserverInfo] = {
    val await = Try(Await.result(comAdobeCqSocialSyncImplDiffChangesObserverAsync(post, apply, delete, action, location, propertylist, enabled, agentName, diffPath, propertyNames), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param agentName  (optional)
   * @param diffPath  (optional)
   * @param propertyNames  (optional)
   * @return Future(ComAdobeCqSocialSyncImplDiffChangesObserverInfo)
   */
  def comAdobeCqSocialSyncImplDiffChangesObserverAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, agentName: Option[String] = None, diffPath: Option[String] = None, propertyNames: Option[String] = None): Future[ComAdobeCqSocialSyncImplDiffChangesObserverInfo] = {
      helper.comAdobeCqSocialSyncImplDiffChangesObserver(post, apply, delete, action, location, propertylist, enabled, agentName, diffPath, propertyNames)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param nodetypes  (optional)
   * @param ignorableprops  (optional)
   * @param ignorablenodes  (optional)
   * @param enabled  (optional)
   * @param distfolders  (optional)
   * @return ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo
   */
  def comAdobeCqSocialSyncImplGroupSyncListenerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, nodetypes: Option[List[String]] = None, ignorableprops: Option[List[String]] = None, ignorablenodes: Option[String] = None, enabled: Option[Boolean] = None, distfolders: Option[String] = None): Option[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialSyncImplGroupSyncListenerImplAsync(post, apply, delete, action, location, propertylist, nodetypes, ignorableprops, ignorablenodes, enabled, distfolders), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param nodetypes  (optional)
   * @param ignorableprops  (optional)
   * @param ignorablenodes  (optional)
   * @param enabled  (optional)
   * @param distfolders  (optional)
   * @return Future(ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo)
   */
  def comAdobeCqSocialSyncImplGroupSyncListenerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, nodetypes: Option[List[String]] = None, ignorableprops: Option[List[String]] = None, ignorablenodes: Option[String] = None, enabled: Option[Boolean] = None, distfolders: Option[String] = None): Future[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo] = {
      helper.comAdobeCqSocialSyncImplGroupSyncListenerImpl(post, apply, delete, action, location, propertylist, nodetypes, ignorableprops, ignorablenodes, enabled, distfolders)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param activeRunModes  (optional)
   * @return ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo
   */
  def comAdobeCqSocialSyncImplPublisherSyncServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, activeRunModes: Option[List[String]] = None): Option[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialSyncImplPublisherSyncServiceImplAsync(post, apply, delete, action, location, propertylist, activeRunModes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param activeRunModes  (optional)
   * @return Future(ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo)
   */
  def comAdobeCqSocialSyncImplPublisherSyncServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, activeRunModes: Option[List[String]] = None): Future[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo] = {
      helper.comAdobeCqSocialSyncImplPublisherSyncServiceImpl(post, apply, delete, action, location, propertylist, activeRunModes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param nodetypes  (optional)
   * @param ignorableprops  (optional)
   * @param ignorablenodes  (optional)
   * @param enabled  (optional)
   * @param distfolders  (optional)
   * @return ComAdobeCqSocialSyncImplUserSyncListenerImplInfo
   */
  def comAdobeCqSocialSyncImplUserSyncListenerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, nodetypes: Option[List[String]] = None, ignorableprops: Option[List[String]] = None, ignorablenodes: Option[List[String]] = None, enabled: Option[Boolean] = None, distfolders: Option[List[String]] = None): Option[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialSyncImplUserSyncListenerImplAsync(post, apply, delete, action, location, propertylist, nodetypes, ignorableprops, ignorablenodes, enabled, distfolders), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param nodetypes  (optional)
   * @param ignorableprops  (optional)
   * @param ignorablenodes  (optional)
   * @param enabled  (optional)
   * @param distfolders  (optional)
   * @return Future(ComAdobeCqSocialSyncImplUserSyncListenerImplInfo)
   */
  def comAdobeCqSocialSyncImplUserSyncListenerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, nodetypes: Option[List[String]] = None, ignorableprops: Option[List[String]] = None, ignorablenodes: Option[List[String]] = None, enabled: Option[Boolean] = None, distfolders: Option[List[String]] = None): Future[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo] = {
      helper.comAdobeCqSocialSyncImplUserSyncListenerImpl(post, apply, delete, action, location, propertylist, nodetypes, ignorableprops, ignorablenodes, enabled, distfolders)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param translateLanguage  (optional)
   * @param translateDisplay  (optional)
   * @param translateAttribution  (optional)
   * @param translateCaching  (optional)
   * @param translateSmartRendering  (optional)
   * @param translateCachingDuration  (optional)
   * @param translateSessionSaveInterval  (optional)
   * @param translateSessionSaveBatchLimit  (optional)
   * @return ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo
   */
  def comAdobeCqSocialTranslationImplTranslationServiceConfigManager(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, translateLanguage: Option[String] = None, translateDisplay: Option[String] = None, translateAttribution: Option[Boolean] = None, translateCaching: Option[String] = None, translateSmartRendering: Option[String] = None, translateCachingDuration: Option[String] = None, translateSessionSaveInterval: Option[String] = None, translateSessionSaveBatchLimit: Option[String] = None): Option[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo] = {
    val await = Try(Await.result(comAdobeCqSocialTranslationImplTranslationServiceConfigManagerAsync(post, apply, delete, action, location, propertylist, translateLanguage, translateDisplay, translateAttribution, translateCaching, translateSmartRendering, translateCachingDuration, translateSessionSaveInterval, translateSessionSaveBatchLimit), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param translateLanguage  (optional)
   * @param translateDisplay  (optional)
   * @param translateAttribution  (optional)
   * @param translateCaching  (optional)
   * @param translateSmartRendering  (optional)
   * @param translateCachingDuration  (optional)
   * @param translateSessionSaveInterval  (optional)
   * @param translateSessionSaveBatchLimit  (optional)
   * @return Future(ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo)
   */
  def comAdobeCqSocialTranslationImplTranslationServiceConfigManagerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, translateLanguage: Option[String] = None, translateDisplay: Option[String] = None, translateAttribution: Option[Boolean] = None, translateCaching: Option[String] = None, translateSmartRendering: Option[String] = None, translateCachingDuration: Option[String] = None, translateSessionSaveInterval: Option[String] = None, translateSessionSaveBatchLimit: Option[String] = None): Future[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo] = {
      helper.comAdobeCqSocialTranslationImplTranslationServiceConfigManager(post, apply, delete, action, location, propertylist, translateLanguage, translateDisplay, translateAttribution, translateCaching, translateSmartRendering, translateCachingDuration, translateSessionSaveInterval, translateSessionSaveBatchLimit)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @param translateListenerType  (optional)
   * @param translatePropertyList  (optional)
   * @param poolSize  (optional)
   * @param maxPoolSize  (optional)
   * @param queueSize  (optional)
   * @param keepAliveTime  (optional)
   * @return ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo
   */
  def comAdobeCqSocialTranslationImplUGCLanguageDetector(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None, translateListenerType: Option[List[String]] = None, translatePropertyList: Option[List[String]] = None, poolSize: Option[Integer] = None, maxPoolSize: Option[Integer] = None, queueSize: Option[Integer] = None, keepAliveTime: Option[Integer] = None): Option[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo] = {
    val await = Try(Await.result(comAdobeCqSocialTranslationImplUGCLanguageDetectorAsync(post, apply, delete, action, location, propertylist, eventTopics, eventFilter, translateListenerType, translatePropertyList, poolSize, maxPoolSize, queueSize, keepAliveTime), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @param eventFilter  (optional)
   * @param translateListenerType  (optional)
   * @param translatePropertyList  (optional)
   * @param poolSize  (optional)
   * @param maxPoolSize  (optional)
   * @param queueSize  (optional)
   * @param keepAliveTime  (optional)
   * @return Future(ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo)
   */
  def comAdobeCqSocialTranslationImplUGCLanguageDetectorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[String] = None, eventFilter: Option[String] = None, translateListenerType: Option[List[String]] = None, translatePropertyList: Option[List[String]] = None, poolSize: Option[Integer] = None, maxPoolSize: Option[Integer] = None, queueSize: Option[Integer] = None, keepAliveTime: Option[Integer] = None): Future[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo] = {
      helper.comAdobeCqSocialTranslationImplUGCLanguageDetector(post, apply, delete, action, location, propertylist, eventTopics, eventFilter, translateListenerType, translatePropertyList, poolSize, maxPoolSize, queueSize, keepAliveTime)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param threadPoolSize  (optional)
   * @param delayTime  (optional)
   * @param workerSleepTime  (optional)
   * @return ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo
   */
  def comAdobeCqSocialUgcbaseDispatcherImplFlushServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, threadPoolSize: Option[Integer] = None, delayTime: Option[Integer] = None, workerSleepTime: Option[Integer] = None): Option[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplAsync(post, apply, delete, action, location, propertylist, threadPoolSize, delayTime, workerSleepTime), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param threadPoolSize  (optional)
   * @param delayTime  (optional)
   * @param workerSleepTime  (optional)
   * @return Future(ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo)
   */
  def comAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, threadPoolSize: Option[Integer] = None, delayTime: Option[Integer] = None, workerSleepTime: Option[Integer] = None): Future[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo] = {
      helper.comAdobeCqSocialUgcbaseDispatcherImplFlushServiceImpl(post, apply, delete, action, location, propertylist, threadPoolSize, delayTime, workerSleepTime)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param poolSize  (optional)
   * @param maxPoolSize  (optional)
   * @param queueSize  (optional)
   * @param keepAliveTime  (optional)
   * @return ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo
   */
  def comAdobeCqSocialUgcbaseImplAysncReverseReplicatorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, poolSize: Option[Integer] = None, maxPoolSize: Option[Integer] = None, queueSize: Option[Integer] = None, keepAliveTime: Option[Integer] = None): Option[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplAsync(post, apply, delete, action, location, propertylist, poolSize, maxPoolSize, queueSize, keepAliveTime), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param poolSize  (optional)
   * @param maxPoolSize  (optional)
   * @param queueSize  (optional)
   * @param keepAliveTime  (optional)
   * @return Future(ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo)
   */
  def comAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, poolSize: Option[Integer] = None, maxPoolSize: Option[Integer] = None, queueSize: Option[Integer] = None, keepAliveTime: Option[Integer] = None): Future[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo] = {
      helper.comAdobeCqSocialUgcbaseImplAysncReverseReplicatorImpl(post, apply, delete, action, location, propertylist, poolSize, maxPoolSize, queueSize, keepAliveTime)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isPrimaryPublisher  (optional)
   * @return ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo
   */
  def comAdobeCqSocialUgcbaseImplPublisherConfigurationImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isPrimaryPublisher: Option[Boolean] = None): Option[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialUgcbaseImplPublisherConfigurationImplAsync(post, apply, delete, action, location, propertylist, isPrimaryPublisher), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isPrimaryPublisher  (optional)
   * @return Future(ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo)
   */
  def comAdobeCqSocialUgcbaseImplPublisherConfigurationImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isPrimaryPublisher: Option[Boolean] = None): Future[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo] = {
      helper.comAdobeCqSocialUgcbaseImplPublisherConfigurationImpl(post, apply, delete, action, location, propertylist, isPrimaryPublisher)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param legacyCloudUGCPathMapping  (optional)
   * @return ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo
   */
  def comAdobeCqSocialUgcbaseImplSocialUtilsImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, legacyCloudUGCPathMapping: Option[Boolean] = None): Option[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialUgcbaseImplSocialUtilsImplAsync(post, apply, delete, action, location, propertylist, legacyCloudUGCPathMapping), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param legacyCloudUGCPathMapping  (optional)
   * @return Future(ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo)
   */
  def comAdobeCqSocialUgcbaseImplSocialUtilsImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, legacyCloudUGCPathMapping: Option[Boolean] = None): Future[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo] = {
      helper.comAdobeCqSocialUgcbaseImplSocialUtilsImpl(post, apply, delete, action, location, propertylist, legacyCloudUGCPathMapping)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param automoderationSequence  (optional)
   * @param automoderationOnfailurestop  (optional)
   * @return ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo
   */
  def comAdobeCqSocialUgcbaseModerationImplAutoModerationImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, automoderationSequence: Option[List[String]] = None, automoderationOnfailurestop: Option[Boolean] = None): Option[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialUgcbaseModerationImplAutoModerationImplAsync(post, apply, delete, action, location, propertylist, automoderationSequence, automoderationOnfailurestop), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param automoderationSequence  (optional)
   * @param automoderationOnfailurestop  (optional)
   * @return Future(ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo)
   */
  def comAdobeCqSocialUgcbaseModerationImplAutoModerationImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, automoderationSequence: Option[List[String]] = None, automoderationOnfailurestop: Option[Boolean] = None): Future[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo] = {
      helper.comAdobeCqSocialUgcbaseModerationImplAutoModerationImpl(post, apply, delete, action, location, propertylist, automoderationSequence, automoderationOnfailurestop)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param watchwordsPositive  (optional)
   * @param watchwordsNegative  (optional)
   * @param watchwordsPath  (optional)
   * @param sentimentPath  (optional)
   * @return ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo
   */
  def comAdobeCqSocialUgcbaseModerationImplSentimentProcess(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, watchwordsPositive: Option[List[String]] = None, watchwordsNegative: Option[List[String]] = None, watchwordsPath: Option[String] = None, sentimentPath: Option[String] = None): Option[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo] = {
    val await = Try(Await.result(comAdobeCqSocialUgcbaseModerationImplSentimentProcessAsync(post, apply, delete, action, location, propertylist, watchwordsPositive, watchwordsNegative, watchwordsPath, sentimentPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param watchwordsPositive  (optional)
   * @param watchwordsNegative  (optional)
   * @param watchwordsPath  (optional)
   * @param sentimentPath  (optional)
   * @return Future(ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo)
   */
  def comAdobeCqSocialUgcbaseModerationImplSentimentProcessAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, watchwordsPositive: Option[List[String]] = None, watchwordsNegative: Option[List[String]] = None, watchwordsPath: Option[String] = None, sentimentPath: Option[String] = None): Future[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo] = {
      helper.comAdobeCqSocialUgcbaseModerationImplSentimentProcess(post, apply, delete, action, location, propertylist, watchwordsPositive, watchwordsNegative, watchwordsPath, sentimentPath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultAttachmentTypeBlacklist  (optional)
   * @param baselineAttachmentTypeBlacklist  (optional)
   * @return ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo
   */
  def comAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackli(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultAttachmentTypeBlacklist: Option[List[String]] = None, baselineAttachmentTypeBlacklist: Option[List[String]] = None): Option[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo] = {
    val await = Try(Await.result(comAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliAsync(post, apply, delete, action, location, propertylist, defaultAttachmentTypeBlacklist, baselineAttachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultAttachmentTypeBlacklist  (optional)
   * @param baselineAttachmentTypeBlacklist  (optional)
   * @return Future(ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo)
   */
  def comAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultAttachmentTypeBlacklist: Option[List[String]] = None, baselineAttachmentTypeBlacklist: Option[List[String]] = None): Future[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo] = {
      helper.comAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackli(post, apply, delete, action, location, propertylist, defaultAttachmentTypeBlacklist, baselineAttachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param parameterWhitelist  (optional)
   * @param parameterWhitelistPrefixes  (optional)
   * @param binaryParameterWhitelist  (optional)
   * @param modifierWhitelist  (optional)
   * @param operationWhitelist  (optional)
   * @param operationWhitelistPrefixes  (optional)
   * @param typehintWhitelist  (optional)
   * @param resourcetypeWhitelist  (optional)
   * @return ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo
   */
  def comAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, parameterWhitelist: Option[List[String]] = None, parameterWhitelistPrefixes: Option[List[String]] = None, binaryParameterWhitelist: Option[List[String]] = None, modifierWhitelist: Option[List[String]] = None, operationWhitelist: Option[List[String]] = None, operationWhitelistPrefixes: Option[List[String]] = None, typehintWhitelist: Option[List[String]] = None, resourcetypeWhitelist: Option[List[String]] = None): Option[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo] = {
    val await = Try(Await.result(comAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplAsync(post, apply, delete, action, location, propertylist, parameterWhitelist, parameterWhitelistPrefixes, binaryParameterWhitelist, modifierWhitelist, operationWhitelist, operationWhitelistPrefixes, typehintWhitelist, resourcetypeWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param parameterWhitelist  (optional)
   * @param parameterWhitelistPrefixes  (optional)
   * @param binaryParameterWhitelist  (optional)
   * @param modifierWhitelist  (optional)
   * @param operationWhitelist  (optional)
   * @param operationWhitelistPrefixes  (optional)
   * @param typehintWhitelist  (optional)
   * @param resourcetypeWhitelist  (optional)
   * @return Future(ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo)
   */
  def comAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, parameterWhitelist: Option[List[String]] = None, parameterWhitelistPrefixes: Option[List[String]] = None, binaryParameterWhitelist: Option[List[String]] = None, modifierWhitelist: Option[List[String]] = None, operationWhitelist: Option[List[String]] = None, operationWhitelistPrefixes: Option[List[String]] = None, typehintWhitelist: Option[List[String]] = None, resourcetypeWhitelist: Option[List[String]] = None): Future[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo] = {
      helper.comAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImpl(post, apply, delete, action, location, propertylist, parameterWhitelist, parameterWhitelistPrefixes, binaryParameterWhitelist, modifierWhitelist, operationWhitelist, operationWhitelistPrefixes, typehintWhitelist, resourcetypeWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletExtensions  (optional)
   * @param slingServletPaths  (optional)
   * @param slingServletMethods  (optional)
   * @return ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo
   */
  def comAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletExtensions: Option[String] = None, slingServletPaths: Option[String] = None, slingServletMethods: Option[String] = None): Option[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo] = {
    val await = Try(Await.result(comAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletAsync(post, apply, delete, action, location, propertylist, slingServletExtensions, slingServletPaths, slingServletMethods), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletExtensions  (optional)
   * @param slingServletPaths  (optional)
   * @param slingServletMethods  (optional)
   * @return Future(ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo)
   */
  def comAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletExtensions: Option[String] = None, slingServletPaths: Option[String] = None, slingServletMethods: Option[String] = None): Future[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo] = {
      helper.comAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServlet(post, apply, delete, action, location, propertylist, slingServletExtensions, slingServletPaths, slingServletMethods)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enable  (optional)
   * @param agentConfiguration  (optional)
   * @param contextPath  (optional)
   * @param disabledCipherSuites  (optional)
   * @param enabledCipherSuites  (optional)
   * @return ComAdobeCqSocialUserImplTransportHttpToPublisherInfo
   */
  def comAdobeCqSocialUserImplTransportHttpToPublisher(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enable: Option[Boolean] = None, agentConfiguration: Option[List[String]] = None, contextPath: Option[String] = None, disabledCipherSuites: Option[List[String]] = None, enabledCipherSuites: Option[List[String]] = None): Option[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo] = {
    val await = Try(Await.result(comAdobeCqSocialUserImplTransportHttpToPublisherAsync(post, apply, delete, action, location, propertylist, enable, agentConfiguration, contextPath, disabledCipherSuites, enabledCipherSuites), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enable  (optional)
   * @param agentConfiguration  (optional)
   * @param contextPath  (optional)
   * @param disabledCipherSuites  (optional)
   * @param enabledCipherSuites  (optional)
   * @return Future(ComAdobeCqSocialUserImplTransportHttpToPublisherInfo)
   */
  def comAdobeCqSocialUserImplTransportHttpToPublisherAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enable: Option[Boolean] = None, agentConfiguration: Option[List[String]] = None, contextPath: Option[String] = None, disabledCipherSuites: Option[List[String]] = None, enabledCipherSuites: Option[List[String]] = None): Future[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo] = {
      helper.comAdobeCqSocialUserImplTransportHttpToPublisher(post, apply, delete, action, location, propertylist, enable, agentConfiguration, contextPath, disabledCipherSuites, enabledCipherSuites)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param resourceTypes  (optional)
   * @return ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo
   */
  def comAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFact(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, resourceTypes: Option[List[String]] = None): Option[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo] = {
    val await = Try(Await.result(comAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactAsync(post, apply, delete, action, location, propertylist, resourceTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param resourceTypes  (optional)
   * @return Future(ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo)
   */
  def comAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, resourceTypes: Option[List[String]] = None): Future[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo] = {
      helper.comAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFact(post, apply, delete, action, location, propertylist, resourceTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param deletePathRegexps  (optional)
   * @param deleteSql2Query  (optional)
   * @return ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo
   */
  def comAdobeCqUpgradesCleanupImplUpgradeContentCleanup(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, deletePathRegexps: Option[List[String]] = None, deleteSql2Query: Option[String] = None): Option[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo] = {
    val await = Try(Await.result(comAdobeCqUpgradesCleanupImplUpgradeContentCleanupAsync(post, apply, delete, action, location, propertylist, deletePathRegexps, deleteSql2Query), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param deletePathRegexps  (optional)
   * @param deleteSql2Query  (optional)
   * @return Future(ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo)
   */
  def comAdobeCqUpgradesCleanupImplUpgradeContentCleanupAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, deletePathRegexps: Option[List[String]] = None, deleteSql2Query: Option[String] = None): Future[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo] = {
      helper.comAdobeCqUpgradesCleanupImplUpgradeContentCleanup(post, apply, delete, action, location, propertylist, deletePathRegexps, deleteSql2Query)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param deleteNameRegexps  (optional)
   * @return ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo
   */
  def comAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanup(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, deleteNameRegexps: Option[List[String]] = None): Option[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo] = {
    val await = Try(Await.result(comAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupAsync(post, apply, delete, action, location, propertylist, deleteNameRegexps), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param deleteNameRegexps  (optional)
   * @return Future(ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo)
   */
  def comAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, deleteNameRegexps: Option[List[String]] = None): Future[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo] = {
      helper.comAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanup(post, apply, delete, action, location, propertylist, deleteNameRegexps)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param threshold  (optional)
   * @param jobTopicName  (optional)
   * @param emailEnabled  (optional)
   * @return ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo
   */
  def comAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, threshold: Option[Integer] = None, jobTopicName: Option[String] = None, emailEnabled: Option[Boolean] = None): Option[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo] = {
    val await = Try(Await.result(comAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceAsync(post, apply, delete, action, location, propertylist, threshold, jobTopicName, emailEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param threshold  (optional)
   * @param jobTopicName  (optional)
   * @param emailEnabled  (optional)
   * @return Future(ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo)
   */
  def comAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, threshold: Option[Integer] = None, jobTopicName: Option[String] = None, emailEnabled: Option[Boolean] = None): Future[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo] = {
      helper.comAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderService(post, apply, delete, action, location, propertylist, threshold, jobTopicName, emailEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param jobPurgeThreshold  (optional)
   * @param jobPurgeMaxJobs  (optional)
   * @return ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo
   */
  def comAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, jobPurgeThreshold: Option[Integer] = None, jobPurgeMaxJobs: Option[Integer] = None): Option[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo] = {
    val await = Try(Await.result(comAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskAsync(post, apply, delete, action, location, propertylist, schedulerExpression, jobPurgeThreshold, jobPurgeMaxJobs), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param jobPurgeThreshold  (optional)
   * @param jobPurgeMaxJobs  (optional)
   * @return Future(ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo)
   */
  def comAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, jobPurgeThreshold: Option[Integer] = None, jobPurgeMaxJobs: Option[Integer] = None): Future[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo] = {
      helper.comAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTask(post, apply, delete, action, location, propertylist, schedulerExpression, jobPurgeThreshold, jobPurgeMaxJobs)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param threshold  (optional)
   * @param jobTopicName  (optional)
   * @param emailEnabled  (optional)
   * @return ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo
   */
  def comAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, threshold: Option[Integer] = None, jobTopicName: Option[String] = None, emailEnabled: Option[Boolean] = None): Option[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo] = {
    val await = Try(Await.result(comAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceAsync(post, apply, delete, action, location, propertylist, threshold, jobTopicName, emailEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param threshold  (optional)
   * @param jobTopicName  (optional)
   * @param emailEnabled  (optional)
   * @return Future(ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo)
   */
  def comAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, threshold: Option[Integer] = None, jobTopicName: Option[String] = None, emailEnabled: Option[Boolean] = None): Future[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo] = {
      helper.comAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderService(post, apply, delete, action, location, propertylist, threshold, jobTopicName, emailEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param threshold  (optional)
   * @param jobTopicName  (optional)
   * @param emailEnabled  (optional)
   * @return ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo
   */
  def comAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, threshold: Option[Integer] = None, jobTopicName: Option[String] = None, emailEnabled: Option[Boolean] = None): Option[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo] = {
    val await = Try(Await.result(comAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceAsync(post, apply, delete, action, location, propertylist, threshold, jobTopicName, emailEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param threshold  (optional)
   * @param jobTopicName  (optional)
   * @param emailEnabled  (optional)
   * @return Future(ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo)
   */
  def comAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, threshold: Option[Integer] = None, jobTopicName: Option[String] = None, emailEnabled: Option[Boolean] = None): Future[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo] = {
      helper.comAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderService(post, apply, delete, action, location, propertylist, threshold, jobTopicName, emailEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param launchesEventhandlerThreadpoolMaxsize  (optional)
   * @param launchesEventhandlerThreadpoolPriority  (optional)
   * @param launchesEventhandlerUpdatelastmodification  (optional)
   * @return ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo
   */
  def comAdobeCqWcmLaunchesImplLaunchesEventHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, launchesEventhandlerThreadpoolMaxsize: Option[Integer] = None, launchesEventhandlerThreadpoolPriority: Option[String] = None, launchesEventhandlerUpdatelastmodification: Option[Boolean] = None): Option[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo] = {
    val await = Try(Await.result(comAdobeCqWcmLaunchesImplLaunchesEventHandlerAsync(post, apply, delete, action, location, propertylist, eventFilter, launchesEventhandlerThreadpoolMaxsize, launchesEventhandlerThreadpoolPriority, launchesEventhandlerUpdatelastmodification), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param launchesEventhandlerThreadpoolMaxsize  (optional)
   * @param launchesEventhandlerThreadpoolPriority  (optional)
   * @param launchesEventhandlerUpdatelastmodification  (optional)
   * @return Future(ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo)
   */
  def comAdobeCqWcmLaunchesImplLaunchesEventHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, launchesEventhandlerThreadpoolMaxsize: Option[Integer] = None, launchesEventhandlerThreadpoolPriority: Option[String] = None, launchesEventhandlerUpdatelastmodification: Option[Boolean] = None): Future[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo] = {
      helper.comAdobeCqWcmLaunchesImplLaunchesEventHandler(post, apply, delete, action, location, propertylist, eventFilter, launchesEventhandlerThreadpoolMaxsize, launchesEventhandlerThreadpoolPriority, launchesEventhandlerUpdatelastmodification)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmQrcodeServletWhitelist  (optional)
   * @return ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo
   */
  def comAdobeCqWcmMobileQrcodeServletQRCodeImageGenerator(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmQrcodeServletWhitelist: Option[List[String]] = None): Option[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo] = {
    val await = Try(Await.result(comAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorAsync(post, apply, delete, action, location, propertylist, cqWcmQrcodeServletWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmQrcodeServletWhitelist  (optional)
   * @return Future(ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo)
   */
  def comAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmQrcodeServletWhitelist: Option[List[String]] = None): Future[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo] = {
      helper.comAdobeCqWcmMobileQrcodeServletQRCodeImageGenerator(post, apply, delete, action, location, propertylist, cqWcmQrcodeServletWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param size  (optional)
   * @return ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo
   */
  def comAdobeCqWcmStyleInternalComponentStyleInfoCacheImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, size: Option[Integer] = None): Option[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo] = {
    val await = Try(Await.result(comAdobeCqWcmStyleInternalComponentStyleInfoCacheImplAsync(post, apply, delete, action, location, propertylist, size), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param size  (optional)
   * @return Future(ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo)
   */
  def comAdobeCqWcmStyleInternalComponentStyleInfoCacheImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, size: Option[Integer] = None): Future[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo] = {
      helper.comAdobeCqWcmStyleInternalComponentStyleInfoCacheImpl(post, apply, delete, action, location, propertylist, size)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param syncTranslationStateSchedulingFormat  (optional)
   * @param schedulingRepeatTranslationSchedulingFormat  (optional)
   * @param syncTranslationStateLockTimeoutInMinutes  (optional)
   * @param exportFormat  (optional)
   * @return ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo
   */
  def comAdobeCqWcmTranslationImplTranslationPlatformConfigurationImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, syncTranslationStateSchedulingFormat: Option[String] = None, schedulingRepeatTranslationSchedulingFormat: Option[String] = None, syncTranslationStateLockTimeoutInMinutes: Option[String] = None, exportFormat: Option[String] = None): Option[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo] = {
    val await = Try(Await.result(comAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplAsync(post, apply, delete, action, location, propertylist, syncTranslationStateSchedulingFormat, schedulingRepeatTranslationSchedulingFormat, syncTranslationStateLockTimeoutInMinutes, exportFormat), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param syncTranslationStateSchedulingFormat  (optional)
   * @param schedulingRepeatTranslationSchedulingFormat  (optional)
   * @param syncTranslationStateLockTimeoutInMinutes  (optional)
   * @param exportFormat  (optional)
   * @return Future(ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo)
   */
  def comAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, syncTranslationStateSchedulingFormat: Option[String] = None, schedulingRepeatTranslationSchedulingFormat: Option[String] = None, syncTranslationStateLockTimeoutInMinutes: Option[String] = None, exportFormat: Option[String] = None): Future[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo] = {
      helper.comAdobeCqWcmTranslationImplTranslationPlatformConfigurationImpl(post, apply, delete, action, location, propertylist, syncTranslationStateSchedulingFormat, schedulingRepeatTranslationSchedulingFormat, syncTranslationStateLockTimeoutInMinutes, exportFormat)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param portalOutboxes  (optional)
   * @param draftDataService  (optional)
   * @param draftMetadataService  (optional)
   * @param submitDataService  (optional)
   * @param submitMetadataService  (optional)
   * @param pendingSignDataService  (optional)
   * @param pendingSignMetadataService  (optional)
   * @return ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo
   */
  def comAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, portalOutboxes: Option[List[String]] = None, draftDataService: Option[String] = None, draftMetadataService: Option[String] = None, submitDataService: Option[String] = None, submitMetadataService: Option[String] = None, pendingSignDataService: Option[String] = None, pendingSignMetadataService: Option[String] = None): Option[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo] = {
    val await = Try(Await.result(comAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceAsync(post, apply, delete, action, location, propertylist, portalOutboxes, draftDataService, draftMetadataService, submitDataService, submitMetadataService, pendingSignDataService, pendingSignMetadataService), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param portalOutboxes  (optional)
   * @param draftDataService  (optional)
   * @param draftMetadataService  (optional)
   * @param submitDataService  (optional)
   * @param submitMetadataService  (optional)
   * @param pendingSignDataService  (optional)
   * @param pendingSignMetadataService  (optional)
   * @return Future(ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo)
   */
  def comAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, portalOutboxes: Option[List[String]] = None, draftDataService: Option[String] = None, draftMetadataService: Option[String] = None, submitDataService: Option[String] = None, submitMetadataService: Option[String] = None, pendingSignDataService: Option[String] = None, pendingSignMetadataService: Option[String] = None): Future[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo] = {
      helper.comAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigService(post, apply, delete, action, location, propertylist, portalOutboxes, draftDataService, draftMetadataService, submitDataService, submitMetadataService, pendingSignDataService, pendingSignMetadataService)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param formportalInterval  (optional)
   * @return ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo
   */
  def comAdobeFdFpConfigFormsPortalSchedulerService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, formportalInterval: Option[String] = None): Option[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo] = {
    val await = Try(Await.result(comAdobeFdFpConfigFormsPortalSchedulerServiceAsync(post, apply, delete, action, location, propertylist, formportalInterval), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param formportalInterval  (optional)
   * @return Future(ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo)
   */
  def comAdobeFdFpConfigFormsPortalSchedulerServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, formportalInterval: Option[String] = None): Future[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo] = {
      helper.comAdobeFdFpConfigFormsPortalSchedulerService(post, apply, delete, action, location, propertylist, formportalInterval)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param alloweddataFileLocations  (optional)
   * @return ComAdobeFormsCommonServiceImplDefaultDataProviderInfo
   */
  def comAdobeFormsCommonServiceImplDefaultDataProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, alloweddataFileLocations: Option[List[String]] = None): Option[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo] = {
    val await = Try(Await.result(comAdobeFormsCommonServiceImplDefaultDataProviderAsync(post, apply, delete, action, location, propertylist, alloweddataFileLocations), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param alloweddataFileLocations  (optional)
   * @return Future(ComAdobeFormsCommonServiceImplDefaultDataProviderInfo)
   */
  def comAdobeFormsCommonServiceImplDefaultDataProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, alloweddataFileLocations: Option[List[String]] = None): Future[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo] = {
      helper.comAdobeFormsCommonServiceImplDefaultDataProvider(post, apply, delete, action, location, propertylist, alloweddataFileLocations)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param tempStorageConfig  (optional)
   * @return ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo
   */
  def comAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImp(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, tempStorageConfig: Option[String] = None): Option[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo] = {
    val await = Try(Await.result(comAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpAsync(post, apply, delete, action, location, propertylist, tempStorageConfig), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param tempStorageConfig  (optional)
   * @return Future(ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo)
   */
  def comAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, tempStorageConfig: Option[String] = None): Future[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo] = {
      helper.comAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImp(post, apply, delete, action, location, propertylist, tempStorageConfig)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param durationForTemporaryStorage  (optional)
   * @param durationForAnonymousStorage  (optional)
   * @return ComAdobeFormsCommonServletTempCleanUpTaskInfo
   */
  def comAdobeFormsCommonServletTempCleanUpTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, durationForTemporaryStorage: Option[String] = None, durationForAnonymousStorage: Option[String] = None): Option[ComAdobeFormsCommonServletTempCleanUpTaskInfo] = {
    val await = Try(Await.result(comAdobeFormsCommonServletTempCleanUpTaskAsync(post, apply, delete, action, location, propertylist, schedulerExpression, durationForTemporaryStorage, durationForAnonymousStorage), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param durationForTemporaryStorage  (optional)
   * @param durationForAnonymousStorage  (optional)
   * @return Future(ComAdobeFormsCommonServletTempCleanUpTaskInfo)
   */
  def comAdobeFormsCommonServletTempCleanUpTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, durationForTemporaryStorage: Option[String] = None, durationForAnonymousStorage: Option[String] = None): Future[ComAdobeFormsCommonServletTempCleanUpTaskInfo] = {
      helper.comAdobeFormsCommonServletTempCleanUpTask(post, apply, delete, action, location, propertylist, schedulerExpression, durationForTemporaryStorage, durationForAnonymousStorage)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queryLimit  (optional)
   * @param fileTypeExtensionMap  (optional)
   * @return ComAdobeGraniteAcpPlatformPlatformServletInfo
   */
  def comAdobeGraniteAcpPlatformPlatformServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queryLimit: Option[Integer] = None, fileTypeExtensionMap: Option[List[String]] = None): Option[ComAdobeGraniteAcpPlatformPlatformServletInfo] = {
    val await = Try(Await.result(comAdobeGraniteAcpPlatformPlatformServletAsync(post, apply, delete, action, location, propertylist, queryLimit, fileTypeExtensionMap), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queryLimit  (optional)
   * @param fileTypeExtensionMap  (optional)
   * @return Future(ComAdobeGraniteAcpPlatformPlatformServletInfo)
   */
  def comAdobeGraniteAcpPlatformPlatformServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queryLimit: Option[Integer] = None, fileTypeExtensionMap: Option[List[String]] = None): Future[ComAdobeGraniteAcpPlatformPlatformServletInfo] = {
      helper.comAdobeGraniteAcpPlatformPlatformServlet(post, apply, delete, action, location, propertylist, queryLimit, fileTypeExtensionMap)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param aggregateRelationships  (optional)
   * @param aggregateDescendVirtual  (optional)
   * @return ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo
   */
  def comAdobeGraniteActivitystreamsImplActivityManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, aggregateRelationships: Option[List[String]] = None, aggregateDescendVirtual: Option[Boolean] = None): Option[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteActivitystreamsImplActivityManagerImplAsync(post, apply, delete, action, location, propertylist, aggregateRelationships, aggregateDescendVirtual), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param aggregateRelationships  (optional)
   * @param aggregateDescendVirtual  (optional)
   * @return Future(ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo)
   */
  def comAdobeGraniteActivitystreamsImplActivityManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, aggregateRelationships: Option[List[String]] = None, aggregateDescendVirtual: Option[Boolean] = None): Future[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo] = {
      helper.comAdobeGraniteActivitystreamsImplActivityManagerImpl(post, apply, delete, action, location, propertylist, aggregateRelationships, aggregateDescendVirtual)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disabled  (optional)
   * @return ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo
   */
  def comAdobeGraniteAnalyzerBaseSystemStatusServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disabled: Option[Boolean] = None): Option[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo] = {
    val await = Try(Await.result(comAdobeGraniteAnalyzerBaseSystemStatusServletAsync(post, apply, delete, action, location, propertylist, disabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disabled  (optional)
   * @return Future(ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo)
   */
  def comAdobeGraniteAnalyzerBaseSystemStatusServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disabled: Option[Boolean] = None): Future[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo] = {
      helper.comAdobeGraniteAnalyzerBaseSystemStatusServlet(post, apply, delete, action, location, propertylist, disabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disabled  (optional)
   * @return ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo
   */
  def comAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disabled: Option[Boolean] = None): Option[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo] = {
    val await = Try(Await.result(comAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletAsync(post, apply, delete, action, location, propertylist, disabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disabled  (optional)
   * @return Future(ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo)
   */
  def comAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disabled: Option[Boolean] = None): Future[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo] = {
      helper.comAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServlet(post, apply, delete, action, location, propertylist, disabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeCqCdnCdnRewriter  (optional)
   * @param comAdobeCqCloudConfigComponents  (optional)
   * @param comAdobeCqCloudConfigCore  (optional)
   * @param comAdobeCqCloudConfigUi  (optional)
   * @param comAdobeCqComAdobeCqEditor  (optional)
   * @param comAdobeCqComAdobeCqProjectsCore  (optional)
   * @param comAdobeCqComAdobeCqProjectsWcmCore  (optional)
   * @param comAdobeCqComAdobeCqUiCommons  (optional)
   * @param comAdobeCqComAdobeCqWcmStyle  (optional)
   * @param comAdobeCqCqActivitymapIntegration  (optional)
   * @param comAdobeCqCqContexthubCommons  (optional)
   * @param comAdobeCqCqDtm  (optional)
   * @param comAdobeCqCqHealthcheck  (optional)
   * @param comAdobeCqCqMultisiteTargeting  (optional)
   * @param comAdobeCqCqPreUpgradeCleanup  (optional)
   * @param comAdobeCqCqProductInfoProvider  (optional)
   * @param comAdobeCqCqRestSites  (optional)
   * @param comAdobeCqCqSecurityHc  (optional)
   * @param comAdobeCqDamCqDamSvgHandler  (optional)
   * @param comAdobeCqDamCqScene7Imaging  (optional)
   * @param comAdobeCqDtmReactorCore  (optional)
   * @param comAdobeCqDtmReactorUi  (optional)
   * @param comAdobeCqExpJspelResolver  (optional)
   * @param comAdobeCqInboxCqInbox  (optional)
   * @param comAdobeCqJsonSchemaParser  (optional)
   * @param comAdobeCqMediaCqMediaPublishingDpsFpCore  (optional)
   * @param comAdobeCqMobileCqMobileCaas  (optional)
   * @param comAdobeCqMobileCqMobileIndexBuilder  (optional)
   * @param comAdobeCqMobileCqMobilePhonegapBuild  (optional)
   * @param comAdobeCqMyspell  (optional)
   * @param comAdobeCqSampleWeRetailCore  (optional)
   * @param comAdobeCqScreensComAdobeCqScreensDcc  (optional)
   * @param comAdobeCqScreensComAdobeCqScreensMqCore  (optional)
   * @param comAdobeCqSocialCqSocialAsProvider  (optional)
   * @param comAdobeCqSocialCqSocialBadgingBasicImpl  (optional)
   * @param comAdobeCqSocialCqSocialBadgingImpl  (optional)
   * @param comAdobeCqSocialCqSocialCalendarImpl  (optional)
   * @param comAdobeCqSocialCqSocialContentFragmentsImpl  (optional)
   * @param comAdobeCqSocialCqSocialEnablementImpl  (optional)
   * @param comAdobeCqSocialCqSocialGraphImpl  (optional)
   * @param comAdobeCqSocialCqSocialIdeationImpl  (optional)
   * @param comAdobeCqSocialCqSocialJcrProvider  (optional)
   * @param comAdobeCqSocialCqSocialMembersImpl  (optional)
   * @param comAdobeCqSocialCqSocialMsProvider  (optional)
   * @param comAdobeCqSocialCqSocialNotificationsChannelsWeb  (optional)
   * @param comAdobeCqSocialCqSocialNotificationsImpl  (optional)
   * @param comAdobeCqSocialCqSocialRdbProvider  (optional)
   * @param comAdobeCqSocialCqSocialScfImpl  (optional)
   * @param comAdobeCqSocialCqSocialScoringBasicImpl  (optional)
   * @param comAdobeCqSocialCqSocialScoringImpl  (optional)
   * @param comAdobeCqSocialCqSocialServiceusersImpl  (optional)
   * @param comAdobeCqSocialCqSocialSrpImpl  (optional)
   * @param comAdobeCqSocialCqSocialUgcbaseImpl  (optional)
   * @param comAdobeDamCqDamCfmImpl  (optional)
   * @param comAdobeFormsFoundationFormsFoundationBase  (optional)
   * @param comAdobeGraniteApicontroller  (optional)
   * @param comAdobeGraniteAssetCore  (optional)
   * @param comAdobeGraniteAuthSso  (optional)
   * @param comAdobeGraniteBundlesHcImpl  (optional)
   * @param comAdobeGraniteCompatRouter  (optional)
   * @param comAdobeGraniteConf  (optional)
   * @param comAdobeGraniteConfUiCore  (optional)
   * @param comAdobeGraniteCors  (optional)
   * @param comAdobeGraniteCrxExplorer  (optional)
   * @param comAdobeGraniteCrxdeLite  (optional)
   * @param comAdobeGraniteCryptoConfig  (optional)
   * @param comAdobeGraniteCryptoExtension  (optional)
   * @param comAdobeGraniteCryptoFile  (optional)
   * @param comAdobeGraniteCryptoJcr  (optional)
   * @param comAdobeGraniteCsrf  (optional)
   * @param comAdobeGraniteDistributionCore  (optional)
   * @param comAdobeGraniteDropwizardMetrics  (optional)
   * @param comAdobeGraniteFragsImpl  (optional)
   * @param comAdobeGraniteGibson  (optional)
   * @param comAdobeGraniteInfocollector  (optional)
   * @param comAdobeGraniteInstallerFactoryPackages  (optional)
   * @param comAdobeGraniteJettySsl  (optional)
   * @param comAdobeGraniteJobsAsync  (optional)
   * @param comAdobeGraniteMaintenanceOak  (optional)
   * @param comAdobeGraniteMonitoringCore  (optional)
   * @param comAdobeGraniteQueries  (optional)
   * @param comAdobeGraniteReplicationHcImpl  (optional)
   * @param comAdobeGraniteRepositoryChecker  (optional)
   * @param comAdobeGraniteRepositoryHcImpl  (optional)
   * @param comAdobeGraniteRestAssets  (optional)
   * @param comAdobeGraniteSecurityUi  (optional)
   * @param comAdobeGraniteStartup  (optional)
   * @param comAdobeGraniteTagsoup  (optional)
   * @param comAdobeGraniteTaskmanagementCore  (optional)
   * @param comAdobeGraniteTaskmanagementWorkflow  (optional)
   * @param comAdobeGraniteUiClientlibsCompilerLess  (optional)
   * @param comAdobeGraniteUiClientlibsProcessorGcc  (optional)
   * @param comAdobeGraniteWebconsolePlugins  (optional)
   * @param comAdobeGraniteWorkflowConsole  (optional)
   * @param comAdobeXmpWorkerFilesNativeFragmentLinux  (optional)
   * @param comAdobeXmpWorkerFilesNativeFragmentMacosx  (optional)
   * @param comAdobeXmpWorkerFilesNativeFragmentWin  (optional)
   * @param comDayCommonsOsgiWrapperSimpleJndi  (optional)
   * @param comDayCqCqAuthhandler  (optional)
   * @param comDayCqCqCompatConfigupdate  (optional)
   * @param comDayCqCqLicensebranding  (optional)
   * @param comDayCqCqNotifcationImpl  (optional)
   * @param comDayCqCqReplicationAudit  (optional)
   * @param comDayCqCqSearchExt  (optional)
   * @param comDayCqDamCqDamAnnotationPrint  (optional)
   * @param comDayCqDamCqDamAssetUsage  (optional)
   * @param comDayCqDamCqDamS7dam  (optional)
   * @param comDayCqDamCqDamSimilaritysearch  (optional)
   * @param comDayCqDamDamWebdavSupport  (optional)
   * @param comDayCqPreUpgradeTasks  (optional)
   * @param comDayCqReplicationExtensions  (optional)
   * @param comDayCqWcmCqMsmCore  (optional)
   * @param comDayCqWcmCqWcmTranslation  (optional)
   * @param dayCommonsJrawio  (optional)
   * @param orgApacheAriesJmxWhiteboard  (optional)
   * @param orgApacheFelixHttpSslfilter  (optional)
   * @param orgApacheFelixOrgApacheFelixThreaddump  (optional)
   * @param orgApacheFelixWebconsolePluginsDs  (optional)
   * @param orgApacheFelixWebconsolePluginsEvent  (optional)
   * @param orgApacheFelixWebconsolePluginsMemoryusage  (optional)
   * @param orgApacheFelixWebconsolePluginsPackageadmin  (optional)
   * @param orgApacheJackrabbitOakAuthLdap  (optional)
   * @param orgApacheJackrabbitOakSegmentTar  (optional)
   * @param orgApacheJackrabbitOakSolrOsgi  (optional)
   * @param orgApacheSlingBundleresourceImpl  (optional)
   * @param orgApacheSlingCommonsFsclassloader  (optional)
   * @param orgApacheSlingCommonsLogWebconsole  (optional)
   * @param orgApacheSlingDatasource  (optional)
   * @param orgApacheSlingDiscoveryBase  (optional)
   * @param orgApacheSlingDiscoveryOak  (optional)
   * @param orgApacheSlingDiscoverySupport  (optional)
   * @param orgApacheSlingDistributionApi  (optional)
   * @param orgApacheSlingDistributionCore  (optional)
   * @param orgApacheSlingExtensionsWebconsolesecurityprovider  (optional)
   * @param orgApacheSlingHcWebconsole  (optional)
   * @param orgApacheSlingInstallerConsole  (optional)
   * @param orgApacheSlingInstallerProviderFile  (optional)
   * @param orgApacheSlingInstallerProviderJcr  (optional)
   * @param orgApacheSlingJcrDavex  (optional)
   * @param orgApacheSlingJcrResourcesecurity  (optional)
   * @param orgApacheSlingJmxProvider  (optional)
   * @param orgApacheSlingLaunchpadInstaller  (optional)
   * @param orgApacheSlingModelsImpl  (optional)
   * @param orgApacheSlingRepoinitParser  (optional)
   * @param orgApacheSlingResourceInventory  (optional)
   * @param orgApacheSlingResourceresolver  (optional)
   * @param orgApacheSlingScriptingJavascript  (optional)
   * @param orgApacheSlingScriptingJst  (optional)
   * @param orgApacheSlingScriptingSightlyJsProvider  (optional)
   * @param orgApacheSlingScriptingSightlyModelsProvider  (optional)
   * @param orgApacheSlingSecurity  (optional)
   * @param orgApacheSlingServletsCompat  (optional)
   * @param orgApacheSlingServletsGet  (optional)
   * @param orgApacheSlingStartupfilterDisabler  (optional)
   * @param orgApacheSlingTracer  (optional)
   * @param weRetailClientAppCore  (optional)
   * @return ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo
   */
  def comAdobeGraniteApicontrollerFilterResolverHookFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeCqCdnCdnRewriter: Option[String] = None, comAdobeCqCloudConfigComponents: Option[String] = None, comAdobeCqCloudConfigCore: Option[String] = None, comAdobeCqCloudConfigUi: Option[String] = None, comAdobeCqComAdobeCqEditor: Option[String] = None, comAdobeCqComAdobeCqProjectsCore: Option[String] = None, comAdobeCqComAdobeCqProjectsWcmCore: Option[String] = None, comAdobeCqComAdobeCqUiCommons: Option[String] = None, comAdobeCqComAdobeCqWcmStyle: Option[String] = None, comAdobeCqCqActivitymapIntegration: Option[String] = None, comAdobeCqCqContexthubCommons: Option[String] = None, comAdobeCqCqDtm: Option[String] = None, comAdobeCqCqHealthcheck: Option[String] = None, comAdobeCqCqMultisiteTargeting: Option[String] = None, comAdobeCqCqPreUpgradeCleanup: Option[String] = None, comAdobeCqCqProductInfoProvider: Option[String] = None, comAdobeCqCqRestSites: Option[String] = None, comAdobeCqCqSecurityHc: Option[String] = None, comAdobeCqDamCqDamSvgHandler: Option[String] = None, comAdobeCqDamCqScene7Imaging: Option[String] = None, comAdobeCqDtmReactorCore: Option[String] = None, comAdobeCqDtmReactorUi: Option[String] = None, comAdobeCqExpJspelResolver: Option[String] = None, comAdobeCqInboxCqInbox: Option[String] = None, comAdobeCqJsonSchemaParser: Option[String] = None, comAdobeCqMediaCqMediaPublishingDpsFpCore: Option[String] = None, comAdobeCqMobileCqMobileCaas: Option[String] = None, comAdobeCqMobileCqMobileIndexBuilder: Option[String] = None, comAdobeCqMobileCqMobilePhonegapBuild: Option[String] = None, comAdobeCqMyspell: Option[String] = None, comAdobeCqSampleWeRetailCore: Option[String] = None, comAdobeCqScreensComAdobeCqScreensDcc: Option[String] = None, comAdobeCqScreensComAdobeCqScreensMqCore: Option[String] = None, comAdobeCqSocialCqSocialAsProvider: Option[String] = None, comAdobeCqSocialCqSocialBadgingBasicImpl: Option[String] = None, comAdobeCqSocialCqSocialBadgingImpl: Option[String] = None, comAdobeCqSocialCqSocialCalendarImpl: Option[String] = None, comAdobeCqSocialCqSocialContentFragmentsImpl: Option[String] = None, comAdobeCqSocialCqSocialEnablementImpl: Option[String] = None, comAdobeCqSocialCqSocialGraphImpl: Option[String] = None, comAdobeCqSocialCqSocialIdeationImpl: Option[String] = None, comAdobeCqSocialCqSocialJcrProvider: Option[String] = None, comAdobeCqSocialCqSocialMembersImpl: Option[String] = None, comAdobeCqSocialCqSocialMsProvider: Option[String] = None, comAdobeCqSocialCqSocialNotificationsChannelsWeb: Option[String] = None, comAdobeCqSocialCqSocialNotificationsImpl: Option[String] = None, comAdobeCqSocialCqSocialRdbProvider: Option[String] = None, comAdobeCqSocialCqSocialScfImpl: Option[String] = None, comAdobeCqSocialCqSocialScoringBasicImpl: Option[String] = None, comAdobeCqSocialCqSocialScoringImpl: Option[String] = None, comAdobeCqSocialCqSocialServiceusersImpl: Option[String] = None, comAdobeCqSocialCqSocialSrpImpl: Option[String] = None, comAdobeCqSocialCqSocialUgcbaseImpl: Option[String] = None, comAdobeDamCqDamCfmImpl: Option[String] = None, comAdobeFormsFoundationFormsFoundationBase: Option[String] = None, comAdobeGraniteApicontroller: Option[String] = None, comAdobeGraniteAssetCore: Option[String] = None, comAdobeGraniteAuthSso: Option[String] = None, comAdobeGraniteBundlesHcImpl: Option[String] = None, comAdobeGraniteCompatRouter: Option[String] = None, comAdobeGraniteConf: Option[String] = None, comAdobeGraniteConfUiCore: Option[String] = None, comAdobeGraniteCors: Option[String] = None, comAdobeGraniteCrxExplorer: Option[String] = None, comAdobeGraniteCrxdeLite: Option[String] = None, comAdobeGraniteCryptoConfig: Option[String] = None, comAdobeGraniteCryptoExtension: Option[String] = None, comAdobeGraniteCryptoFile: Option[String] = None, comAdobeGraniteCryptoJcr: Option[String] = None, comAdobeGraniteCsrf: Option[String] = None, comAdobeGraniteDistributionCore: Option[String] = None, comAdobeGraniteDropwizardMetrics: Option[String] = None, comAdobeGraniteFragsImpl: Option[String] = None, comAdobeGraniteGibson: Option[String] = None, comAdobeGraniteInfocollector: Option[String] = None, comAdobeGraniteInstallerFactoryPackages: Option[String] = None, comAdobeGraniteJettySsl: Option[String] = None, comAdobeGraniteJobsAsync: Option[String] = None, comAdobeGraniteMaintenanceOak: Option[String] = None, comAdobeGraniteMonitoringCore: Option[String] = None, comAdobeGraniteQueries: Option[String] = None, comAdobeGraniteReplicationHcImpl: Option[String] = None, comAdobeGraniteRepositoryChecker: Option[String] = None, comAdobeGraniteRepositoryHcImpl: Option[String] = None, comAdobeGraniteRestAssets: Option[String] = None, comAdobeGraniteSecurityUi: Option[String] = None, comAdobeGraniteStartup: Option[String] = None, comAdobeGraniteTagsoup: Option[String] = None, comAdobeGraniteTaskmanagementCore: Option[String] = None, comAdobeGraniteTaskmanagementWorkflow: Option[String] = None, comAdobeGraniteUiClientlibsCompilerLess: Option[String] = None, comAdobeGraniteUiClientlibsProcessorGcc: Option[String] = None, comAdobeGraniteWebconsolePlugins: Option[String] = None, comAdobeGraniteWorkflowConsole: Option[String] = None, comAdobeXmpWorkerFilesNativeFragmentLinux: Option[String] = None, comAdobeXmpWorkerFilesNativeFragmentMacosx: Option[String] = None, comAdobeXmpWorkerFilesNativeFragmentWin: Option[String] = None, comDayCommonsOsgiWrapperSimpleJndi: Option[String] = None, comDayCqCqAuthhandler: Option[String] = None, comDayCqCqCompatConfigupdate: Option[String] = None, comDayCqCqLicensebranding: Option[String] = None, comDayCqCqNotifcationImpl: Option[String] = None, comDayCqCqReplicationAudit: Option[String] = None, comDayCqCqSearchExt: Option[String] = None, comDayCqDamCqDamAnnotationPrint: Option[String] = None, comDayCqDamCqDamAssetUsage: Option[String] = None, comDayCqDamCqDamS7dam: Option[String] = None, comDayCqDamCqDamSimilaritysearch: Option[String] = None, comDayCqDamDamWebdavSupport: Option[String] = None, comDayCqPreUpgradeTasks: Option[String] = None, comDayCqReplicationExtensions: Option[String] = None, comDayCqWcmCqMsmCore: Option[String] = None, comDayCqWcmCqWcmTranslation: Option[String] = None, dayCommonsJrawio: Option[String] = None, orgApacheAriesJmxWhiteboard: Option[String] = None, orgApacheFelixHttpSslfilter: Option[String] = None, orgApacheFelixOrgApacheFelixThreaddump: Option[String] = None, orgApacheFelixWebconsolePluginsDs: Option[String] = None, orgApacheFelixWebconsolePluginsEvent: Option[String] = None, orgApacheFelixWebconsolePluginsMemoryusage: Option[String] = None, orgApacheFelixWebconsolePluginsPackageadmin: Option[String] = None, orgApacheJackrabbitOakAuthLdap: Option[String] = None, orgApacheJackrabbitOakSegmentTar: Option[String] = None, orgApacheJackrabbitOakSolrOsgi: Option[String] = None, orgApacheSlingBundleresourceImpl: Option[String] = None, orgApacheSlingCommonsFsclassloader: Option[String] = None, orgApacheSlingCommonsLogWebconsole: Option[String] = None, orgApacheSlingDatasource: Option[String] = None, orgApacheSlingDiscoveryBase: Option[String] = None, orgApacheSlingDiscoveryOak: Option[String] = None, orgApacheSlingDiscoverySupport: Option[String] = None, orgApacheSlingDistributionApi: Option[String] = None, orgApacheSlingDistributionCore: Option[String] = None, orgApacheSlingExtensionsWebconsolesecurityprovider: Option[String] = None, orgApacheSlingHcWebconsole: Option[String] = None, orgApacheSlingInstallerConsole: Option[String] = None, orgApacheSlingInstallerProviderFile: Option[String] = None, orgApacheSlingInstallerProviderJcr: Option[String] = None, orgApacheSlingJcrDavex: Option[String] = None, orgApacheSlingJcrResourcesecurity: Option[String] = None, orgApacheSlingJmxProvider: Option[String] = None, orgApacheSlingLaunchpadInstaller: Option[String] = None, orgApacheSlingModelsImpl: Option[String] = None, orgApacheSlingRepoinitParser: Option[String] = None, orgApacheSlingResourceInventory: Option[String] = None, orgApacheSlingResourceresolver: Option[String] = None, orgApacheSlingScriptingJavascript: Option[String] = None, orgApacheSlingScriptingJst: Option[String] = None, orgApacheSlingScriptingSightlyJsProvider: Option[String] = None, orgApacheSlingScriptingSightlyModelsProvider: Option[String] = None, orgApacheSlingSecurity: Option[String] = None, orgApacheSlingServletsCompat: Option[String] = None, orgApacheSlingServletsGet: Option[String] = None, orgApacheSlingStartupfilterDisabler: Option[String] = None, orgApacheSlingTracer: Option[String] = None, weRetailClientAppCore: Option[String] = None): Option[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo] = {
    val await = Try(Await.result(comAdobeGraniteApicontrollerFilterResolverHookFactoryAsync(post, apply, delete, action, location, propertylist, comAdobeCqCdnCdnRewriter, comAdobeCqCloudConfigComponents, comAdobeCqCloudConfigCore, comAdobeCqCloudConfigUi, comAdobeCqComAdobeCqEditor, comAdobeCqComAdobeCqProjectsCore, comAdobeCqComAdobeCqProjectsWcmCore, comAdobeCqComAdobeCqUiCommons, comAdobeCqComAdobeCqWcmStyle, comAdobeCqCqActivitymapIntegration, comAdobeCqCqContexthubCommons, comAdobeCqCqDtm, comAdobeCqCqHealthcheck, comAdobeCqCqMultisiteTargeting, comAdobeCqCqPreUpgradeCleanup, comAdobeCqCqProductInfoProvider, comAdobeCqCqRestSites, comAdobeCqCqSecurityHc, comAdobeCqDamCqDamSvgHandler, comAdobeCqDamCqScene7Imaging, comAdobeCqDtmReactorCore, comAdobeCqDtmReactorUi, comAdobeCqExpJspelResolver, comAdobeCqInboxCqInbox, comAdobeCqJsonSchemaParser, comAdobeCqMediaCqMediaPublishingDpsFpCore, comAdobeCqMobileCqMobileCaas, comAdobeCqMobileCqMobileIndexBuilder, comAdobeCqMobileCqMobilePhonegapBuild, comAdobeCqMyspell, comAdobeCqSampleWeRetailCore, comAdobeCqScreensComAdobeCqScreensDcc, comAdobeCqScreensComAdobeCqScreensMqCore, comAdobeCqSocialCqSocialAsProvider, comAdobeCqSocialCqSocialBadgingBasicImpl, comAdobeCqSocialCqSocialBadgingImpl, comAdobeCqSocialCqSocialCalendarImpl, comAdobeCqSocialCqSocialContentFragmentsImpl, comAdobeCqSocialCqSocialEnablementImpl, comAdobeCqSocialCqSocialGraphImpl, comAdobeCqSocialCqSocialIdeationImpl, comAdobeCqSocialCqSocialJcrProvider, comAdobeCqSocialCqSocialMembersImpl, comAdobeCqSocialCqSocialMsProvider, comAdobeCqSocialCqSocialNotificationsChannelsWeb, comAdobeCqSocialCqSocialNotificationsImpl, comAdobeCqSocialCqSocialRdbProvider, comAdobeCqSocialCqSocialScfImpl, comAdobeCqSocialCqSocialScoringBasicImpl, comAdobeCqSocialCqSocialScoringImpl, comAdobeCqSocialCqSocialServiceusersImpl, comAdobeCqSocialCqSocialSrpImpl, comAdobeCqSocialCqSocialUgcbaseImpl, comAdobeDamCqDamCfmImpl, comAdobeFormsFoundationFormsFoundationBase, comAdobeGraniteApicontroller, comAdobeGraniteAssetCore, comAdobeGraniteAuthSso, comAdobeGraniteBundlesHcImpl, comAdobeGraniteCompatRouter, comAdobeGraniteConf, comAdobeGraniteConfUiCore, comAdobeGraniteCors, comAdobeGraniteCrxExplorer, comAdobeGraniteCrxdeLite, comAdobeGraniteCryptoConfig, comAdobeGraniteCryptoExtension, comAdobeGraniteCryptoFile, comAdobeGraniteCryptoJcr, comAdobeGraniteCsrf, comAdobeGraniteDistributionCore, comAdobeGraniteDropwizardMetrics, comAdobeGraniteFragsImpl, comAdobeGraniteGibson, comAdobeGraniteInfocollector, comAdobeGraniteInstallerFactoryPackages, comAdobeGraniteJettySsl, comAdobeGraniteJobsAsync, comAdobeGraniteMaintenanceOak, comAdobeGraniteMonitoringCore, comAdobeGraniteQueries, comAdobeGraniteReplicationHcImpl, comAdobeGraniteRepositoryChecker, comAdobeGraniteRepositoryHcImpl, comAdobeGraniteRestAssets, comAdobeGraniteSecurityUi, comAdobeGraniteStartup, comAdobeGraniteTagsoup, comAdobeGraniteTaskmanagementCore, comAdobeGraniteTaskmanagementWorkflow, comAdobeGraniteUiClientlibsCompilerLess, comAdobeGraniteUiClientlibsProcessorGcc, comAdobeGraniteWebconsolePlugins, comAdobeGraniteWorkflowConsole, comAdobeXmpWorkerFilesNativeFragmentLinux, comAdobeXmpWorkerFilesNativeFragmentMacosx, comAdobeXmpWorkerFilesNativeFragmentWin, comDayCommonsOsgiWrapperSimpleJndi, comDayCqCqAuthhandler, comDayCqCqCompatConfigupdate, comDayCqCqLicensebranding, comDayCqCqNotifcationImpl, comDayCqCqReplicationAudit, comDayCqCqSearchExt, comDayCqDamCqDamAnnotationPrint, comDayCqDamCqDamAssetUsage, comDayCqDamCqDamS7dam, comDayCqDamCqDamSimilaritysearch, comDayCqDamDamWebdavSupport, comDayCqPreUpgradeTasks, comDayCqReplicationExtensions, comDayCqWcmCqMsmCore, comDayCqWcmCqWcmTranslation, dayCommonsJrawio, orgApacheAriesJmxWhiteboard, orgApacheFelixHttpSslfilter, orgApacheFelixOrgApacheFelixThreaddump, orgApacheFelixWebconsolePluginsDs, orgApacheFelixWebconsolePluginsEvent, orgApacheFelixWebconsolePluginsMemoryusage, orgApacheFelixWebconsolePluginsPackageadmin, orgApacheJackrabbitOakAuthLdap, orgApacheJackrabbitOakSegmentTar, orgApacheJackrabbitOakSolrOsgi, orgApacheSlingBundleresourceImpl, orgApacheSlingCommonsFsclassloader, orgApacheSlingCommonsLogWebconsole, orgApacheSlingDatasource, orgApacheSlingDiscoveryBase, orgApacheSlingDiscoveryOak, orgApacheSlingDiscoverySupport, orgApacheSlingDistributionApi, orgApacheSlingDistributionCore, orgApacheSlingExtensionsWebconsolesecurityprovider, orgApacheSlingHcWebconsole, orgApacheSlingInstallerConsole, orgApacheSlingInstallerProviderFile, orgApacheSlingInstallerProviderJcr, orgApacheSlingJcrDavex, orgApacheSlingJcrResourcesecurity, orgApacheSlingJmxProvider, orgApacheSlingLaunchpadInstaller, orgApacheSlingModelsImpl, orgApacheSlingRepoinitParser, orgApacheSlingResourceInventory, orgApacheSlingResourceresolver, orgApacheSlingScriptingJavascript, orgApacheSlingScriptingJst, orgApacheSlingScriptingSightlyJsProvider, orgApacheSlingScriptingSightlyModelsProvider, orgApacheSlingSecurity, orgApacheSlingServletsCompat, orgApacheSlingServletsGet, orgApacheSlingStartupfilterDisabler, orgApacheSlingTracer, weRetailClientAppCore), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeCqCdnCdnRewriter  (optional)
   * @param comAdobeCqCloudConfigComponents  (optional)
   * @param comAdobeCqCloudConfigCore  (optional)
   * @param comAdobeCqCloudConfigUi  (optional)
   * @param comAdobeCqComAdobeCqEditor  (optional)
   * @param comAdobeCqComAdobeCqProjectsCore  (optional)
   * @param comAdobeCqComAdobeCqProjectsWcmCore  (optional)
   * @param comAdobeCqComAdobeCqUiCommons  (optional)
   * @param comAdobeCqComAdobeCqWcmStyle  (optional)
   * @param comAdobeCqCqActivitymapIntegration  (optional)
   * @param comAdobeCqCqContexthubCommons  (optional)
   * @param comAdobeCqCqDtm  (optional)
   * @param comAdobeCqCqHealthcheck  (optional)
   * @param comAdobeCqCqMultisiteTargeting  (optional)
   * @param comAdobeCqCqPreUpgradeCleanup  (optional)
   * @param comAdobeCqCqProductInfoProvider  (optional)
   * @param comAdobeCqCqRestSites  (optional)
   * @param comAdobeCqCqSecurityHc  (optional)
   * @param comAdobeCqDamCqDamSvgHandler  (optional)
   * @param comAdobeCqDamCqScene7Imaging  (optional)
   * @param comAdobeCqDtmReactorCore  (optional)
   * @param comAdobeCqDtmReactorUi  (optional)
   * @param comAdobeCqExpJspelResolver  (optional)
   * @param comAdobeCqInboxCqInbox  (optional)
   * @param comAdobeCqJsonSchemaParser  (optional)
   * @param comAdobeCqMediaCqMediaPublishingDpsFpCore  (optional)
   * @param comAdobeCqMobileCqMobileCaas  (optional)
   * @param comAdobeCqMobileCqMobileIndexBuilder  (optional)
   * @param comAdobeCqMobileCqMobilePhonegapBuild  (optional)
   * @param comAdobeCqMyspell  (optional)
   * @param comAdobeCqSampleWeRetailCore  (optional)
   * @param comAdobeCqScreensComAdobeCqScreensDcc  (optional)
   * @param comAdobeCqScreensComAdobeCqScreensMqCore  (optional)
   * @param comAdobeCqSocialCqSocialAsProvider  (optional)
   * @param comAdobeCqSocialCqSocialBadgingBasicImpl  (optional)
   * @param comAdobeCqSocialCqSocialBadgingImpl  (optional)
   * @param comAdobeCqSocialCqSocialCalendarImpl  (optional)
   * @param comAdobeCqSocialCqSocialContentFragmentsImpl  (optional)
   * @param comAdobeCqSocialCqSocialEnablementImpl  (optional)
   * @param comAdobeCqSocialCqSocialGraphImpl  (optional)
   * @param comAdobeCqSocialCqSocialIdeationImpl  (optional)
   * @param comAdobeCqSocialCqSocialJcrProvider  (optional)
   * @param comAdobeCqSocialCqSocialMembersImpl  (optional)
   * @param comAdobeCqSocialCqSocialMsProvider  (optional)
   * @param comAdobeCqSocialCqSocialNotificationsChannelsWeb  (optional)
   * @param comAdobeCqSocialCqSocialNotificationsImpl  (optional)
   * @param comAdobeCqSocialCqSocialRdbProvider  (optional)
   * @param comAdobeCqSocialCqSocialScfImpl  (optional)
   * @param comAdobeCqSocialCqSocialScoringBasicImpl  (optional)
   * @param comAdobeCqSocialCqSocialScoringImpl  (optional)
   * @param comAdobeCqSocialCqSocialServiceusersImpl  (optional)
   * @param comAdobeCqSocialCqSocialSrpImpl  (optional)
   * @param comAdobeCqSocialCqSocialUgcbaseImpl  (optional)
   * @param comAdobeDamCqDamCfmImpl  (optional)
   * @param comAdobeFormsFoundationFormsFoundationBase  (optional)
   * @param comAdobeGraniteApicontroller  (optional)
   * @param comAdobeGraniteAssetCore  (optional)
   * @param comAdobeGraniteAuthSso  (optional)
   * @param comAdobeGraniteBundlesHcImpl  (optional)
   * @param comAdobeGraniteCompatRouter  (optional)
   * @param comAdobeGraniteConf  (optional)
   * @param comAdobeGraniteConfUiCore  (optional)
   * @param comAdobeGraniteCors  (optional)
   * @param comAdobeGraniteCrxExplorer  (optional)
   * @param comAdobeGraniteCrxdeLite  (optional)
   * @param comAdobeGraniteCryptoConfig  (optional)
   * @param comAdobeGraniteCryptoExtension  (optional)
   * @param comAdobeGraniteCryptoFile  (optional)
   * @param comAdobeGraniteCryptoJcr  (optional)
   * @param comAdobeGraniteCsrf  (optional)
   * @param comAdobeGraniteDistributionCore  (optional)
   * @param comAdobeGraniteDropwizardMetrics  (optional)
   * @param comAdobeGraniteFragsImpl  (optional)
   * @param comAdobeGraniteGibson  (optional)
   * @param comAdobeGraniteInfocollector  (optional)
   * @param comAdobeGraniteInstallerFactoryPackages  (optional)
   * @param comAdobeGraniteJettySsl  (optional)
   * @param comAdobeGraniteJobsAsync  (optional)
   * @param comAdobeGraniteMaintenanceOak  (optional)
   * @param comAdobeGraniteMonitoringCore  (optional)
   * @param comAdobeGraniteQueries  (optional)
   * @param comAdobeGraniteReplicationHcImpl  (optional)
   * @param comAdobeGraniteRepositoryChecker  (optional)
   * @param comAdobeGraniteRepositoryHcImpl  (optional)
   * @param comAdobeGraniteRestAssets  (optional)
   * @param comAdobeGraniteSecurityUi  (optional)
   * @param comAdobeGraniteStartup  (optional)
   * @param comAdobeGraniteTagsoup  (optional)
   * @param comAdobeGraniteTaskmanagementCore  (optional)
   * @param comAdobeGraniteTaskmanagementWorkflow  (optional)
   * @param comAdobeGraniteUiClientlibsCompilerLess  (optional)
   * @param comAdobeGraniteUiClientlibsProcessorGcc  (optional)
   * @param comAdobeGraniteWebconsolePlugins  (optional)
   * @param comAdobeGraniteWorkflowConsole  (optional)
   * @param comAdobeXmpWorkerFilesNativeFragmentLinux  (optional)
   * @param comAdobeXmpWorkerFilesNativeFragmentMacosx  (optional)
   * @param comAdobeXmpWorkerFilesNativeFragmentWin  (optional)
   * @param comDayCommonsOsgiWrapperSimpleJndi  (optional)
   * @param comDayCqCqAuthhandler  (optional)
   * @param comDayCqCqCompatConfigupdate  (optional)
   * @param comDayCqCqLicensebranding  (optional)
   * @param comDayCqCqNotifcationImpl  (optional)
   * @param comDayCqCqReplicationAudit  (optional)
   * @param comDayCqCqSearchExt  (optional)
   * @param comDayCqDamCqDamAnnotationPrint  (optional)
   * @param comDayCqDamCqDamAssetUsage  (optional)
   * @param comDayCqDamCqDamS7dam  (optional)
   * @param comDayCqDamCqDamSimilaritysearch  (optional)
   * @param comDayCqDamDamWebdavSupport  (optional)
   * @param comDayCqPreUpgradeTasks  (optional)
   * @param comDayCqReplicationExtensions  (optional)
   * @param comDayCqWcmCqMsmCore  (optional)
   * @param comDayCqWcmCqWcmTranslation  (optional)
   * @param dayCommonsJrawio  (optional)
   * @param orgApacheAriesJmxWhiteboard  (optional)
   * @param orgApacheFelixHttpSslfilter  (optional)
   * @param orgApacheFelixOrgApacheFelixThreaddump  (optional)
   * @param orgApacheFelixWebconsolePluginsDs  (optional)
   * @param orgApacheFelixWebconsolePluginsEvent  (optional)
   * @param orgApacheFelixWebconsolePluginsMemoryusage  (optional)
   * @param orgApacheFelixWebconsolePluginsPackageadmin  (optional)
   * @param orgApacheJackrabbitOakAuthLdap  (optional)
   * @param orgApacheJackrabbitOakSegmentTar  (optional)
   * @param orgApacheJackrabbitOakSolrOsgi  (optional)
   * @param orgApacheSlingBundleresourceImpl  (optional)
   * @param orgApacheSlingCommonsFsclassloader  (optional)
   * @param orgApacheSlingCommonsLogWebconsole  (optional)
   * @param orgApacheSlingDatasource  (optional)
   * @param orgApacheSlingDiscoveryBase  (optional)
   * @param orgApacheSlingDiscoveryOak  (optional)
   * @param orgApacheSlingDiscoverySupport  (optional)
   * @param orgApacheSlingDistributionApi  (optional)
   * @param orgApacheSlingDistributionCore  (optional)
   * @param orgApacheSlingExtensionsWebconsolesecurityprovider  (optional)
   * @param orgApacheSlingHcWebconsole  (optional)
   * @param orgApacheSlingInstallerConsole  (optional)
   * @param orgApacheSlingInstallerProviderFile  (optional)
   * @param orgApacheSlingInstallerProviderJcr  (optional)
   * @param orgApacheSlingJcrDavex  (optional)
   * @param orgApacheSlingJcrResourcesecurity  (optional)
   * @param orgApacheSlingJmxProvider  (optional)
   * @param orgApacheSlingLaunchpadInstaller  (optional)
   * @param orgApacheSlingModelsImpl  (optional)
   * @param orgApacheSlingRepoinitParser  (optional)
   * @param orgApacheSlingResourceInventory  (optional)
   * @param orgApacheSlingResourceresolver  (optional)
   * @param orgApacheSlingScriptingJavascript  (optional)
   * @param orgApacheSlingScriptingJst  (optional)
   * @param orgApacheSlingScriptingSightlyJsProvider  (optional)
   * @param orgApacheSlingScriptingSightlyModelsProvider  (optional)
   * @param orgApacheSlingSecurity  (optional)
   * @param orgApacheSlingServletsCompat  (optional)
   * @param orgApacheSlingServletsGet  (optional)
   * @param orgApacheSlingStartupfilterDisabler  (optional)
   * @param orgApacheSlingTracer  (optional)
   * @param weRetailClientAppCore  (optional)
   * @return Future(ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo)
   */
  def comAdobeGraniteApicontrollerFilterResolverHookFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeCqCdnCdnRewriter: Option[String] = None, comAdobeCqCloudConfigComponents: Option[String] = None, comAdobeCqCloudConfigCore: Option[String] = None, comAdobeCqCloudConfigUi: Option[String] = None, comAdobeCqComAdobeCqEditor: Option[String] = None, comAdobeCqComAdobeCqProjectsCore: Option[String] = None, comAdobeCqComAdobeCqProjectsWcmCore: Option[String] = None, comAdobeCqComAdobeCqUiCommons: Option[String] = None, comAdobeCqComAdobeCqWcmStyle: Option[String] = None, comAdobeCqCqActivitymapIntegration: Option[String] = None, comAdobeCqCqContexthubCommons: Option[String] = None, comAdobeCqCqDtm: Option[String] = None, comAdobeCqCqHealthcheck: Option[String] = None, comAdobeCqCqMultisiteTargeting: Option[String] = None, comAdobeCqCqPreUpgradeCleanup: Option[String] = None, comAdobeCqCqProductInfoProvider: Option[String] = None, comAdobeCqCqRestSites: Option[String] = None, comAdobeCqCqSecurityHc: Option[String] = None, comAdobeCqDamCqDamSvgHandler: Option[String] = None, comAdobeCqDamCqScene7Imaging: Option[String] = None, comAdobeCqDtmReactorCore: Option[String] = None, comAdobeCqDtmReactorUi: Option[String] = None, comAdobeCqExpJspelResolver: Option[String] = None, comAdobeCqInboxCqInbox: Option[String] = None, comAdobeCqJsonSchemaParser: Option[String] = None, comAdobeCqMediaCqMediaPublishingDpsFpCore: Option[String] = None, comAdobeCqMobileCqMobileCaas: Option[String] = None, comAdobeCqMobileCqMobileIndexBuilder: Option[String] = None, comAdobeCqMobileCqMobilePhonegapBuild: Option[String] = None, comAdobeCqMyspell: Option[String] = None, comAdobeCqSampleWeRetailCore: Option[String] = None, comAdobeCqScreensComAdobeCqScreensDcc: Option[String] = None, comAdobeCqScreensComAdobeCqScreensMqCore: Option[String] = None, comAdobeCqSocialCqSocialAsProvider: Option[String] = None, comAdobeCqSocialCqSocialBadgingBasicImpl: Option[String] = None, comAdobeCqSocialCqSocialBadgingImpl: Option[String] = None, comAdobeCqSocialCqSocialCalendarImpl: Option[String] = None, comAdobeCqSocialCqSocialContentFragmentsImpl: Option[String] = None, comAdobeCqSocialCqSocialEnablementImpl: Option[String] = None, comAdobeCqSocialCqSocialGraphImpl: Option[String] = None, comAdobeCqSocialCqSocialIdeationImpl: Option[String] = None, comAdobeCqSocialCqSocialJcrProvider: Option[String] = None, comAdobeCqSocialCqSocialMembersImpl: Option[String] = None, comAdobeCqSocialCqSocialMsProvider: Option[String] = None, comAdobeCqSocialCqSocialNotificationsChannelsWeb: Option[String] = None, comAdobeCqSocialCqSocialNotificationsImpl: Option[String] = None, comAdobeCqSocialCqSocialRdbProvider: Option[String] = None, comAdobeCqSocialCqSocialScfImpl: Option[String] = None, comAdobeCqSocialCqSocialScoringBasicImpl: Option[String] = None, comAdobeCqSocialCqSocialScoringImpl: Option[String] = None, comAdobeCqSocialCqSocialServiceusersImpl: Option[String] = None, comAdobeCqSocialCqSocialSrpImpl: Option[String] = None, comAdobeCqSocialCqSocialUgcbaseImpl: Option[String] = None, comAdobeDamCqDamCfmImpl: Option[String] = None, comAdobeFormsFoundationFormsFoundationBase: Option[String] = None, comAdobeGraniteApicontroller: Option[String] = None, comAdobeGraniteAssetCore: Option[String] = None, comAdobeGraniteAuthSso: Option[String] = None, comAdobeGraniteBundlesHcImpl: Option[String] = None, comAdobeGraniteCompatRouter: Option[String] = None, comAdobeGraniteConf: Option[String] = None, comAdobeGraniteConfUiCore: Option[String] = None, comAdobeGraniteCors: Option[String] = None, comAdobeGraniteCrxExplorer: Option[String] = None, comAdobeGraniteCrxdeLite: Option[String] = None, comAdobeGraniteCryptoConfig: Option[String] = None, comAdobeGraniteCryptoExtension: Option[String] = None, comAdobeGraniteCryptoFile: Option[String] = None, comAdobeGraniteCryptoJcr: Option[String] = None, comAdobeGraniteCsrf: Option[String] = None, comAdobeGraniteDistributionCore: Option[String] = None, comAdobeGraniteDropwizardMetrics: Option[String] = None, comAdobeGraniteFragsImpl: Option[String] = None, comAdobeGraniteGibson: Option[String] = None, comAdobeGraniteInfocollector: Option[String] = None, comAdobeGraniteInstallerFactoryPackages: Option[String] = None, comAdobeGraniteJettySsl: Option[String] = None, comAdobeGraniteJobsAsync: Option[String] = None, comAdobeGraniteMaintenanceOak: Option[String] = None, comAdobeGraniteMonitoringCore: Option[String] = None, comAdobeGraniteQueries: Option[String] = None, comAdobeGraniteReplicationHcImpl: Option[String] = None, comAdobeGraniteRepositoryChecker: Option[String] = None, comAdobeGraniteRepositoryHcImpl: Option[String] = None, comAdobeGraniteRestAssets: Option[String] = None, comAdobeGraniteSecurityUi: Option[String] = None, comAdobeGraniteStartup: Option[String] = None, comAdobeGraniteTagsoup: Option[String] = None, comAdobeGraniteTaskmanagementCore: Option[String] = None, comAdobeGraniteTaskmanagementWorkflow: Option[String] = None, comAdobeGraniteUiClientlibsCompilerLess: Option[String] = None, comAdobeGraniteUiClientlibsProcessorGcc: Option[String] = None, comAdobeGraniteWebconsolePlugins: Option[String] = None, comAdobeGraniteWorkflowConsole: Option[String] = None, comAdobeXmpWorkerFilesNativeFragmentLinux: Option[String] = None, comAdobeXmpWorkerFilesNativeFragmentMacosx: Option[String] = None, comAdobeXmpWorkerFilesNativeFragmentWin: Option[String] = None, comDayCommonsOsgiWrapperSimpleJndi: Option[String] = None, comDayCqCqAuthhandler: Option[String] = None, comDayCqCqCompatConfigupdate: Option[String] = None, comDayCqCqLicensebranding: Option[String] = None, comDayCqCqNotifcationImpl: Option[String] = None, comDayCqCqReplicationAudit: Option[String] = None, comDayCqCqSearchExt: Option[String] = None, comDayCqDamCqDamAnnotationPrint: Option[String] = None, comDayCqDamCqDamAssetUsage: Option[String] = None, comDayCqDamCqDamS7dam: Option[String] = None, comDayCqDamCqDamSimilaritysearch: Option[String] = None, comDayCqDamDamWebdavSupport: Option[String] = None, comDayCqPreUpgradeTasks: Option[String] = None, comDayCqReplicationExtensions: Option[String] = None, comDayCqWcmCqMsmCore: Option[String] = None, comDayCqWcmCqWcmTranslation: Option[String] = None, dayCommonsJrawio: Option[String] = None, orgApacheAriesJmxWhiteboard: Option[String] = None, orgApacheFelixHttpSslfilter: Option[String] = None, orgApacheFelixOrgApacheFelixThreaddump: Option[String] = None, orgApacheFelixWebconsolePluginsDs: Option[String] = None, orgApacheFelixWebconsolePluginsEvent: Option[String] = None, orgApacheFelixWebconsolePluginsMemoryusage: Option[String] = None, orgApacheFelixWebconsolePluginsPackageadmin: Option[String] = None, orgApacheJackrabbitOakAuthLdap: Option[String] = None, orgApacheJackrabbitOakSegmentTar: Option[String] = None, orgApacheJackrabbitOakSolrOsgi: Option[String] = None, orgApacheSlingBundleresourceImpl: Option[String] = None, orgApacheSlingCommonsFsclassloader: Option[String] = None, orgApacheSlingCommonsLogWebconsole: Option[String] = None, orgApacheSlingDatasource: Option[String] = None, orgApacheSlingDiscoveryBase: Option[String] = None, orgApacheSlingDiscoveryOak: Option[String] = None, orgApacheSlingDiscoverySupport: Option[String] = None, orgApacheSlingDistributionApi: Option[String] = None, orgApacheSlingDistributionCore: Option[String] = None, orgApacheSlingExtensionsWebconsolesecurityprovider: Option[String] = None, orgApacheSlingHcWebconsole: Option[String] = None, orgApacheSlingInstallerConsole: Option[String] = None, orgApacheSlingInstallerProviderFile: Option[String] = None, orgApacheSlingInstallerProviderJcr: Option[String] = None, orgApacheSlingJcrDavex: Option[String] = None, orgApacheSlingJcrResourcesecurity: Option[String] = None, orgApacheSlingJmxProvider: Option[String] = None, orgApacheSlingLaunchpadInstaller: Option[String] = None, orgApacheSlingModelsImpl: Option[String] = None, orgApacheSlingRepoinitParser: Option[String] = None, orgApacheSlingResourceInventory: Option[String] = None, orgApacheSlingResourceresolver: Option[String] = None, orgApacheSlingScriptingJavascript: Option[String] = None, orgApacheSlingScriptingJst: Option[String] = None, orgApacheSlingScriptingSightlyJsProvider: Option[String] = None, orgApacheSlingScriptingSightlyModelsProvider: Option[String] = None, orgApacheSlingSecurity: Option[String] = None, orgApacheSlingServletsCompat: Option[String] = None, orgApacheSlingServletsGet: Option[String] = None, orgApacheSlingStartupfilterDisabler: Option[String] = None, orgApacheSlingTracer: Option[String] = None, weRetailClientAppCore: Option[String] = None): Future[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo] = {
      helper.comAdobeGraniteApicontrollerFilterResolverHookFactory(post, apply, delete, action, location, propertylist, comAdobeCqCdnCdnRewriter, comAdobeCqCloudConfigComponents, comAdobeCqCloudConfigCore, comAdobeCqCloudConfigUi, comAdobeCqComAdobeCqEditor, comAdobeCqComAdobeCqProjectsCore, comAdobeCqComAdobeCqProjectsWcmCore, comAdobeCqComAdobeCqUiCommons, comAdobeCqComAdobeCqWcmStyle, comAdobeCqCqActivitymapIntegration, comAdobeCqCqContexthubCommons, comAdobeCqCqDtm, comAdobeCqCqHealthcheck, comAdobeCqCqMultisiteTargeting, comAdobeCqCqPreUpgradeCleanup, comAdobeCqCqProductInfoProvider, comAdobeCqCqRestSites, comAdobeCqCqSecurityHc, comAdobeCqDamCqDamSvgHandler, comAdobeCqDamCqScene7Imaging, comAdobeCqDtmReactorCore, comAdobeCqDtmReactorUi, comAdobeCqExpJspelResolver, comAdobeCqInboxCqInbox, comAdobeCqJsonSchemaParser, comAdobeCqMediaCqMediaPublishingDpsFpCore, comAdobeCqMobileCqMobileCaas, comAdobeCqMobileCqMobileIndexBuilder, comAdobeCqMobileCqMobilePhonegapBuild, comAdobeCqMyspell, comAdobeCqSampleWeRetailCore, comAdobeCqScreensComAdobeCqScreensDcc, comAdobeCqScreensComAdobeCqScreensMqCore, comAdobeCqSocialCqSocialAsProvider, comAdobeCqSocialCqSocialBadgingBasicImpl, comAdobeCqSocialCqSocialBadgingImpl, comAdobeCqSocialCqSocialCalendarImpl, comAdobeCqSocialCqSocialContentFragmentsImpl, comAdobeCqSocialCqSocialEnablementImpl, comAdobeCqSocialCqSocialGraphImpl, comAdobeCqSocialCqSocialIdeationImpl, comAdobeCqSocialCqSocialJcrProvider, comAdobeCqSocialCqSocialMembersImpl, comAdobeCqSocialCqSocialMsProvider, comAdobeCqSocialCqSocialNotificationsChannelsWeb, comAdobeCqSocialCqSocialNotificationsImpl, comAdobeCqSocialCqSocialRdbProvider, comAdobeCqSocialCqSocialScfImpl, comAdobeCqSocialCqSocialScoringBasicImpl, comAdobeCqSocialCqSocialScoringImpl, comAdobeCqSocialCqSocialServiceusersImpl, comAdobeCqSocialCqSocialSrpImpl, comAdobeCqSocialCqSocialUgcbaseImpl, comAdobeDamCqDamCfmImpl, comAdobeFormsFoundationFormsFoundationBase, comAdobeGraniteApicontroller, comAdobeGraniteAssetCore, comAdobeGraniteAuthSso, comAdobeGraniteBundlesHcImpl, comAdobeGraniteCompatRouter, comAdobeGraniteConf, comAdobeGraniteConfUiCore, comAdobeGraniteCors, comAdobeGraniteCrxExplorer, comAdobeGraniteCrxdeLite, comAdobeGraniteCryptoConfig, comAdobeGraniteCryptoExtension, comAdobeGraniteCryptoFile, comAdobeGraniteCryptoJcr, comAdobeGraniteCsrf, comAdobeGraniteDistributionCore, comAdobeGraniteDropwizardMetrics, comAdobeGraniteFragsImpl, comAdobeGraniteGibson, comAdobeGraniteInfocollector, comAdobeGraniteInstallerFactoryPackages, comAdobeGraniteJettySsl, comAdobeGraniteJobsAsync, comAdobeGraniteMaintenanceOak, comAdobeGraniteMonitoringCore, comAdobeGraniteQueries, comAdobeGraniteReplicationHcImpl, comAdobeGraniteRepositoryChecker, comAdobeGraniteRepositoryHcImpl, comAdobeGraniteRestAssets, comAdobeGraniteSecurityUi, comAdobeGraniteStartup, comAdobeGraniteTagsoup, comAdobeGraniteTaskmanagementCore, comAdobeGraniteTaskmanagementWorkflow, comAdobeGraniteUiClientlibsCompilerLess, comAdobeGraniteUiClientlibsProcessorGcc, comAdobeGraniteWebconsolePlugins, comAdobeGraniteWorkflowConsole, comAdobeXmpWorkerFilesNativeFragmentLinux, comAdobeXmpWorkerFilesNativeFragmentMacosx, comAdobeXmpWorkerFilesNativeFragmentWin, comDayCommonsOsgiWrapperSimpleJndi, comDayCqCqAuthhandler, comDayCqCqCompatConfigupdate, comDayCqCqLicensebranding, comDayCqCqNotifcationImpl, comDayCqCqReplicationAudit, comDayCqCqSearchExt, comDayCqDamCqDamAnnotationPrint, comDayCqDamCqDamAssetUsage, comDayCqDamCqDamS7dam, comDayCqDamCqDamSimilaritysearch, comDayCqDamDamWebdavSupport, comDayCqPreUpgradeTasks, comDayCqReplicationExtensions, comDayCqWcmCqMsmCore, comDayCqWcmCqWcmTranslation, dayCommonsJrawio, orgApacheAriesJmxWhiteboard, orgApacheFelixHttpSslfilter, orgApacheFelixOrgApacheFelixThreaddump, orgApacheFelixWebconsolePluginsDs, orgApacheFelixWebconsolePluginsEvent, orgApacheFelixWebconsolePluginsMemoryusage, orgApacheFelixWebconsolePluginsPackageadmin, orgApacheJackrabbitOakAuthLdap, orgApacheJackrabbitOakSegmentTar, orgApacheJackrabbitOakSolrOsgi, orgApacheSlingBundleresourceImpl, orgApacheSlingCommonsFsclassloader, orgApacheSlingCommonsLogWebconsole, orgApacheSlingDatasource, orgApacheSlingDiscoveryBase, orgApacheSlingDiscoveryOak, orgApacheSlingDiscoverySupport, orgApacheSlingDistributionApi, orgApacheSlingDistributionCore, orgApacheSlingExtensionsWebconsolesecurityprovider, orgApacheSlingHcWebconsole, orgApacheSlingInstallerConsole, orgApacheSlingInstallerProviderFile, orgApacheSlingInstallerProviderJcr, orgApacheSlingJcrDavex, orgApacheSlingJcrResourcesecurity, orgApacheSlingJmxProvider, orgApacheSlingLaunchpadInstaller, orgApacheSlingModelsImpl, orgApacheSlingRepoinitParser, orgApacheSlingResourceInventory, orgApacheSlingResourceresolver, orgApacheSlingScriptingJavascript, orgApacheSlingScriptingJst, orgApacheSlingScriptingSightlyJsProvider, orgApacheSlingScriptingSightlyModelsProvider, orgApacheSlingSecurity, orgApacheSlingServletsCompat, orgApacheSlingServletsGet, orgApacheSlingStartupfilterDisabler, orgApacheSlingTracer, weRetailClientAppCore)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param serviceRanking  (optional)
   * @return ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo
   */
  def comAdobeGraniteAuthCertImplClientCertAuthHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, serviceRanking: Option[Integer] = None): Option[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthCertImplClientCertAuthHandlerAsync(post, apply, delete, action, location, propertylist, `path`, serviceRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param serviceRanking  (optional)
   * @return Future(ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo)
   */
  def comAdobeGraniteAuthCertImplClientCertAuthHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, serviceRanking: Option[Integer] = None): Future[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo] = {
      helper.comAdobeGraniteAuthCertImplClientCertAuthHandler(post, apply, delete, action, location, propertylist, `path`, serviceRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param configid  (optional)
   * @param scope  (optional)
   * @return ComAdobeGraniteAuthImsInfo
   */
  def comAdobeGraniteAuthIms(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, configid: Option[String] = None, scope: Option[String] = None): Option[ComAdobeGraniteAuthImsInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthImsAsync(post, apply, delete, action, location, propertylist, configid, scope), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param configid  (optional)
   * @param scope  (optional)
   * @return Future(ComAdobeGraniteAuthImsInfo)
   */
  def comAdobeGraniteAuthImsAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, configid: Option[String] = None, scope: Option[String] = None): Future[ComAdobeGraniteAuthImsInfo] = {
      helper.comAdobeGraniteAuthIms(post, apply, delete, action, location, propertylist, configid, scope)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @return ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo
   */
  def comAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtension(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None): Option[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionAsync(post, apply, delete, action, location, propertylist, oauthProviderId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @return Future(ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo)
   */
  def comAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None): Future[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo] = {
      helper.comAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtension(post, apply, delete, action, location, propertylist, oauthProviderId)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param authImsClientSecret  (optional)
   * @param customizerType  (optional)
   * @return ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo
   */
  def comAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, authImsClientSecret: Option[String] = None, customizerType: Option[String] = None): Option[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplAsync(post, apply, delete, action, location, propertylist, authImsClientSecret, customizerType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param authImsClientSecret  (optional)
   * @param customizerType  (optional)
   * @return Future(ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo)
   */
  def comAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, authImsClientSecret: Option[String] = None, customizerType: Option[String] = None): Future[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo] = {
      helper.comAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImpl(post, apply, delete, action, location, propertylist, authImsClientSecret, customizerType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @return ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo
   */
  def comAdobeGraniteAuthImsImplIMSInstanceCredentialsValidator(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None): Option[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorAsync(post, apply, delete, action, location, propertylist, oauthProviderId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @return Future(ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo)
   */
  def comAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None): Future[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo] = {
      helper.comAdobeGraniteAuthImsImplIMSInstanceCredentialsValidator(post, apply, delete, action, location, propertylist, oauthProviderId)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @param oauthProviderImsAuthorizationUrl  (optional)
   * @param oauthProviderImsTokenUrl  (optional)
   * @param oauthProviderImsProfileUrl  (optional)
   * @param oauthProviderImsExtendedDetailsUrls  (optional)
   * @param oauthProviderImsValidateTokenUrl  (optional)
   * @param oauthProviderImsSessionProperty  (optional)
   * @param oauthProviderImsServiceTokenClientId  (optional)
   * @param oauthProviderImsServiceTokenClientSecret  (optional)
   * @param oauthProviderImsServiceToken  (optional)
   * @param imsOrgRef  (optional)
   * @param imsGroupMapping  (optional)
   * @param oauthProviderImsOnlyLicenseGroup  (optional)
   * @return ComAdobeGraniteAuthImsImplIMSProviderImplInfo
   */
  def comAdobeGraniteAuthImsImplIMSProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None, oauthProviderImsAuthorizationUrl: Option[String] = None, oauthProviderImsTokenUrl: Option[String] = None, oauthProviderImsProfileUrl: Option[String] = None, oauthProviderImsExtendedDetailsUrls: Option[List[String]] = None, oauthProviderImsValidateTokenUrl: Option[String] = None, oauthProviderImsSessionProperty: Option[String] = None, oauthProviderImsServiceTokenClientId: Option[String] = None, oauthProviderImsServiceTokenClientSecret: Option[String] = None, oauthProviderImsServiceToken: Option[String] = None, imsOrgRef: Option[String] = None, imsGroupMapping: Option[List[String]] = None, oauthProviderImsOnlyLicenseGroup: Option[Boolean] = None): Option[ComAdobeGraniteAuthImsImplIMSProviderImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthImsImplIMSProviderImplAsync(post, apply, delete, action, location, propertylist, oauthProviderId, oauthProviderImsAuthorizationUrl, oauthProviderImsTokenUrl, oauthProviderImsProfileUrl, oauthProviderImsExtendedDetailsUrls, oauthProviderImsValidateTokenUrl, oauthProviderImsSessionProperty, oauthProviderImsServiceTokenClientId, oauthProviderImsServiceTokenClientSecret, oauthProviderImsServiceToken, imsOrgRef, imsGroupMapping, oauthProviderImsOnlyLicenseGroup), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @param oauthProviderImsAuthorizationUrl  (optional)
   * @param oauthProviderImsTokenUrl  (optional)
   * @param oauthProviderImsProfileUrl  (optional)
   * @param oauthProviderImsExtendedDetailsUrls  (optional)
   * @param oauthProviderImsValidateTokenUrl  (optional)
   * @param oauthProviderImsSessionProperty  (optional)
   * @param oauthProviderImsServiceTokenClientId  (optional)
   * @param oauthProviderImsServiceTokenClientSecret  (optional)
   * @param oauthProviderImsServiceToken  (optional)
   * @param imsOrgRef  (optional)
   * @param imsGroupMapping  (optional)
   * @param oauthProviderImsOnlyLicenseGroup  (optional)
   * @return Future(ComAdobeGraniteAuthImsImplIMSProviderImplInfo)
   */
  def comAdobeGraniteAuthImsImplIMSProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None, oauthProviderImsAuthorizationUrl: Option[String] = None, oauthProviderImsTokenUrl: Option[String] = None, oauthProviderImsProfileUrl: Option[String] = None, oauthProviderImsExtendedDetailsUrls: Option[List[String]] = None, oauthProviderImsValidateTokenUrl: Option[String] = None, oauthProviderImsSessionProperty: Option[String] = None, oauthProviderImsServiceTokenClientId: Option[String] = None, oauthProviderImsServiceTokenClientSecret: Option[String] = None, oauthProviderImsServiceToken: Option[String] = None, imsOrgRef: Option[String] = None, imsGroupMapping: Option[List[String]] = None, oauthProviderImsOnlyLicenseGroup: Option[Boolean] = None): Future[ComAdobeGraniteAuthImsImplIMSProviderImplInfo] = {
      helper.comAdobeGraniteAuthImsImplIMSProviderImpl(post, apply, delete, action, location, propertylist, oauthProviderId, oauthProviderImsAuthorizationUrl, oauthProviderImsTokenUrl, oauthProviderImsProfileUrl, oauthProviderImsExtendedDetailsUrls, oauthProviderImsValidateTokenUrl, oauthProviderImsSessionProperty, oauthProviderImsServiceTokenClientId, oauthProviderImsServiceTokenClientSecret, oauthProviderImsServiceToken, imsOrgRef, imsGroupMapping, oauthProviderImsOnlyLicenseGroup)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthConfigmanagerImsConfigid  (optional)
   * @param imsOwningEntity  (optional)
   * @param aemInstanceId  (optional)
   * @param imsServiceCode  (optional)
   * @return ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo
   */
  def comAdobeGraniteAuthImsImplImsConfigProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthConfigmanagerImsConfigid: Option[String] = None, imsOwningEntity: Option[String] = None, aemInstanceId: Option[String] = None, imsServiceCode: Option[String] = None): Option[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthImsImplImsConfigProviderImplAsync(post, apply, delete, action, location, propertylist, oauthConfigmanagerImsConfigid, imsOwningEntity, aemInstanceId, imsServiceCode), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthConfigmanagerImsConfigid  (optional)
   * @param imsOwningEntity  (optional)
   * @param aemInstanceId  (optional)
   * @param imsServiceCode  (optional)
   * @return Future(ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo)
   */
  def comAdobeGraniteAuthImsImplImsConfigProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthConfigmanagerImsConfigid: Option[String] = None, imsOwningEntity: Option[String] = None, aemInstanceId: Option[String] = None, imsServiceCode: Option[String] = None): Future[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo] = {
      helper.comAdobeGraniteAuthImsImplImsConfigProviderImpl(post, apply, delete, action, location, propertylist, oauthConfigmanagerImsConfigid, imsOwningEntity, aemInstanceId, imsServiceCode)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param authTokenProviderTitle  (optional)
   * @param authTokenProviderDefaultClaims  (optional)
   * @param authTokenProviderEndpoint  (optional)
   * @param authAccessTokenRequest  (optional)
   * @param authTokenProviderKeypairAlias  (optional)
   * @param authTokenProviderConnTimeout  (optional)
   * @param authTokenProviderSoTimeout  (optional)
   * @param authTokenProviderClientId  (optional)
   * @param authTokenProviderScope  (optional)
   * @param authTokenProviderReuseAccessToken  (optional)
   * @param authTokenProviderRelaxedSsl  (optional)
   * @param tokenRequestCustomizerType  (optional)
   * @param authTokenValidatorType  (optional)
   * @return ComAdobeGraniteAuthOauthAccesstokenProviderInfo
   */
  def comAdobeGraniteAuthOauthAccesstokenProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, authTokenProviderTitle: Option[String] = None, authTokenProviderDefaultClaims: Option[List[String]] = None, authTokenProviderEndpoint: Option[String] = None, authAccessTokenRequest: Option[String] = None, authTokenProviderKeypairAlias: Option[String] = None, authTokenProviderConnTimeout: Option[Integer] = None, authTokenProviderSoTimeout: Option[Integer] = None, authTokenProviderClientId: Option[String] = None, authTokenProviderScope: Option[String] = None, authTokenProviderReuseAccessToken: Option[Boolean] = None, authTokenProviderRelaxedSsl: Option[Boolean] = None, tokenRequestCustomizerType: Option[String] = None, authTokenValidatorType: Option[String] = None): Option[ComAdobeGraniteAuthOauthAccesstokenProviderInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthAccesstokenProviderAsync(post, apply, delete, action, location, propertylist, name, authTokenProviderTitle, authTokenProviderDefaultClaims, authTokenProviderEndpoint, authAccessTokenRequest, authTokenProviderKeypairAlias, authTokenProviderConnTimeout, authTokenProviderSoTimeout, authTokenProviderClientId, authTokenProviderScope, authTokenProviderReuseAccessToken, authTokenProviderRelaxedSsl, tokenRequestCustomizerType, authTokenValidatorType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param authTokenProviderTitle  (optional)
   * @param authTokenProviderDefaultClaims  (optional)
   * @param authTokenProviderEndpoint  (optional)
   * @param authAccessTokenRequest  (optional)
   * @param authTokenProviderKeypairAlias  (optional)
   * @param authTokenProviderConnTimeout  (optional)
   * @param authTokenProviderSoTimeout  (optional)
   * @param authTokenProviderClientId  (optional)
   * @param authTokenProviderScope  (optional)
   * @param authTokenProviderReuseAccessToken  (optional)
   * @param authTokenProviderRelaxedSsl  (optional)
   * @param tokenRequestCustomizerType  (optional)
   * @param authTokenValidatorType  (optional)
   * @return Future(ComAdobeGraniteAuthOauthAccesstokenProviderInfo)
   */
  def comAdobeGraniteAuthOauthAccesstokenProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, authTokenProviderTitle: Option[String] = None, authTokenProviderDefaultClaims: Option[List[String]] = None, authTokenProviderEndpoint: Option[String] = None, authAccessTokenRequest: Option[String] = None, authTokenProviderKeypairAlias: Option[String] = None, authTokenProviderConnTimeout: Option[Integer] = None, authTokenProviderSoTimeout: Option[Integer] = None, authTokenProviderClientId: Option[String] = None, authTokenProviderScope: Option[String] = None, authTokenProviderReuseAccessToken: Option[Boolean] = None, authTokenProviderRelaxedSsl: Option[Boolean] = None, tokenRequestCustomizerType: Option[String] = None, authTokenValidatorType: Option[String] = None): Future[ComAdobeGraniteAuthOauthAccesstokenProviderInfo] = {
      helper.comAdobeGraniteAuthOauthAccesstokenProvider(post, apply, delete, action, location, propertylist, name, authTokenProviderTitle, authTokenProviderDefaultClaims, authTokenProviderEndpoint, authAccessTokenRequest, authTokenProviderKeypairAlias, authTokenProviderConnTimeout, authTokenProviderSoTimeout, authTokenProviderClientId, authTokenProviderScope, authTokenProviderReuseAccessToken, authTokenProviderRelaxedSsl, tokenRequestCustomizerType, authTokenValidatorType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param oauthClientIdsAllowed  (optional)
   * @param authBearerSyncIms  (optional)
   * @param authTokenRequestParameter  (optional)
   * @param oauthBearerConfigid  (optional)
   * @param oauthJwtSupport  (optional)
   * @return ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo
   */
  def comAdobeGraniteAuthOauthImplBearerAuthenticationHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, oauthClientIdsAllowed: Option[List[String]] = None, authBearerSyncIms: Option[Boolean] = None, authTokenRequestParameter: Option[String] = None, oauthBearerConfigid: Option[String] = None, oauthJwtSupport: Option[Boolean] = None): Option[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthImplBearerAuthenticationHandlerAsync(post, apply, delete, action, location, propertylist, `path`, oauthClientIdsAllowed, authBearerSyncIms, authTokenRequestParameter, oauthBearerConfigid, oauthJwtSupport), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param oauthClientIdsAllowed  (optional)
   * @param authBearerSyncIms  (optional)
   * @param authTokenRequestParameter  (optional)
   * @param oauthBearerConfigid  (optional)
   * @param oauthJwtSupport  (optional)
   * @return Future(ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo)
   */
  def comAdobeGraniteAuthOauthImplBearerAuthenticationHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, oauthClientIdsAllowed: Option[List[String]] = None, authBearerSyncIms: Option[Boolean] = None, authTokenRequestParameter: Option[String] = None, oauthBearerConfigid: Option[String] = None, oauthJwtSupport: Option[Boolean] = None): Future[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo] = {
      helper.comAdobeGraniteAuthOauthImplBearerAuthenticationHandler(post, apply, delete, action, location, propertylist, `path`, oauthClientIdsAllowed, authBearerSyncIms, authTokenRequestParameter, oauthBearerConfigid, oauthJwtSupport)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param authTokenValidatorType  (optional)
   * @return ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo
   */
  def comAdobeGraniteAuthOauthImplDefaultTokenValidatorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, authTokenValidatorType: Option[String] = None): Option[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthImplDefaultTokenValidatorImplAsync(post, apply, delete, action, location, propertylist, authTokenValidatorType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param authTokenValidatorType  (optional)
   * @return Future(ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo)
   */
  def comAdobeGraniteAuthOauthImplDefaultTokenValidatorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, authTokenValidatorType: Option[String] = None): Future[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo] = {
      helper.comAdobeGraniteAuthOauthImplDefaultTokenValidatorImpl(post, apply, delete, action, location, propertylist, authTokenValidatorType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @return ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo
   */
  def comAdobeGraniteAuthOauthImplFacebookProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None): Option[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthImplFacebookProviderImplAsync(post, apply, delete, action, location, propertylist, oauthProviderId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @return Future(ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo)
   */
  def comAdobeGraniteAuthOauthImplFacebookProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None): Future[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo] = {
      helper.comAdobeGraniteAuthOauthImplFacebookProviderImpl(post, apply, delete, action, location, propertylist, oauthProviderId)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @param oauthProviderGithubAuthorizationUrl  (optional)
   * @param oauthProviderGithubTokenUrl  (optional)
   * @param oauthProviderGithubProfileUrl  (optional)
   * @return ComAdobeGraniteAuthOauthImplGithubProviderImplInfo
   */
  def comAdobeGraniteAuthOauthImplGithubProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None, oauthProviderGithubAuthorizationUrl: Option[String] = None, oauthProviderGithubTokenUrl: Option[String] = None, oauthProviderGithubProfileUrl: Option[String] = None): Option[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthImplGithubProviderImplAsync(post, apply, delete, action, location, propertylist, oauthProviderId, oauthProviderGithubAuthorizationUrl, oauthProviderGithubTokenUrl, oauthProviderGithubProfileUrl), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @param oauthProviderGithubAuthorizationUrl  (optional)
   * @param oauthProviderGithubTokenUrl  (optional)
   * @param oauthProviderGithubProfileUrl  (optional)
   * @return Future(ComAdobeGraniteAuthOauthImplGithubProviderImplInfo)
   */
  def comAdobeGraniteAuthOauthImplGithubProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None, oauthProviderGithubAuthorizationUrl: Option[String] = None, oauthProviderGithubTokenUrl: Option[String] = None, oauthProviderGithubProfileUrl: Option[String] = None): Future[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo] = {
      helper.comAdobeGraniteAuthOauthImplGithubProviderImpl(post, apply, delete, action, location, propertylist, oauthProviderId, oauthProviderGithubAuthorizationUrl, oauthProviderGithubTokenUrl, oauthProviderGithubProfileUrl)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @param oauthProviderGraniteAuthorizationUrl  (optional)
   * @param oauthProviderGraniteTokenUrl  (optional)
   * @param oauthProviderGraniteProfileUrl  (optional)
   * @param oauthProviderGraniteExtendedDetailsUrls  (optional)
   * @return ComAdobeGraniteAuthOauthImplGraniteProviderInfo
   */
  def comAdobeGraniteAuthOauthImplGraniteProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None, oauthProviderGraniteAuthorizationUrl: Option[String] = None, oauthProviderGraniteTokenUrl: Option[String] = None, oauthProviderGraniteProfileUrl: Option[String] = None, oauthProviderGraniteExtendedDetailsUrls: Option[String] = None): Option[ComAdobeGraniteAuthOauthImplGraniteProviderInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthImplGraniteProviderAsync(post, apply, delete, action, location, propertylist, oauthProviderId, oauthProviderGraniteAuthorizationUrl, oauthProviderGraniteTokenUrl, oauthProviderGraniteProfileUrl, oauthProviderGraniteExtendedDetailsUrls), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @param oauthProviderGraniteAuthorizationUrl  (optional)
   * @param oauthProviderGraniteTokenUrl  (optional)
   * @param oauthProviderGraniteProfileUrl  (optional)
   * @param oauthProviderGraniteExtendedDetailsUrls  (optional)
   * @return Future(ComAdobeGraniteAuthOauthImplGraniteProviderInfo)
   */
  def comAdobeGraniteAuthOauthImplGraniteProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None, oauthProviderGraniteAuthorizationUrl: Option[String] = None, oauthProviderGraniteTokenUrl: Option[String] = None, oauthProviderGraniteProfileUrl: Option[String] = None, oauthProviderGraniteExtendedDetailsUrls: Option[String] = None): Future[ComAdobeGraniteAuthOauthImplGraniteProviderInfo] = {
      helper.comAdobeGraniteAuthOauthImplGraniteProvider(post, apply, delete, action, location, propertylist, oauthProviderId, oauthProviderGraniteAuthorizationUrl, oauthProviderGraniteTokenUrl, oauthProviderGraniteProfileUrl, oauthProviderGraniteExtendedDetailsUrls)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthCookieLoginTimeout  (optional)
   * @param oauthCookieMaxAge  (optional)
   * @return ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo
   */
  def comAdobeGraniteAuthOauthImplHelperProviderConfigManager(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthCookieLoginTimeout: Option[String] = None, oauthCookieMaxAge: Option[String] = None): Option[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthImplHelperProviderConfigManagerAsync(post, apply, delete, action, location, propertylist, oauthCookieLoginTimeout, oauthCookieMaxAge), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthCookieLoginTimeout  (optional)
   * @param oauthCookieMaxAge  (optional)
   * @return Future(ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo)
   */
  def comAdobeGraniteAuthOauthImplHelperProviderConfigManagerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthCookieLoginTimeout: Option[String] = None, oauthCookieMaxAge: Option[String] = None): Future[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo] = {
      helper.comAdobeGraniteAuthOauthImplHelperProviderConfigManager(post, apply, delete, action, location, propertylist, oauthCookieLoginTimeout, oauthCookieMaxAge)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthCookieLoginTimeout  (optional)
   * @param oauthCookieMaxAge  (optional)
   * @return ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo
   */
  def comAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternal(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthCookieLoginTimeout: Option[String] = None, oauthCookieMaxAge: Option[String] = None): Option[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalAsync(post, apply, delete, action, location, propertylist, oauthCookieLoginTimeout, oauthCookieMaxAge), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthCookieLoginTimeout  (optional)
   * @param oauthCookieMaxAge  (optional)
   * @return Future(ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo)
   */
  def comAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthCookieLoginTimeout: Option[String] = None, oauthCookieMaxAge: Option[String] = None): Future[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo] = {
      helper.comAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternal(post, apply, delete, action, location, propertylist, oauthCookieLoginTimeout, oauthCookieMaxAge)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @return ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo
   */
  def comAdobeGraniteAuthOauthImplOAuthAuthenticationHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None): Option[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerAsync(post, apply, delete, action, location, propertylist, `path`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @return Future(ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo)
   */
  def comAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None): Future[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo] = {
      helper.comAdobeGraniteAuthOauthImplOAuthAuthenticationHandler(post, apply, delete, action, location, propertylist, `path`)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @return ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo
   */
  def comAdobeGraniteAuthOauthImplTwitterProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None): Option[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthImplTwitterProviderImplAsync(post, apply, delete, action, location, propertylist, oauthProviderId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthProviderId  (optional)
   * @return Future(ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo)
   */
  def comAdobeGraniteAuthOauthImplTwitterProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthProviderId: Option[String] = None): Future[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo] = {
      helper.comAdobeGraniteAuthOauthImplTwitterProviderImpl(post, apply, delete, action, location, propertylist, oauthProviderId)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthConfigId  (optional)
   * @param oauthClientId  (optional)
   * @param oauthClientSecret  (optional)
   * @param oauthScope  (optional)
   * @param oauthConfigProviderId  (optional)
   * @param oauthCreateUsers  (optional)
   * @param oauthUseridProperty  (optional)
   * @param forceStrictUsernameMatching  (optional)
   * @param oauthEncodeUserids  (optional)
   * @param oauthHashUserids  (optional)
   * @param oauthCallBackUrl  (optional)
   * @param oauthAccessTokenPersist  (optional)
   * @param oauthAccessTokenPersistCookie  (optional)
   * @param oauthCsrfStateProtection  (optional)
   * @param oauthRedirectRequestParams  (optional)
   * @param oauthConfigSiblingsAllow  (optional)
   * @return ComAdobeGraniteAuthOauthProviderInfo
   */
  def comAdobeGraniteAuthOauthProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthConfigId: Option[String] = None, oauthClientId: Option[String] = None, oauthClientSecret: Option[String] = None, oauthScope: Option[List[String]] = None, oauthConfigProviderId: Option[String] = None, oauthCreateUsers: Option[Boolean] = None, oauthUseridProperty: Option[String] = None, forceStrictUsernameMatching: Option[Boolean] = None, oauthEncodeUserids: Option[Boolean] = None, oauthHashUserids: Option[Boolean] = None, oauthCallBackUrl: Option[String] = None, oauthAccessTokenPersist: Option[Boolean] = None, oauthAccessTokenPersistCookie: Option[Boolean] = None, oauthCsrfStateProtection: Option[Boolean] = None, oauthRedirectRequestParams: Option[Boolean] = None, oauthConfigSiblingsAllow: Option[Boolean] = None): Option[ComAdobeGraniteAuthOauthProviderInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthOauthProviderAsync(post, apply, delete, action, location, propertylist, oauthConfigId, oauthClientId, oauthClientSecret, oauthScope, oauthConfigProviderId, oauthCreateUsers, oauthUseridProperty, forceStrictUsernameMatching, oauthEncodeUserids, oauthHashUserids, oauthCallBackUrl, oauthAccessTokenPersist, oauthAccessTokenPersistCookie, oauthCsrfStateProtection, oauthRedirectRequestParams, oauthConfigSiblingsAllow), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthConfigId  (optional)
   * @param oauthClientId  (optional)
   * @param oauthClientSecret  (optional)
   * @param oauthScope  (optional)
   * @param oauthConfigProviderId  (optional)
   * @param oauthCreateUsers  (optional)
   * @param oauthUseridProperty  (optional)
   * @param forceStrictUsernameMatching  (optional)
   * @param oauthEncodeUserids  (optional)
   * @param oauthHashUserids  (optional)
   * @param oauthCallBackUrl  (optional)
   * @param oauthAccessTokenPersist  (optional)
   * @param oauthAccessTokenPersistCookie  (optional)
   * @param oauthCsrfStateProtection  (optional)
   * @param oauthRedirectRequestParams  (optional)
   * @param oauthConfigSiblingsAllow  (optional)
   * @return Future(ComAdobeGraniteAuthOauthProviderInfo)
   */
  def comAdobeGraniteAuthOauthProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthConfigId: Option[String] = None, oauthClientId: Option[String] = None, oauthClientSecret: Option[String] = None, oauthScope: Option[List[String]] = None, oauthConfigProviderId: Option[String] = None, oauthCreateUsers: Option[Boolean] = None, oauthUseridProperty: Option[String] = None, forceStrictUsernameMatching: Option[Boolean] = None, oauthEncodeUserids: Option[Boolean] = None, oauthHashUserids: Option[Boolean] = None, oauthCallBackUrl: Option[String] = None, oauthAccessTokenPersist: Option[Boolean] = None, oauthAccessTokenPersistCookie: Option[Boolean] = None, oauthCsrfStateProtection: Option[Boolean] = None, oauthRedirectRequestParams: Option[Boolean] = None, oauthConfigSiblingsAllow: Option[Boolean] = None): Future[ComAdobeGraniteAuthOauthProviderInfo] = {
      helper.comAdobeGraniteAuthOauthProvider(post, apply, delete, action, location, propertylist, oauthConfigId, oauthClientId, oauthClientSecret, oauthScope, oauthConfigProviderId, oauthCreateUsers, oauthUseridProperty, forceStrictUsernameMatching, oauthEncodeUserids, oauthHashUserids, oauthCallBackUrl, oauthAccessTokenPersist, oauthAccessTokenPersistCookie, oauthCsrfStateProtection, oauthRedirectRequestParams, oauthConfigSiblingsAllow)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param supportedPaths  (optional)
   * @return ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo
   */
  def comAdobeGraniteAuthRequirementImplDefaultRequirementHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, supportedPaths: Option[List[String]] = None): Option[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthRequirementImplDefaultRequirementHandlerAsync(post, apply, delete, action, location, propertylist, supportedPaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param supportedPaths  (optional)
   * @return Future(ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo)
   */
  def comAdobeGraniteAuthRequirementImplDefaultRequirementHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, supportedPaths: Option[List[String]] = None): Future[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo] = {
      helper.comAdobeGraniteAuthRequirementImplDefaultRequirementHandler(post, apply, delete, action, location, propertylist, supportedPaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param serviceRanking  (optional)
   * @param idpUrl  (optional)
   * @param idpCertAlias  (optional)
   * @param idpHttpRedirect  (optional)
   * @param serviceProviderEntityId  (optional)
   * @param assertionConsumerServiceURL  (optional)
   * @param spPrivateKeyAlias  (optional)
   * @param keyStorePassword  (optional)
   * @param defaultRedirectUrl  (optional)
   * @param userIDAttribute  (optional)
   * @param useEncryption  (optional)
   * @param createUser  (optional)
   * @param userIntermediatePath  (optional)
   * @param addGroupMemberships  (optional)
   * @param groupMembershipAttribute  (optional)
   * @param defaultGroups  (optional)
   * @param nameIdFormat  (optional)
   * @param synchronizeAttributes  (optional)
   * @param handleLogout  (optional)
   * @param logoutUrl  (optional)
   * @param clockTolerance  (optional)
   * @param digestMethod  (optional)
   * @param signatureMethod  (optional)
   * @param identitySyncType  (optional)
   * @param idpIdentifier  (optional)
   * @return ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo
   */
  def comAdobeGraniteAuthSamlSamlAuthenticationHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[List[String]] = None, serviceRanking: Option[Integer] = None, idpUrl: Option[String] = None, idpCertAlias: Option[String] = None, idpHttpRedirect: Option[Boolean] = None, serviceProviderEntityId: Option[String] = None, assertionConsumerServiceURL: Option[String] = None, spPrivateKeyAlias: Option[String] = None, keyStorePassword: Option[String] = None, defaultRedirectUrl: Option[String] = None, userIDAttribute: Option[String] = None, useEncryption: Option[Boolean] = None, createUser: Option[Boolean] = None, userIntermediatePath: Option[String] = None, addGroupMemberships: Option[Boolean] = None, groupMembershipAttribute: Option[String] = None, defaultGroups: Option[List[String]] = None, nameIdFormat: Option[String] = None, synchronizeAttributes: Option[List[String]] = None, handleLogout: Option[Boolean] = None, logoutUrl: Option[String] = None, clockTolerance: Option[Integer] = None, digestMethod: Option[String] = None, signatureMethod: Option[String] = None, identitySyncType: Option[String] = None, idpIdentifier: Option[String] = None): Option[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthSamlSamlAuthenticationHandlerAsync(post, apply, delete, action, location, propertylist, `path`, serviceRanking, idpUrl, idpCertAlias, idpHttpRedirect, serviceProviderEntityId, assertionConsumerServiceURL, spPrivateKeyAlias, keyStorePassword, defaultRedirectUrl, userIDAttribute, useEncryption, createUser, userIntermediatePath, addGroupMemberships, groupMembershipAttribute, defaultGroups, nameIdFormat, synchronizeAttributes, handleLogout, logoutUrl, clockTolerance, digestMethod, signatureMethod, identitySyncType, idpIdentifier), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param serviceRanking  (optional)
   * @param idpUrl  (optional)
   * @param idpCertAlias  (optional)
   * @param idpHttpRedirect  (optional)
   * @param serviceProviderEntityId  (optional)
   * @param assertionConsumerServiceURL  (optional)
   * @param spPrivateKeyAlias  (optional)
   * @param keyStorePassword  (optional)
   * @param defaultRedirectUrl  (optional)
   * @param userIDAttribute  (optional)
   * @param useEncryption  (optional)
   * @param createUser  (optional)
   * @param userIntermediatePath  (optional)
   * @param addGroupMemberships  (optional)
   * @param groupMembershipAttribute  (optional)
   * @param defaultGroups  (optional)
   * @param nameIdFormat  (optional)
   * @param synchronizeAttributes  (optional)
   * @param handleLogout  (optional)
   * @param logoutUrl  (optional)
   * @param clockTolerance  (optional)
   * @param digestMethod  (optional)
   * @param signatureMethod  (optional)
   * @param identitySyncType  (optional)
   * @param idpIdentifier  (optional)
   * @return Future(ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo)
   */
  def comAdobeGraniteAuthSamlSamlAuthenticationHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[List[String]] = None, serviceRanking: Option[Integer] = None, idpUrl: Option[String] = None, idpCertAlias: Option[String] = None, idpHttpRedirect: Option[Boolean] = None, serviceProviderEntityId: Option[String] = None, assertionConsumerServiceURL: Option[String] = None, spPrivateKeyAlias: Option[String] = None, keyStorePassword: Option[String] = None, defaultRedirectUrl: Option[String] = None, userIDAttribute: Option[String] = None, useEncryption: Option[Boolean] = None, createUser: Option[Boolean] = None, userIntermediatePath: Option[String] = None, addGroupMemberships: Option[Boolean] = None, groupMembershipAttribute: Option[String] = None, defaultGroups: Option[List[String]] = None, nameIdFormat: Option[String] = None, synchronizeAttributes: Option[List[String]] = None, handleLogout: Option[Boolean] = None, logoutUrl: Option[String] = None, clockTolerance: Option[Integer] = None, digestMethod: Option[String] = None, signatureMethod: Option[String] = None, identitySyncType: Option[String] = None, idpIdentifier: Option[String] = None): Future[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo] = {
      helper.comAdobeGraniteAuthSamlSamlAuthenticationHandler(post, apply, delete, action, location, propertylist, `path`, serviceRanking, idpUrl, idpCertAlias, idpHttpRedirect, serviceProviderEntityId, assertionConsumerServiceURL, spPrivateKeyAlias, keyStorePassword, defaultRedirectUrl, userIDAttribute, useEncryption, createUser, userIntermediatePath, addGroupMemberships, groupMembershipAttribute, defaultGroups, nameIdFormat, synchronizeAttributes, handleLogout, logoutUrl, clockTolerance, digestMethod, signatureMethod, identitySyncType, idpIdentifier)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param serviceRanking  (optional)
   * @param jaasControlFlag  (optional)
   * @param jaasRealmName  (optional)
   * @param jaasRanking  (optional)
   * @param headers  (optional)
   * @param cookies  (optional)
   * @param parameters  (optional)
   * @param usermap  (optional)
   * @param format  (optional)
   * @param trustedCredentialsAttribute  (optional)
   * @return ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo
   */
  def comAdobeGraniteAuthSsoImplSsoAuthenticationHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, serviceRanking: Option[Integer] = None, jaasControlFlag: Option[String] = None, jaasRealmName: Option[String] = None, jaasRanking: Option[Integer] = None, headers: Option[List[String]] = None, cookies: Option[List[String]] = None, parameters: Option[List[String]] = None, usermap: Option[List[String]] = None, format: Option[String] = None, trustedCredentialsAttribute: Option[String] = None): Option[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo] = {
    val await = Try(Await.result(comAdobeGraniteAuthSsoImplSsoAuthenticationHandlerAsync(post, apply, delete, action, location, propertylist, `path`, serviceRanking, jaasControlFlag, jaasRealmName, jaasRanking, headers, cookies, parameters, usermap, format, trustedCredentialsAttribute), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param serviceRanking  (optional)
   * @param jaasControlFlag  (optional)
   * @param jaasRealmName  (optional)
   * @param jaasRanking  (optional)
   * @param headers  (optional)
   * @param cookies  (optional)
   * @param parameters  (optional)
   * @param usermap  (optional)
   * @param format  (optional)
   * @param trustedCredentialsAttribute  (optional)
   * @return Future(ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo)
   */
  def comAdobeGraniteAuthSsoImplSsoAuthenticationHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, serviceRanking: Option[Integer] = None, jaasControlFlag: Option[String] = None, jaasRealmName: Option[String] = None, jaasRanking: Option[Integer] = None, headers: Option[List[String]] = None, cookies: Option[List[String]] = None, parameters: Option[List[String]] = None, usermap: Option[List[String]] = None, format: Option[String] = None, trustedCredentialsAttribute: Option[String] = None): Future[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo] = {
      helper.comAdobeGraniteAuthSsoImplSsoAuthenticationHandler(post, apply, delete, action, location, propertylist, `path`, serviceRanking, jaasControlFlag, jaasRealmName, jaasRanking, headers, cookies, parameters, usermap, format, trustedCredentialsAttribute)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param minimumCodeCacheSize  (optional)
   * @return ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo
   */
  def comAdobeGraniteBundlesHcImplCodeCacheHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, minimumCodeCacheSize: Option[Integer] = None): Option[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteBundlesHcImplCodeCacheHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags, minimumCodeCacheSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param minimumCodeCacheSize  (optional)
   * @return Future(ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo)
   */
  def comAdobeGraniteBundlesHcImplCodeCacheHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, minimumCodeCacheSize: Option[Integer] = None): Future[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo] = {
      helper.comAdobeGraniteBundlesHcImplCodeCacheHealthCheck(post, apply, delete, action, location, propertylist, hcTags, minimumCodeCacheSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo
   */
  def comAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo)
   */
  def comAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo] = {
      helper.comAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo
   */
  def comAdobeGraniteBundlesHcImplDavExBundleHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteBundlesHcImplDavExBundleHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo)
   */
  def comAdobeGraniteBundlesHcImplDavExBundleHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo] = {
      helper.comAdobeGraniteBundlesHcImplDavExBundleHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param ignoredBundles  (optional)
   * @return ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo
   */
  def comAdobeGraniteBundlesHcImplInactiveBundlesHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, ignoredBundles: Option[List[String]] = None): Option[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags, ignoredBundles), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param ignoredBundles  (optional)
   * @return Future(ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo)
   */
  def comAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, ignoredBundles: Option[List[String]] = None): Future[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo] = {
      helper.comAdobeGraniteBundlesHcImplInactiveBundlesHealthCheck(post, apply, delete, action, location, propertylist, hcTags, ignoredBundles)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param maxQueuedJobs  (optional)
   * @return ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo
   */
  def comAdobeGraniteBundlesHcImplJobsHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, maxQueuedJobs: Option[Integer] = None): Option[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteBundlesHcImplJobsHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags, maxQueuedJobs), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param maxQueuedJobs  (optional)
   * @return Future(ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo)
   */
  def comAdobeGraniteBundlesHcImplJobsHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, maxQueuedJobs: Option[Integer] = None): Future[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo] = {
      helper.comAdobeGraniteBundlesHcImplJobsHealthCheck(post, apply, delete, action, location, propertylist, hcTags, maxQueuedJobs)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo
   */
  def comAdobeGraniteBundlesHcImplSlingGetServletHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteBundlesHcImplSlingGetServletHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo)
   */
  def comAdobeGraniteBundlesHcImplSlingGetServletHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo] = {
      helper.comAdobeGraniteBundlesHcImplSlingGetServletHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo
   */
  def comAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo)
   */
  def comAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo] = {
      helper.comAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo
   */
  def comAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo)
   */
  def comAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo] = {
      helper.comAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo
   */
  def comAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo)
   */
  def comAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo] = {
      helper.comAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo
   */
  def comAdobeGraniteBundlesHcImplWebDavBundleHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteBundlesHcImplWebDavBundleHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo)
   */
  def comAdobeGraniteBundlesHcImplWebDavBundleHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo] = {
      helper.comAdobeGraniteBundlesHcImplWebDavBundleHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param replicateCommentResourceTypes  (optional)
   * @return ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo
   */
  def comAdobeGraniteCommentsInternalCommentReplicationContentFilterFac(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, replicateCommentResourceTypes: Option[List[String]] = None): Option[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo] = {
    val await = Try(Await.result(comAdobeGraniteCommentsInternalCommentReplicationContentFilterFacAsync(post, apply, delete, action, location, propertylist, replicateCommentResourceTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param replicateCommentResourceTypes  (optional)
   * @return Future(ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo)
   */
  def comAdobeGraniteCommentsInternalCommentReplicationContentFilterFacAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, replicateCommentResourceTypes: Option[List[String]] = None): Future[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo] = {
      helper.comAdobeGraniteCommentsInternalCommentReplicationContentFilterFac(post, apply, delete, action, location, propertylist, replicateCommentResourceTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param compatgroups  (optional)
   * @param enabled  (optional)
   * @return ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo
   */
  def comAdobeGraniteCompatrouterImplCompatSwitchingServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, compatgroups: Option[List[String]] = None, enabled: Option[Boolean] = None): Option[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteCompatrouterImplCompatSwitchingServiceImplAsync(post, apply, delete, action, location, propertylist, compatgroups, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param compatgroups  (optional)
   * @param enabled  (optional)
   * @return Future(ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo)
   */
  def comAdobeGraniteCompatrouterImplCompatSwitchingServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, compatgroups: Option[List[String]] = None, enabled: Option[Boolean] = None): Future[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo] = {
      helper.comAdobeGraniteCompatrouterImplCompatSwitchingServiceImpl(post, apply, delete, action, location, propertylist, compatgroups, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param id  (optional)
   * @param compatPath  (optional)
   * @param newPath  (optional)
   * @return ComAdobeGraniteCompatrouterImplRoutingConfigInfo
   */
  def comAdobeGraniteCompatrouterImplRoutingConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, id: Option[String] = None, compatPath: Option[String] = None, newPath: Option[String] = None): Option[ComAdobeGraniteCompatrouterImplRoutingConfigInfo] = {
    val await = Try(Await.result(comAdobeGraniteCompatrouterImplRoutingConfigAsync(post, apply, delete, action, location, propertylist, id, compatPath, newPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param id  (optional)
   * @param compatPath  (optional)
   * @param newPath  (optional)
   * @return Future(ComAdobeGraniteCompatrouterImplRoutingConfigInfo)
   */
  def comAdobeGraniteCompatrouterImplRoutingConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, id: Option[String] = None, compatPath: Option[String] = None, newPath: Option[String] = None): Future[ComAdobeGraniteCompatrouterImplRoutingConfigInfo] = {
      helper.comAdobeGraniteCompatrouterImplRoutingConfig(post, apply, delete, action, location, propertylist, id, compatPath, newPath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param group  (optional)
   * @param ids  (optional)
   * @return ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo
   */
  def comAdobeGraniteCompatrouterImplSwitchMappingConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, group: Option[String] = None, ids: Option[List[String]] = None): Option[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo] = {
    val await = Try(Await.result(comAdobeGraniteCompatrouterImplSwitchMappingConfigAsync(post, apply, delete, action, location, propertylist, group, ids), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param group  (optional)
   * @param ids  (optional)
   * @return Future(ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo)
   */
  def comAdobeGraniteCompatrouterImplSwitchMappingConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, group: Option[String] = None, ids: Option[List[String]] = None): Future[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo] = {
      helper.comAdobeGraniteCompatrouterImplSwitchMappingConfig(post, apply, delete, action, location, propertylist, group, ids)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param fallbackPaths  (optional)
   * @return ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo
   */
  def comAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolving(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, fallbackPaths: Option[List[String]] = None): Option[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo] = {
    val await = Try(Await.result(comAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingAsync(post, apply, delete, action, location, propertylist, enabled, fallbackPaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param fallbackPaths  (optional)
   * @return Future(ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo)
   */
  def comAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, fallbackPaths: Option[List[String]] = None): Future[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo] = {
      helper.comAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolving(post, apply, delete, action, location, propertylist, enabled, fallbackPaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeGraniteContexthubSilentMode  (optional)
   * @param comAdobeGraniteContexthubShowUi  (optional)
   * @return ComAdobeGraniteContexthubImplContextHubImplInfo
   */
  def comAdobeGraniteContexthubImplContextHubImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeGraniteContexthubSilentMode: Option[Boolean] = None, comAdobeGraniteContexthubShowUi: Option[Boolean] = None): Option[ComAdobeGraniteContexthubImplContextHubImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteContexthubImplContextHubImplAsync(post, apply, delete, action, location, propertylist, comAdobeGraniteContexthubSilentMode, comAdobeGraniteContexthubShowUi), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeGraniteContexthubSilentMode  (optional)
   * @param comAdobeGraniteContexthubShowUi  (optional)
   * @return Future(ComAdobeGraniteContexthubImplContextHubImplInfo)
   */
  def comAdobeGraniteContexthubImplContextHubImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeGraniteContexthubSilentMode: Option[Boolean] = None, comAdobeGraniteContexthubShowUi: Option[Boolean] = None): Future[ComAdobeGraniteContexthubImplContextHubImplInfo] = {
      helper.comAdobeGraniteContexthubImplContextHubImpl(post, apply, delete, action, location, propertylist, comAdobeGraniteContexthubSilentMode, comAdobeGraniteContexthubShowUi)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param alloworigin  (optional)
   * @param alloworiginregexp  (optional)
   * @param allowedpaths  (optional)
   * @param exposedheaders  (optional)
   * @param maxage  (optional)
   * @param supportedheaders  (optional)
   * @param supportedmethods  (optional)
   * @param supportscredentials  (optional)
   * @return ComAdobeGraniteCorsImplCORSPolicyImplInfo
   */
  def comAdobeGraniteCorsImplCORSPolicyImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, alloworigin: Option[List[String]] = None, alloworiginregexp: Option[List[String]] = None, allowedpaths: Option[List[String]] = None, exposedheaders: Option[List[String]] = None, maxage: Option[Integer] = None, supportedheaders: Option[List[String]] = None, supportedmethods: Option[List[String]] = None, supportscredentials: Option[Boolean] = None): Option[ComAdobeGraniteCorsImplCORSPolicyImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteCorsImplCORSPolicyImplAsync(post, apply, delete, action, location, propertylist, alloworigin, alloworiginregexp, allowedpaths, exposedheaders, maxage, supportedheaders, supportedmethods, supportscredentials), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param alloworigin  (optional)
   * @param alloworiginregexp  (optional)
   * @param allowedpaths  (optional)
   * @param exposedheaders  (optional)
   * @param maxage  (optional)
   * @param supportedheaders  (optional)
   * @param supportedmethods  (optional)
   * @param supportscredentials  (optional)
   * @return Future(ComAdobeGraniteCorsImplCORSPolicyImplInfo)
   */
  def comAdobeGraniteCorsImplCORSPolicyImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, alloworigin: Option[List[String]] = None, alloworiginregexp: Option[List[String]] = None, allowedpaths: Option[List[String]] = None, exposedheaders: Option[List[String]] = None, maxage: Option[Integer] = None, supportedheaders: Option[List[String]] = None, supportedmethods: Option[List[String]] = None, supportscredentials: Option[Boolean] = None): Future[ComAdobeGraniteCorsImplCORSPolicyImplInfo] = {
      helper.comAdobeGraniteCorsImplCORSPolicyImpl(post, apply, delete, action, location, propertylist, alloworigin, alloworiginregexp, allowedpaths, exposedheaders, maxage, supportedheaders, supportedmethods, supportscredentials)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param filterMethods  (optional)
   * @param filterEnableSafeUserAgents  (optional)
   * @param filterSafeUserAgents  (optional)
   * @param filterExcludedPaths  (optional)
   * @return ComAdobeGraniteCsrfImplCSRFFilterInfo
   */
  def comAdobeGraniteCsrfImplCSRFFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, filterMethods: Option[List[String]] = None, filterEnableSafeUserAgents: Option[Boolean] = None, filterSafeUserAgents: Option[List[String]] = None, filterExcludedPaths: Option[List[String]] = None): Option[ComAdobeGraniteCsrfImplCSRFFilterInfo] = {
    val await = Try(Await.result(comAdobeGraniteCsrfImplCSRFFilterAsync(post, apply, delete, action, location, propertylist, filterMethods, filterEnableSafeUserAgents, filterSafeUserAgents, filterExcludedPaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param filterMethods  (optional)
   * @param filterEnableSafeUserAgents  (optional)
   * @param filterSafeUserAgents  (optional)
   * @param filterExcludedPaths  (optional)
   * @return Future(ComAdobeGraniteCsrfImplCSRFFilterInfo)
   */
  def comAdobeGraniteCsrfImplCSRFFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, filterMethods: Option[List[String]] = None, filterEnableSafeUserAgents: Option[Boolean] = None, filterSafeUserAgents: Option[List[String]] = None, filterExcludedPaths: Option[List[String]] = None): Future[ComAdobeGraniteCsrfImplCSRFFilterInfo] = {
      helper.comAdobeGraniteCsrfImplCSRFFilter(post, apply, delete, action, location, propertylist, filterMethods, filterEnableSafeUserAgents, filterSafeUserAgents, filterExcludedPaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param csrfTokenExpiresIn  (optional)
   * @param slingAuthRequirements  (optional)
   * @return ComAdobeGraniteCsrfImplCSRFServletInfo
   */
  def comAdobeGraniteCsrfImplCSRFServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, csrfTokenExpiresIn: Option[Integer] = None, slingAuthRequirements: Option[String] = None): Option[ComAdobeGraniteCsrfImplCSRFServletInfo] = {
    val await = Try(Await.result(comAdobeGraniteCsrfImplCSRFServletAsync(post, apply, delete, action, location, propertylist, csrfTokenExpiresIn, slingAuthRequirements), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param csrfTokenExpiresIn  (optional)
   * @param slingAuthRequirements  (optional)
   * @return Future(ComAdobeGraniteCsrfImplCSRFServletInfo)
   */
  def comAdobeGraniteCsrfImplCSRFServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, csrfTokenExpiresIn: Option[Integer] = None, slingAuthRequirements: Option[String] = None): Future[ComAdobeGraniteCsrfImplCSRFServletInfo] = {
      helper.comAdobeGraniteCsrfImplCSRFServlet(post, apply, delete, action, location, propertylist, csrfTokenExpiresIn, slingAuthRequirements)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param username  (optional)
   * @param encryptedPassword  (optional)
   * @return ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo
   */
  def comAdobeGraniteDistributionCoreImplCryptoDistributionTransportSe(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, username: Option[String] = None, encryptedPassword: Option[String] = None): Option[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo] = {
    val await = Try(Await.result(comAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeAsync(post, apply, delete, action, location, propertylist, name, username, encryptedPassword), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param username  (optional)
   * @param encryptedPassword  (optional)
   * @return Future(ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo)
   */
  def comAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, username: Option[String] = None, encryptedPassword: Option[String] = None): Future[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo] = {
      helper.comAdobeGraniteDistributionCoreImplCryptoDistributionTransportSe(post, apply, delete, action, location, propertylist, name, username, encryptedPassword)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param agentName  (optional)
   * @param diffPath  (optional)
   * @param observedPath  (optional)
   * @param serviceName  (optional)
   * @param propertyNames  (optional)
   * @param distributionDelay  (optional)
   * @param serviceUserTarget  (optional)
   * @return ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo
   */
  def comAdobeGraniteDistributionCoreImplDiffDiffChangesObserver(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, agentName: Option[String] = None, diffPath: Option[String] = None, observedPath: Option[String] = None, serviceName: Option[String] = None, propertyNames: Option[String] = None, distributionDelay: Option[Integer] = None, serviceUserTarget: Option[String] = None): Option[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo] = {
    val await = Try(Await.result(comAdobeGraniteDistributionCoreImplDiffDiffChangesObserverAsync(post, apply, delete, action, location, propertylist, enabled, agentName, diffPath, observedPath, serviceName, propertyNames, distributionDelay, serviceUserTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param agentName  (optional)
   * @param diffPath  (optional)
   * @param observedPath  (optional)
   * @param serviceName  (optional)
   * @param propertyNames  (optional)
   * @param distributionDelay  (optional)
   * @param serviceUserTarget  (optional)
   * @return Future(ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo)
   */
  def comAdobeGraniteDistributionCoreImplDiffDiffChangesObserverAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, agentName: Option[String] = None, diffPath: Option[String] = None, observedPath: Option[String] = None, serviceName: Option[String] = None, propertyNames: Option[String] = None, distributionDelay: Option[Integer] = None, serviceUserTarget: Option[String] = None): Future[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo] = {
      helper.comAdobeGraniteDistributionCoreImplDiffDiffChangesObserver(post, apply, delete, action, location, propertylist, enabled, agentName, diffPath, observedPath, serviceName, propertyNames, distributionDelay, serviceUserTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param diffPath  (optional)
   * @param serviceName  (optional)
   * @param serviceUserTarget  (optional)
   * @return ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo
   */
  def comAdobeGraniteDistributionCoreImplDiffDiffEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, diffPath: Option[String] = None, serviceName: Option[String] = None, serviceUserTarget: Option[String] = None): Option[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo] = {
    val await = Try(Await.result(comAdobeGraniteDistributionCoreImplDiffDiffEventListenerAsync(post, apply, delete, action, location, propertylist, diffPath, serviceName, serviceUserTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param diffPath  (optional)
   * @param serviceName  (optional)
   * @param serviceUserTarget  (optional)
   * @return Future(ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo)
   */
  def comAdobeGraniteDistributionCoreImplDiffDiffEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, diffPath: Option[String] = None, serviceName: Option[String] = None, serviceUserTarget: Option[String] = None): Future[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo] = {
      helper.comAdobeGraniteDistributionCoreImplDiffDiffEventListener(post, apply, delete, action, location, propertylist, diffPath, serviceName, serviceUserTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param importerName  (optional)
   * @return ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo
   */
  def comAdobeGraniteDistributionCoreImplDistributionToReplicationEven(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, importerName: Option[List[String]] = None): Option[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo] = {
    val await = Try(Await.result(comAdobeGraniteDistributionCoreImplDistributionToReplicationEvenAsync(post, apply, delete, action, location, propertylist, importerName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param importerName  (optional)
   * @return Future(ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo)
   */
  def comAdobeGraniteDistributionCoreImplDistributionToReplicationEvenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, importerName: Option[List[String]] = None): Future[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo] = {
      helper.comAdobeGraniteDistributionCoreImplDistributionToReplicationEven(post, apply, delete, action, location, propertylist, importerName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerName  (optional)
   * @param forwardRequests  (optional)
   * @return ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo
   */
  def comAdobeGraniteDistributionCoreImplReplicationAdaptersReplicat(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerName: Option[String] = None, forwardRequests: Option[Boolean] = None): Option[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo] = {
    val await = Try(Await.result(comAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatAsync(post, apply, delete, action, location, propertylist, providerName, forwardRequests), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerName  (optional)
   * @param forwardRequests  (optional)
   * @return Future(ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo)
   */
  def comAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerName: Option[String] = None, forwardRequests: Option[Boolean] = None): Future[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo] = {
      helper.comAdobeGraniteDistributionCoreImplReplicationAdaptersReplicat(post, apply, delete, action, location, propertylist, providerName, forwardRequests)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param forwardRequests  (optional)
   * @return ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo
   */
  def comAdobeGraniteDistributionCoreImplReplicationDistributionTrans(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, forwardRequests: Option[Boolean] = None): Option[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo] = {
    val await = Try(Await.result(comAdobeGraniteDistributionCoreImplReplicationDistributionTransAsync(post, apply, delete, action, location, propertylist, forwardRequests), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param forwardRequests  (optional)
   * @return Future(ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo)
   */
  def comAdobeGraniteDistributionCoreImplReplicationDistributionTransAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, forwardRequests: Option[Boolean] = None): Future[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo] = {
      helper.comAdobeGraniteDistributionCoreImplReplicationDistributionTrans(post, apply, delete, action, location, propertylist, forwardRequests)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param serviceName  (optional)
   * @param userId  (optional)
   * @param accessTokenProviderTarget  (optional)
   * @return ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo
   */
  def comAdobeGraniteDistributionCoreImplTransportAccessTokenDistribu(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, serviceName: Option[String] = None, userId: Option[String] = None, accessTokenProviderTarget: Option[String] = None): Option[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo] = {
    val await = Try(Await.result(comAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuAsync(post, apply, delete, action, location, propertylist, name, serviceName, userId, accessTokenProviderTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param serviceName  (optional)
   * @param userId  (optional)
   * @param accessTokenProviderTarget  (optional)
   * @return Future(ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo)
   */
  def comAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, serviceName: Option[String] = None, userId: Option[String] = None, accessTokenProviderTarget: Option[String] = None): Future[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo] = {
      helper.comAdobeGraniteDistributionCoreImplTransportAccessTokenDistribu(post, apply, delete, action, location, propertylist, name, serviceName, userId, accessTokenProviderTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param featureName  (optional)
   * @param featureDescription  (optional)
   * @param httpHeaderName  (optional)
   * @param httpHeaderValuepattern  (optional)
   * @return ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo
   */
  def comAdobeGraniteFragsImplCheckHttpHeaderFlag(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, featureName: Option[String] = None, featureDescription: Option[String] = None, httpHeaderName: Option[String] = None, httpHeaderValuepattern: Option[String] = None): Option[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo] = {
    val await = Try(Await.result(comAdobeGraniteFragsImplCheckHttpHeaderFlagAsync(post, apply, delete, action, location, propertylist, featureName, featureDescription, httpHeaderName, httpHeaderValuepattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param featureName  (optional)
   * @param featureDescription  (optional)
   * @param httpHeaderName  (optional)
   * @param httpHeaderValuepattern  (optional)
   * @return Future(ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo)
   */
  def comAdobeGraniteFragsImplCheckHttpHeaderFlagAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, featureName: Option[String] = None, featureDescription: Option[String] = None, httpHeaderName: Option[String] = None, httpHeaderValuepattern: Option[String] = None): Future[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo] = {
      helper.comAdobeGraniteFragsImplCheckHttpHeaderFlag(post, apply, delete, action, location, propertylist, featureName, featureDescription, httpHeaderName, httpHeaderValuepattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param featureName  (optional)
   * @param featureDescription  (optional)
   * @param activePercentage  (optional)
   * @param cookieName  (optional)
   * @param cookieMaxAge  (optional)
   * @return ComAdobeGraniteFragsImplRandomFeatureInfo
   */
  def comAdobeGraniteFragsImplRandomFeature(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, featureName: Option[String] = None, featureDescription: Option[String] = None, activePercentage: Option[String] = None, cookieName: Option[String] = None, cookieMaxAge: Option[Integer] = None): Option[ComAdobeGraniteFragsImplRandomFeatureInfo] = {
    val await = Try(Await.result(comAdobeGraniteFragsImplRandomFeatureAsync(post, apply, delete, action, location, propertylist, featureName, featureDescription, activePercentage, cookieName, cookieMaxAge), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param featureName  (optional)
   * @param featureDescription  (optional)
   * @param activePercentage  (optional)
   * @param cookieName  (optional)
   * @param cookieMaxAge  (optional)
   * @return Future(ComAdobeGraniteFragsImplRandomFeatureInfo)
   */
  def comAdobeGraniteFragsImplRandomFeatureAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, featureName: Option[String] = None, featureDescription: Option[String] = None, activePercentage: Option[String] = None, cookieName: Option[String] = None, cookieMaxAge: Option[Integer] = None): Future[ComAdobeGraniteFragsImplRandomFeatureInfo] = {
      helper.comAdobeGraniteFragsImplRandomFeature(post, apply, delete, action, location, propertylist, featureName, featureDescription, activePercentage, cookieName, cookieMaxAge)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeGraniteHttpcacheFileDocumentRoot  (optional)
   * @param comAdobeGraniteHttpcacheFileIncludeHost  (optional)
   * @return ComAdobeGraniteHttpcacheFileFileCacheStoreInfo
   */
  def comAdobeGraniteHttpcacheFileFileCacheStore(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeGraniteHttpcacheFileDocumentRoot: Option[String] = None, comAdobeGraniteHttpcacheFileIncludeHost: Option[String] = None): Option[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo] = {
    val await = Try(Await.result(comAdobeGraniteHttpcacheFileFileCacheStoreAsync(post, apply, delete, action, location, propertylist, comAdobeGraniteHttpcacheFileDocumentRoot, comAdobeGraniteHttpcacheFileIncludeHost), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeGraniteHttpcacheFileDocumentRoot  (optional)
   * @param comAdobeGraniteHttpcacheFileIncludeHost  (optional)
   * @return Future(ComAdobeGraniteHttpcacheFileFileCacheStoreInfo)
   */
  def comAdobeGraniteHttpcacheFileFileCacheStoreAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeGraniteHttpcacheFileDocumentRoot: Option[String] = None, comAdobeGraniteHttpcacheFileIncludeHost: Option[String] = None): Future[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo] = {
      helper.comAdobeGraniteHttpcacheFileFileCacheStore(post, apply, delete, action, location, propertylist, comAdobeGraniteHttpcacheFileDocumentRoot, comAdobeGraniteHttpcacheFileIncludeHost)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeGraniteHttpcacheUrlPaths  (optional)
   * @return ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo
   */
  def comAdobeGraniteHttpcacheImplOuterCacheFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeGraniteHttpcacheUrlPaths: Option[List[String]] = None): Option[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo] = {
    val await = Try(Await.result(comAdobeGraniteHttpcacheImplOuterCacheFilterAsync(post, apply, delete, action, location, propertylist, comAdobeGraniteHttpcacheUrlPaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeGraniteHttpcacheUrlPaths  (optional)
   * @return Future(ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo)
   */
  def comAdobeGraniteHttpcacheImplOuterCacheFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeGraniteHttpcacheUrlPaths: Option[List[String]] = None): Future[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo] = {
      helper.comAdobeGraniteHttpcacheImplOuterCacheFilter(post, apply, delete, action, location, propertylist, comAdobeGraniteHttpcacheUrlPaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pseudoPatterns  (optional)
   * @return ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo
   */
  def comAdobeGraniteI18nImplBundlePseudoTranslations(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pseudoPatterns: Option[List[String]] = None): Option[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo] = {
    val await = Try(Await.result(comAdobeGraniteI18nImplBundlePseudoTranslationsAsync(post, apply, delete, action, location, propertylist, pseudoPatterns), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pseudoPatterns  (optional)
   * @return Future(ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo)
   */
  def comAdobeGraniteI18nImplBundlePseudoTranslationsAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pseudoPatterns: Option[List[String]] = None): Future[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo] = {
      helper.comAdobeGraniteI18nImplBundlePseudoTranslations(post, apply, delete, action, location, propertylist, pseudoPatterns)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param securityPreferencesName  (optional)
   * @return ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo
   */
  def comAdobeGraniteI18nImplPreferencesLocaleResolverService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, securityPreferencesName: Option[String] = None): Option[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo] = {
    val await = Try(Await.result(comAdobeGraniteI18nImplPreferencesLocaleResolverServiceAsync(post, apply, delete, action, location, propertylist, securityPreferencesName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param securityPreferencesName  (optional)
   * @return Future(ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo)
   */
  def comAdobeGraniteI18nImplPreferencesLocaleResolverServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, securityPreferencesName: Option[String] = None): Future[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo] = {
      helper.comAdobeGraniteI18nImplPreferencesLocaleResolverService(post, apply, delete, action, location, propertylist, securityPreferencesName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param graniteInfocollectorIncludeThreadDumps  (optional)
   * @param graniteInfocollectorIncludeHeapDump  (optional)
   * @return ComAdobeGraniteInfocollectorInfoCollectorInfo
   */
  def comAdobeGraniteInfocollectorInfoCollector(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, graniteInfocollectorIncludeThreadDumps: Option[Boolean] = None, graniteInfocollectorIncludeHeapDump: Option[Boolean] = None): Option[ComAdobeGraniteInfocollectorInfoCollectorInfo] = {
    val await = Try(Await.result(comAdobeGraniteInfocollectorInfoCollectorAsync(post, apply, delete, action, location, propertylist, graniteInfocollectorIncludeThreadDumps, graniteInfocollectorIncludeHeapDump), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param graniteInfocollectorIncludeThreadDumps  (optional)
   * @param graniteInfocollectorIncludeHeapDump  (optional)
   * @return Future(ComAdobeGraniteInfocollectorInfoCollectorInfo)
   */
  def comAdobeGraniteInfocollectorInfoCollectorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, graniteInfocollectorIncludeThreadDumps: Option[Boolean] = None, graniteInfocollectorIncludeHeapDump: Option[Boolean] = None): Future[ComAdobeGraniteInfocollectorInfoCollectorInfo] = {
      helper.comAdobeGraniteInfocollectorInfoCollector(post, apply, delete, action, location, propertylist, graniteInfocollectorIncludeThreadDumps, graniteInfocollectorIncludeHeapDump)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeGraniteJettySslPort  (optional)
   * @param comAdobeGraniteJettySslKeystoreUser  (optional)
   * @param comAdobeGraniteJettySslKeystorePassword  (optional)
   * @param comAdobeGraniteJettySslCiphersuitesExcluded  (optional)
   * @param comAdobeGraniteJettySslCiphersuitesIncluded  (optional)
   * @param comAdobeGraniteJettySslClientCertificate  (optional)
   * @return ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo
   */
  def comAdobeGraniteJettySslInternalGraniteSslConnectorFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeGraniteJettySslPort: Option[Integer] = None, comAdobeGraniteJettySslKeystoreUser: Option[String] = None, comAdobeGraniteJettySslKeystorePassword: Option[String] = None, comAdobeGraniteJettySslCiphersuitesExcluded: Option[List[String]] = None, comAdobeGraniteJettySslCiphersuitesIncluded: Option[List[String]] = None, comAdobeGraniteJettySslClientCertificate: Option[String] = None): Option[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo] = {
    val await = Try(Await.result(comAdobeGraniteJettySslInternalGraniteSslConnectorFactoryAsync(post, apply, delete, action, location, propertylist, comAdobeGraniteJettySslPort, comAdobeGraniteJettySslKeystoreUser, comAdobeGraniteJettySslKeystorePassword, comAdobeGraniteJettySslCiphersuitesExcluded, comAdobeGraniteJettySslCiphersuitesIncluded, comAdobeGraniteJettySslClientCertificate), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comAdobeGraniteJettySslPort  (optional)
   * @param comAdobeGraniteJettySslKeystoreUser  (optional)
   * @param comAdobeGraniteJettySslKeystorePassword  (optional)
   * @param comAdobeGraniteJettySslCiphersuitesExcluded  (optional)
   * @param comAdobeGraniteJettySslCiphersuitesIncluded  (optional)
   * @param comAdobeGraniteJettySslClientCertificate  (optional)
   * @return Future(ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo)
   */
  def comAdobeGraniteJettySslInternalGraniteSslConnectorFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comAdobeGraniteJettySslPort: Option[Integer] = None, comAdobeGraniteJettySslKeystoreUser: Option[String] = None, comAdobeGraniteJettySslKeystorePassword: Option[String] = None, comAdobeGraniteJettySslCiphersuitesExcluded: Option[List[String]] = None, comAdobeGraniteJettySslCiphersuitesIncluded: Option[List[String]] = None, comAdobeGraniteJettySslClientCertificate: Option[String] = None): Future[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo] = {
      helper.comAdobeGraniteJettySslInternalGraniteSslConnectorFactory(post, apply, delete, action, location, propertylist, comAdobeGraniteJettySslPort, comAdobeGraniteJettySslKeystoreUser, comAdobeGraniteJettySslKeystorePassword, comAdobeGraniteJettySslCiphersuitesExcluded, comAdobeGraniteJettySslCiphersuitesIncluded, comAdobeGraniteJettySslClientCertificate)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param checkInternval  (optional)
   * @param excludeIds  (optional)
   * @param encryptPing  (optional)
   * @return ComAdobeGraniteLicenseImplLicenseCheckFilterInfo
   */
  def comAdobeGraniteLicenseImplLicenseCheckFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, checkInternval: Option[Integer] = None, excludeIds: Option[List[String]] = None, encryptPing: Option[Boolean] = None): Option[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo] = {
    val await = Try(Await.result(comAdobeGraniteLicenseImplLicenseCheckFilterAsync(post, apply, delete, action, location, propertylist, checkInternval, excludeIds, encryptPing), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param checkInternval  (optional)
   * @param excludeIds  (optional)
   * @param encryptPing  (optional)
   * @return Future(ComAdobeGraniteLicenseImplLicenseCheckFilterInfo)
   */
  def comAdobeGraniteLicenseImplLicenseCheckFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, checkInternval: Option[Integer] = None, excludeIds: Option[List[String]] = None, encryptPing: Option[Boolean] = None): Future[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo] = {
      helper.comAdobeGraniteLicenseImplLicenseCheckFilter(post, apply, delete, action, location, propertylist, checkInternval, excludeIds, encryptPing)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param messagesQueueSize  (optional)
   * @param loggerConfig  (optional)
   * @param messagesSize  (optional)
   * @return ComAdobeGraniteLoggingImplLogAnalyserImplInfo
   */
  def comAdobeGraniteLoggingImplLogAnalyserImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, messagesQueueSize: Option[Integer] = None, loggerConfig: Option[List[String]] = None, messagesSize: Option[Integer] = None): Option[ComAdobeGraniteLoggingImplLogAnalyserImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteLoggingImplLogAnalyserImplAsync(post, apply, delete, action, location, propertylist, messagesQueueSize, loggerConfig, messagesSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param messagesQueueSize  (optional)
   * @param loggerConfig  (optional)
   * @param messagesSize  (optional)
   * @return Future(ComAdobeGraniteLoggingImplLogAnalyserImplInfo)
   */
  def comAdobeGraniteLoggingImplLogAnalyserImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, messagesQueueSize: Option[Integer] = None, loggerConfig: Option[List[String]] = None, messagesSize: Option[Integer] = None): Future[ComAdobeGraniteLoggingImplLogAnalyserImplInfo] = {
      helper.comAdobeGraniteLoggingImplLogAnalyserImpl(post, apply, delete, action, location, propertylist, messagesQueueSize, loggerConfig, messagesSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo
   */
  def comAdobeGraniteLoggingImplLogErrorHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteLoggingImplLogErrorHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo)
   */
  def comAdobeGraniteLoggingImplLogErrorHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo] = {
      helper.comAdobeGraniteLoggingImplLogErrorHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param graniteMaintenanceMandatory  (optional)
   * @param jobTopics  (optional)
   * @return ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo
   */
  def comAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, graniteMaintenanceMandatory: Option[Boolean] = None, jobTopics: Option[String] = None): Option[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo] = {
    val await = Try(Await.result(comAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskAsync(post, apply, delete, action, location, propertylist, graniteMaintenanceMandatory, jobTopics), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param graniteMaintenanceMandatory  (optional)
   * @param jobTopics  (optional)
   * @return Future(ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo)
   */
  def comAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, graniteMaintenanceMandatory: Option[Boolean] = None, jobTopics: Option[String] = None): Future[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo] = {
      helper.comAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTask(post, apply, delete, action, location, propertylist, graniteMaintenanceMandatory, jobTopics)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jobTopics  (optional)
   * @return ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo
   */
  def comAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jobTopics: Option[String] = None): Option[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo] = {
    val await = Try(Await.result(comAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskAsync(post, apply, delete, action, location, propertylist, jobTopics), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jobTopics  (optional)
   * @return Future(ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo)
   */
  def comAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jobTopics: Option[String] = None): Future[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo] = {
      helper.comAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTask(post, apply, delete, action, location, propertylist, jobTopics)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fullGcDays  (optional)
   * @return ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo
   */
  def comAdobeGraniteMaintenanceCrxImplRevisionCleanupTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fullGcDays: Option[List[String]] = None): Option[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo] = {
    val await = Try(Await.result(comAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskAsync(post, apply, delete, action, location, propertylist, fullGcDays), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fullGcDays  (optional)
   * @return Future(ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo)
   */
  def comAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fullGcDays: Option[List[String]] = None): Future[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo] = {
      helper.comAdobeGraniteMaintenanceCrxImplRevisionCleanupTask(post, apply, delete, action, location, propertylist, fullGcDays)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param scriptFilename  (optional)
   * @param scriptDisplay  (optional)
   * @param scriptPath  (optional)
   * @param scriptPlatform  (optional)
   * @param interval  (optional)
   * @param jmxdomain  (optional)
   * @return ComAdobeGraniteMonitoringImplScriptConfigImplInfo
   */
  def comAdobeGraniteMonitoringImplScriptConfigImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, scriptFilename: Option[String] = None, scriptDisplay: Option[String] = None, scriptPath: Option[String] = None, scriptPlatform: Option[List[String]] = None, interval: Option[Integer] = None, jmxdomain: Option[String] = None): Option[ComAdobeGraniteMonitoringImplScriptConfigImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteMonitoringImplScriptConfigImplAsync(post, apply, delete, action, location, propertylist, scriptFilename, scriptDisplay, scriptPath, scriptPlatform, interval, jmxdomain), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param scriptFilename  (optional)
   * @param scriptDisplay  (optional)
   * @param scriptPath  (optional)
   * @param scriptPlatform  (optional)
   * @param interval  (optional)
   * @param jmxdomain  (optional)
   * @return Future(ComAdobeGraniteMonitoringImplScriptConfigImplInfo)
   */
  def comAdobeGraniteMonitoringImplScriptConfigImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, scriptFilename: Option[String] = None, scriptDisplay: Option[String] = None, scriptPath: Option[String] = None, scriptPlatform: Option[List[String]] = None, interval: Option[Integer] = None, jmxdomain: Option[String] = None): Future[ComAdobeGraniteMonitoringImplScriptConfigImplInfo] = {
      helper.comAdobeGraniteMonitoringImplScriptConfigImpl(post, apply, delete, action, location, propertylist, scriptFilename, scriptDisplay, scriptPath, scriptPlatform, interval, jmxdomain)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param jaasControlFlag  (optional)
   * @param jaasRealmName  (optional)
   * @param jaasRanking  (optional)
   * @param oauthOfflineValidation  (optional)
   * @return ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo
   */
  def comAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHan(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, jaasControlFlag: Option[String] = None, jaasRealmName: Option[String] = None, jaasRanking: Option[Integer] = None, oauthOfflineValidation: Option[Boolean] = None): Option[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo] = {
    val await = Try(Await.result(comAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanAsync(post, apply, delete, action, location, propertylist, `path`, jaasControlFlag, jaasRealmName, jaasRanking, oauthOfflineValidation), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param jaasControlFlag  (optional)
   * @param jaasRealmName  (optional)
   * @param jaasRanking  (optional)
   * @param oauthOfflineValidation  (optional)
   * @return Future(ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo)
   */
  def comAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, jaasControlFlag: Option[String] = None, jaasRealmName: Option[String] = None, jaasRanking: Option[Integer] = None, oauthOfflineValidation: Option[Boolean] = None): Future[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo] = {
      helper.comAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHan(post, apply, delete, action, location, propertylist, `path`, jaasControlFlag, jaasRealmName, jaasRanking, oauthOfflineValidation)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @return ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo
   */
  def comAdobeGraniteOauthServerImplAccessTokenCleanupTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None): Option[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo] = {
    val await = Try(Await.result(comAdobeGraniteOauthServerImplAccessTokenCleanupTaskAsync(post, apply, delete, action, location, propertylist, schedulerExpression), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @return Future(ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo)
   */
  def comAdobeGraniteOauthServerImplAccessTokenCleanupTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None): Future[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo] = {
      helper.comAdobeGraniteOauthServerImplAccessTokenCleanupTask(post, apply, delete, action, location, propertylist, schedulerExpression)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthClientRevocationActive  (optional)
   * @return ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo
   */
  def comAdobeGraniteOauthServerImplOAuth2ClientRevocationServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthClientRevocationActive: Option[Boolean] = None): Option[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo] = {
    val await = Try(Await.result(comAdobeGraniteOauthServerImplOAuth2ClientRevocationServletAsync(post, apply, delete, action, location, propertylist, oauthClientRevocationActive), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthClientRevocationActive  (optional)
   * @return Future(ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo)
   */
  def comAdobeGraniteOauthServerImplOAuth2ClientRevocationServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthClientRevocationActive: Option[Boolean] = None): Future[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo] = {
      helper.comAdobeGraniteOauthServerImplOAuth2ClientRevocationServlet(post, apply, delete, action, location, propertylist, oauthClientRevocationActive)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletPaths  (optional)
   * @param oauthRevocationActive  (optional)
   * @return ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo
   */
  def comAdobeGraniteOauthServerImplOAuth2RevocationEndpointServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletPaths: Option[String] = None, oauthRevocationActive: Option[Boolean] = None): Option[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo] = {
    val await = Try(Await.result(comAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletAsync(post, apply, delete, action, location, propertylist, slingServletPaths, oauthRevocationActive), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletPaths  (optional)
   * @param oauthRevocationActive  (optional)
   * @return Future(ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo)
   */
  def comAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletPaths: Option[String] = None, oauthRevocationActive: Option[Boolean] = None): Future[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo] = {
      helper.comAdobeGraniteOauthServerImplOAuth2RevocationEndpointServlet(post, apply, delete, action, location, propertylist, slingServletPaths, oauthRevocationActive)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthIssuer  (optional)
   * @param oauthAccessTokenExpiresIn  (optional)
   * @param osgiHttpWhiteboardServletPattern  (optional)
   * @param osgiHttpWhiteboardContextSelect  (optional)
   * @return ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo
   */
  def comAdobeGraniteOauthServerImplOAuth2TokenEndpointServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthIssuer: Option[String] = None, oauthAccessTokenExpiresIn: Option[String] = None, osgiHttpWhiteboardServletPattern: Option[String] = None, osgiHttpWhiteboardContextSelect: Option[String] = None): Option[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo] = {
    val await = Try(Await.result(comAdobeGraniteOauthServerImplOAuth2TokenEndpointServletAsync(post, apply, delete, action, location, propertylist, oauthIssuer, oauthAccessTokenExpiresIn, osgiHttpWhiteboardServletPattern, osgiHttpWhiteboardContextSelect), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthIssuer  (optional)
   * @param oauthAccessTokenExpiresIn  (optional)
   * @param osgiHttpWhiteboardServletPattern  (optional)
   * @param osgiHttpWhiteboardContextSelect  (optional)
   * @return Future(ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo)
   */
  def comAdobeGraniteOauthServerImplOAuth2TokenEndpointServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthIssuer: Option[String] = None, oauthAccessTokenExpiresIn: Option[String] = None, osgiHttpWhiteboardServletPattern: Option[String] = None, osgiHttpWhiteboardContextSelect: Option[String] = None): Future[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo] = {
      helper.comAdobeGraniteOauthServerImplOAuth2TokenEndpointServlet(post, apply, delete, action, location, propertylist, oauthIssuer, oauthAccessTokenExpiresIn, osgiHttpWhiteboardServletPattern, osgiHttpWhiteboardContextSelect)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthTokenRevocationActive  (optional)
   * @return ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo
   */
  def comAdobeGraniteOauthServerImplOAuth2TokenRevocationServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthTokenRevocationActive: Option[Boolean] = None): Option[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo] = {
    val await = Try(Await.result(comAdobeGraniteOauthServerImplOAuth2TokenRevocationServletAsync(post, apply, delete, action, location, propertylist, oauthTokenRevocationActive), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param oauthTokenRevocationActive  (optional)
   * @return Future(ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo)
   */
  def comAdobeGraniteOauthServerImplOAuth2TokenRevocationServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, oauthTokenRevocationActive: Option[Boolean] = None): Future[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo] = {
      helper.comAdobeGraniteOauthServerImplOAuth2TokenRevocationServlet(post, apply, delete, action, location, propertylist, oauthTokenRevocationActive)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param offloadingTransporter  (optional)
   * @param offloadingCleanupPayload  (optional)
   * @return ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo
   */
  def comAdobeGraniteOffloadingImplOffloadingConfigurator(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, offloadingTransporter: Option[String] = None, offloadingCleanupPayload: Option[Boolean] = None): Option[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo] = {
    val await = Try(Await.result(comAdobeGraniteOffloadingImplOffloadingConfiguratorAsync(post, apply, delete, action, location, propertylist, offloadingTransporter, offloadingCleanupPayload), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param offloadingTransporter  (optional)
   * @param offloadingCleanupPayload  (optional)
   * @return Future(ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo)
   */
  def comAdobeGraniteOffloadingImplOffloadingConfiguratorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, offloadingTransporter: Option[String] = None, offloadingCleanupPayload: Option[Boolean] = None): Future[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo] = {
      helper.comAdobeGraniteOffloadingImplOffloadingConfigurator(post, apply, delete, action, location, propertylist, offloadingTransporter, offloadingCleanupPayload)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param offloadingJobclonerEnabled  (optional)
   * @return ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo
   */
  def comAdobeGraniteOffloadingImplOffloadingJobCloner(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, offloadingJobclonerEnabled: Option[Boolean] = None): Option[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo] = {
    val await = Try(Await.result(comAdobeGraniteOffloadingImplOffloadingJobClonerAsync(post, apply, delete, action, location, propertylist, offloadingJobclonerEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param offloadingJobclonerEnabled  (optional)
   * @return Future(ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo)
   */
  def comAdobeGraniteOffloadingImplOffloadingJobClonerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, offloadingJobclonerEnabled: Option[Boolean] = None): Future[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo] = {
      helper.comAdobeGraniteOffloadingImplOffloadingJobCloner(post, apply, delete, action, location, propertylist, offloadingJobclonerEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param offloadingOffloaderEnabled  (optional)
   * @return ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo
   */
  def comAdobeGraniteOffloadingImplOffloadingJobOffloader(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, offloadingOffloaderEnabled: Option[Boolean] = None): Option[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo] = {
    val await = Try(Await.result(comAdobeGraniteOffloadingImplOffloadingJobOffloaderAsync(post, apply, delete, action, location, propertylist, offloadingOffloaderEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param offloadingOffloaderEnabled  (optional)
   * @return Future(ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo)
   */
  def comAdobeGraniteOffloadingImplOffloadingJobOffloaderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, offloadingOffloaderEnabled: Option[Boolean] = None): Future[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo] = {
      helper.comAdobeGraniteOffloadingImplOffloadingJobOffloader(post, apply, delete, action, location, propertylist, offloadingOffloaderEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param offloadingAgentmanagerEnabled  (optional)
   * @return ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo
   */
  def comAdobeGraniteOffloadingImplTransporterOffloadingAgentManager(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, offloadingAgentmanagerEnabled: Option[Boolean] = None): Option[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo] = {
    val await = Try(Await.result(comAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerAsync(post, apply, delete, action, location, propertylist, offloadingAgentmanagerEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param offloadingAgentmanagerEnabled  (optional)
   * @return Future(ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo)
   */
  def comAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, offloadingAgentmanagerEnabled: Option[Boolean] = None): Future[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo] = {
      helper.comAdobeGraniteOffloadingImplTransporterOffloadingAgentManager(post, apply, delete, action, location, propertylist, offloadingAgentmanagerEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultTransportAgentToWorkerPrefix  (optional)
   * @param defaultTransportAgentToMasterPrefix  (optional)
   * @param defaultTransportInputPackage  (optional)
   * @param defaultTransportOutputPackage  (optional)
   * @param defaultTransportReplicationSynchronous  (optional)
   * @param defaultTransportContentpackage  (optional)
   * @param offloadingTransporterDefaultEnabled  (optional)
   * @return ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo
   */
  def comAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspo(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultTransportAgentToWorkerPrefix: Option[String] = None, defaultTransportAgentToMasterPrefix: Option[String] = None, defaultTransportInputPackage: Option[String] = None, defaultTransportOutputPackage: Option[String] = None, defaultTransportReplicationSynchronous: Option[Boolean] = None, defaultTransportContentpackage: Option[Boolean] = None, offloadingTransporterDefaultEnabled: Option[Boolean] = None): Option[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo] = {
    val await = Try(Await.result(comAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoAsync(post, apply, delete, action, location, propertylist, defaultTransportAgentToWorkerPrefix, defaultTransportAgentToMasterPrefix, defaultTransportInputPackage, defaultTransportOutputPackage, defaultTransportReplicationSynchronous, defaultTransportContentpackage, offloadingTransporterDefaultEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultTransportAgentToWorkerPrefix  (optional)
   * @param defaultTransportAgentToMasterPrefix  (optional)
   * @param defaultTransportInputPackage  (optional)
   * @param defaultTransportOutputPackage  (optional)
   * @param defaultTransportReplicationSynchronous  (optional)
   * @param defaultTransportContentpackage  (optional)
   * @param offloadingTransporterDefaultEnabled  (optional)
   * @return Future(ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo)
   */
  def comAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultTransportAgentToWorkerPrefix: Option[String] = None, defaultTransportAgentToMasterPrefix: Option[String] = None, defaultTransportInputPackage: Option[String] = None, defaultTransportOutputPackage: Option[String] = None, defaultTransportReplicationSynchronous: Option[Boolean] = None, defaultTransportContentpackage: Option[Boolean] = None, offloadingTransporterDefaultEnabled: Option[Boolean] = None): Future[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo] = {
      helper.comAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspo(post, apply, delete, action, location, propertylist, defaultTransportAgentToWorkerPrefix, defaultTransportAgentToMasterPrefix, defaultTransportInputPackage, defaultTransportOutputPackage, defaultTransportReplicationSynchronous, defaultTransportContentpackage, offloadingTransporterDefaultEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param omnisearchSuggestionRequiretextMin  (optional)
   * @param omnisearchSuggestionSpellcheckRequire  (optional)
   * @return ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo
   */
  def comAdobeGraniteOmnisearchImplCoreOmniSearchServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, omnisearchSuggestionRequiretextMin: Option[Integer] = None, omnisearchSuggestionSpellcheckRequire: Option[Boolean] = None): Option[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplAsync(post, apply, delete, action, location, propertylist, omnisearchSuggestionRequiretextMin, omnisearchSuggestionSpellcheckRequire), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param omnisearchSuggestionRequiretextMin  (optional)
   * @param omnisearchSuggestionSpellcheckRequire  (optional)
   * @return Future(ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo)
   */
  def comAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, omnisearchSuggestionRequiretextMin: Option[Integer] = None, omnisearchSuggestionSpellcheckRequire: Option[Boolean] = None): Future[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo] = {
      helper.comAdobeGraniteOmnisearchImplCoreOmniSearchServiceImpl(post, apply, delete, action, location, propertylist, omnisearchSuggestionRequiretextMin, omnisearchSuggestionSpellcheckRequire)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param optoutCookies  (optional)
   * @param optoutHeaders  (optional)
   * @param optoutWhitelistCookies  (optional)
   * @return ComAdobeGraniteOptoutImplOptOutServiceImplInfo
   */
  def comAdobeGraniteOptoutImplOptOutServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, optoutCookies: Option[List[String]] = None, optoutHeaders: Option[List[String]] = None, optoutWhitelistCookies: Option[List[String]] = None): Option[ComAdobeGraniteOptoutImplOptOutServiceImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteOptoutImplOptOutServiceImplAsync(post, apply, delete, action, location, propertylist, optoutCookies, optoutHeaders, optoutWhitelistCookies), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param optoutCookies  (optional)
   * @param optoutHeaders  (optional)
   * @param optoutWhitelistCookies  (optional)
   * @return Future(ComAdobeGraniteOptoutImplOptOutServiceImplInfo)
   */
  def comAdobeGraniteOptoutImplOptOutServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, optoutCookies: Option[List[String]] = None, optoutHeaders: Option[List[String]] = None, optoutWhitelistCookies: Option[List[String]] = None): Future[ComAdobeGraniteOptoutImplOptOutServiceImplInfo] = {
      helper.comAdobeGraniteOptoutImplOptOutServiceImpl(post, apply, delete, action, location, propertylist, optoutCookies, optoutHeaders, optoutWhitelistCookies)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param indexingCriticalThreshold  (optional)
   * @param indexingWarnThreshold  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo
   */
  def comAdobeGraniteQueriesImplHcAsyncIndexHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, indexingCriticalThreshold: Option[Integer] = None, indexingWarnThreshold: Option[Integer] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteQueriesImplHcAsyncIndexHealthCheckAsync(post, apply, delete, action, location, propertylist, indexingCriticalThreshold, indexingWarnThreshold, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param indexingCriticalThreshold  (optional)
   * @param indexingWarnThreshold  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo)
   */
  def comAdobeGraniteQueriesImplHcAsyncIndexHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, indexingCriticalThreshold: Option[Integer] = None, indexingWarnThreshold: Option[Integer] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo] = {
      helper.comAdobeGraniteQueriesImplHcAsyncIndexHealthCheck(post, apply, delete, action, location, propertylist, indexingCriticalThreshold, indexingWarnThreshold, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param largeIndexCriticalThreshold  (optional)
   * @param largeIndexWarnThreshold  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo
   */
  def comAdobeGraniteQueriesImplHcLargeIndexHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, largeIndexCriticalThreshold: Option[Integer] = None, largeIndexWarnThreshold: Option[Integer] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteQueriesImplHcLargeIndexHealthCheckAsync(post, apply, delete, action, location, propertylist, largeIndexCriticalThreshold, largeIndexWarnThreshold, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param largeIndexCriticalThreshold  (optional)
   * @param largeIndexWarnThreshold  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo)
   */
  def comAdobeGraniteQueriesImplHcLargeIndexHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, largeIndexCriticalThreshold: Option[Integer] = None, largeIndexWarnThreshold: Option[Integer] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo] = {
      helper.comAdobeGraniteQueriesImplHcLargeIndexHealthCheck(post, apply, delete, action, location, propertylist, largeIndexCriticalThreshold, largeIndexWarnThreshold, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo
   */
  def comAdobeGraniteQueriesImplHcQueriesStatusHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteQueriesImplHcQueriesStatusHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo)
   */
  def comAdobeGraniteQueriesImplHcQueriesStatusHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo] = {
      helper.comAdobeGraniteQueriesImplHcQueriesStatusHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param getPeriod  (optional)
   * @return ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo
   */
  def comAdobeGraniteQueriesImplHcQueryHealthCheckMetrics(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, getPeriod: Option[Integer] = None): Option[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo] = {
    val await = Try(Await.result(comAdobeGraniteQueriesImplHcQueryHealthCheckMetricsAsync(post, apply, delete, action, location, propertylist, getPeriod), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param getPeriod  (optional)
   * @return Future(ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo)
   */
  def comAdobeGraniteQueriesImplHcQueryHealthCheckMetricsAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, getPeriod: Option[Integer] = None): Future[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo] = {
      helper.comAdobeGraniteQueriesImplHcQueryHealthCheckMetrics(post, apply, delete, action, location, propertylist, getPeriod)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo
   */
  def comAdobeGraniteQueriesImplHcQueryLimitsHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteQueriesImplHcQueryLimitsHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo)
   */
  def comAdobeGraniteQueriesImplHcQueryLimitsHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo] = {
      helper.comAdobeGraniteQueriesImplHcQueryLimitsHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param numberOfRetriesAllowed  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo
   */
  def comAdobeGraniteReplicationHcImplReplicationQueueHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, numberOfRetriesAllowed: Option[Integer] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteReplicationHcImplReplicationQueueHealthCheckAsync(post, apply, delete, action, location, propertylist, numberOfRetriesAllowed, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param numberOfRetriesAllowed  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo)
   */
  def comAdobeGraniteReplicationHcImplReplicationQueueHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, numberOfRetriesAllowed: Option[Integer] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo] = {
      helper.comAdobeGraniteReplicationHcImplReplicationQueueHealthCheck(post, apply, delete, action, location, propertylist, numberOfRetriesAllowed, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo
   */
  def comAdobeGraniteReplicationHcImplReplicationTransportUsersHealthC(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo] = {
    val await = Try(Await.result(comAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo)
   */
  def comAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo] = {
      helper.comAdobeGraniteReplicationHcImplReplicationTransportUsersHealthC(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo
   */
  def comAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo)
   */
  def comAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo] = {
      helper.comAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param excludeSearchPath  (optional)
   * @return ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo
   */
  def comAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthC(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, excludeSearchPath: Option[List[String]] = None): Option[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo] = {
    val await = Try(Await.result(comAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCAsync(post, apply, delete, action, location, propertylist, hcTags, excludeSearchPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param excludeSearchPath  (optional)
   * @return Future(ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo)
   */
  def comAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, excludeSearchPath: Option[List[String]] = None): Future[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo] = {
      helper.comAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthC(post, apply, delete, action, location, propertylist, hcTags, excludeSearchPath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo
   */
  def comAdobeGraniteRepositoryHcImplContinuousRGCHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo)
   */
  def comAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo] = {
      helper.comAdobeGraniteRepositoryHcImplContinuousRGCHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo
   */
  def comAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthChe(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo] = {
    val await = Try(Await.result(comAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo)
   */
  def comAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo] = {
      helper.comAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthChe(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param accountLogins  (optional)
   * @param consoleLogins  (optional)
   * @return ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo
   */
  def comAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, accountLogins: Option[List[String]] = None, consoleLogins: Option[List[String]] = None): Option[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags, accountLogins, consoleLogins), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param accountLogins  (optional)
   * @param consoleLogins  (optional)
   * @return Future(ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo)
   */
  def comAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, accountLogins: Option[List[String]] = None, consoleLogins: Option[List[String]] = None): Future[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo] = {
      helper.comAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheck(post, apply, delete, action, location, propertylist, hcTags, accountLogins, consoleLogins)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param diskSpaceWarnThreshold  (optional)
   * @param diskSpaceErrorThreshold  (optional)
   * @return ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo
   */
  def comAdobeGraniteRepositoryHcImplDiskSpaceHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, diskSpaceWarnThreshold: Option[Integer] = None, diskSpaceErrorThreshold: Option[Integer] = None): Option[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags, diskSpaceWarnThreshold, diskSpaceErrorThreshold), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @param diskSpaceWarnThreshold  (optional)
   * @param diskSpaceErrorThreshold  (optional)
   * @return Future(ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo)
   */
  def comAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None, diskSpaceWarnThreshold: Option[Integer] = None, diskSpaceErrorThreshold: Option[Integer] = None): Future[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo] = {
      helper.comAdobeGraniteRepositoryHcImplDiskSpaceHealthCheck(post, apply, delete, action, location, propertylist, hcTags, diskSpaceWarnThreshold, diskSpaceErrorThreshold)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo
   */
  def comAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo] = {
    val await = Try(Await.result(comAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo)
   */
  def comAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo] = {
      helper.comAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheck(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param intervalSeconds  (optional)
   * @param commitsPerIntervalThreshold  (optional)
   * @param maxLocationLength  (optional)
   * @param maxDetailsShown  (optional)
   * @param minDetailsPercentage  (optional)
   * @param threadMatchers  (optional)
   * @param maxGreedyDepth  (optional)
   * @param greedyStackMatchers  (optional)
   * @param stackFilters  (optional)
   * @param stackMatchers  (optional)
   * @param stackCategorizers  (optional)
   * @param stackShorteners  (optional)
   * @return ComAdobeGraniteRepositoryImplCommitStatsConfigInfo
   */
  def comAdobeGraniteRepositoryImplCommitStatsConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, intervalSeconds: Option[Integer] = None, commitsPerIntervalThreshold: Option[Integer] = None, maxLocationLength: Option[Integer] = None, maxDetailsShown: Option[Integer] = None, minDetailsPercentage: Option[Integer] = None, threadMatchers: Option[List[String]] = None, maxGreedyDepth: Option[Integer] = None, greedyStackMatchers: Option[String] = None, stackFilters: Option[List[String]] = None, stackMatchers: Option[List[String]] = None, stackCategorizers: Option[List[String]] = None, stackShorteners: Option[List[String]] = None): Option[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo] = {
    val await = Try(Await.result(comAdobeGraniteRepositoryImplCommitStatsConfigAsync(post, apply, delete, action, location, propertylist, enabled, intervalSeconds, commitsPerIntervalThreshold, maxLocationLength, maxDetailsShown, minDetailsPercentage, threadMatchers, maxGreedyDepth, greedyStackMatchers, stackFilters, stackMatchers, stackCategorizers, stackShorteners), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param intervalSeconds  (optional)
   * @param commitsPerIntervalThreshold  (optional)
   * @param maxLocationLength  (optional)
   * @param maxDetailsShown  (optional)
   * @param minDetailsPercentage  (optional)
   * @param threadMatchers  (optional)
   * @param maxGreedyDepth  (optional)
   * @param greedyStackMatchers  (optional)
   * @param stackFilters  (optional)
   * @param stackMatchers  (optional)
   * @param stackCategorizers  (optional)
   * @param stackShorteners  (optional)
   * @return Future(ComAdobeGraniteRepositoryImplCommitStatsConfigInfo)
   */
  def comAdobeGraniteRepositoryImplCommitStatsConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, intervalSeconds: Option[Integer] = None, commitsPerIntervalThreshold: Option[Integer] = None, maxLocationLength: Option[Integer] = None, maxDetailsShown: Option[Integer] = None, minDetailsPercentage: Option[Integer] = None, threadMatchers: Option[List[String]] = None, maxGreedyDepth: Option[Integer] = None, greedyStackMatchers: Option[String] = None, stackFilters: Option[List[String]] = None, stackMatchers: Option[List[String]] = None, stackCategorizers: Option[List[String]] = None, stackShorteners: Option[List[String]] = None): Future[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo] = {
      helper.comAdobeGraniteRepositoryImplCommitStatsConfig(post, apply, delete, action, location, propertylist, enabled, intervalSeconds, commitsPerIntervalThreshold, maxLocationLength, maxDetailsShown, minDetailsPercentage, threadMatchers, maxGreedyDepth, greedyStackMatchers, stackFilters, stackMatchers, stackCategorizers, stackShorteners)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param serviceusersSimpleSubjectPopulation  (optional)
   * @param serviceusersList  (optional)
   * @return ComAdobeGraniteRepositoryServiceUserConfigurationInfo
   */
  def comAdobeGraniteRepositoryServiceUserConfiguration(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, serviceusersSimpleSubjectPopulation: Option[Boolean] = None, serviceusersList: Option[List[String]] = None): Option[ComAdobeGraniteRepositoryServiceUserConfigurationInfo] = {
    val await = Try(Await.result(comAdobeGraniteRepositoryServiceUserConfigurationAsync(post, apply, delete, action, location, propertylist, serviceRanking, serviceusersSimpleSubjectPopulation, serviceusersList), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param serviceusersSimpleSubjectPopulation  (optional)
   * @param serviceusersList  (optional)
   * @return Future(ComAdobeGraniteRepositoryServiceUserConfigurationInfo)
   */
  def comAdobeGraniteRepositoryServiceUserConfigurationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, serviceusersSimpleSubjectPopulation: Option[Boolean] = None, serviceusersList: Option[List[String]] = None): Future[ComAdobeGraniteRepositoryServiceUserConfigurationInfo] = {
      helper.comAdobeGraniteRepositoryServiceUserConfiguration(post, apply, delete, action, location, propertylist, serviceRanking, serviceusersSimpleSubjectPopulation, serviceusersList)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo
   */
  def comAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckIm(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo] = {
    val await = Try(Await.result(comAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo)
   */
  def comAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo] = {
      helper.comAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckIm(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param types  (optional)
   * @return ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo
   */
  def comAdobeGraniteResourcestatusImplCompositeStatusType(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, types: Option[List[String]] = None): Option[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo] = {
    val await = Try(Await.result(comAdobeGraniteResourcestatusImplCompositeStatusTypeAsync(post, apply, delete, action, location, propertylist, name, types), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param types  (optional)
   * @return Future(ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo)
   */
  def comAdobeGraniteResourcestatusImplCompositeStatusTypeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, types: Option[List[String]] = None): Future[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo] = {
      helper.comAdobeGraniteResourcestatusImplCompositeStatusType(post, apply, delete, action, location, propertylist, name, types)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerRoot  (optional)
   * @return ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo
   */
  def comAdobeGraniteResourcestatusImplStatusResourceProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerRoot: Option[String] = None): Option[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteResourcestatusImplStatusResourceProviderImplAsync(post, apply, delete, action, location, propertylist, providerRoot), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerRoot  (optional)
   * @return Future(ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo)
   */
  def comAdobeGraniteResourcestatusImplStatusResourceProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerRoot: Option[String] = None): Future[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo] = {
      helper.comAdobeGraniteResourcestatusImplStatusResourceProviderImpl(post, apply, delete, action, location, propertylist, providerRoot)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mimeAllowEmpty  (optional)
   * @param mimeAllowed  (optional)
   * @return ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo
   */
  def comAdobeGraniteRestAssetsImplAssetContentDispositionFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mimeAllowEmpty: Option[Boolean] = None, mimeAllowed: Option[List[String]] = None): Option[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo] = {
    val await = Try(Await.result(comAdobeGraniteRestAssetsImplAssetContentDispositionFilterAsync(post, apply, delete, action, location, propertylist, mimeAllowEmpty, mimeAllowed), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mimeAllowEmpty  (optional)
   * @param mimeAllowed  (optional)
   * @return Future(ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo)
   */
  def comAdobeGraniteRestAssetsImplAssetContentDispositionFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mimeAllowEmpty: Option[Boolean] = None, mimeAllowed: Option[List[String]] = None): Future[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo] = {
      helper.comAdobeGraniteRestAssetsImplAssetContentDispositionFilter(post, apply, delete, action, location, propertylist, mimeAllowEmpty, mimeAllowed)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerRoots  (optional)
   * @return ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo
   */
  def comAdobeGraniteRestImplApiEndpointResourceProviderFactoryImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerRoots: Option[String] = None): Option[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplAsync(post, apply, delete, action, location, propertylist, providerRoots), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerRoots  (optional)
   * @return Future(ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo)
   */
  def comAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerRoots: Option[String] = None): Future[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo] = {
      helper.comAdobeGraniteRestImplApiEndpointResourceProviderFactoryImpl(post, apply, delete, action, location, propertylist, providerRoots)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultLimit  (optional)
   * @param useAbsoluteUri  (optional)
   * @return ComAdobeGraniteRestImplServletDefaultGETServletInfo
   */
  def comAdobeGraniteRestImplServletDefaultGETServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultLimit: Option[Integer] = None, useAbsoluteUri: Option[Boolean] = None): Option[ComAdobeGraniteRestImplServletDefaultGETServletInfo] = {
    val await = Try(Await.result(comAdobeGraniteRestImplServletDefaultGETServletAsync(post, apply, delete, action, location, propertylist, defaultLimit, useAbsoluteUri), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultLimit  (optional)
   * @param useAbsoluteUri  (optional)
   * @return Future(ComAdobeGraniteRestImplServletDefaultGETServletInfo)
   */
  def comAdobeGraniteRestImplServletDefaultGETServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultLimit: Option[Integer] = None, useAbsoluteUri: Option[Boolean] = None): Future[ComAdobeGraniteRestImplServletDefaultGETServletInfo] = {
      helper.comAdobeGraniteRestImplServletDefaultGETServlet(post, apply, delete, action, location, propertylist, defaultLimit, useAbsoluteUri)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo
   */
  def comAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationS(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Option[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo] = {
    val await = Try(Await.result(comAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSAsync(post, apply, delete, action, location, propertylist, hcTags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcTags  (optional)
   * @return Future(ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo)
   */
  def comAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcTags: Option[List[String]] = None): Future[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo] = {
      helper.comAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationS(post, apply, delete, action, location, propertylist, hcTags)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param adapterCondition  (optional)
   * @param graniteUserpropertiesNodetypes  (optional)
   * @param graniteUserpropertiesResourcetypes  (optional)
   * @return ComAdobeGraniteSecurityUserUserPropertiesServiceInfo
   */
  def comAdobeGraniteSecurityUserUserPropertiesService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, adapterCondition: Option[String] = None, graniteUserpropertiesNodetypes: Option[List[String]] = None, graniteUserpropertiesResourcetypes: Option[List[String]] = None): Option[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo] = {
    val await = Try(Await.result(comAdobeGraniteSecurityUserUserPropertiesServiceAsync(post, apply, delete, action, location, propertylist, adapterCondition, graniteUserpropertiesNodetypes, graniteUserpropertiesResourcetypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param adapterCondition  (optional)
   * @param graniteUserpropertiesNodetypes  (optional)
   * @param graniteUserpropertiesResourcetypes  (optional)
   * @return Future(ComAdobeGraniteSecurityUserUserPropertiesServiceInfo)
   */
  def comAdobeGraniteSecurityUserUserPropertiesServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, adapterCondition: Option[String] = None, graniteUserpropertiesNodetypes: Option[List[String]] = None, graniteUserpropertiesResourcetypes: Option[List[String]] = None): Future[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo] = {
      helper.comAdobeGraniteSecurityUserUserPropertiesService(post, apply, delete, action, location, propertylist, adapterCondition, graniteUserpropertiesNodetypes, graniteUserpropertiesResourcetypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param group2memberRelationshipOutgoing  (optional)
   * @param group2memberExcludedOutgoing  (optional)
   * @param group2memberRelationshipIncoming  (optional)
   * @param group2memberExcludedIncoming  (optional)
   * @return ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo
   */
  def comAdobeGraniteSocialgraphImplSocialGraphFactoryImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, group2memberRelationshipOutgoing: Option[String] = None, group2memberExcludedOutgoing: Option[List[String]] = None, group2memberRelationshipIncoming: Option[String] = None, group2memberExcludedIncoming: Option[List[String]] = None): Option[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteSocialgraphImplSocialGraphFactoryImplAsync(post, apply, delete, action, location, propertylist, group2memberRelationshipOutgoing, group2memberExcludedOutgoing, group2memberRelationshipIncoming, group2memberExcludedIncoming), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param group2memberRelationshipOutgoing  (optional)
   * @param group2memberExcludedOutgoing  (optional)
   * @param group2memberRelationshipIncoming  (optional)
   * @param group2memberExcludedIncoming  (optional)
   * @return Future(ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo)
   */
  def comAdobeGraniteSocialgraphImplSocialGraphFactoryImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, group2memberRelationshipOutgoing: Option[String] = None, group2memberExcludedOutgoing: Option[List[String]] = None, group2memberRelationshipIncoming: Option[String] = None, group2memberExcludedIncoming: Option[List[String]] = None): Future[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo] = {
      helper.comAdobeGraniteSocialgraphImplSocialGraphFactoryImpl(post, apply, delete, action, location, propertylist, group2memberRelationshipOutgoing, group2memberExcludedOutgoing, group2memberRelationshipIncoming, group2memberExcludedIncoming)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param jmxObjectname  (optional)
   * @return ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo
   */
  def comAdobeGraniteSystemMonitoringImplSystemStatsMBeanImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, jmxObjectname: Option[String] = None): Option[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplAsync(post, apply, delete, action, location, propertylist, schedulerExpression, jmxObjectname), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param jmxObjectname  (optional)
   * @return Future(ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo)
   */
  def comAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, jmxObjectname: Option[String] = None): Future[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo] = {
      helper.comAdobeGraniteSystemMonitoringImplSystemStatsMBeanImpl(post, apply, delete, action, location, propertylist, schedulerExpression, jmxObjectname)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param adapterCondition  (optional)
   * @return ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo
   */
  def comAdobeGraniteTaskmanagementImplJcrTaskAdapterFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, adapterCondition: Option[String] = None): Option[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo] = {
    val await = Try(Await.result(comAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryAsync(post, apply, delete, action, location, propertylist, adapterCondition), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param adapterCondition  (optional)
   * @return Future(ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo)
   */
  def comAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, adapterCondition: Option[String] = None): Future[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo] = {
      helper.comAdobeGraniteTaskmanagementImplJcrTaskAdapterFactory(post, apply, delete, action, location, propertylist, adapterCondition)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param archivingEnabled  (optional)
   * @param schedulerExpression  (optional)
   * @param archiveSinceDaysCompleted  (optional)
   * @return ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo
   */
  def comAdobeGraniteTaskmanagementImplJcrTaskArchiveService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, archivingEnabled: Option[Boolean] = None, schedulerExpression: Option[String] = None, archiveSinceDaysCompleted: Option[Integer] = None): Option[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo] = {
    val await = Try(Await.result(comAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceAsync(post, apply, delete, action, location, propertylist, archivingEnabled, schedulerExpression, archiveSinceDaysCompleted), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param archivingEnabled  (optional)
   * @param schedulerExpression  (optional)
   * @param archiveSinceDaysCompleted  (optional)
   * @return Future(ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo)
   */
  def comAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, archivingEnabled: Option[Boolean] = None, schedulerExpression: Option[String] = None, archiveSinceDaysCompleted: Option[Integer] = None): Future[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo] = {
      helper.comAdobeGraniteTaskmanagementImplJcrTaskArchiveService(post, apply, delete, action, location, propertylist, archivingEnabled, schedulerExpression, archiveSinceDaysCompleted)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param purgeCompleted  (optional)
   * @param completedAge  (optional)
   * @param purgeActive  (optional)
   * @param activeAge  (optional)
   * @param saveThreshold  (optional)
   * @return ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo
   */
  def comAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, purgeCompleted: Option[Boolean] = None, completedAge: Option[Integer] = None, purgeActive: Option[Boolean] = None, activeAge: Option[Integer] = None, saveThreshold: Option[Integer] = None): Option[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo] = {
    val await = Try(Await.result(comAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskAsync(post, apply, delete, action, location, propertylist, purgeCompleted, completedAge, purgeActive, activeAge, saveThreshold), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param purgeCompleted  (optional)
   * @param completedAge  (optional)
   * @param purgeActive  (optional)
   * @param activeAge  (optional)
   * @param saveThreshold  (optional)
   * @return Future(ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo)
   */
  def comAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, purgeCompleted: Option[Boolean] = None, completedAge: Option[Integer] = None, purgeActive: Option[Boolean] = None, activeAge: Option[Integer] = None, saveThreshold: Option[Integer] = None): Future[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo] = {
      helper.comAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTask(post, apply, delete, action, location, propertylist, purgeCompleted, completedAge, purgeActive, activeAge, saveThreshold)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param adapterCondition  (optional)
   * @param taskmanagerAdmingroups  (optional)
   * @return ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo
   */
  def comAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, adapterCondition: Option[String] = None, taskmanagerAdmingroups: Option[List[String]] = None): Option[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo] = {
    val await = Try(Await.result(comAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorAsync(post, apply, delete, action, location, propertylist, adapterCondition, taskmanagerAdmingroups), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param adapterCondition  (optional)
   * @param taskmanagerAdmingroups  (optional)
   * @return Future(ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo)
   */
  def comAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, adapterCondition: Option[String] = None, taskmanagerAdmingroups: Option[List[String]] = None): Future[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo] = {
      helper.comAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactor(post, apply, delete, action, location, propertylist, adapterCondition, taskmanagerAdmingroups)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerPeriod  (optional)
   * @param schedulerRunOn  (optional)
   * @param graniteThreaddumpEnabled  (optional)
   * @param graniteThreaddumpDumpsPerFile  (optional)
   * @param graniteThreaddumpEnableGzipCompression  (optional)
   * @param graniteThreaddumpEnableDirectoriesCompression  (optional)
   * @param graniteThreaddumpEnableJStack  (optional)
   * @param graniteThreaddumpMaxBackupDays  (optional)
   * @param graniteThreaddumpBackupCleanTrigger  (optional)
   * @return ComAdobeGraniteThreaddumpThreadDumpCollectorInfo
   */
  def comAdobeGraniteThreaddumpThreadDumpCollector(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerPeriod: Option[Integer] = None, schedulerRunOn: Option[String] = None, graniteThreaddumpEnabled: Option[Boolean] = None, graniteThreaddumpDumpsPerFile: Option[Integer] = None, graniteThreaddumpEnableGzipCompression: Option[Boolean] = None, graniteThreaddumpEnableDirectoriesCompression: Option[Boolean] = None, graniteThreaddumpEnableJStack: Option[Boolean] = None, graniteThreaddumpMaxBackupDays: Option[Integer] = None, graniteThreaddumpBackupCleanTrigger: Option[String] = None): Option[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo] = {
    val await = Try(Await.result(comAdobeGraniteThreaddumpThreadDumpCollectorAsync(post, apply, delete, action, location, propertylist, schedulerPeriod, schedulerRunOn, graniteThreaddumpEnabled, graniteThreaddumpDumpsPerFile, graniteThreaddumpEnableGzipCompression, graniteThreaddumpEnableDirectoriesCompression, graniteThreaddumpEnableJStack, graniteThreaddumpMaxBackupDays, graniteThreaddumpBackupCleanTrigger), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerPeriod  (optional)
   * @param schedulerRunOn  (optional)
   * @param graniteThreaddumpEnabled  (optional)
   * @param graniteThreaddumpDumpsPerFile  (optional)
   * @param graniteThreaddumpEnableGzipCompression  (optional)
   * @param graniteThreaddumpEnableDirectoriesCompression  (optional)
   * @param graniteThreaddumpEnableJStack  (optional)
   * @param graniteThreaddumpMaxBackupDays  (optional)
   * @param graniteThreaddumpBackupCleanTrigger  (optional)
   * @return Future(ComAdobeGraniteThreaddumpThreadDumpCollectorInfo)
   */
  def comAdobeGraniteThreaddumpThreadDumpCollectorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerPeriod: Option[Integer] = None, schedulerRunOn: Option[String] = None, graniteThreaddumpEnabled: Option[Boolean] = None, graniteThreaddumpDumpsPerFile: Option[Integer] = None, graniteThreaddumpEnableGzipCompression: Option[Boolean] = None, graniteThreaddumpEnableDirectoriesCompression: Option[Boolean] = None, graniteThreaddumpEnableJStack: Option[Boolean] = None, graniteThreaddumpMaxBackupDays: Option[Integer] = None, graniteThreaddumpBackupCleanTrigger: Option[String] = None): Future[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo] = {
      helper.comAdobeGraniteThreaddumpThreadDumpCollector(post, apply, delete, action, location, propertylist, schedulerPeriod, schedulerRunOn, graniteThreaddumpEnabled, graniteThreaddumpDumpsPerFile, graniteThreaddumpEnableGzipCompression, graniteThreaddumpEnableDirectoriesCompression, graniteThreaddumpEnableJStack, graniteThreaddumpMaxBackupDays, graniteThreaddumpBackupCleanTrigger)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param translationFactory  (optional)
   * @param defaultConnectorLabel  (optional)
   * @param defaultConnectorAttribution  (optional)
   * @param defaultConnectorWorkspaceId  (optional)
   * @param defaultConnectorSubscriptionKey  (optional)
   * @param languageMapLocation  (optional)
   * @param categoryMapLocation  (optional)
   * @param retryAttempts  (optional)
   * @param timeoutCount  (optional)
   * @return ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo
   */
  def comAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTransl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, translationFactory: Option[String] = None, defaultConnectorLabel: Option[String] = None, defaultConnectorAttribution: Option[String] = None, defaultConnectorWorkspaceId: Option[String] = None, defaultConnectorSubscriptionKey: Option[String] = None, languageMapLocation: Option[String] = None, categoryMapLocation: Option[String] = None, retryAttempts: Option[Integer] = None, timeoutCount: Option[Integer] = None): Option[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo] = {
    val await = Try(Await.result(comAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslAsync(post, apply, delete, action, location, propertylist, translationFactory, defaultConnectorLabel, defaultConnectorAttribution, defaultConnectorWorkspaceId, defaultConnectorSubscriptionKey, languageMapLocation, categoryMapLocation, retryAttempts, timeoutCount), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param translationFactory  (optional)
   * @param defaultConnectorLabel  (optional)
   * @param defaultConnectorAttribution  (optional)
   * @param defaultConnectorWorkspaceId  (optional)
   * @param defaultConnectorSubscriptionKey  (optional)
   * @param languageMapLocation  (optional)
   * @param categoryMapLocation  (optional)
   * @param retryAttempts  (optional)
   * @param timeoutCount  (optional)
   * @return Future(ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo)
   */
  def comAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, translationFactory: Option[String] = None, defaultConnectorLabel: Option[String] = None, defaultConnectorAttribution: Option[String] = None, defaultConnectorWorkspaceId: Option[String] = None, defaultConnectorSubscriptionKey: Option[String] = None, languageMapLocation: Option[String] = None, categoryMapLocation: Option[String] = None, retryAttempts: Option[Integer] = None, timeoutCount: Option[Integer] = None): Future[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo] = {
      helper.comAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTransl(post, apply, delete, action, location, propertylist, translationFactory, defaultConnectorLabel, defaultConnectorAttribution, defaultConnectorWorkspaceId, defaultConnectorSubscriptionKey, languageMapLocation, categoryMapLocation, retryAttempts, timeoutCount)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultConnectorName  (optional)
   * @param defaultCategory  (optional)
   * @return ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo
   */
  def comAdobeGraniteTranslationCoreImplTranslationManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultConnectorName: Option[String] = None, defaultCategory: Option[String] = None): Option[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteTranslationCoreImplTranslationManagerImplAsync(post, apply, delete, action, location, propertylist, defaultConnectorName, defaultCategory), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultConnectorName  (optional)
   * @param defaultCategory  (optional)
   * @return Future(ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo)
   */
  def comAdobeGraniteTranslationCoreImplTranslationManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultConnectorName: Option[String] = None, defaultCategory: Option[String] = None): Future[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo] = {
      helper.comAdobeGraniteTranslationCoreImplTranslationManagerImpl(post, apply, delete, action, location, propertylist, defaultConnectorName, defaultCategory)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param htmllibmanagerTiming  (optional)
   * @param htmllibmanagerDebugInitJs  (optional)
   * @param htmllibmanagerMinify  (optional)
   * @param htmllibmanagerDebug  (optional)
   * @param htmllibmanagerGzip  (optional)
   * @param htmllibmanagerMaxDataUriSize  (optional)
   * @param htmllibmanagerMaxage  (optional)
   * @param htmllibmanagerForceCQUrlInfo  (optional)
   * @param htmllibmanagerDefaultthemename  (optional)
   * @param htmllibmanagerDefaultuserthemename  (optional)
   * @param htmllibmanagerClientmanager  (optional)
   * @param htmllibmanagerPathList  (optional)
   * @param htmllibmanagerExcludedPathList  (optional)
   * @param htmllibmanagerProcessorJs  (optional)
   * @param htmllibmanagerProcessorCss  (optional)
   * @param htmllibmanagerLongcachePatterns  (optional)
   * @param htmllibmanagerLongcacheFormat  (optional)
   * @param htmllibmanagerUseFileSystemOutputCache  (optional)
   * @param htmllibmanagerFileSystemOutputCacheLocation  (optional)
   * @param htmllibmanagerDisableReplacement  (optional)
   * @return ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo
   */
  def comAdobeGraniteUiClientlibsImplHtmlLibraryManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, htmllibmanagerTiming: Option[Boolean] = None, htmllibmanagerDebugInitJs: Option[String] = None, htmllibmanagerMinify: Option[Boolean] = None, htmllibmanagerDebug: Option[Boolean] = None, htmllibmanagerGzip: Option[Boolean] = None, htmllibmanagerMaxDataUriSize: Option[Integer] = None, htmllibmanagerMaxage: Option[Integer] = None, htmllibmanagerForceCQUrlInfo: Option[Boolean] = None, htmllibmanagerDefaultthemename: Option[String] = None, htmllibmanagerDefaultuserthemename: Option[String] = None, htmllibmanagerClientmanager: Option[String] = None, htmllibmanagerPathList: Option[List[String]] = None, htmllibmanagerExcludedPathList: Option[List[String]] = None, htmllibmanagerProcessorJs: Option[List[String]] = None, htmllibmanagerProcessorCss: Option[List[String]] = None, htmllibmanagerLongcachePatterns: Option[List[String]] = None, htmllibmanagerLongcacheFormat: Option[String] = None, htmllibmanagerUseFileSystemOutputCache: Option[Boolean] = None, htmllibmanagerFileSystemOutputCacheLocation: Option[String] = None, htmllibmanagerDisableReplacement: Option[List[String]] = None): Option[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo] = {
    val await = Try(Await.result(comAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplAsync(post, apply, delete, action, location, propertylist, htmllibmanagerTiming, htmllibmanagerDebugInitJs, htmllibmanagerMinify, htmllibmanagerDebug, htmllibmanagerGzip, htmllibmanagerMaxDataUriSize, htmllibmanagerMaxage, htmllibmanagerForceCQUrlInfo, htmllibmanagerDefaultthemename, htmllibmanagerDefaultuserthemename, htmllibmanagerClientmanager, htmllibmanagerPathList, htmllibmanagerExcludedPathList, htmllibmanagerProcessorJs, htmllibmanagerProcessorCss, htmllibmanagerLongcachePatterns, htmllibmanagerLongcacheFormat, htmllibmanagerUseFileSystemOutputCache, htmllibmanagerFileSystemOutputCacheLocation, htmllibmanagerDisableReplacement), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param htmllibmanagerTiming  (optional)
   * @param htmllibmanagerDebugInitJs  (optional)
   * @param htmllibmanagerMinify  (optional)
   * @param htmllibmanagerDebug  (optional)
   * @param htmllibmanagerGzip  (optional)
   * @param htmllibmanagerMaxDataUriSize  (optional)
   * @param htmllibmanagerMaxage  (optional)
   * @param htmllibmanagerForceCQUrlInfo  (optional)
   * @param htmllibmanagerDefaultthemename  (optional)
   * @param htmllibmanagerDefaultuserthemename  (optional)
   * @param htmllibmanagerClientmanager  (optional)
   * @param htmllibmanagerPathList  (optional)
   * @param htmllibmanagerExcludedPathList  (optional)
   * @param htmllibmanagerProcessorJs  (optional)
   * @param htmllibmanagerProcessorCss  (optional)
   * @param htmllibmanagerLongcachePatterns  (optional)
   * @param htmllibmanagerLongcacheFormat  (optional)
   * @param htmllibmanagerUseFileSystemOutputCache  (optional)
   * @param htmllibmanagerFileSystemOutputCacheLocation  (optional)
   * @param htmllibmanagerDisableReplacement  (optional)
   * @return Future(ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo)
   */
  def comAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, htmllibmanagerTiming: Option[Boolean] = None, htmllibmanagerDebugInitJs: Option[String] = None, htmllibmanagerMinify: Option[Boolean] = None, htmllibmanagerDebug: Option[Boolean] = None, htmllibmanagerGzip: Option[Boolean] = None, htmllibmanagerMaxDataUriSize: Option[Integer] = None, htmllibmanagerMaxage: Option[Integer] = None, htmllibmanagerForceCQUrlInfo: Option[Boolean] = None, htmllibmanagerDefaultthemename: Option[String] = None, htmllibmanagerDefaultuserthemename: Option[String] = None, htmllibmanagerClientmanager: Option[String] = None, htmllibmanagerPathList: Option[List[String]] = None, htmllibmanagerExcludedPathList: Option[List[String]] = None, htmllibmanagerProcessorJs: Option[List[String]] = None, htmllibmanagerProcessorCss: Option[List[String]] = None, htmllibmanagerLongcachePatterns: Option[List[String]] = None, htmllibmanagerLongcacheFormat: Option[String] = None, htmllibmanagerUseFileSystemOutputCache: Option[Boolean] = None, htmllibmanagerFileSystemOutputCacheLocation: Option[String] = None, htmllibmanagerDisableReplacement: Option[List[String]] = None): Future[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo] = {
      helper.comAdobeGraniteUiClientlibsImplHtmlLibraryManagerImpl(post, apply, delete, action, location, propertylist, htmllibmanagerTiming, htmllibmanagerDebugInitJs, htmllibmanagerMinify, htmllibmanagerDebug, htmllibmanagerGzip, htmllibmanagerMaxDataUriSize, htmllibmanagerMaxage, htmllibmanagerForceCQUrlInfo, htmllibmanagerDefaultthemename, htmllibmanagerDefaultuserthemename, htmllibmanagerClientmanager, htmllibmanagerPathList, htmllibmanagerExcludedPathList, htmllibmanagerProcessorJs, htmllibmanagerProcessorCss, htmllibmanagerLongcachePatterns, htmllibmanagerLongcacheFormat, htmllibmanagerUseFileSystemOutputCache, htmllibmanagerFileSystemOutputCacheLocation, htmllibmanagerDisableReplacement)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo
   */
  def comAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeature(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Option[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureAsync(post, apply, delete, action, location, propertylist, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return Future(ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo)
   */
  def comAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Future[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo] = {
      helper.comAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeature(post, apply, delete, action, location, propertylist, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param graniteWorkflowWorkflowPublishEventServiceEnabled  (optional)
   * @return ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo
   */
  def comAdobeGraniteWorkflowConsolePublishWorkflowPublishEventService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, graniteWorkflowWorkflowPublishEventServiceEnabled: Option[Boolean] = None): Option[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceAsync(post, apply, delete, action, location, propertylist, graniteWorkflowWorkflowPublishEventServiceEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param graniteWorkflowWorkflowPublishEventServiceEnabled  (optional)
   * @return Future(ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo)
   */
  def comAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, graniteWorkflowWorkflowPublishEventServiceEnabled: Option[Boolean] = None): Future[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo] = {
      helper.comAdobeGraniteWorkflowConsolePublishWorkflowPublishEventService(post, apply, delete, action, location, propertylist, graniteWorkflowWorkflowPublishEventServiceEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param bucketSize  (optional)
   * @return ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo
   */
  def comAdobeGraniteWorkflowCoreJcrWorkflowBucketManager(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, bucketSize: Option[Integer] = None): Option[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerAsync(post, apply, delete, action, location, propertylist, bucketSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param bucketSize  (optional)
   * @return Future(ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo)
   */
  def comAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, bucketSize: Option[Integer] = None): Future[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo] = {
      helper.comAdobeGraniteWorkflowCoreJcrWorkflowBucketManager(post, apply, delete, action, location, propertylist, bucketSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultTimeout  (optional)
   * @param maxTimeout  (optional)
   * @param defaultPeriod  (optional)
   * @return ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo
   */
  def comAdobeGraniteWorkflowCoreJobExternalProcessJobHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultTimeout: Option[Integer] = None, maxTimeout: Option[Integer] = None, defaultPeriod: Option[Integer] = None): Option[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerAsync(post, apply, delete, action, location, propertylist, defaultTimeout, maxTimeout, defaultPeriod), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultTimeout  (optional)
   * @param maxTimeout  (optional)
   * @param defaultPeriod  (optional)
   * @return Future(ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo)
   */
  def comAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultTimeout: Option[Integer] = None, maxTimeout: Option[Integer] = None, defaultPeriod: Option[Integer] = None): Future[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo] = {
      helper.comAdobeGraniteWorkflowCoreJobExternalProcessJobHandler(post, apply, delete, action, location, propertylist, defaultTimeout, maxTimeout, defaultPeriod)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jobTopics  (optional)
   * @param allowSelfProcessTermination  (optional)
   * @return ComAdobeGraniteWorkflowCoreJobJobHandlerInfo
   */
  def comAdobeGraniteWorkflowCoreJobJobHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jobTopics: Option[List[String]] = None, allowSelfProcessTermination: Option[Boolean] = None): Option[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowCoreJobJobHandlerAsync(post, apply, delete, action, location, propertylist, jobTopics, allowSelfProcessTermination), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jobTopics  (optional)
   * @param allowSelfProcessTermination  (optional)
   * @return Future(ComAdobeGraniteWorkflowCoreJobJobHandlerInfo)
   */
  def comAdobeGraniteWorkflowCoreJobJobHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jobTopics: Option[List[String]] = None, allowSelfProcessTermination: Option[Boolean] = None): Future[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo] = {
      helper.comAdobeGraniteWorkflowCoreJobJobHandler(post, apply, delete, action, location, propertylist, jobTopics, allowSelfProcessTermination)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jobTopics  (optional)
   * @return ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo
   */
  def comAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsum(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jobTopics: Option[String] = None): Option[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumAsync(post, apply, delete, action, location, propertylist, jobTopics), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jobTopics  (optional)
   * @return Future(ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo)
   */
  def comAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jobTopics: Option[String] = None): Future[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo] = {
      helper.comAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsum(post, apply, delete, action, location, propertylist, jobTopics)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param getSystemWorkflowModels  (optional)
   * @param getPackageRootPath  (optional)
   * @return ComAdobeGraniteWorkflowCorePayloadMapCacheInfo
   */
  def comAdobeGraniteWorkflowCorePayloadMapCache(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, getSystemWorkflowModels: Option[List[String]] = None, getPackageRootPath: Option[String] = None): Option[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowCorePayloadMapCacheAsync(post, apply, delete, action, location, propertylist, getSystemWorkflowModels, getPackageRootPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param getSystemWorkflowModels  (optional)
   * @param getPackageRootPath  (optional)
   * @return Future(ComAdobeGraniteWorkflowCorePayloadMapCacheInfo)
   */
  def comAdobeGraniteWorkflowCorePayloadMapCacheAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, getSystemWorkflowModels: Option[List[String]] = None, getPackageRootPath: Option[String] = None): Future[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo] = {
      helper.comAdobeGraniteWorkflowCorePayloadMapCache(post, apply, delete, action, location, propertylist, getSystemWorkflowModels, getPackageRootPath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param payloadMoveWhiteList  (optional)
   * @param payloadMoveHandleFromWorkflowProcess  (optional)
   * @return ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo
   */
  def comAdobeGraniteWorkflowCorePayloadmapPayloadMoveListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, payloadMoveWhiteList: Option[List[String]] = None, payloadMoveHandleFromWorkflowProcess: Option[Boolean] = None): Option[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerAsync(post, apply, delete, action, location, propertylist, payloadMoveWhiteList, payloadMoveHandleFromWorkflowProcess), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param payloadMoveWhiteList  (optional)
   * @param payloadMoveHandleFromWorkflowProcess  (optional)
   * @return Future(ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo)
   */
  def comAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, payloadMoveWhiteList: Option[List[String]] = None, payloadMoveHandleFromWorkflowProcess: Option[Boolean] = None): Future[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo] = {
      helper.comAdobeGraniteWorkflowCorePayloadmapPayloadMoveListener(post, apply, delete, action, location, propertylist, payloadMoveWhiteList, payloadMoveHandleFromWorkflowProcess)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWorkflowConfigWorkflowPackagesRootPath  (optional)
   * @param cqWorkflowConfigWorkflowProcessLegacyMode  (optional)
   * @param cqWorkflowConfigAllowLocking  (optional)
   * @return ComAdobeGraniteWorkflowCoreWorkflowConfigInfo
   */
  def comAdobeGraniteWorkflowCoreWorkflowConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWorkflowConfigWorkflowPackagesRootPath: Option[List[String]] = None, cqWorkflowConfigWorkflowProcessLegacyMode: Option[Boolean] = None, cqWorkflowConfigAllowLocking: Option[Boolean] = None): Option[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowCoreWorkflowConfigAsync(post, apply, delete, action, location, propertylist, cqWorkflowConfigWorkflowPackagesRootPath, cqWorkflowConfigWorkflowProcessLegacyMode, cqWorkflowConfigAllowLocking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWorkflowConfigWorkflowPackagesRootPath  (optional)
   * @param cqWorkflowConfigWorkflowProcessLegacyMode  (optional)
   * @param cqWorkflowConfigAllowLocking  (optional)
   * @return Future(ComAdobeGraniteWorkflowCoreWorkflowConfigInfo)
   */
  def comAdobeGraniteWorkflowCoreWorkflowConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWorkflowConfigWorkflowPackagesRootPath: Option[List[String]] = None, cqWorkflowConfigWorkflowProcessLegacyMode: Option[Boolean] = None, cqWorkflowConfigAllowLocking: Option[Boolean] = None): Future[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo] = {
      helper.comAdobeGraniteWorkflowCoreWorkflowConfig(post, apply, delete, action, location, propertylist, cqWorkflowConfigWorkflowPackagesRootPath, cqWorkflowConfigWorkflowProcessLegacyMode, cqWorkflowConfigAllowLocking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param graniteWorkflowinboxSortPropertyName  (optional)
   * @param graniteWorkflowinboxSortOrder  (optional)
   * @param cqWorkflowJobRetry  (optional)
   * @param cqWorkflowSuperuser  (optional)
   * @param graniteWorkflowInboxQuerySize  (optional)
   * @param graniteWorkflowAdminUserGroupFilter  (optional)
   * @param graniteWorkflowEnforceWorkitemAssigneePermissions  (optional)
   * @param graniteWorkflowEnforceWorkflowInitiatorPermissions  (optional)
   * @param graniteWorkflowInjectTenantIdInJobTopics  (optional)
   * @param graniteWorkflowMaxPurgeSaveThreshold  (optional)
   * @param graniteWorkflowMaxPurgeQueryCount  (optional)
   * @return ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo
   */
  def comAdobeGraniteWorkflowCoreWorkflowSessionFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, graniteWorkflowinboxSortPropertyName: Option[String] = None, graniteWorkflowinboxSortOrder: Option[String] = None, cqWorkflowJobRetry: Option[Integer] = None, cqWorkflowSuperuser: Option[List[String]] = None, graniteWorkflowInboxQuerySize: Option[Integer] = None, graniteWorkflowAdminUserGroupFilter: Option[Boolean] = None, graniteWorkflowEnforceWorkitemAssigneePermissions: Option[Boolean] = None, graniteWorkflowEnforceWorkflowInitiatorPermissions: Option[Boolean] = None, graniteWorkflowInjectTenantIdInJobTopics: Option[Boolean] = None, graniteWorkflowMaxPurgeSaveThreshold: Option[Integer] = None, graniteWorkflowMaxPurgeQueryCount: Option[Integer] = None): Option[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowCoreWorkflowSessionFactoryAsync(post, apply, delete, action, location, propertylist, graniteWorkflowinboxSortPropertyName, graniteWorkflowinboxSortOrder, cqWorkflowJobRetry, cqWorkflowSuperuser, graniteWorkflowInboxQuerySize, graniteWorkflowAdminUserGroupFilter, graniteWorkflowEnforceWorkitemAssigneePermissions, graniteWorkflowEnforceWorkflowInitiatorPermissions, graniteWorkflowInjectTenantIdInJobTopics, graniteWorkflowMaxPurgeSaveThreshold, graniteWorkflowMaxPurgeQueryCount), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param graniteWorkflowinboxSortPropertyName  (optional)
   * @param graniteWorkflowinboxSortOrder  (optional)
   * @param cqWorkflowJobRetry  (optional)
   * @param cqWorkflowSuperuser  (optional)
   * @param graniteWorkflowInboxQuerySize  (optional)
   * @param graniteWorkflowAdminUserGroupFilter  (optional)
   * @param graniteWorkflowEnforceWorkitemAssigneePermissions  (optional)
   * @param graniteWorkflowEnforceWorkflowInitiatorPermissions  (optional)
   * @param graniteWorkflowInjectTenantIdInJobTopics  (optional)
   * @param graniteWorkflowMaxPurgeSaveThreshold  (optional)
   * @param graniteWorkflowMaxPurgeQueryCount  (optional)
   * @return Future(ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo)
   */
  def comAdobeGraniteWorkflowCoreWorkflowSessionFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, graniteWorkflowinboxSortPropertyName: Option[String] = None, graniteWorkflowinboxSortOrder: Option[String] = None, cqWorkflowJobRetry: Option[Integer] = None, cqWorkflowSuperuser: Option[List[String]] = None, graniteWorkflowInboxQuerySize: Option[Integer] = None, graniteWorkflowAdminUserGroupFilter: Option[Boolean] = None, graniteWorkflowEnforceWorkitemAssigneePermissions: Option[Boolean] = None, graniteWorkflowEnforceWorkflowInitiatorPermissions: Option[Boolean] = None, graniteWorkflowInjectTenantIdInJobTopics: Option[Boolean] = None, graniteWorkflowMaxPurgeSaveThreshold: Option[Integer] = None, graniteWorkflowMaxPurgeQueryCount: Option[Integer] = None): Future[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo] = {
      helper.comAdobeGraniteWorkflowCoreWorkflowSessionFactory(post, apply, delete, action, location, propertylist, graniteWorkflowinboxSortPropertyName, graniteWorkflowinboxSortOrder, cqWorkflowJobRetry, cqWorkflowSuperuser, graniteWorkflowInboxQuerySize, graniteWorkflowAdminUserGroupFilter, graniteWorkflowEnforceWorkitemAssigneePermissions, graniteWorkflowEnforceWorkflowInitiatorPermissions, graniteWorkflowInjectTenantIdInJobTopics, graniteWorkflowMaxPurgeSaveThreshold, graniteWorkflowMaxPurgeQueryCount)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param scheduledpurgeName  (optional)
   * @param scheduledpurgeWorkflowStatus  (optional)
   * @param scheduledpurgeModelIds  (optional)
   * @param scheduledpurgeDaysold  (optional)
   * @return ComAdobeGraniteWorkflowPurgeSchedulerInfo
   */
  def comAdobeGraniteWorkflowPurgeScheduler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, scheduledpurgeName: Option[String] = None, scheduledpurgeWorkflowStatus: Option[String] = None, scheduledpurgeModelIds: Option[List[String]] = None, scheduledpurgeDaysold: Option[Integer] = None): Option[ComAdobeGraniteWorkflowPurgeSchedulerInfo] = {
    val await = Try(Await.result(comAdobeGraniteWorkflowPurgeSchedulerAsync(post, apply, delete, action, location, propertylist, scheduledpurgeName, scheduledpurgeWorkflowStatus, scheduledpurgeModelIds, scheduledpurgeDaysold), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param scheduledpurgeName  (optional)
   * @param scheduledpurgeWorkflowStatus  (optional)
   * @param scheduledpurgeModelIds  (optional)
   * @param scheduledpurgeDaysold  (optional)
   * @return Future(ComAdobeGraniteWorkflowPurgeSchedulerInfo)
   */
  def comAdobeGraniteWorkflowPurgeSchedulerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, scheduledpurgeName: Option[String] = None, scheduledpurgeWorkflowStatus: Option[String] = None, scheduledpurgeModelIds: Option[List[String]] = None, scheduledpurgeDaysold: Option[Integer] = None): Future[ComAdobeGraniteWorkflowPurgeSchedulerInfo] = {
      helper.comAdobeGraniteWorkflowPurgeScheduler(post, apply, delete, action, location, propertylist, scheduledpurgeName, scheduledpurgeWorkflowStatus, scheduledpurgeModelIds, scheduledpurgeDaysold)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxConnections  (optional)
   * @param maxRequests  (optional)
   * @param requestTimeout  (optional)
   * @param requestRetries  (optional)
   * @param launchTimeout  (optional)
   * @return ComAdobeOctopusNcommBootstrapInfo
   */
  def comAdobeOctopusNcommBootstrap(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxConnections: Option[Integer] = None, maxRequests: Option[Integer] = None, requestTimeout: Option[Integer] = None, requestRetries: Option[Integer] = None, launchTimeout: Option[Integer] = None): Option[ComAdobeOctopusNcommBootstrapInfo] = {
    val await = Try(Await.result(comAdobeOctopusNcommBootstrapAsync(post, apply, delete, action, location, propertylist, maxConnections, maxRequests, requestTimeout, requestRetries, launchTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxConnections  (optional)
   * @param maxRequests  (optional)
   * @param requestTimeout  (optional)
   * @param requestRetries  (optional)
   * @param launchTimeout  (optional)
   * @return Future(ComAdobeOctopusNcommBootstrapInfo)
   */
  def comAdobeOctopusNcommBootstrapAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxConnections: Option[Integer] = None, maxRequests: Option[Integer] = None, requestTimeout: Option[Integer] = None, requestRetries: Option[Integer] = None, launchTimeout: Option[Integer] = None): Future[ComAdobeOctopusNcommBootstrapInfo] = {
      helper.comAdobeOctopusNcommBootstrap(post, apply, delete, action, location, propertylist, maxConnections, maxRequests, requestTimeout, requestRetries, launchTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param communitiesIntegrationLivefyreSlingEventFilter  (optional)
   * @return ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo
   */
  def comAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullS(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, communitiesIntegrationLivefyreSlingEventFilter: Option[String] = None): Option[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo] = {
    val await = Try(Await.result(comAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSAsync(post, apply, delete, action, location, propertylist, communitiesIntegrationLivefyreSlingEventFilter), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param communitiesIntegrationLivefyreSlingEventFilter  (optional)
   * @return Future(ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo)
   */
  def comAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, communitiesIntegrationLivefyreSlingEventFilter: Option[String] = None): Future[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo] = {
      helper.comAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullS(post, apply, delete, action, location, propertylist, communitiesIntegrationLivefyreSlingEventFilter)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxConnections  (optional)
   * @param maxRequests  (optional)
   * @param requestTimeout  (optional)
   * @param logDir  (optional)
   * @return ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo
   */
  def comAdobeXmpWorkerFilesNcommXMPFilesNComm(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxConnections: Option[String] = None, maxRequests: Option[String] = None, requestTimeout: Option[String] = None, logDir: Option[String] = None): Option[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo] = {
    val await = Try(Await.result(comAdobeXmpWorkerFilesNcommXMPFilesNCommAsync(post, apply, delete, action, location, propertylist, maxConnections, maxRequests, requestTimeout, logDir), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxConnections  (optional)
   * @param maxRequests  (optional)
   * @param requestTimeout  (optional)
   * @param logDir  (optional)
   * @return Future(ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo)
   */
  def comAdobeXmpWorkerFilesNcommXMPFilesNCommAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxConnections: Option[String] = None, maxRequests: Option[String] = None, requestTimeout: Option[String] = None, logDir: Option[String] = None): Future[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo] = {
      helper.comAdobeXmpWorkerFilesNcommXMPFilesNComm(post, apply, delete, action, location, propertylist, maxConnections, maxRequests, requestTimeout, logDir)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jdbcDriverClass  (optional)
   * @param jdbcConnectionUri  (optional)
   * @param jdbcUsername  (optional)
   * @param jdbcPassword  (optional)
   * @param jdbcValidationQuery  (optional)
   * @param defaultReadonly  (optional)
   * @param defaultAutocommit  (optional)
   * @param poolSize  (optional)
   * @param poolMaxWaitMsec  (optional)
   * @param datasourceName  (optional)
   * @param datasourceSvcProperties  (optional)
   * @return ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo
   */
  def comDayCommonsDatasourceJdbcpoolJdbcPoolService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jdbcDriverClass: Option[String] = None, jdbcConnectionUri: Option[String] = None, jdbcUsername: Option[String] = None, jdbcPassword: Option[String] = None, jdbcValidationQuery: Option[String] = None, defaultReadonly: Option[Boolean] = None, defaultAutocommit: Option[Boolean] = None, poolSize: Option[Integer] = None, poolMaxWaitMsec: Option[Integer] = None, datasourceName: Option[String] = None, datasourceSvcProperties: Option[List[String]] = None): Option[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo] = {
    val await = Try(Await.result(comDayCommonsDatasourceJdbcpoolJdbcPoolServiceAsync(post, apply, delete, action, location, propertylist, jdbcDriverClass, jdbcConnectionUri, jdbcUsername, jdbcPassword, jdbcValidationQuery, defaultReadonly, defaultAutocommit, poolSize, poolMaxWaitMsec, datasourceName, datasourceSvcProperties), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jdbcDriverClass  (optional)
   * @param jdbcConnectionUri  (optional)
   * @param jdbcUsername  (optional)
   * @param jdbcPassword  (optional)
   * @param jdbcValidationQuery  (optional)
   * @param defaultReadonly  (optional)
   * @param defaultAutocommit  (optional)
   * @param poolSize  (optional)
   * @param poolMaxWaitMsec  (optional)
   * @param datasourceName  (optional)
   * @param datasourceSvcProperties  (optional)
   * @return Future(ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo)
   */
  def comDayCommonsDatasourceJdbcpoolJdbcPoolServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jdbcDriverClass: Option[String] = None, jdbcConnectionUri: Option[String] = None, jdbcUsername: Option[String] = None, jdbcPassword: Option[String] = None, jdbcValidationQuery: Option[String] = None, defaultReadonly: Option[Boolean] = None, defaultAutocommit: Option[Boolean] = None, poolSize: Option[Integer] = None, poolMaxWaitMsec: Option[Integer] = None, datasourceName: Option[String] = None, datasourceSvcProperties: Option[List[String]] = None): Future[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo] = {
      helper.comDayCommonsDatasourceJdbcpoolJdbcPoolService(post, apply, delete, action, location, propertylist, jdbcDriverClass, jdbcConnectionUri, jdbcUsername, jdbcPassword, jdbcValidationQuery, defaultReadonly, defaultAutocommit, poolSize, poolMaxWaitMsec, datasourceName, datasourceSvcProperties)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param proxyEnabled  (optional)
   * @param proxyHost  (optional)
   * @param proxyUser  (optional)
   * @param proxyPassword  (optional)
   * @param proxyNtlmHost  (optional)
   * @param proxyNtlmDomain  (optional)
   * @param proxyExceptions  (optional)
   * @return ComDayCommonsHttpclientInfo
   */
  def comDayCommonsHttpclient(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, proxyEnabled: Option[Boolean] = None, proxyHost: Option[String] = None, proxyUser: Option[String] = None, proxyPassword: Option[String] = None, proxyNtlmHost: Option[String] = None, proxyNtlmDomain: Option[String] = None, proxyExceptions: Option[List[String]] = None): Option[ComDayCommonsHttpclientInfo] = {
    val await = Try(Await.result(comDayCommonsHttpclientAsync(post, apply, delete, action, location, propertylist, proxyEnabled, proxyHost, proxyUser, proxyPassword, proxyNtlmHost, proxyNtlmDomain, proxyExceptions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param proxyEnabled  (optional)
   * @param proxyHost  (optional)
   * @param proxyUser  (optional)
   * @param proxyPassword  (optional)
   * @param proxyNtlmHost  (optional)
   * @param proxyNtlmDomain  (optional)
   * @param proxyExceptions  (optional)
   * @return Future(ComDayCommonsHttpclientInfo)
   */
  def comDayCommonsHttpclientAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, proxyEnabled: Option[Boolean] = None, proxyHost: Option[String] = None, proxyUser: Option[String] = None, proxyPassword: Option[String] = None, proxyNtlmHost: Option[String] = None, proxyNtlmDomain: Option[String] = None, proxyExceptions: Option[List[String]] = None): Future[ComDayCommonsHttpclientInfo] = {
      helper.comDayCommonsHttpclient(post, apply, delete, action, location, propertylist, proxyEnabled, proxyHost, proxyUser, proxyPassword, proxyNtlmHost, proxyNtlmDomain, proxyExceptions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqStoreListenerAdditionalStorePaths  (optional)
   * @return ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo
   */
  def comDayCqAnalyticsImplStorePropertiesChangeListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqStoreListenerAdditionalStorePaths: Option[List[String]] = None): Option[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsImplStorePropertiesChangeListenerAsync(post, apply, delete, action, location, propertylist, cqStoreListenerAdditionalStorePaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqStoreListenerAdditionalStorePaths  (optional)
   * @return Future(ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo)
   */
  def comDayCqAnalyticsImplStorePropertiesChangeListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqStoreListenerAdditionalStorePaths: Option[List[String]] = None): Future[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo] = {
      helper.comDayCqAnalyticsImplStorePropertiesChangeListener(post, apply, delete, action, location, propertylist, cqStoreListenerAdditionalStorePaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param allowedPaths  (optional)
   * @param cqAnalyticsSaintExporterPagesize  (optional)
   * @return ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo
   */
  def comDayCqAnalyticsSitecatalystImplExporterClassificationsExporte(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, allowedPaths: Option[List[String]] = None, cqAnalyticsSaintExporterPagesize: Option[Integer] = None): Option[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsSitecatalystImplExporterClassificationsExporteAsync(post, apply, delete, action, location, propertylist, allowedPaths, cqAnalyticsSaintExporterPagesize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param allowedPaths  (optional)
   * @param cqAnalyticsSaintExporterPagesize  (optional)
   * @return Future(ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo)
   */
  def comDayCqAnalyticsSitecatalystImplExporterClassificationsExporteAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, allowedPaths: Option[List[String]] = None, cqAnalyticsSaintExporterPagesize: Option[Integer] = None): Future[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo] = {
      helper.comDayCqAnalyticsSitecatalystImplExporterClassificationsExporte(post, apply, delete, action, location, propertylist, allowedPaths, cqAnalyticsSaintExporterPagesize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param reportFetchAttempts  (optional)
   * @param reportFetchDelay  (optional)
   * @return ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo
   */
  def comDayCqAnalyticsSitecatalystImplImporterReportImporter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, reportFetchAttempts: Option[Integer] = None, reportFetchDelay: Option[Integer] = None): Option[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsSitecatalystImplImporterReportImporterAsync(post, apply, delete, action, location, propertylist, reportFetchAttempts, reportFetchDelay), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param reportFetchAttempts  (optional)
   * @param reportFetchDelay  (optional)
   * @return Future(ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo)
   */
  def comDayCqAnalyticsSitecatalystImplImporterReportImporterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, reportFetchAttempts: Option[Integer] = None, reportFetchDelay: Option[Integer] = None): Future[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo] = {
      helper.comDayCqAnalyticsSitecatalystImplImporterReportImporter(post, apply, delete, action, location, propertylist, reportFetchAttempts, reportFetchDelay)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsAdapterfactoryContextstores  (optional)
   * @return ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo
   */
  def comDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsAdapterfactoryContextstores: Option[List[String]] = None): Option[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryAsync(post, apply, delete, action, location, propertylist, cqAnalyticsAdapterfactoryContextstores), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsAdapterfactoryContextstores  (optional)
   * @return Future(ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo)
   */
  def comDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsAdapterfactoryContextstores: Option[List[String]] = None): Future[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo] = {
      helper.comDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactory(post, apply, delete, action, location, propertylist, cqAnalyticsAdapterfactoryContextstores)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsSitecatalystServiceDatacenterUrl  (optional)
   * @param devhostnamepatterns  (optional)
   * @param connectionTimeout  (optional)
   * @param socketTimeout  (optional)
   * @return ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo
   */
  def comDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsSitecatalystServiceDatacenterUrl: Option[List[String]] = None, devhostnamepatterns: Option[List[String]] = None, connectionTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None): Option[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplAsync(post, apply, delete, action, location, propertylist, cqAnalyticsSitecatalystServiceDatacenterUrl, devhostnamepatterns, connectionTimeout, socketTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsSitecatalystServiceDatacenterUrl  (optional)
   * @param devhostnamepatterns  (optional)
   * @param connectionTimeout  (optional)
   * @param socketTimeout  (optional)
   * @return Future(ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo)
   */
  def comDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsSitecatalystServiceDatacenterUrl: Option[List[String]] = None, devhostnamepatterns: Option[List[String]] = None, connectionTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None): Future[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo] = {
      helper.comDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImpl(post, apply, delete, action, location, propertylist, cqAnalyticsSitecatalystServiceDatacenterUrl, devhostnamepatterns, connectionTimeout, socketTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsTestandtargetAccountoptionsupdaterEnabled  (optional)
   * @return ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo
   */
  def comDayCqAnalyticsTestandtargetImplAccountOptionsUpdater(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsTestandtargetAccountoptionsupdaterEnabled: Option[Boolean] = None): Option[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterAsync(post, apply, delete, action, location, propertylist, cqAnalyticsTestandtargetAccountoptionsupdaterEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsTestandtargetAccountoptionsupdaterEnabled  (optional)
   * @return Future(ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo)
   */
  def comDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsTestandtargetAccountoptionsupdaterEnabled: Option[Boolean] = None): Future[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo] = {
      helper.comDayCqAnalyticsTestandtargetImplAccountOptionsUpdater(post, apply, delete, action, location, propertylist, cqAnalyticsTestandtargetAccountoptionsupdaterEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled  (optional)
   * @return ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo
   */
  def comDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled: Option[Boolean] = None): Option[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerAsync(post, apply, delete, action, location, propertylist, cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled  (optional)
   * @return Future(ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo)
   */
  def comDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled: Option[Boolean] = None): Future[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo] = {
      helper.comDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListener(post, apply, delete, action, location, propertylist, cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled  (optional)
   * @return ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo
   */
  def comDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled: Option[Boolean] = None): Option[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerAsync(post, apply, delete, action, location, propertylist, cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled  (optional)
   * @return Future(ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo)
   */
  def comDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled: Option[Boolean] = None): Future[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo] = {
      helper.comDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListener(post, apply, delete, action, location, propertylist, cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsTestandtargetSegmentimporterEnabled  (optional)
   * @return ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo
   */
  def comDayCqAnalyticsTestandtargetImplSegmentImporter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsTestandtargetSegmentimporterEnabled: Option[Boolean] = None): Option[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsTestandtargetImplSegmentImporterAsync(post, apply, delete, action, location, propertylist, cqAnalyticsTestandtargetSegmentimporterEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsTestandtargetSegmentimporterEnabled  (optional)
   * @return Future(ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo)
   */
  def comDayCqAnalyticsTestandtargetImplSegmentImporterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsTestandtargetSegmentimporterEnabled: Option[Boolean] = None): Future[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo] = {
      helper.comDayCqAnalyticsTestandtargetImplSegmentImporter(post, apply, delete, action, location, propertylist, cqAnalyticsTestandtargetSegmentimporterEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param endpointUri  (optional)
   * @param connectionTimeout  (optional)
   * @param socketTimeout  (optional)
   * @return ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo
   */
  def comDayCqAnalyticsTestandtargetImplServiceWebServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, endpointUri: Option[String] = None, connectionTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None): Option[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsTestandtargetImplServiceWebServiceImplAsync(post, apply, delete, action, location, propertylist, endpointUri, connectionTimeout, socketTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param endpointUri  (optional)
   * @param connectionTimeout  (optional)
   * @param socketTimeout  (optional)
   * @return Future(ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo)
   */
  def comDayCqAnalyticsTestandtargetImplServiceWebServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, endpointUri: Option[String] = None, connectionTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None): Future[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo] = {
      helper.comDayCqAnalyticsTestandtargetImplServiceWebServiceImpl(post, apply, delete, action, location, propertylist, endpointUri, connectionTimeout, socketTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param testandtargetEndpointUrl  (optional)
   * @return ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo
   */
  def comDayCqAnalyticsTestandtargetImplServletsAdminServerServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, testandtargetEndpointUrl: Option[String] = None): Option[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsTestandtargetImplServletsAdminServerServletAsync(post, apply, delete, action, location, propertylist, testandtargetEndpointUrl), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param testandtargetEndpointUrl  (optional)
   * @return Future(ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo)
   */
  def comDayCqAnalyticsTestandtargetImplServletsAdminServerServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, testandtargetEndpointUrl: Option[String] = None): Future[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo] = {
      helper.comDayCqAnalyticsTestandtargetImplServletsAdminServerServlet(post, apply, delete, action, location, propertylist, testandtargetEndpointUrl)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsTestandtargetApiUrl  (optional)
   * @param cqAnalyticsTestandtargetTimeout  (optional)
   * @param cqAnalyticsTestandtargetSockettimeout  (optional)
   * @param cqAnalyticsTestandtargetRecommendationsUrlReplace  (optional)
   * @param cqAnalyticsTestandtargetRecommendationsUrlReplacewith  (optional)
   * @return ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo
   */
  def comDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsTestandtargetApiUrl: Option[String] = None, cqAnalyticsTestandtargetTimeout: Option[Integer] = None, cqAnalyticsTestandtargetSockettimeout: Option[Integer] = None, cqAnalyticsTestandtargetRecommendationsUrlReplace: Option[String] = None, cqAnalyticsTestandtargetRecommendationsUrlReplacewith: Option[String] = None): Option[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo] = {
    val await = Try(Await.result(comDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplAsync(post, apply, delete, action, location, propertylist, cqAnalyticsTestandtargetApiUrl, cqAnalyticsTestandtargetTimeout, cqAnalyticsTestandtargetSockettimeout, cqAnalyticsTestandtargetRecommendationsUrlReplace, cqAnalyticsTestandtargetRecommendationsUrlReplacewith), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAnalyticsTestandtargetApiUrl  (optional)
   * @param cqAnalyticsTestandtargetTimeout  (optional)
   * @param cqAnalyticsTestandtargetSockettimeout  (optional)
   * @param cqAnalyticsTestandtargetRecommendationsUrlReplace  (optional)
   * @param cqAnalyticsTestandtargetRecommendationsUrlReplacewith  (optional)
   * @return Future(ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo)
   */
  def comDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAnalyticsTestandtargetApiUrl: Option[String] = None, cqAnalyticsTestandtargetTimeout: Option[Integer] = None, cqAnalyticsTestandtargetSockettimeout: Option[Integer] = None, cqAnalyticsTestandtargetRecommendationsUrlReplace: Option[String] = None, cqAnalyticsTestandtargetRecommendationsUrlReplacewith: Option[String] = None): Future[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo] = {
      helper.comDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImpl(post, apply, delete, action, location, propertylist, cqAnalyticsTestandtargetApiUrl, cqAnalyticsTestandtargetTimeout, cqAnalyticsTestandtargetSockettimeout, cqAnalyticsTestandtargetRecommendationsUrlReplace, cqAnalyticsTestandtargetRecommendationsUrlReplacewith)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cugExemptedPrincipals  (optional)
   * @param cugEnabled  (optional)
   * @param cugPrincipalsRegex  (optional)
   * @param cugPrincipalsReplacement  (optional)
   * @return ComDayCqAuthImplCugCugSupportImplInfo
   */
  def comDayCqAuthImplCugCugSupportImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cugExemptedPrincipals: Option[List[String]] = None, cugEnabled: Option[Boolean] = None, cugPrincipalsRegex: Option[String] = None, cugPrincipalsReplacement: Option[String] = None): Option[ComDayCqAuthImplCugCugSupportImplInfo] = {
    val await = Try(Await.result(comDayCqAuthImplCugCugSupportImplAsync(post, apply, delete, action, location, propertylist, cugExemptedPrincipals, cugEnabled, cugPrincipalsRegex, cugPrincipalsReplacement), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cugExemptedPrincipals  (optional)
   * @param cugEnabled  (optional)
   * @param cugPrincipalsRegex  (optional)
   * @param cugPrincipalsReplacement  (optional)
   * @return Future(ComDayCqAuthImplCugCugSupportImplInfo)
   */
  def comDayCqAuthImplCugCugSupportImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cugExemptedPrincipals: Option[List[String]] = None, cugEnabled: Option[Boolean] = None, cugPrincipalsRegex: Option[String] = None, cugPrincipalsReplacement: Option[String] = None): Future[ComDayCqAuthImplCugCugSupportImplInfo] = {
      helper.comDayCqAuthImplCugCugSupportImpl(post, apply, delete, action, location, propertylist, cugExemptedPrincipals, cugEnabled, cugPrincipalsRegex, cugPrincipalsReplacement)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param serviceRanking  (optional)
   * @param authLoginselectorMappings  (optional)
   * @param authLoginselectorChangepwMappings  (optional)
   * @param authLoginselectorDefaultloginpage  (optional)
   * @param authLoginselectorDefaultchangepwpage  (optional)
   * @param authLoginselectorHandle  (optional)
   * @param authLoginselectorHandleAllExtensions  (optional)
   * @return ComDayCqAuthImplLoginSelectorHandlerInfo
   */
  def comDayCqAuthImplLoginSelectorHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, serviceRanking: Option[Integer] = None, authLoginselectorMappings: Option[List[String]] = None, authLoginselectorChangepwMappings: Option[List[String]] = None, authLoginselectorDefaultloginpage: Option[String] = None, authLoginselectorDefaultchangepwpage: Option[String] = None, authLoginselectorHandle: Option[List[String]] = None, authLoginselectorHandleAllExtensions: Option[Boolean] = None): Option[ComDayCqAuthImplLoginSelectorHandlerInfo] = {
    val await = Try(Await.result(comDayCqAuthImplLoginSelectorHandlerAsync(post, apply, delete, action, location, propertylist, `path`, serviceRanking, authLoginselectorMappings, authLoginselectorChangepwMappings, authLoginselectorDefaultloginpage, authLoginselectorDefaultchangepwpage, authLoginselectorHandle, authLoginselectorHandleAllExtensions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param serviceRanking  (optional)
   * @param authLoginselectorMappings  (optional)
   * @param authLoginselectorChangepwMappings  (optional)
   * @param authLoginselectorDefaultloginpage  (optional)
   * @param authLoginselectorDefaultchangepwpage  (optional)
   * @param authLoginselectorHandle  (optional)
   * @param authLoginselectorHandleAllExtensions  (optional)
   * @return Future(ComDayCqAuthImplLoginSelectorHandlerInfo)
   */
  def comDayCqAuthImplLoginSelectorHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, serviceRanking: Option[Integer] = None, authLoginselectorMappings: Option[List[String]] = None, authLoginselectorChangepwMappings: Option[List[String]] = None, authLoginselectorDefaultloginpage: Option[String] = None, authLoginselectorDefaultchangepwpage: Option[String] = None, authLoginselectorHandle: Option[List[String]] = None, authLoginselectorHandleAllExtensions: Option[Boolean] = None): Future[ComDayCqAuthImplLoginSelectorHandlerInfo] = {
      helper.comDayCqAuthImplLoginSelectorHandler(post, apply, delete, action, location, propertylist, `path`, serviceRanking, authLoginselectorMappings, authLoginselectorChangepwMappings, authLoginselectorDefaultloginpage, authLoginselectorDefaultchangepwpage, authLoginselectorHandle, authLoginselectorHandleAllExtensions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param externalizerDomains  (optional)
   * @param externalizerHost  (optional)
   * @param externalizerContextpath  (optional)
   * @param externalizerEncodedpath  (optional)
   * @return ComDayCqCommonsImplExternalizerImplInfo
   */
  def comDayCqCommonsImplExternalizerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, externalizerDomains: Option[List[String]] = None, externalizerHost: Option[String] = None, externalizerContextpath: Option[String] = None, externalizerEncodedpath: Option[Boolean] = None): Option[ComDayCqCommonsImplExternalizerImplInfo] = {
    val await = Try(Await.result(comDayCqCommonsImplExternalizerImplAsync(post, apply, delete, action, location, propertylist, externalizerDomains, externalizerHost, externalizerContextpath, externalizerEncodedpath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param externalizerDomains  (optional)
   * @param externalizerHost  (optional)
   * @param externalizerContextpath  (optional)
   * @param externalizerEncodedpath  (optional)
   * @return Future(ComDayCqCommonsImplExternalizerImplInfo)
   */
  def comDayCqCommonsImplExternalizerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, externalizerDomains: Option[List[String]] = None, externalizerHost: Option[String] = None, externalizerContextpath: Option[String] = None, externalizerEncodedpath: Option[Boolean] = None): Future[ComDayCqCommonsImplExternalizerImplInfo] = {
      helper.comDayCqCommonsImplExternalizerImpl(post, apply, delete, action, location, propertylist, externalizerDomains, externalizerHost, externalizerContextpath, externalizerEncodedpath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param rootmappingTarget  (optional)
   * @return ComDayCqCommonsServletsRootMappingServletInfo
   */
  def comDayCqCommonsServletsRootMappingServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, rootmappingTarget: Option[String] = None): Option[ComDayCqCommonsServletsRootMappingServletInfo] = {
    val await = Try(Await.result(comDayCqCommonsServletsRootMappingServletAsync(post, apply, delete, action, location, propertylist, rootmappingTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param rootmappingTarget  (optional)
   * @return Future(ComDayCqCommonsServletsRootMappingServletInfo)
   */
  def comDayCqCommonsServletsRootMappingServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, rootmappingTarget: Option[String] = None): Future[ComDayCqCommonsServletsRootMappingServletInfo] = {
      helper.comDayCqCommonsServletsRootMappingServlet(post, apply, delete, action, location, propertylist, rootmappingTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param codeupgradetasks  (optional)
   * @param codeupgradetaskfilters  (optional)
   * @return ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo
   */
  def comDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionChecke(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, codeupgradetasks: Option[List[String]] = None, codeupgradetaskfilters: Option[List[String]] = None): Option[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo] = {
    val await = Try(Await.result(comDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeAsync(post, apply, delete, action, location, propertylist, codeupgradetasks, codeupgradetaskfilters), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param codeupgradetasks  (optional)
   * @param codeupgradetaskfilters  (optional)
   * @return Future(ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo)
   */
  def comDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, codeupgradetasks: Option[List[String]] = None, codeupgradetaskfilters: Option[List[String]] = None): Future[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo] = {
      helper.comDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionChecke(post, apply, delete, action, location, propertylist, codeupgradetasks, codeupgradetaskfilters)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param upgradeTaskIgnoreList  (optional)
   * @return ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo
   */
  def comDayCqCompatCodeupgradeImplUpgradeTaskIgnoreList(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, upgradeTaskIgnoreList: Option[List[String]] = None): Option[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo] = {
    val await = Try(Await.result(comDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListAsync(post, apply, delete, action, location, propertylist, upgradeTaskIgnoreList), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param upgradeTaskIgnoreList  (optional)
   * @return Future(ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo)
   */
  def comDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, upgradeTaskIgnoreList: Option[List[String]] = None): Future[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo] = {
      helper.comDayCqCompatCodeupgradeImplUpgradeTaskIgnoreList(post, apply, delete, action, location, propertylist, upgradeTaskIgnoreList)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param effectiveBundleListPath  (optional)
   * @return ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo
   */
  def comDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelist(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, effectiveBundleListPath: Option[String] = None): Option[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo] = {
    val await = Try(Await.result(comDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistAsync(post, apply, delete, action, location, propertylist, effectiveBundleListPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param effectiveBundleListPath  (optional)
   * @return Future(ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo)
   */
  def comDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, effectiveBundleListPath: Option[String] = None): Future[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo] = {
      helper.comDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelist(post, apply, delete, action, location, propertylist, effectiveBundleListPath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param contentsyncFallbackAuthorizable  (optional)
   * @param contentsyncFallbackUpdateuser  (optional)
   * @return ComDayCqContentsyncImplContentSyncManagerImplInfo
   */
  def comDayCqContentsyncImplContentSyncManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, contentsyncFallbackAuthorizable: Option[String] = None, contentsyncFallbackUpdateuser: Option[String] = None): Option[ComDayCqContentsyncImplContentSyncManagerImplInfo] = {
    val await = Try(Await.result(comDayCqContentsyncImplContentSyncManagerImplAsync(post, apply, delete, action, location, propertylist, contentsyncFallbackAuthorizable, contentsyncFallbackUpdateuser), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param contentsyncFallbackAuthorizable  (optional)
   * @param contentsyncFallbackUpdateuser  (optional)
   * @return Future(ComDayCqContentsyncImplContentSyncManagerImplInfo)
   */
  def comDayCqContentsyncImplContentSyncManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, contentsyncFallbackAuthorizable: Option[String] = None, contentsyncFallbackUpdateuser: Option[String] = None): Future[ComDayCqContentsyncImplContentSyncManagerImplInfo] = {
      helper.comDayCqContentsyncImplContentSyncManagerImpl(post, apply, delete, action, location, propertylist, contentsyncFallbackAuthorizable, contentsyncFallbackUpdateuser)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param largeFileThreshold  (optional)
   * @param largeCommentThreshold  (optional)
   * @param cqDamEnableExtMetaExtraction  (optional)
   * @return ComDayCqDamCommonsHandlerStandardImageHandlerInfo
   */
  def comDayCqDamCommonsHandlerStandardImageHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, largeFileThreshold: Option[Integer] = None, largeCommentThreshold: Option[Integer] = None, cqDamEnableExtMetaExtraction: Option[Boolean] = None): Option[ComDayCqDamCommonsHandlerStandardImageHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamCommonsHandlerStandardImageHandlerAsync(post, apply, delete, action, location, propertylist, largeFileThreshold, largeCommentThreshold, cqDamEnableExtMetaExtraction), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param largeFileThreshold  (optional)
   * @param largeCommentThreshold  (optional)
   * @param cqDamEnableExtMetaExtraction  (optional)
   * @return Future(ComDayCqDamCommonsHandlerStandardImageHandlerInfo)
   */
  def comDayCqDamCommonsHandlerStandardImageHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, largeFileThreshold: Option[Integer] = None, largeCommentThreshold: Option[Integer] = None, cqDamEnableExtMetaExtraction: Option[Boolean] = None): Future[ComDayCqDamCommonsHandlerStandardImageHandlerInfo] = {
      helper.comDayCqDamCommonsHandlerStandardImageHandler(post, apply, delete, action, location, propertylist, largeFileThreshold, largeCommentThreshold, cqDamEnableExtMetaExtraction)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param xmpFilterApplyWhitelist  (optional)
   * @param xmpFilterWhitelist  (optional)
   * @param xmpFilterApplyBlacklist  (optional)
   * @param xmpFilterBlacklist  (optional)
   * @return ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo
   */
  def comDayCqDamCommonsMetadataXmpFilterBlackWhite(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, xmpFilterApplyWhitelist: Option[Boolean] = None, xmpFilterWhitelist: Option[List[String]] = None, xmpFilterApplyBlacklist: Option[Boolean] = None, xmpFilterBlacklist: Option[List[String]] = None): Option[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo] = {
    val await = Try(Await.result(comDayCqDamCommonsMetadataXmpFilterBlackWhiteAsync(post, apply, delete, action, location, propertylist, xmpFilterApplyWhitelist, xmpFilterWhitelist, xmpFilterApplyBlacklist, xmpFilterBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param xmpFilterApplyWhitelist  (optional)
   * @param xmpFilterWhitelist  (optional)
   * @param xmpFilterApplyBlacklist  (optional)
   * @param xmpFilterBlacklist  (optional)
   * @return Future(ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo)
   */
  def comDayCqDamCommonsMetadataXmpFilterBlackWhiteAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, xmpFilterApplyWhitelist: Option[Boolean] = None, xmpFilterWhitelist: Option[List[String]] = None, xmpFilterApplyBlacklist: Option[Boolean] = None, xmpFilterBlacklist: Option[List[String]] = None): Future[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo] = {
      helper.comDayCqDamCommonsMetadataXmpFilterBlackWhite(post, apply, delete, action, location, propertylist, xmpFilterApplyWhitelist, xmpFilterWhitelist, xmpFilterApplyBlacklist, xmpFilterBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param largeFileMin  (optional)
   * @param cacheApply  (optional)
   * @param mimeTypes  (optional)
   * @return ComDayCqDamCommonsUtilImplAssetCacheImplInfo
   */
  def comDayCqDamCommonsUtilImplAssetCacheImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, largeFileMin: Option[Integer] = None, cacheApply: Option[Boolean] = None, mimeTypes: Option[List[String]] = None): Option[ComDayCqDamCommonsUtilImplAssetCacheImplInfo] = {
    val await = Try(Await.result(comDayCqDamCommonsUtilImplAssetCacheImplAsync(post, apply, delete, action, location, propertylist, largeFileMin, cacheApply, mimeTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param largeFileMin  (optional)
   * @param cacheApply  (optional)
   * @param mimeTypes  (optional)
   * @return Future(ComDayCqDamCommonsUtilImplAssetCacheImplInfo)
   */
  def comDayCqDamCommonsUtilImplAssetCacheImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, largeFileMin: Option[Integer] = None, cacheApply: Option[Boolean] = None, mimeTypes: Option[List[String]] = None): Future[ComDayCqDamCommonsUtilImplAssetCacheImplInfo] = {
      helper.comDayCqDamCommonsUtilImplAssetCacheImpl(post, apply, delete, action, location, propertylist, largeFileMin, cacheApply, mimeTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamConfigAnnotationPdfDocumentWidth  (optional)
   * @param cqDamConfigAnnotationPdfDocumentHeight  (optional)
   * @param cqDamConfigAnnotationPdfDocumentPaddingHorizontal  (optional)
   * @param cqDamConfigAnnotationPdfDocumentPaddingVertical  (optional)
   * @param cqDamConfigAnnotationPdfFontSize  (optional)
   * @param cqDamConfigAnnotationPdfFontColor  (optional)
   * @param cqDamConfigAnnotationPdfFontFamily  (optional)
   * @param cqDamConfigAnnotationPdfFontLight  (optional)
   * @param cqDamConfigAnnotationPdfMarginTextImage  (optional)
   * @param cqDamConfigAnnotationPdfMinImageHeight  (optional)
   * @param cqDamConfigAnnotationPdfReviewStatusWidth  (optional)
   * @param cqDamConfigAnnotationPdfReviewStatusColorApproved  (optional)
   * @param cqDamConfigAnnotationPdfReviewStatusColorRejected  (optional)
   * @param cqDamConfigAnnotationPdfReviewStatusColorChangesRequested  (optional)
   * @param cqDamConfigAnnotationPdfAnnotationMarkerWidth  (optional)
   * @param cqDamConfigAnnotationPdfAssetMinheight  (optional)
   * @return ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo
   */
  def comDayCqDamCoreImplAnnotationPdfAnnotationPdfConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamConfigAnnotationPdfDocumentWidth: Option[Integer] = None, cqDamConfigAnnotationPdfDocumentHeight: Option[Integer] = None, cqDamConfigAnnotationPdfDocumentPaddingHorizontal: Option[Integer] = None, cqDamConfigAnnotationPdfDocumentPaddingVertical: Option[Integer] = None, cqDamConfigAnnotationPdfFontSize: Option[Integer] = None, cqDamConfigAnnotationPdfFontColor: Option[String] = None, cqDamConfigAnnotationPdfFontFamily: Option[String] = None, cqDamConfigAnnotationPdfFontLight: Option[String] = None, cqDamConfigAnnotationPdfMarginTextImage: Option[Integer] = None, cqDamConfigAnnotationPdfMinImageHeight: Option[Integer] = None, cqDamConfigAnnotationPdfReviewStatusWidth: Option[Integer] = None, cqDamConfigAnnotationPdfReviewStatusColorApproved: Option[String] = None, cqDamConfigAnnotationPdfReviewStatusColorRejected: Option[String] = None, cqDamConfigAnnotationPdfReviewStatusColorChangesRequested: Option[String] = None, cqDamConfigAnnotationPdfAnnotationMarkerWidth: Option[Integer] = None, cqDamConfigAnnotationPdfAssetMinheight: Option[Integer] = None): Option[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigAsync(post, apply, delete, action, location, propertylist, cqDamConfigAnnotationPdfDocumentWidth, cqDamConfigAnnotationPdfDocumentHeight, cqDamConfigAnnotationPdfDocumentPaddingHorizontal, cqDamConfigAnnotationPdfDocumentPaddingVertical, cqDamConfigAnnotationPdfFontSize, cqDamConfigAnnotationPdfFontColor, cqDamConfigAnnotationPdfFontFamily, cqDamConfigAnnotationPdfFontLight, cqDamConfigAnnotationPdfMarginTextImage, cqDamConfigAnnotationPdfMinImageHeight, cqDamConfigAnnotationPdfReviewStatusWidth, cqDamConfigAnnotationPdfReviewStatusColorApproved, cqDamConfigAnnotationPdfReviewStatusColorRejected, cqDamConfigAnnotationPdfReviewStatusColorChangesRequested, cqDamConfigAnnotationPdfAnnotationMarkerWidth, cqDamConfigAnnotationPdfAssetMinheight), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamConfigAnnotationPdfDocumentWidth  (optional)
   * @param cqDamConfigAnnotationPdfDocumentHeight  (optional)
   * @param cqDamConfigAnnotationPdfDocumentPaddingHorizontal  (optional)
   * @param cqDamConfigAnnotationPdfDocumentPaddingVertical  (optional)
   * @param cqDamConfigAnnotationPdfFontSize  (optional)
   * @param cqDamConfigAnnotationPdfFontColor  (optional)
   * @param cqDamConfigAnnotationPdfFontFamily  (optional)
   * @param cqDamConfigAnnotationPdfFontLight  (optional)
   * @param cqDamConfigAnnotationPdfMarginTextImage  (optional)
   * @param cqDamConfigAnnotationPdfMinImageHeight  (optional)
   * @param cqDamConfigAnnotationPdfReviewStatusWidth  (optional)
   * @param cqDamConfigAnnotationPdfReviewStatusColorApproved  (optional)
   * @param cqDamConfigAnnotationPdfReviewStatusColorRejected  (optional)
   * @param cqDamConfigAnnotationPdfReviewStatusColorChangesRequested  (optional)
   * @param cqDamConfigAnnotationPdfAnnotationMarkerWidth  (optional)
   * @param cqDamConfigAnnotationPdfAssetMinheight  (optional)
   * @return Future(ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo)
   */
  def comDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamConfigAnnotationPdfDocumentWidth: Option[Integer] = None, cqDamConfigAnnotationPdfDocumentHeight: Option[Integer] = None, cqDamConfigAnnotationPdfDocumentPaddingHorizontal: Option[Integer] = None, cqDamConfigAnnotationPdfDocumentPaddingVertical: Option[Integer] = None, cqDamConfigAnnotationPdfFontSize: Option[Integer] = None, cqDamConfigAnnotationPdfFontColor: Option[String] = None, cqDamConfigAnnotationPdfFontFamily: Option[String] = None, cqDamConfigAnnotationPdfFontLight: Option[String] = None, cqDamConfigAnnotationPdfMarginTextImage: Option[Integer] = None, cqDamConfigAnnotationPdfMinImageHeight: Option[Integer] = None, cqDamConfigAnnotationPdfReviewStatusWidth: Option[Integer] = None, cqDamConfigAnnotationPdfReviewStatusColorApproved: Option[String] = None, cqDamConfigAnnotationPdfReviewStatusColorRejected: Option[String] = None, cqDamConfigAnnotationPdfReviewStatusColorChangesRequested: Option[String] = None, cqDamConfigAnnotationPdfAnnotationMarkerWidth: Option[Integer] = None, cqDamConfigAnnotationPdfAssetMinheight: Option[Integer] = None): Future[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo] = {
      helper.comDayCqDamCoreImplAnnotationPdfAnnotationPdfConfig(post, apply, delete, action, location, propertylist, cqDamConfigAnnotationPdfDocumentWidth, cqDamConfigAnnotationPdfDocumentHeight, cqDamConfigAnnotationPdfDocumentPaddingHorizontal, cqDamConfigAnnotationPdfDocumentPaddingVertical, cqDamConfigAnnotationPdfFontSize, cqDamConfigAnnotationPdfFontColor, cqDamConfigAnnotationPdfFontFamily, cqDamConfigAnnotationPdfFontLight, cqDamConfigAnnotationPdfMarginTextImage, cqDamConfigAnnotationPdfMinImageHeight, cqDamConfigAnnotationPdfReviewStatusWidth, cqDamConfigAnnotationPdfReviewStatusColorApproved, cqDamConfigAnnotationPdfReviewStatusColorRejected, cqDamConfigAnnotationPdfReviewStatusColorChangesRequested, cqDamConfigAnnotationPdfAnnotationMarkerWidth, cqDamConfigAnnotationPdfAssetMinheight)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return ComDayCqDamCoreImplAssetMoveListenerInfo
   */
  def comDayCqDamCoreImplAssetMoveListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Option[ComDayCqDamCoreImplAssetMoveListenerInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplAssetMoveListenerAsync(post, apply, delete, action, location, propertylist, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return Future(ComDayCqDamCoreImplAssetMoveListenerInfo)
   */
  def comDayCqDamCoreImplAssetMoveListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Future[ComDayCqDamCoreImplAssetMoveListenerInfo] = {
      helper.comDayCqDamCoreImplAssetMoveListener(post, apply, delete, action, location, propertylist, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isEnabled  (optional)
   * @return ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo
   */
  def comDayCqDamCoreImplAssethomeAssetHomePageConfiguration(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isEnabled: Option[Boolean] = None): Option[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplAssethomeAssetHomePageConfigurationAsync(post, apply, delete, action, location, propertylist, isEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isEnabled  (optional)
   * @return Future(ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo)
   */
  def comDayCqDamCoreImplAssethomeAssetHomePageConfigurationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isEnabled: Option[Boolean] = None): Future[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo] = {
      helper.comDayCqDamCoreImplAssethomeAssetHomePageConfiguration(post, apply, delete, action, location, propertylist, isEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamAdhocAssetSharePrezipMaxcontentsize  (optional)
   * @return ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo
   */
  def comDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamAdhocAssetSharePrezipMaxcontentsize: Option[Integer] = None): Option[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletAsync(post, apply, delete, action, location, propertylist, cqDamAdhocAssetSharePrezipMaxcontentsize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamAdhocAssetSharePrezipMaxcontentsize  (optional)
   * @return Future(ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo)
   */
  def comDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamAdhocAssetSharePrezipMaxcontentsize: Option[Integer] = None): Future[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo] = {
      helper.comDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServlet(post, apply, delete, action, location, propertylist, cqDamAdhocAssetSharePrezipMaxcontentsize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamImageCacheMaxMemory  (optional)
   * @param cqDamImageCacheMaxAge  (optional)
   * @param cqDamImageCacheMaxDimension  (optional)
   * @return ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo
   */
  def comDayCqDamCoreImplCacheCQBufferedImageCache(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamImageCacheMaxMemory: Option[Integer] = None, cqDamImageCacheMaxAge: Option[Integer] = None, cqDamImageCacheMaxDimension: Option[String] = None): Option[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplCacheCQBufferedImageCacheAsync(post, apply, delete, action, location, propertylist, cqDamImageCacheMaxMemory, cqDamImageCacheMaxAge, cqDamImageCacheMaxDimension), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamImageCacheMaxMemory  (optional)
   * @param cqDamImageCacheMaxAge  (optional)
   * @param cqDamImageCacheMaxDimension  (optional)
   * @return Future(ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo)
   */
  def comDayCqDamCoreImplCacheCQBufferedImageCacheAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamImageCacheMaxMemory: Option[Integer] = None, cqDamImageCacheMaxAge: Option[Integer] = None, cqDamImageCacheMaxDimension: Option[String] = None): Future[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo] = {
      helper.comDayCqDamCoreImplCacheCQBufferedImageCache(post, apply, delete, action, location, propertylist, cqDamImageCacheMaxMemory, cqDamImageCacheMaxAge, cqDamImageCacheMaxDimension)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param changeeventlistenerObservedPaths  (optional)
   * @return ComDayCqDamCoreImplDamChangeEventListenerInfo
   */
  def comDayCqDamCoreImplDamChangeEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, changeeventlistenerObservedPaths: Option[List[String]] = None): Option[ComDayCqDamCoreImplDamChangeEventListenerInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplDamChangeEventListenerAsync(post, apply, delete, action, location, propertylist, changeeventlistenerObservedPaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param changeeventlistenerObservedPaths  (optional)
   * @return Future(ComDayCqDamCoreImplDamChangeEventListenerInfo)
   */
  def comDayCqDamCoreImplDamChangeEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, changeeventlistenerObservedPaths: Option[List[String]] = None): Future[ComDayCqDamCoreImplDamChangeEventListenerInfo] = {
      helper.comDayCqDamCoreImplDamChangeEventListener(post, apply, delete, action, location, propertylist, changeeventlistenerObservedPaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param maxSavedActivities  (optional)
   * @param saveInterval  (optional)
   * @param enableActivityPurge  (optional)
   * @param eventTypes  (optional)
   * @return ComDayCqDamCoreImplDamEventPurgeServiceInfo
   */
  def comDayCqDamCoreImplDamEventPurgeService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, maxSavedActivities: Option[Integer] = None, saveInterval: Option[Integer] = None, enableActivityPurge: Option[Boolean] = None, eventTypes: Option[String] = None): Option[ComDayCqDamCoreImplDamEventPurgeServiceInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplDamEventPurgeServiceAsync(post, apply, delete, action, location, propertylist, schedulerExpression, maxSavedActivities, saveInterval, enableActivityPurge, eventTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param maxSavedActivities  (optional)
   * @param saveInterval  (optional)
   * @param enableActivityPurge  (optional)
   * @param eventTypes  (optional)
   * @return Future(ComDayCqDamCoreImplDamEventPurgeServiceInfo)
   */
  def comDayCqDamCoreImplDamEventPurgeServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, maxSavedActivities: Option[Integer] = None, saveInterval: Option[Integer] = None, enableActivityPurge: Option[Boolean] = None, eventTypes: Option[String] = None): Future[ComDayCqDamCoreImplDamEventPurgeServiceInfo] = {
      helper.comDayCqDamCoreImplDamEventPurgeService(post, apply, delete, action, location, propertylist, schedulerExpression, maxSavedActivities, saveInterval, enableActivityPurge, eventTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param eventQueueLength  (optional)
   * @param eventrecorderEnabled  (optional)
   * @param eventrecorderBlacklist  (optional)
   * @param eventrecorderEventtypes  (optional)
   * @return ComDayCqDamCoreImplDamEventRecorderImplInfo
   */
  def comDayCqDamCoreImplDamEventRecorderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, eventQueueLength: Option[Integer] = None, eventrecorderEnabled: Option[Boolean] = None, eventrecorderBlacklist: Option[List[String]] = None, eventrecorderEventtypes: Option[String] = None): Option[ComDayCqDamCoreImplDamEventRecorderImplInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplDamEventRecorderImplAsync(post, apply, delete, action, location, propertylist, eventFilter, eventQueueLength, eventrecorderEnabled, eventrecorderBlacklist, eventrecorderEventtypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param eventQueueLength  (optional)
   * @param eventrecorderEnabled  (optional)
   * @param eventrecorderBlacklist  (optional)
   * @param eventrecorderEventtypes  (optional)
   * @return Future(ComDayCqDamCoreImplDamEventRecorderImplInfo)
   */
  def comDayCqDamCoreImplDamEventRecorderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, eventQueueLength: Option[Integer] = None, eventrecorderEnabled: Option[Boolean] = None, eventrecorderBlacklist: Option[List[String]] = None, eventrecorderEventtypes: Option[String] = None): Future[ComDayCqDamCoreImplDamEventRecorderImplInfo] = {
      helper.comDayCqDamCoreImplDamEventRecorderImpl(post, apply, delete, action, location, propertylist, eventFilter, eventQueueLength, eventrecorderEnabled, eventrecorderBlacklist, eventrecorderEventtypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param enabled  (optional)
   * @return ComDayCqDamCoreImplEventDamEventAuditListenerInfo
   */
  def comDayCqDamCoreImplEventDamEventAuditListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, enabled: Option[Boolean] = None): Option[ComDayCqDamCoreImplEventDamEventAuditListenerInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplEventDamEventAuditListenerAsync(post, apply, delete, action, location, propertylist, eventFilter, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param enabled  (optional)
   * @return Future(ComDayCqDamCoreImplEventDamEventAuditListenerInfo)
   */
  def comDayCqDamCoreImplEventDamEventAuditListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, enabled: Option[Boolean] = None): Future[ComDayCqDamCoreImplEventDamEventAuditListenerInfo] = {
      helper.comDayCqDamCoreImplEventDamEventAuditListener(post, apply, delete, action, location, propertylist, eventFilter, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamExpiryNotificationSchedulerIstimebased  (optional)
   * @param cqDamExpiryNotificationSchedulerTimebasedRule  (optional)
   * @param cqDamExpiryNotificationSchedulerPeriodRule  (optional)
   * @param sendEmail  (optional)
   * @param assetExpiredLimit  (optional)
   * @param priorNotificationSeconds  (optional)
   * @param cqDamExpiryNotificationUrlProtocol  (optional)
   * @return ComDayCqDamCoreImplExpiryNotificationJobImplInfo
   */
  def comDayCqDamCoreImplExpiryNotificationJobImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamExpiryNotificationSchedulerIstimebased: Option[Boolean] = None, cqDamExpiryNotificationSchedulerTimebasedRule: Option[String] = None, cqDamExpiryNotificationSchedulerPeriodRule: Option[Integer] = None, sendEmail: Option[Boolean] = None, assetExpiredLimit: Option[Integer] = None, priorNotificationSeconds: Option[Integer] = None, cqDamExpiryNotificationUrlProtocol: Option[String] = None): Option[ComDayCqDamCoreImplExpiryNotificationJobImplInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplExpiryNotificationJobImplAsync(post, apply, delete, action, location, propertylist, cqDamExpiryNotificationSchedulerIstimebased, cqDamExpiryNotificationSchedulerTimebasedRule, cqDamExpiryNotificationSchedulerPeriodRule, sendEmail, assetExpiredLimit, priorNotificationSeconds, cqDamExpiryNotificationUrlProtocol), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamExpiryNotificationSchedulerIstimebased  (optional)
   * @param cqDamExpiryNotificationSchedulerTimebasedRule  (optional)
   * @param cqDamExpiryNotificationSchedulerPeriodRule  (optional)
   * @param sendEmail  (optional)
   * @param assetExpiredLimit  (optional)
   * @param priorNotificationSeconds  (optional)
   * @param cqDamExpiryNotificationUrlProtocol  (optional)
   * @return Future(ComDayCqDamCoreImplExpiryNotificationJobImplInfo)
   */
  def comDayCqDamCoreImplExpiryNotificationJobImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamExpiryNotificationSchedulerIstimebased: Option[Boolean] = None, cqDamExpiryNotificationSchedulerTimebasedRule: Option[String] = None, cqDamExpiryNotificationSchedulerPeriodRule: Option[Integer] = None, sendEmail: Option[Boolean] = None, assetExpiredLimit: Option[Integer] = None, priorNotificationSeconds: Option[Integer] = None, cqDamExpiryNotificationUrlProtocol: Option[String] = None): Future[ComDayCqDamCoreImplExpiryNotificationJobImplInfo] = {
      helper.comDayCqDamCoreImplExpiryNotificationJobImpl(post, apply, delete, action, location, propertylist, cqDamExpiryNotificationSchedulerIstimebased, cqDamExpiryNotificationSchedulerTimebasedRule, cqDamExpiryNotificationSchedulerPeriodRule, sendEmail, assetExpiredLimit, priorNotificationSeconds, cqDamExpiryNotificationUrlProtocol)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isEnabled  (optional)
   * @return ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo
   */
  def comDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeat(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isEnabled: Option[Boolean] = None): Option[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatAsync(post, apply, delete, action, location, propertylist, isEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param isEnabled  (optional)
   * @return Future(ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo)
   */
  def comDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, isEnabled: Option[Boolean] = None): Future[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo] = {
      helper.comDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeat(post, apply, delete, action, location, propertylist, isEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param skipBufferedcache  (optional)
   * @return ComDayCqDamCoreImplGfxCommonsGfxRendererInfo
   */
  def comDayCqDamCoreImplGfxCommonsGfxRenderer(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, skipBufferedcache: Option[Boolean] = None): Option[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplGfxCommonsGfxRendererAsync(post, apply, delete, action, location, propertylist, skipBufferedcache), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param skipBufferedcache  (optional)
   * @return Future(ComDayCqDamCoreImplGfxCommonsGfxRendererInfo)
   */
  def comDayCqDamCoreImplGfxCommonsGfxRendererAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, skipBufferedcache: Option[Boolean] = None): Future[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo] = {
      helper.comDayCqDamCoreImplGfxCommonsGfxRenderer(post, apply, delete, action, location, propertylist, skipBufferedcache)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mimetype  (optional)
   * @return ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo
   */
  def comDayCqDamCoreImplHandlerEPSFormatHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mimetype: Option[String] = None): Option[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplHandlerEPSFormatHandlerAsync(post, apply, delete, action, location, propertylist, mimetype), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mimetype  (optional)
   * @return Future(ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo)
   */
  def comDayCqDamCoreImplHandlerEPSFormatHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mimetype: Option[String] = None): Future[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo] = {
      helper.comDayCqDamCoreImplHandlerEPSFormatHandler(post, apply, delete, action, location, propertylist, mimetype)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mimetype  (optional)
   * @return ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo
   */
  def comDayCqDamCoreImplHandlerIndesignFormatHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mimetype: Option[List[String]] = None): Option[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplHandlerIndesignFormatHandlerAsync(post, apply, delete, action, location, propertylist, mimetype), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mimetype  (optional)
   * @return Future(ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo)
   */
  def comDayCqDamCoreImplHandlerIndesignFormatHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mimetype: Option[List[String]] = None): Future[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo] = {
      helper.comDayCqDamCoreImplHandlerIndesignFormatHandler(post, apply, delete, action, location, propertylist, mimetype)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamEnableExtMetaExtraction  (optional)
   * @param largeFileThreshold  (optional)
   * @param largeCommentThreshold  (optional)
   * @return ComDayCqDamCoreImplHandlerJpegHandlerInfo
   */
  def comDayCqDamCoreImplHandlerJpegHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamEnableExtMetaExtraction: Option[Boolean] = None, largeFileThreshold: Option[Integer] = None, largeCommentThreshold: Option[Integer] = None): Option[ComDayCqDamCoreImplHandlerJpegHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplHandlerJpegHandlerAsync(post, apply, delete, action, location, propertylist, cqDamEnableExtMetaExtraction, largeFileThreshold, largeCommentThreshold), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamEnableExtMetaExtraction  (optional)
   * @param largeFileThreshold  (optional)
   * @param largeCommentThreshold  (optional)
   * @return Future(ComDayCqDamCoreImplHandlerJpegHandlerInfo)
   */
  def comDayCqDamCoreImplHandlerJpegHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamEnableExtMetaExtraction: Option[Boolean] = None, largeFileThreshold: Option[Integer] = None, largeCommentThreshold: Option[Integer] = None): Future[ComDayCqDamCoreImplHandlerJpegHandlerInfo] = {
      helper.comDayCqDamCoreImplHandlerJpegHandler(post, apply, delete, action, location, propertylist, cqDamEnableExtMetaExtraction, largeFileThreshold, largeCommentThreshold)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param xmphandlerCqFormats  (optional)
   * @return ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo
   */
  def comDayCqDamCoreImplHandlerXmpNCommXMPHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, xmphandlerCqFormats: Option[List[String]] = None): Option[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplHandlerXmpNCommXMPHandlerAsync(post, apply, delete, action, location, propertylist, xmphandlerCqFormats), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param xmphandlerCqFormats  (optional)
   * @return Future(ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo)
   */
  def comDayCqDamCoreImplHandlerXmpNCommXMPHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, xmphandlerCqFormats: Option[List[String]] = None): Future[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo] = {
      helper.comDayCqDamCoreImplHandlerXmpNCommXMPHandler(post, apply, delete, action, location, propertylist, xmphandlerCqFormats)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jmxObjectname  (optional)
   * @param propertyMeasureEnabled  (optional)
   * @param propertyName  (optional)
   * @param propertyMaxWaitMs  (optional)
   * @param propertyMaxRate  (optional)
   * @param fulltextMeasureEnabled  (optional)
   * @param fulltextName  (optional)
   * @param fulltextMaxWaitMs  (optional)
   * @param fulltextMaxRate  (optional)
   * @return ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo
   */
  def comDayCqDamCoreImplJmxAssetIndexUpdateMonitor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jmxObjectname: Option[String] = None, propertyMeasureEnabled: Option[Boolean] = None, propertyName: Option[String] = None, propertyMaxWaitMs: Option[Integer] = None, propertyMaxRate: Option[Number] = None, fulltextMeasureEnabled: Option[Boolean] = None, fulltextName: Option[String] = None, fulltextMaxWaitMs: Option[Integer] = None, fulltextMaxRate: Option[Number] = None): Option[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplJmxAssetIndexUpdateMonitorAsync(post, apply, delete, action, location, propertylist, jmxObjectname, propertyMeasureEnabled, propertyName, propertyMaxWaitMs, propertyMaxRate, fulltextMeasureEnabled, fulltextName, fulltextMaxWaitMs, fulltextMaxRate), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jmxObjectname  (optional)
   * @param propertyMeasureEnabled  (optional)
   * @param propertyName  (optional)
   * @param propertyMaxWaitMs  (optional)
   * @param propertyMaxRate  (optional)
   * @param fulltextMeasureEnabled  (optional)
   * @param fulltextName  (optional)
   * @param fulltextMaxWaitMs  (optional)
   * @param fulltextMaxRate  (optional)
   * @return Future(ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo)
   */
  def comDayCqDamCoreImplJmxAssetIndexUpdateMonitorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jmxObjectname: Option[String] = None, propertyMeasureEnabled: Option[Boolean] = None, propertyName: Option[String] = None, propertyMaxWaitMs: Option[Integer] = None, propertyMaxRate: Option[Number] = None, fulltextMeasureEnabled: Option[Boolean] = None, fulltextName: Option[String] = None, fulltextMaxWaitMs: Option[Integer] = None, fulltextMaxRate: Option[Number] = None): Future[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo] = {
      helper.comDayCqDamCoreImplJmxAssetIndexUpdateMonitor(post, apply, delete, action, location, propertylist, jmxObjectname, propertyMeasureEnabled, propertyName, propertyMaxWaitMs, propertyMaxRate, fulltextMeasureEnabled, fulltextName, fulltextMaxWaitMs, fulltextMaxRate)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jmxObjectname  (optional)
   * @return ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo
   */
  def comDayCqDamCoreImplJmxAssetMigrationMBeanImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jmxObjectname: Option[String] = None): Option[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplJmxAssetMigrationMBeanImplAsync(post, apply, delete, action, location, propertylist, jmxObjectname), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jmxObjectname  (optional)
   * @return Future(ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo)
   */
  def comDayCqDamCoreImplJmxAssetMigrationMBeanImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jmxObjectname: Option[String] = None): Future[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo] = {
      helper.comDayCqDamCoreImplJmxAssetMigrationMBeanImpl(post, apply, delete, action, location, propertylist, jmxObjectname)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jmxObjectname  (optional)
   * @param active  (optional)
   * @return ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo
   */
  def comDayCqDamCoreImplJmxAssetUpdateMonitorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jmxObjectname: Option[String] = None, active: Option[Boolean] = None): Option[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplJmxAssetUpdateMonitorImplAsync(post, apply, delete, action, location, propertylist, jmxObjectname, active), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jmxObjectname  (optional)
   * @param active  (optional)
   * @return Future(ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo)
   */
  def comDayCqDamCoreImplJmxAssetUpdateMonitorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jmxObjectname: Option[String] = None, active: Option[Boolean] = None): Future[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo] = {
      helper.comDayCqDamCoreImplJmxAssetUpdateMonitorImpl(post, apply, delete, action, location, propertylist, jmxObjectname, active)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param operation  (optional)
   * @param emailEnabled  (optional)
   * @return ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo
   */
  def comDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, operation: Option[String] = None, emailEnabled: Option[Boolean] = None): Option[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigAsync(post, apply, delete, action, location, propertylist, operation, emailEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param operation  (optional)
   * @param emailEnabled  (optional)
   * @return Future(ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo)
   */
  def comDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, operation: Option[String] = None, emailEnabled: Option[Boolean] = None): Future[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo] = {
      helper.comDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfig(post, apply, delete, action, location, propertylist, operation, emailEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param operation  (optional)
   * @param operationIcon  (optional)
   * @param topicName  (optional)
   * @param emailEnabled  (optional)
   * @return ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo
   */
  def comDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, operation: Option[String] = None, operationIcon: Option[String] = None, topicName: Option[String] = None, emailEnabled: Option[Boolean] = None): Option[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigAsync(post, apply, delete, action, location, propertylist, operation, operationIcon, topicName, emailEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param operation  (optional)
   * @param operationIcon  (optional)
   * @param topicName  (optional)
   * @param emailEnabled  (optional)
   * @return Future(ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo)
   */
  def comDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, operation: Option[String] = None, operationIcon: Option[String] = None, topicName: Option[String] = None, emailEnabled: Option[Boolean] = None): Future[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo] = {
      helper.comDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfig(post, apply, delete, action, location, propertylist, operation, operationIcon, topicName, emailEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletPaths  (optional)
   * @param slingServletMethods  (optional)
   * @param cqDamEnableAnonymous  (optional)
   * @return ComDayCqDamCoreImplLightboxLightboxServletInfo
   */
  def comDayCqDamCoreImplLightboxLightboxServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletPaths: Option[String] = None, slingServletMethods: Option[List[String]] = None, cqDamEnableAnonymous: Option[Boolean] = None): Option[ComDayCqDamCoreImplLightboxLightboxServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplLightboxLightboxServletAsync(post, apply, delete, action, location, propertylist, slingServletPaths, slingServletMethods, cqDamEnableAnonymous), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletPaths  (optional)
   * @param slingServletMethods  (optional)
   * @param cqDamEnableAnonymous  (optional)
   * @return Future(ComDayCqDamCoreImplLightboxLightboxServletInfo)
   */
  def comDayCqDamCoreImplLightboxLightboxServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletPaths: Option[String] = None, slingServletMethods: Option[List[String]] = None, cqDamEnableAnonymous: Option[Boolean] = None): Future[ComDayCqDamCoreImplLightboxLightboxServletInfo] = {
      helper.comDayCqDamCoreImplLightboxLightboxServlet(post, apply, delete, action, location, propertylist, slingServletPaths, slingServletMethods, cqDamEnableAnonymous)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param granitedata  (optional)
   * @return ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo
   */
  def comDayCqDamCoreImplMetadataEditorSelectComponentHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, granitedata: Option[List[String]] = None): Option[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplMetadataEditorSelectComponentHandlerAsync(post, apply, delete, action, location, propertylist, granitedata), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param granitedata  (optional)
   * @return Future(ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo)
   */
  def comDayCqDamCoreImplMetadataEditorSelectComponentHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, granitedata: Option[List[String]] = None): Future[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo] = {
      helper.comDayCqDamCoreImplMetadataEditorSelectComponentHandler(post, apply, delete, action, location, propertylist, granitedata)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamAllowAllMime  (optional)
   * @param cqDamAllowedAssetMimes  (optional)
   * @return ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo
   */
  def comDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelper(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamAllowAllMime: Option[Boolean] = None, cqDamAllowedAssetMimes: Option[List[String]] = None): Option[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperAsync(post, apply, delete, action, location, propertylist, cqDamAllowAllMime, cqDamAllowedAssetMimes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamAllowAllMime  (optional)
   * @param cqDamAllowedAssetMimes  (optional)
   * @return Future(ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo)
   */
  def comDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamAllowAllMime: Option[Boolean] = None, cqDamAllowedAssetMimes: Option[List[String]] = None): Future[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo] = {
      helper.comDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelper(post, apply, delete, action, location, propertylist, cqDamAllowAllMime, cqDamAllowedAssetMimes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamDetectAssetMimeFromContent  (optional)
   * @return ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo
   */
  def comDayCqDamCoreImplMimeTypeDamMimeTypeServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamDetectAssetMimeFromContent: Option[Boolean] = None): Option[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplAsync(post, apply, delete, action, location, propertylist, cqDamDetectAssetMimeFromContent), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamDetectAssetMimeFromContent  (optional)
   * @return Future(ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo)
   */
  def comDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamDetectAssetMimeFromContent: Option[Boolean] = None): Future[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo] = {
      helper.comDayCqDamCoreImplMimeTypeDamMimeTypeServiceImpl(post, apply, delete, action, location, propertylist, cqDamDetectAssetMimeFromContent)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamMissingmetadataNotificationSchedulerIstimebased  (optional)
   * @param cqDamMissingmetadataNotificationSchedulerTimebasedRule  (optional)
   * @param cqDamMissingmetadataNotificationSchedulerPeriodRule  (optional)
   * @param cqDamMissingmetadataNotificationRecipient  (optional)
   * @return ComDayCqDamCoreImplMissingMetadataNotificationJobInfo
   */
  def comDayCqDamCoreImplMissingMetadataNotificationJob(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamMissingmetadataNotificationSchedulerIstimebased: Option[Boolean] = None, cqDamMissingmetadataNotificationSchedulerTimebasedRule: Option[String] = None, cqDamMissingmetadataNotificationSchedulerPeriodRule: Option[Integer] = None, cqDamMissingmetadataNotificationRecipient: Option[String] = None): Option[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplMissingMetadataNotificationJobAsync(post, apply, delete, action, location, propertylist, cqDamMissingmetadataNotificationSchedulerIstimebased, cqDamMissingmetadataNotificationSchedulerTimebasedRule, cqDamMissingmetadataNotificationSchedulerPeriodRule, cqDamMissingmetadataNotificationRecipient), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamMissingmetadataNotificationSchedulerIstimebased  (optional)
   * @param cqDamMissingmetadataNotificationSchedulerTimebasedRule  (optional)
   * @param cqDamMissingmetadataNotificationSchedulerPeriodRule  (optional)
   * @param cqDamMissingmetadataNotificationRecipient  (optional)
   * @return Future(ComDayCqDamCoreImplMissingMetadataNotificationJobInfo)
   */
  def comDayCqDamCoreImplMissingMetadataNotificationJobAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamMissingmetadataNotificationSchedulerIstimebased: Option[Boolean] = None, cqDamMissingmetadataNotificationSchedulerTimebasedRule: Option[String] = None, cqDamMissingmetadataNotificationSchedulerPeriodRule: Option[Integer] = None, cqDamMissingmetadataNotificationRecipient: Option[String] = None): Future[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo] = {
      helper.comDayCqDamCoreImplMissingMetadataNotificationJob(post, apply, delete, action, location, propertylist, cqDamMissingmetadataNotificationSchedulerIstimebased, cqDamMissingmetadataNotificationSchedulerTimebasedRule, cqDamMissingmetadataNotificationSchedulerPeriodRule, cqDamMissingmetadataNotificationRecipient)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param notifyOnComplete  (optional)
   * @return ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo
   */
  def comDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPr(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, notifyOnComplete: Option[Boolean] = None): Option[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrAsync(post, apply, delete, action, location, propertylist, processLabel, notifyOnComplete), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param notifyOnComplete  (optional)
   * @return Future(ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo)
   */
  def comDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, notifyOnComplete: Option[Boolean] = None): Future[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo] = {
      helper.comDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPr(post, apply, delete, action, location, propertylist, processLabel, notifyOnComplete)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mimeTypes  (optional)
   * @param maxExtract  (optional)
   * @return ComDayCqDamCoreImplProcessTextExtractionProcessInfo
   */
  def comDayCqDamCoreImplProcessTextExtractionProcess(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mimeTypes: Option[List[String]] = None, maxExtract: Option[Integer] = None): Option[ComDayCqDamCoreImplProcessTextExtractionProcessInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplProcessTextExtractionProcessAsync(post, apply, delete, action, location, propertylist, mimeTypes, maxExtract), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mimeTypes  (optional)
   * @param maxExtract  (optional)
   * @return Future(ComDayCqDamCoreImplProcessTextExtractionProcessInfo)
   */
  def comDayCqDamCoreImplProcessTextExtractionProcessAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mimeTypes: Option[List[String]] = None, maxExtract: Option[Integer] = None): Future[ComDayCqDamCoreImplProcessTextExtractionProcessInfo] = {
      helper.comDayCqDamCoreImplProcessTextExtractionProcess(post, apply, delete, action, location, propertylist, mimeTypes, maxExtract)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param xmpPropagate  (optional)
   * @param xmpExcludes  (optional)
   * @return ComDayCqDamCoreImplRenditionMakerImplInfo
   */
  def comDayCqDamCoreImplRenditionMakerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, xmpPropagate: Option[Boolean] = None, xmpExcludes: Option[List[String]] = None): Option[ComDayCqDamCoreImplRenditionMakerImplInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplRenditionMakerImplAsync(post, apply, delete, action, location, propertylist, xmpPropagate, xmpExcludes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param xmpPropagate  (optional)
   * @param xmpExcludes  (optional)
   * @return Future(ComDayCqDamCoreImplRenditionMakerImplInfo)
   */
  def comDayCqDamCoreImplRenditionMakerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, xmpPropagate: Option[Boolean] = None, xmpExcludes: Option[List[String]] = None): Future[ComDayCqDamCoreImplRenditionMakerImplInfo] = {
      helper.comDayCqDamCoreImplRenditionMakerImpl(post, apply, delete, action, location, propertylist, xmpPropagate, xmpExcludes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queryBatchSize  (optional)
   * @return ComDayCqDamCoreImplReportsReportExportServiceInfo
   */
  def comDayCqDamCoreImplReportsReportExportService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queryBatchSize: Option[Integer] = None): Option[ComDayCqDamCoreImplReportsReportExportServiceInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplReportsReportExportServiceAsync(post, apply, delete, action, location, propertylist, queryBatchSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queryBatchSize  (optional)
   * @return Future(ComDayCqDamCoreImplReportsReportExportServiceInfo)
   */
  def comDayCqDamCoreImplReportsReportExportServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queryBatchSize: Option[Integer] = None): Future[ComDayCqDamCoreImplReportsReportExportServiceInfo] = {
      helper.comDayCqDamCoreImplReportsReportExportService(post, apply, delete, action, location, propertylist, queryBatchSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param maxSavedReports  (optional)
   * @param timeDuration  (optional)
   * @param enableReportPurge  (optional)
   * @return ComDayCqDamCoreImplReportsReportPurgeServiceInfo
   */
  def comDayCqDamCoreImplReportsReportPurgeService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, maxSavedReports: Option[Integer] = None, timeDuration: Option[Integer] = None, enableReportPurge: Option[Boolean] = None): Option[ComDayCqDamCoreImplReportsReportPurgeServiceInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplReportsReportPurgeServiceAsync(post, apply, delete, action, location, propertylist, schedulerExpression, maxSavedReports, timeDuration, enableReportPurge), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param maxSavedReports  (optional)
   * @param timeDuration  (optional)
   * @param enableReportPurge  (optional)
   * @return Future(ComDayCqDamCoreImplReportsReportPurgeServiceInfo)
   */
  def comDayCqDamCoreImplReportsReportPurgeServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, maxSavedReports: Option[Integer] = None, timeDuration: Option[Integer] = None, enableReportPurge: Option[Boolean] = None): Future[ComDayCqDamCoreImplReportsReportPurgeServiceInfo] = {
      helper.comDayCqDamCoreImplReportsReportPurgeService(post, apply, delete, action, location, propertylist, schedulerExpression, maxSavedReports, timeDuration, enableReportPurge)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return ComDayCqDamCoreImplServletAssetDownloadServletInfo
   */
  def comDayCqDamCoreImplServletAssetDownloadServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Option[ComDayCqDamCoreImplServletAssetDownloadServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletAssetDownloadServletAsync(post, apply, delete, action, location, propertylist, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return Future(ComDayCqDamCoreImplServletAssetDownloadServletInfo)
   */
  def comDayCqDamCoreImplServletAssetDownloadServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Future[ComDayCqDamCoreImplServletAssetDownloadServletInfo] = {
      helper.comDayCqDamCoreImplServletAssetDownloadServlet(post, apply, delete, action, location, propertylist, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamBatchStatusMaxassets  (optional)
   * @return ComDayCqDamCoreImplServletAssetStatusServletInfo
   */
  def comDayCqDamCoreImplServletAssetStatusServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamBatchStatusMaxassets: Option[Integer] = None): Option[ComDayCqDamCoreImplServletAssetStatusServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletAssetStatusServletAsync(post, apply, delete, action, location, propertylist, cqDamBatchStatusMaxassets), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamBatchStatusMaxassets  (optional)
   * @return Future(ComDayCqDamCoreImplServletAssetStatusServletInfo)
   */
  def comDayCqDamCoreImplServletAssetStatusServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamBatchStatusMaxassets: Option[Integer] = None): Future[ComDayCqDamCoreImplServletAssetStatusServletInfo] = {
      helper.comDayCqDamCoreImplServletAssetStatusServlet(post, apply, delete, action, location, propertylist, cqDamBatchStatusMaxassets)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamBatchIndesignMaxassets  (optional)
   * @return ComDayCqDamCoreImplServletAssetXMPSearchServletInfo
   */
  def comDayCqDamCoreImplServletAssetXMPSearchServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamBatchIndesignMaxassets: Option[Integer] = None): Option[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletAssetXMPSearchServletAsync(post, apply, delete, action, location, propertylist, cqDamBatchIndesignMaxassets), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamBatchIndesignMaxassets  (optional)
   * @return Future(ComDayCqDamCoreImplServletAssetXMPSearchServletInfo)
   */
  def comDayCqDamCoreImplServletAssetXMPSearchServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamBatchIndesignMaxassets: Option[Integer] = None): Future[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo] = {
      helper.comDayCqDamCoreImplServletAssetXMPSearchServlet(post, apply, delete, action, location, propertylist, cqDamBatchIndesignMaxassets)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamBatchMetadataAssetDefault  (optional)
   * @param cqDamBatchMetadataCollectionDefault  (optional)
   * @param cqDamBatchMetadataMaxresources  (optional)
   * @return ComDayCqDamCoreImplServletBatchMetadataServletInfo
   */
  def comDayCqDamCoreImplServletBatchMetadataServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamBatchMetadataAssetDefault: Option[List[String]] = None, cqDamBatchMetadataCollectionDefault: Option[List[String]] = None, cqDamBatchMetadataMaxresources: Option[Integer] = None): Option[ComDayCqDamCoreImplServletBatchMetadataServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletBatchMetadataServletAsync(post, apply, delete, action, location, propertylist, cqDamBatchMetadataAssetDefault, cqDamBatchMetadataCollectionDefault, cqDamBatchMetadataMaxresources), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamBatchMetadataAssetDefault  (optional)
   * @param cqDamBatchMetadataCollectionDefault  (optional)
   * @param cqDamBatchMetadataMaxresources  (optional)
   * @return Future(ComDayCqDamCoreImplServletBatchMetadataServletInfo)
   */
  def comDayCqDamCoreImplServletBatchMetadataServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamBatchMetadataAssetDefault: Option[List[String]] = None, cqDamBatchMetadataCollectionDefault: Option[List[String]] = None, cqDamBatchMetadataMaxresources: Option[Integer] = None): Future[ComDayCqDamCoreImplServletBatchMetadataServletInfo] = {
      helper.comDayCqDamCoreImplServletBatchMetadataServlet(post, apply, delete, action, location, propertylist, cqDamBatchMetadataAssetDefault, cqDamBatchMetadataCollectionDefault, cqDamBatchMetadataMaxresources)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletResourceTypes  (optional)
   * @param slingServletMethods  (optional)
   * @param cqDamDrmEnable  (optional)
   * @return ComDayCqDamCoreImplServletBinaryProviderServletInfo
   */
  def comDayCqDamCoreImplServletBinaryProviderServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletResourceTypes: Option[List[String]] = None, slingServletMethods: Option[List[String]] = None, cqDamDrmEnable: Option[Boolean] = None): Option[ComDayCqDamCoreImplServletBinaryProviderServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletBinaryProviderServletAsync(post, apply, delete, action, location, propertylist, slingServletResourceTypes, slingServletMethods, cqDamDrmEnable), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletResourceTypes  (optional)
   * @param slingServletMethods  (optional)
   * @param cqDamDrmEnable  (optional)
   * @return Future(ComDayCqDamCoreImplServletBinaryProviderServletInfo)
   */
  def comDayCqDamCoreImplServletBinaryProviderServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletResourceTypes: Option[List[String]] = None, slingServletMethods: Option[List[String]] = None, cqDamDrmEnable: Option[Boolean] = None): Future[ComDayCqDamCoreImplServletBinaryProviderServletInfo] = {
      helper.comDayCqDamCoreImplServletBinaryProviderServlet(post, apply, delete, action, location, propertylist, slingServletResourceTypes, slingServletMethods, cqDamDrmEnable)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamBatchCollectionProperties  (optional)
   * @param cqDamBatchCollectionMaxcollections  (optional)
   * @return ComDayCqDamCoreImplServletCollectionServletInfo
   */
  def comDayCqDamCoreImplServletCollectionServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamBatchCollectionProperties: Option[List[String]] = None, cqDamBatchCollectionMaxcollections: Option[Integer] = None): Option[ComDayCqDamCoreImplServletCollectionServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletCollectionServletAsync(post, apply, delete, action, location, propertylist, cqDamBatchCollectionProperties, cqDamBatchCollectionMaxcollections), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamBatchCollectionProperties  (optional)
   * @param cqDamBatchCollectionMaxcollections  (optional)
   * @return Future(ComDayCqDamCoreImplServletCollectionServletInfo)
   */
  def comDayCqDamCoreImplServletCollectionServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamBatchCollectionProperties: Option[List[String]] = None, cqDamBatchCollectionMaxcollections: Option[Integer] = None): Future[ComDayCqDamCoreImplServletCollectionServletInfo] = {
      helper.comDayCqDamCoreImplServletCollectionServlet(post, apply, delete, action, location, propertylist, cqDamBatchCollectionProperties, cqDamBatchCollectionMaxcollections)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamBatchCollectionsProperties  (optional)
   * @param cqDamBatchCollectionsLimit  (optional)
   * @return ComDayCqDamCoreImplServletCollectionsServletInfo
   */
  def comDayCqDamCoreImplServletCollectionsServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamBatchCollectionsProperties: Option[List[String]] = None, cqDamBatchCollectionsLimit: Option[Integer] = None): Option[ComDayCqDamCoreImplServletCollectionsServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletCollectionsServletAsync(post, apply, delete, action, location, propertylist, cqDamBatchCollectionsProperties, cqDamBatchCollectionsLimit), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamBatchCollectionsProperties  (optional)
   * @param cqDamBatchCollectionsLimit  (optional)
   * @return Future(ComDayCqDamCoreImplServletCollectionsServletInfo)
   */
  def comDayCqDamCoreImplServletCollectionsServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamBatchCollectionsProperties: Option[List[String]] = None, cqDamBatchCollectionsLimit: Option[Integer] = None): Future[ComDayCqDamCoreImplServletCollectionsServletInfo] = {
      helper.comDayCqDamCoreImplServletCollectionsServlet(post, apply, delete, action, location, propertylist, cqDamBatchCollectionsProperties, cqDamBatchCollectionsLimit)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param moreInfo  (optional)
   * @param mntoverlaydamguicontentassetsmoreinfoHtmlpath  (optional)
   * @return ComDayCqDamCoreImplServletCompanionServletInfo
   */
  def comDayCqDamCoreImplServletCompanionServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, moreInfo: Option[String] = None, mntoverlaydamguicontentassetsmoreinfoHtmlpath: Option[String] = None): Option[ComDayCqDamCoreImplServletCompanionServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletCompanionServletAsync(post, apply, delete, action, location, propertylist, moreInfo, mntoverlaydamguicontentassetsmoreinfoHtmlpath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param moreInfo  (optional)
   * @param mntoverlaydamguicontentassetsmoreinfoHtmlpath  (optional)
   * @return Future(ComDayCqDamCoreImplServletCompanionServletInfo)
   */
  def comDayCqDamCoreImplServletCompanionServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, moreInfo: Option[String] = None, mntoverlaydamguicontentassetsmoreinfoHtmlpath: Option[String] = None): Future[ComDayCqDamCoreImplServletCompanionServletInfo] = {
      helper.comDayCqDamCoreImplServletCompanionServlet(post, apply, delete, action, location, propertylist, moreInfo, mntoverlaydamguicontentassetsmoreinfoHtmlpath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param detectDuplicate  (optional)
   * @return ComDayCqDamCoreImplServletCreateAssetServletInfo
   */
  def comDayCqDamCoreImplServletCreateAssetServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, detectDuplicate: Option[Boolean] = None): Option[ComDayCqDamCoreImplServletCreateAssetServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletCreateAssetServletAsync(post, apply, delete, action, location, propertylist, detectDuplicate), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param detectDuplicate  (optional)
   * @return Future(ComDayCqDamCoreImplServletCreateAssetServletInfo)
   */
  def comDayCqDamCoreImplServletCreateAssetServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, detectDuplicate: Option[Boolean] = None): Future[ComDayCqDamCoreImplServletCreateAssetServletInfo] = {
      helper.comDayCqDamCoreImplServletCreateAssetServlet(post, apply, delete, action, location, propertylist, detectDuplicate)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqMimeTypeBlacklist  (optional)
   * @param cqDamEmptyMime  (optional)
   * @return ComDayCqDamCoreImplServletDamContentDispositionFilterInfo
   */
  def comDayCqDamCoreImplServletDamContentDispositionFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqMimeTypeBlacklist: Option[List[String]] = None, cqDamEmptyMime: Option[Boolean] = None): Option[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletDamContentDispositionFilterAsync(post, apply, delete, action, location, propertylist, cqMimeTypeBlacklist, cqDamEmptyMime), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqMimeTypeBlacklist  (optional)
   * @param cqDamEmptyMime  (optional)
   * @return Future(ComDayCqDamCoreImplServletDamContentDispositionFilterInfo)
   */
  def comDayCqDamCoreImplServletDamContentDispositionFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqMimeTypeBlacklist: Option[List[String]] = None, cqDamEmptyMime: Option[Boolean] = None): Future[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo] = {
      helper.comDayCqDamCoreImplServletDamContentDispositionFilter(post, apply, delete, action, location, propertylist, cqMimeTypeBlacklist, cqDamEmptyMime)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamCoreGuidlookupfilterEnabled  (optional)
   * @return ComDayCqDamCoreImplServletGuidLookupFilterInfo
   */
  def comDayCqDamCoreImplServletGuidLookupFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamCoreGuidlookupfilterEnabled: Option[Boolean] = None): Option[ComDayCqDamCoreImplServletGuidLookupFilterInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletGuidLookupFilterAsync(post, apply, delete, action, location, propertylist, cqDamCoreGuidlookupfilterEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamCoreGuidlookupfilterEnabled  (optional)
   * @return Future(ComDayCqDamCoreImplServletGuidLookupFilterInfo)
   */
  def comDayCqDamCoreImplServletGuidLookupFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamCoreGuidlookupfilterEnabled: Option[Boolean] = None): Future[ComDayCqDamCoreImplServletGuidLookupFilterInfo] = {
      helper.comDayCqDamCoreImplServletGuidLookupFilter(post, apply, delete, action, location, propertylist, cqDamCoreGuidlookupfilterEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamSyncWorkflowId  (optional)
   * @param cqDamSyncFolderTypes  (optional)
   * @return ComDayCqDamCoreImplServletHealthCheckServletInfo
   */
  def comDayCqDamCoreImplServletHealthCheckServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamSyncWorkflowId: Option[String] = None, cqDamSyncFolderTypes: Option[List[String]] = None): Option[ComDayCqDamCoreImplServletHealthCheckServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletHealthCheckServletAsync(post, apply, delete, action, location, propertylist, cqDamSyncWorkflowId, cqDamSyncFolderTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamSyncWorkflowId  (optional)
   * @param cqDamSyncFolderTypes  (optional)
   * @return Future(ComDayCqDamCoreImplServletHealthCheckServletInfo)
   */
  def comDayCqDamCoreImplServletHealthCheckServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamSyncWorkflowId: Option[String] = None, cqDamSyncFolderTypes: Option[List[String]] = None): Future[ComDayCqDamCoreImplServletHealthCheckServletInfo] = {
      helper.comDayCqDamCoreImplServletHealthCheckServlet(post, apply, delete, action, location, propertylist, cqDamSyncWorkflowId, cqDamSyncFolderTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletResourceTypes  (optional)
   * @param slingServletMethods  (optional)
   * @param slingServletExtensions  (optional)
   * @param slingServletSelectors  (optional)
   * @return ComDayCqDamCoreImplServletMetadataGetServletInfo
   */
  def comDayCqDamCoreImplServletMetadataGetServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletResourceTypes: Option[String] = None, slingServletMethods: Option[String] = None, slingServletExtensions: Option[String] = None, slingServletSelectors: Option[String] = None): Option[ComDayCqDamCoreImplServletMetadataGetServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletMetadataGetServletAsync(post, apply, delete, action, location, propertylist, slingServletResourceTypes, slingServletMethods, slingServletExtensions, slingServletSelectors), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletResourceTypes  (optional)
   * @param slingServletMethods  (optional)
   * @param slingServletExtensions  (optional)
   * @param slingServletSelectors  (optional)
   * @return Future(ComDayCqDamCoreImplServletMetadataGetServletInfo)
   */
  def comDayCqDamCoreImplServletMetadataGetServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletResourceTypes: Option[String] = None, slingServletMethods: Option[String] = None, slingServletExtensions: Option[String] = None, slingServletSelectors: Option[String] = None): Future[ComDayCqDamCoreImplServletMetadataGetServletInfo] = {
      helper.comDayCqDamCoreImplServletMetadataGetServlet(post, apply, delete, action, location, propertylist, slingServletResourceTypes, slingServletMethods, slingServletExtensions, slingServletSelectors)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamDrmEnable  (optional)
   * @return ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo
   */
  def comDayCqDamCoreImplServletMultipleLicenseAcceptServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamDrmEnable: Option[Boolean] = None): Option[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletMultipleLicenseAcceptServletAsync(post, apply, delete, action, location, propertylist, cqDamDrmEnable), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamDrmEnable  (optional)
   * @return Future(ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo)
   */
  def comDayCqDamCoreImplServletMultipleLicenseAcceptServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamDrmEnable: Option[Boolean] = None): Future[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo] = {
      helper.comDayCqDamCoreImplServletMultipleLicenseAcceptServlet(post, apply, delete, action, location, propertylist, cqDamDrmEnable)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletResourceTypes  (optional)
   * @param slingServletMethods  (optional)
   * @param slingServletSelectors  (optional)
   * @param downloadConfig  (optional)
   * @param viewSelector  (optional)
   * @param sendEmail  (optional)
   * @return ComDayCqDamCoreImplServletResourceCollectionServletInfo
   */
  def comDayCqDamCoreImplServletResourceCollectionServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletResourceTypes: Option[List[String]] = None, slingServletMethods: Option[String] = None, slingServletSelectors: Option[String] = None, downloadConfig: Option[String] = None, viewSelector: Option[String] = None, sendEmail: Option[Boolean] = None): Option[ComDayCqDamCoreImplServletResourceCollectionServletInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplServletResourceCollectionServletAsync(post, apply, delete, action, location, propertylist, slingServletResourceTypes, slingServletMethods, slingServletSelectors, downloadConfig, viewSelector, sendEmail), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletResourceTypes  (optional)
   * @param slingServletMethods  (optional)
   * @param slingServletSelectors  (optional)
   * @param downloadConfig  (optional)
   * @param viewSelector  (optional)
   * @param sendEmail  (optional)
   * @return Future(ComDayCqDamCoreImplServletResourceCollectionServletInfo)
   */
  def comDayCqDamCoreImplServletResourceCollectionServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletResourceTypes: Option[List[String]] = None, slingServletMethods: Option[String] = None, slingServletSelectors: Option[String] = None, downloadConfig: Option[String] = None, viewSelector: Option[String] = None, sendEmail: Option[Boolean] = None): Future[ComDayCqDamCoreImplServletResourceCollectionServletInfo] = {
      helper.comDayCqDamCoreImplServletResourceCollectionServlet(post, apply, delete, action, location, propertylist, slingServletResourceTypes, slingServletMethods, slingServletSelectors, downloadConfig, viewSelector, sendEmail)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param createPreviewEnabled  (optional)
   * @param updatePreviewEnabled  (optional)
   * @param queueSize  (optional)
   * @param folderPreviewRenditionRegex  (optional)
   * @return ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo
   */
  def comDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, createPreviewEnabled: Option[Boolean] = None, updatePreviewEnabled: Option[Boolean] = None, queueSize: Option[Integer] = None, folderPreviewRenditionRegex: Option[String] = None): Option[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplAsync(post, apply, delete, action, location, propertylist, createPreviewEnabled, updatePreviewEnabled, queueSize, folderPreviewRenditionRegex), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param createPreviewEnabled  (optional)
   * @param updatePreviewEnabled  (optional)
   * @param queueSize  (optional)
   * @param folderPreviewRenditionRegex  (optional)
   * @return Future(ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo)
   */
  def comDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, createPreviewEnabled: Option[Boolean] = None, updatePreviewEnabled: Option[Boolean] = None, queueSize: Option[Integer] = None, folderPreviewRenditionRegex: Option[String] = None): Future[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo] = {
      helper.comDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImpl(post, apply, delete, action, location, propertylist, createPreviewEnabled, updatePreviewEnabled, queueSize, folderPreviewRenditionRegex)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamConfigUnzipMaxuncompressedsize  (optional)
   * @param cqDamConfigUnzipEncoding  (optional)
   * @return ComDayCqDamCoreImplUnzipUnzipConfigInfo
   */
  def comDayCqDamCoreImplUnzipUnzipConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamConfigUnzipMaxuncompressedsize: Option[Integer] = None, cqDamConfigUnzipEncoding: Option[String] = None): Option[ComDayCqDamCoreImplUnzipUnzipConfigInfo] = {
    val await = Try(Await.result(comDayCqDamCoreImplUnzipUnzipConfigAsync(post, apply, delete, action, location, propertylist, cqDamConfigUnzipMaxuncompressedsize, cqDamConfigUnzipEncoding), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamConfigUnzipMaxuncompressedsize  (optional)
   * @param cqDamConfigUnzipEncoding  (optional)
   * @return Future(ComDayCqDamCoreImplUnzipUnzipConfigInfo)
   */
  def comDayCqDamCoreImplUnzipUnzipConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamConfigUnzipMaxuncompressedsize: Option[Integer] = None, cqDamConfigUnzipEncoding: Option[String] = None): Future[ComDayCqDamCoreImplUnzipUnzipConfigInfo] = {
      helper.comDayCqDamCoreImplUnzipUnzipConfig(post, apply, delete, action, location, propertylist, cqDamConfigUnzipMaxuncompressedsize, cqDamConfigUnzipEncoding)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param cqDamEnableSha1  (optional)
   * @return ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo
   */
  def comDayCqDamCoreProcessExifToolExtractMetadataProcess(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, cqDamEnableSha1: Option[Boolean] = None): Option[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo] = {
    val await = Try(Await.result(comDayCqDamCoreProcessExifToolExtractMetadataProcessAsync(post, apply, delete, action, location, propertylist, processLabel, cqDamEnableSha1), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param cqDamEnableSha1  (optional)
   * @return Future(ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo)
   */
  def comDayCqDamCoreProcessExifToolExtractMetadataProcessAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, cqDamEnableSha1: Option[Boolean] = None): Future[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo] = {
      helper.comDayCqDamCoreProcessExifToolExtractMetadataProcess(post, apply, delete, action, location, propertylist, processLabel, cqDamEnableSha1)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param cqDamEnableSha1  (optional)
   * @return ComDayCqDamCoreProcessExtractMetadataProcessInfo
   */
  def comDayCqDamCoreProcessExtractMetadataProcess(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, cqDamEnableSha1: Option[Boolean] = None): Option[ComDayCqDamCoreProcessExtractMetadataProcessInfo] = {
    val await = Try(Await.result(comDayCqDamCoreProcessExtractMetadataProcessAsync(post, apply, delete, action, location, propertylist, processLabel, cqDamEnableSha1), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param cqDamEnableSha1  (optional)
   * @return Future(ComDayCqDamCoreProcessExtractMetadataProcessInfo)
   */
  def comDayCqDamCoreProcessExtractMetadataProcessAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, cqDamEnableSha1: Option[Boolean] = None): Future[ComDayCqDamCoreProcessExtractMetadataProcessInfo] = {
      helper.comDayCqDamCoreProcessExtractMetadataProcess(post, apply, delete, action, location, propertylist, processLabel, cqDamEnableSha1)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param cqDamEnableSha1  (optional)
   * @param cqDamMetadataXssprotectedProperties  (optional)
   * @return ComDayCqDamCoreProcessMetadataProcessorProcessInfo
   */
  def comDayCqDamCoreProcessMetadataProcessorProcess(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, cqDamEnableSha1: Option[Boolean] = None, cqDamMetadataXssprotectedProperties: Option[List[String]] = None): Option[ComDayCqDamCoreProcessMetadataProcessorProcessInfo] = {
    val await = Try(Await.result(comDayCqDamCoreProcessMetadataProcessorProcessAsync(post, apply, delete, action, location, propertylist, processLabel, cqDamEnableSha1, cqDamMetadataXssprotectedProperties), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param cqDamEnableSha1  (optional)
   * @param cqDamMetadataXssprotectedProperties  (optional)
   * @return Future(ComDayCqDamCoreProcessMetadataProcessorProcessInfo)
   */
  def comDayCqDamCoreProcessMetadataProcessorProcessAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, cqDamEnableSha1: Option[Boolean] = None, cqDamMetadataXssprotectedProperties: Option[List[String]] = None): Future[ComDayCqDamCoreProcessMetadataProcessorProcessInfo] = {
      helper.comDayCqDamCoreProcessMetadataProcessorProcess(post, apply, delete, action, location, propertylist, processLabel, cqDamEnableSha1, cqDamMetadataXssprotectedProperties)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param executableSearchpath  (optional)
   * @return ComDayCqDamHandlerFfmpegLocatorImplInfo
   */
  def comDayCqDamHandlerFfmpegLocatorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, executableSearchpath: Option[List[String]] = None): Option[ComDayCqDamHandlerFfmpegLocatorImplInfo] = {
    val await = Try(Await.result(comDayCqDamHandlerFfmpegLocatorImplAsync(post, apply, delete, action, location, propertylist, executableSearchpath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param executableSearchpath  (optional)
   * @return Future(ComDayCqDamHandlerFfmpegLocatorImplInfo)
   */
  def comDayCqDamHandlerFfmpegLocatorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, executableSearchpath: Option[List[String]] = None): Future[ComDayCqDamHandlerFfmpegLocatorImplInfo] = {
      helper.comDayCqDamHandlerFfmpegLocatorImpl(post, apply, delete, action, location, propertylist, executableSearchpath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param fontmgrSystemFontDir  (optional)
   * @param fontmgrAdobeFontDir  (optional)
   * @param fontmgrCustomerFontDir  (optional)
   * @return ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo
   */
  def comDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, fontmgrSystemFontDir: Option[List[String]] = None, fontmgrAdobeFontDir: Option[String] = None, fontmgrCustomerFontDir: Option[String] = None): Option[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo] = {
    val await = Try(Await.result(comDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplAsync(post, apply, delete, action, location, propertylist, eventFilter, fontmgrSystemFontDir, fontmgrAdobeFontDir, fontmgrCustomerFontDir), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param fontmgrSystemFontDir  (optional)
   * @param fontmgrAdobeFontDir  (optional)
   * @param fontmgrCustomerFontDir  (optional)
   * @return Future(ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo)
   */
  def comDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, fontmgrSystemFontDir: Option[List[String]] = None, fontmgrAdobeFontDir: Option[String] = None, fontmgrCustomerFontDir: Option[String] = None): Future[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo] = {
      helper.comDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImpl(post, apply, delete, action, location, propertylist, eventFilter, fontmgrSystemFontDir, fontmgrAdobeFontDir, fontmgrCustomerFontDir)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param rasterAnnotation  (optional)
   * @return ComDayCqDamHandlerStandardPdfPdfHandlerInfo
   */
  def comDayCqDamHandlerStandardPdfPdfHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, rasterAnnotation: Option[Boolean] = None): Option[ComDayCqDamHandlerStandardPdfPdfHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamHandlerStandardPdfPdfHandlerAsync(post, apply, delete, action, location, propertylist, rasterAnnotation), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param rasterAnnotation  (optional)
   * @return Future(ComDayCqDamHandlerStandardPdfPdfHandlerInfo)
   */
  def comDayCqDamHandlerStandardPdfPdfHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, rasterAnnotation: Option[Boolean] = None): Future[ComDayCqDamHandlerStandardPdfPdfHandlerInfo] = {
      helper.comDayCqDamHandlerStandardPdfPdfHandler(post, apply, delete, action, location, propertylist, rasterAnnotation)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param rasterAnnotation  (optional)
   * @return ComDayCqDamHandlerStandardPsPostScriptHandlerInfo
   */
  def comDayCqDamHandlerStandardPsPostScriptHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, rasterAnnotation: Option[Boolean] = None): Option[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamHandlerStandardPsPostScriptHandlerAsync(post, apply, delete, action, location, propertylist, rasterAnnotation), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param rasterAnnotation  (optional)
   * @return Future(ComDayCqDamHandlerStandardPsPostScriptHandlerInfo)
   */
  def comDayCqDamHandlerStandardPsPostScriptHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, rasterAnnotation: Option[Boolean] = None): Future[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo] = {
      helper.comDayCqDamHandlerStandardPsPostScriptHandler(post, apply, delete, action, location, propertylist, rasterAnnotation)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param largeFileThreshold  (optional)
   * @return ComDayCqDamHandlerStandardPsdPsdHandlerInfo
   */
  def comDayCqDamHandlerStandardPsdPsdHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, largeFileThreshold: Option[Integer] = None): Option[ComDayCqDamHandlerStandardPsdPsdHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamHandlerStandardPsdPsdHandlerAsync(post, apply, delete, action, location, propertylist, largeFileThreshold), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param largeFileThreshold  (optional)
   * @return Future(ComDayCqDamHandlerStandardPsdPsdHandlerInfo)
   */
  def comDayCqDamHandlerStandardPsdPsdHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, largeFileThreshold: Option[Integer] = None): Future[ComDayCqDamHandlerStandardPsdPsdHandlerInfo] = {
      helper.comDayCqDamHandlerStandardPsdPsdHandler(post, apply, delete, action, location, propertylist, largeFileThreshold)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enableMultisession  (optional)
   * @param idsCcEnable  (optional)
   * @param enableRetry  (optional)
   * @param enableRetryScripterror  (optional)
   * @param externalizerDomainCqhost  (optional)
   * @param externalizerDomainHttp  (optional)
   * @return ComDayCqDamIdsImplIDSJobProcessorInfo
   */
  def comDayCqDamIdsImplIDSJobProcessor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enableMultisession: Option[Boolean] = None, idsCcEnable: Option[Boolean] = None, enableRetry: Option[Boolean] = None, enableRetryScripterror: Option[Boolean] = None, externalizerDomainCqhost: Option[String] = None, externalizerDomainHttp: Option[String] = None): Option[ComDayCqDamIdsImplIDSJobProcessorInfo] = {
    val await = Try(Await.result(comDayCqDamIdsImplIDSJobProcessorAsync(post, apply, delete, action, location, propertylist, enableMultisession, idsCcEnable, enableRetry, enableRetryScripterror, externalizerDomainCqhost, externalizerDomainHttp), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enableMultisession  (optional)
   * @param idsCcEnable  (optional)
   * @param enableRetry  (optional)
   * @param enableRetryScripterror  (optional)
   * @param externalizerDomainCqhost  (optional)
   * @param externalizerDomainHttp  (optional)
   * @return Future(ComDayCqDamIdsImplIDSJobProcessorInfo)
   */
  def comDayCqDamIdsImplIDSJobProcessorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enableMultisession: Option[Boolean] = None, idsCcEnable: Option[Boolean] = None, enableRetry: Option[Boolean] = None, enableRetryScripterror: Option[Boolean] = None, externalizerDomainCqhost: Option[String] = None, externalizerDomainHttp: Option[String] = None): Future[ComDayCqDamIdsImplIDSJobProcessorInfo] = {
      helper.comDayCqDamIdsImplIDSJobProcessor(post, apply, delete, action, location, propertylist, enableMultisession, idsCcEnable, enableRetry, enableRetryScripterror, externalizerDomainCqhost, externalizerDomainHttp)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxErrorsToBlacklist  (optional)
   * @param retryIntervalToWhitelist  (optional)
   * @param connectTimeout  (optional)
   * @param socketTimeout  (optional)
   * @param processLabel  (optional)
   * @param connectionUseMax  (optional)
   * @return ComDayCqDamIdsImplIDSPoolManagerImplInfo
   */
  def comDayCqDamIdsImplIDSPoolManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxErrorsToBlacklist: Option[Integer] = None, retryIntervalToWhitelist: Option[Integer] = None, connectTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None, processLabel: Option[String] = None, connectionUseMax: Option[Integer] = None): Option[ComDayCqDamIdsImplIDSPoolManagerImplInfo] = {
    val await = Try(Await.result(comDayCqDamIdsImplIDSPoolManagerImplAsync(post, apply, delete, action, location, propertylist, maxErrorsToBlacklist, retryIntervalToWhitelist, connectTimeout, socketTimeout, processLabel, connectionUseMax), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxErrorsToBlacklist  (optional)
   * @param retryIntervalToWhitelist  (optional)
   * @param connectTimeout  (optional)
   * @param socketTimeout  (optional)
   * @param processLabel  (optional)
   * @param connectionUseMax  (optional)
   * @return Future(ComDayCqDamIdsImplIDSPoolManagerImplInfo)
   */
  def comDayCqDamIdsImplIDSPoolManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxErrorsToBlacklist: Option[Integer] = None, retryIntervalToWhitelist: Option[Integer] = None, connectTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None, processLabel: Option[String] = None, connectionUseMax: Option[Integer] = None): Future[ComDayCqDamIdsImplIDSPoolManagerImplInfo] = {
      helper.comDayCqDamIdsImplIDSPoolManagerImpl(post, apply, delete, action, location, propertylist, maxErrorsToBlacklist, retryIntervalToWhitelist, connectTimeout, socketTimeout, processLabel, connectionUseMax)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param extractPages  (optional)
   * @return ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo
   */
  def comDayCqDamInddImplHandlerIndesignXMPHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, extractPages: Option[Boolean] = None): Option[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamInddImplHandlerIndesignXMPHandlerAsync(post, apply, delete, action, location, propertylist, processLabel, extractPages), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param extractPages  (optional)
   * @return Future(ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo)
   */
  def comDayCqDamInddImplHandlerIndesignXMPHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, extractPages: Option[Boolean] = None): Future[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo] = {
      helper.comDayCqDamInddImplHandlerIndesignXMPHandler(post, apply, delete, action, location, propertylist, processLabel, extractPages)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param snippetcreationMaxcollections  (optional)
   * @return ComDayCqDamInddImplServletSnippetCreationServletInfo
   */
  def comDayCqDamInddImplServletSnippetCreationServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, snippetcreationMaxcollections: Option[Integer] = None): Option[ComDayCqDamInddImplServletSnippetCreationServletInfo] = {
    val await = Try(Await.result(comDayCqDamInddImplServletSnippetCreationServletAsync(post, apply, delete, action, location, propertylist, snippetcreationMaxcollections), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param snippetcreationMaxcollections  (optional)
   * @return Future(ComDayCqDamInddImplServletSnippetCreationServletInfo)
   */
  def comDayCqDamInddImplServletSnippetCreationServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, snippetcreationMaxcollections: Option[Integer] = None): Future[ComDayCqDamInddImplServletSnippetCreationServletInfo] = {
      helper.comDayCqDamInddImplServletSnippetCreationServlet(post, apply, delete, action, location, propertylist, snippetcreationMaxcollections)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param cqDamInddPagesRegex  (optional)
   * @param idsJobDecoupled  (optional)
   * @param idsJobWorkflowModel  (optional)
   * @return ComDayCqDamInddProcessINDDMediaExtractProcessInfo
   */
  def comDayCqDamInddProcessINDDMediaExtractProcess(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, cqDamInddPagesRegex: Option[String] = None, idsJobDecoupled: Option[Boolean] = None, idsJobWorkflowModel: Option[String] = None): Option[ComDayCqDamInddProcessINDDMediaExtractProcessInfo] = {
    val await = Try(Await.result(comDayCqDamInddProcessINDDMediaExtractProcessAsync(post, apply, delete, action, location, propertylist, processLabel, cqDamInddPagesRegex, idsJobDecoupled, idsJobWorkflowModel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @param cqDamInddPagesRegex  (optional)
   * @param idsJobDecoupled  (optional)
   * @param idsJobWorkflowModel  (optional)
   * @return Future(ComDayCqDamInddProcessINDDMediaExtractProcessInfo)
   */
  def comDayCqDamInddProcessINDDMediaExtractProcessAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None, cqDamInddPagesRegex: Option[String] = None, idsJobDecoupled: Option[Boolean] = None, idsJobWorkflowModel: Option[String] = None): Future[ComDayCqDamInddProcessINDDMediaExtractProcessInfo] = {
      helper.comDayCqDamInddProcessINDDMediaExtractProcess(post, apply, delete, action, location, propertylist, processLabel, cqDamInddPagesRegex, idsJobDecoupled, idsJobWorkflowModel)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param batchCommitSize  (optional)
   * @return ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo
   */
  def comDayCqDamPerformanceInternalAssetPerformanceDataHandlerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, batchCommitSize: Option[Integer] = None): Option[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo] = {
    val await = Try(Await.result(comDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplAsync(post, apply, delete, action, location, propertylist, batchCommitSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param batchCommitSize  (optional)
   * @return Future(ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo)
   */
  def comDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, batchCommitSize: Option[Integer] = None): Future[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo] = {
      helper.comDayCqDamPerformanceInternalAssetPerformanceDataHandlerImpl(post, apply, delete, action, location, propertylist, batchCommitSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @return ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo
   */
  def comDayCqDamPerformanceInternalAssetPerformanceReportSyncJob(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None): Option[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo] = {
    val await = Try(Await.result(comDayCqDamPerformanceInternalAssetPerformanceReportSyncJobAsync(post, apply, delete, action, location, propertylist, schedulerExpression), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @return Future(ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo)
   */
  def comDayCqDamPerformanceInternalAssetPerformanceReportSyncJobAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None): Future[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo] = {
      helper.comDayCqDamPerformanceInternalAssetPerformanceReportSyncJob(post, apply, delete, action, location, propertylist, schedulerExpression)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param deleteZipFile  (optional)
   * @return ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo
   */
  def comDayCqDamPimImplSourcingUploadProcessProductAssetsUploadPro(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, deleteZipFile: Option[Boolean] = None): Option[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo] = {
    val await = Try(Await.result(comDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProAsync(post, apply, delete, action, location, propertylist, deleteZipFile), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param deleteZipFile  (optional)
   * @return Future(ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo)
   */
  def comDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, deleteZipFile: Option[Boolean] = None): Future[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo] = {
      helper.comDayCqDamPimImplSourcingUploadProcessProductAssetsUploadPro(post, apply, delete, action, location, propertylist, deleteZipFile)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamS7damDynamicmediaconfigeventlistenerEnabled  (optional)
   * @return ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo
   */
  def comDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEven(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamS7damDynamicmediaconfigeventlistenerEnabled: Option[Boolean] = None): Option[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo] = {
    val await = Try(Await.result(comDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenAsync(post, apply, delete, action, location, propertylist, cqDamS7damDynamicmediaconfigeventlistenerEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamS7damDynamicmediaconfigeventlistenerEnabled  (optional)
   * @return Future(ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo)
   */
  def comDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamS7damDynamicmediaconfigeventlistenerEnabled: Option[Boolean] = None): Future[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo] = {
      helper.comDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEven(post, apply, delete, action, location, propertylist, cqDamS7damDynamicmediaconfigeventlistenerEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param schedulerConcurrent  (optional)
   * @return ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo
   */
  def comDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunner(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, schedulerConcurrent: Option[Boolean] = None): Option[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo] = {
    val await = Try(Await.result(comDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerAsync(post, apply, delete, action, location, propertylist, schedulerExpression, schedulerConcurrent), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param schedulerConcurrent  (optional)
   * @return Future(ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo)
   */
  def comDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, schedulerConcurrent: Option[Boolean] = None): Future[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo] = {
      helper.comDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunner(post, apply, delete, action, location, propertylist, schedulerExpression, schedulerConcurrent)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingPostOperation  (optional)
   * @param slingServletMethods  (optional)
   * @return ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo
   */
  def comDayCqDamS7damCommonPostServletsSetCreateHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingPostOperation: Option[String] = None, slingServletMethods: Option[String] = None): Option[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamS7damCommonPostServletsSetCreateHandlerAsync(post, apply, delete, action, location, propertylist, slingPostOperation, slingServletMethods), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingPostOperation  (optional)
   * @param slingServletMethods  (optional)
   * @return Future(ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo)
   */
  def comDayCqDamS7damCommonPostServletsSetCreateHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingPostOperation: Option[String] = None, slingServletMethods: Option[String] = None): Future[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo] = {
      helper.comDayCqDamS7damCommonPostServletsSetCreateHandler(post, apply, delete, action, location, propertylist, slingPostOperation, slingServletMethods)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingPostOperation  (optional)
   * @param slingServletMethods  (optional)
   * @return ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo
   */
  def comDayCqDamS7damCommonPostServletsSetModifyHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingPostOperation: Option[String] = None, slingServletMethods: Option[String] = None): Option[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo] = {
    val await = Try(Await.result(comDayCqDamS7damCommonPostServletsSetModifyHandlerAsync(post, apply, delete, action, location, propertylist, slingPostOperation, slingServletMethods), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingPostOperation  (optional)
   * @param slingServletMethods  (optional)
   * @return Future(ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo)
   */
  def comDayCqDamS7damCommonPostServletsSetModifyHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingPostOperation: Option[String] = None, slingServletMethods: Option[String] = None): Future[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo] = {
      helper.comDayCqDamS7damCommonPostServletsSetModifyHandler(post, apply, delete, action, location, propertylist, slingPostOperation, slingServletMethods)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @return ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo
   */
  def comDayCqDamS7damCommonProcessVideoThumbnailDownloadProcess(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None): Option[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo] = {
    val await = Try(Await.result(comDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessAsync(post, apply, delete, action, location, propertylist, processLabel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param processLabel  (optional)
   * @return Future(ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo)
   */
  def comDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, processLabel: Option[String] = None): Future[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo] = {
      helper.comDayCqDamS7damCommonProcessVideoThumbnailDownloadProcess(post, apply, delete, action, location, propertylist, processLabel)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamS7damDamchangeeventlistenerEnabled  (optional)
   * @return ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo
   */
  def comDayCqDamS7damCommonS7damDamChangeEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamS7damDamchangeeventlistenerEnabled: Option[Boolean] = None): Option[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo] = {
    val await = Try(Await.result(comDayCqDamS7damCommonS7damDamChangeEventListenerAsync(post, apply, delete, action, location, propertylist, cqDamS7damDamchangeeventlistenerEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamS7damDamchangeeventlistenerEnabled  (optional)
   * @return Future(ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo)
   */
  def comDayCqDamS7damCommonS7damDamChangeEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamS7damDamchangeeventlistenerEnabled: Option[Boolean] = None): Future[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo] = {
      helper.comDayCqDamS7damCommonS7damDamChangeEventListener(post, apply, delete, action, location, propertylist, cqDamS7damDamchangeeventlistenerEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletPaths  (optional)
   * @param slingServletMethods  (optional)
   * @return ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo
   */
  def comDayCqDamS7damCommonServletsS7damProductInfoServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletPaths: Option[String] = None, slingServletMethods: Option[String] = None): Option[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo] = {
    val await = Try(Await.result(comDayCqDamS7damCommonServletsS7damProductInfoServletAsync(post, apply, delete, action, location, propertylist, slingServletPaths, slingServletMethods), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletPaths  (optional)
   * @param slingServletMethods  (optional)
   * @return Future(ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo)
   */
  def comDayCqDamS7damCommonServletsS7damProductInfoServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletPaths: Option[String] = None, slingServletMethods: Option[String] = None): Future[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo] = {
      helper.comDayCqDamS7damCommonServletsS7damProductInfoServlet(post, apply, delete, action, location, propertylist, slingServletPaths, slingServletMethods)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName  (optional)
   * @param cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName  (optional)
   * @param cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName  (optional)
   * @param cqDamS7damVideoproxyclientserviceHttpReadtimeoutName  (optional)
   * @param cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName  (optional)
   * @param cqDamS7damVideoproxyclientserviceHttpMaxretrycountName  (optional)
   * @param cqDamS7damVideoproxyclientserviceUploadprogressIntervalName  (optional)
   * @return ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo
   */
  def comDayCqDamS7damCommonVideoImplVideoProxyClientServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceHttpReadtimeoutName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceHttpMaxretrycountName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceUploadprogressIntervalName: Option[Integer] = None): Option[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo] = {
    val await = Try(Await.result(comDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplAsync(post, apply, delete, action, location, propertylist, cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName, cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName, cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName, cqDamS7damVideoproxyclientserviceHttpReadtimeoutName, cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName, cqDamS7damVideoproxyclientserviceHttpMaxretrycountName, cqDamS7damVideoproxyclientserviceUploadprogressIntervalName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName  (optional)
   * @param cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName  (optional)
   * @param cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName  (optional)
   * @param cqDamS7damVideoproxyclientserviceHttpReadtimeoutName  (optional)
   * @param cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName  (optional)
   * @param cqDamS7damVideoproxyclientserviceHttpMaxretrycountName  (optional)
   * @param cqDamS7damVideoproxyclientserviceUploadprogressIntervalName  (optional)
   * @return Future(ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo)
   */
  def comDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceHttpReadtimeoutName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceHttpMaxretrycountName: Option[Integer] = None, cqDamS7damVideoproxyclientserviceUploadprogressIntervalName: Option[Integer] = None): Future[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo] = {
      helper.comDayCqDamS7damCommonVideoImplVideoProxyClientServiceImpl(post, apply, delete, action, location, propertylist, cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName, cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName, cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName, cqDamS7damVideoproxyclientserviceHttpReadtimeoutName, cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName, cqDamS7damVideoproxyclientserviceHttpMaxretrycountName, cqDamS7damVideoproxyclientserviceUploadprogressIntervalName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamScene7ApiclientRecordsperpageNofilterName  (optional)
   * @param cqDamScene7ApiclientRecordsperpageWithfilterName  (optional)
   * @return ComDayCqDamScene7ImplScene7APIClientImplInfo
   */
  def comDayCqDamScene7ImplScene7APIClientImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamScene7ApiclientRecordsperpageNofilterName: Option[Integer] = None, cqDamScene7ApiclientRecordsperpageWithfilterName: Option[Integer] = None): Option[ComDayCqDamScene7ImplScene7APIClientImplInfo] = {
    val await = Try(Await.result(comDayCqDamScene7ImplScene7APIClientImplAsync(post, apply, delete, action, location, propertylist, cqDamScene7ApiclientRecordsperpageNofilterName, cqDamScene7ApiclientRecordsperpageWithfilterName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamScene7ApiclientRecordsperpageNofilterName  (optional)
   * @param cqDamScene7ApiclientRecordsperpageWithfilterName  (optional)
   * @return Future(ComDayCqDamScene7ImplScene7APIClientImplInfo)
   */
  def comDayCqDamScene7ImplScene7APIClientImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamScene7ApiclientRecordsperpageNofilterName: Option[Integer] = None, cqDamScene7ApiclientRecordsperpageWithfilterName: Option[Integer] = None): Future[ComDayCqDamScene7ImplScene7APIClientImplInfo] = {
      helper.comDayCqDamScene7ImplScene7APIClientImpl(post, apply, delete, action, location, propertylist, cqDamScene7ApiclientRecordsperpageNofilterName, cqDamScene7ApiclientRecordsperpageWithfilterName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamScene7AssetmimetypeserviceMapping  (optional)
   * @return ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo
   */
  def comDayCqDamScene7ImplScene7AssetMimeTypeServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamScene7AssetmimetypeserviceMapping: Option[List[String]] = None): Option[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo] = {
    val await = Try(Await.result(comDayCqDamScene7ImplScene7AssetMimeTypeServiceImplAsync(post, apply, delete, action, location, propertylist, cqDamScene7AssetmimetypeserviceMapping), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamScene7AssetmimetypeserviceMapping  (optional)
   * @return Future(ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo)
   */
  def comDayCqDamScene7ImplScene7AssetMimeTypeServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamScene7AssetmimetypeserviceMapping: Option[List[String]] = None): Future[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo] = {
      helper.comDayCqDamScene7ImplScene7AssetMimeTypeServiceImpl(post, apply, delete, action, location, propertylist, cqDamScene7AssetmimetypeserviceMapping)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamScene7ConfigurationeventlistenerEnabled  (optional)
   * @return ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo
   */
  def comDayCqDamScene7ImplScene7ConfigurationEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamScene7ConfigurationeventlistenerEnabled: Option[Boolean] = None): Option[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo] = {
    val await = Try(Await.result(comDayCqDamScene7ImplScene7ConfigurationEventListenerAsync(post, apply, delete, action, location, propertylist, cqDamScene7ConfigurationeventlistenerEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamScene7ConfigurationeventlistenerEnabled  (optional)
   * @return Future(ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo)
   */
  def comDayCqDamScene7ImplScene7ConfigurationEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamScene7ConfigurationeventlistenerEnabled: Option[Boolean] = None): Future[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo] = {
      helper.comDayCqDamScene7ImplScene7ConfigurationEventListener(post, apply, delete, action, location, propertylist, cqDamScene7ConfigurationeventlistenerEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamScene7DamchangeeventlistenerEnabled  (optional)
   * @param cqDamScene7DamchangeeventlistenerObservedPaths  (optional)
   * @return ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo
   */
  def comDayCqDamScene7ImplScene7DamChangeEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamScene7DamchangeeventlistenerEnabled: Option[Boolean] = None, cqDamScene7DamchangeeventlistenerObservedPaths: Option[List[String]] = None): Option[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo] = {
    val await = Try(Await.result(comDayCqDamScene7ImplScene7DamChangeEventListenerAsync(post, apply, delete, action, location, propertylist, cqDamScene7DamchangeeventlistenerEnabled, cqDamScene7DamchangeeventlistenerObservedPaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamScene7DamchangeeventlistenerEnabled  (optional)
   * @param cqDamScene7DamchangeeventlistenerObservedPaths  (optional)
   * @return Future(ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo)
   */
  def comDayCqDamScene7ImplScene7DamChangeEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamScene7DamchangeeventlistenerEnabled: Option[Boolean] = None, cqDamScene7DamchangeeventlistenerObservedPaths: Option[List[String]] = None): Future[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo] = {
      helper.comDayCqDamScene7ImplScene7DamChangeEventListener(post, apply, delete, action, location, propertylist, cqDamScene7DamchangeeventlistenerEnabled, cqDamScene7DamchangeeventlistenerObservedPaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param scene7FlashTemplatesRti  (optional)
   * @param scene7FlashTemplatesRsi  (optional)
   * @param scene7FlashTemplatesRb  (optional)
   * @param scene7FlashTemplatesRurl  (optional)
   * @param scene7FlashTemplateUrlFormatParameter  (optional)
   * @return ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo
   */
  def comDayCqDamScene7ImplScene7FlashTemplatesServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, scene7FlashTemplatesRti: Option[String] = None, scene7FlashTemplatesRsi: Option[String] = None, scene7FlashTemplatesRb: Option[String] = None, scene7FlashTemplatesRurl: Option[String] = None, scene7FlashTemplateUrlFormatParameter: Option[String] = None): Option[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo] = {
    val await = Try(Await.result(comDayCqDamScene7ImplScene7FlashTemplatesServiceImplAsync(post, apply, delete, action, location, propertylist, scene7FlashTemplatesRti, scene7FlashTemplatesRsi, scene7FlashTemplatesRb, scene7FlashTemplatesRurl, scene7FlashTemplateUrlFormatParameter), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param scene7FlashTemplatesRti  (optional)
   * @param scene7FlashTemplatesRsi  (optional)
   * @param scene7FlashTemplatesRb  (optional)
   * @param scene7FlashTemplatesRurl  (optional)
   * @param scene7FlashTemplateUrlFormatParameter  (optional)
   * @return Future(ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo)
   */
  def comDayCqDamScene7ImplScene7FlashTemplatesServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, scene7FlashTemplatesRti: Option[String] = None, scene7FlashTemplatesRsi: Option[String] = None, scene7FlashTemplatesRb: Option[String] = None, scene7FlashTemplatesRurl: Option[String] = None, scene7FlashTemplateUrlFormatParameter: Option[String] = None): Future[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo] = {
      helper.comDayCqDamScene7ImplScene7FlashTemplatesServiceImpl(post, apply, delete, action, location, propertylist, scene7FlashTemplatesRti, scene7FlashTemplatesRsi, scene7FlashTemplatesRb, scene7FlashTemplatesRurl, scene7FlashTemplateUrlFormatParameter)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamScene7UploadserviceActivejobtimeoutLabel  (optional)
   * @param cqDamScene7UploadserviceConnectionmaxperrouteLabel  (optional)
   * @return ComDayCqDamScene7ImplScene7UploadServiceImplInfo
   */
  def comDayCqDamScene7ImplScene7UploadServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamScene7UploadserviceActivejobtimeoutLabel: Option[Integer] = None, cqDamScene7UploadserviceConnectionmaxperrouteLabel: Option[Integer] = None): Option[ComDayCqDamScene7ImplScene7UploadServiceImplInfo] = {
    val await = Try(Await.result(comDayCqDamScene7ImplScene7UploadServiceImplAsync(post, apply, delete, action, location, propertylist, cqDamScene7UploadserviceActivejobtimeoutLabel, cqDamScene7UploadserviceConnectionmaxperrouteLabel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqDamScene7UploadserviceActivejobtimeoutLabel  (optional)
   * @param cqDamScene7UploadserviceConnectionmaxperrouteLabel  (optional)
   * @return Future(ComDayCqDamScene7ImplScene7UploadServiceImplInfo)
   */
  def comDayCqDamScene7ImplScene7UploadServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqDamScene7UploadserviceActivejobtimeoutLabel: Option[Integer] = None, cqDamScene7UploadserviceConnectionmaxperrouteLabel: Option[Integer] = None): Future[ComDayCqDamScene7ImplScene7UploadServiceImplInfo] = {
      helper.comDayCqDamScene7ImplScene7UploadServiceImpl(post, apply, delete, action, location, propertylist, cqDamScene7UploadserviceActivejobtimeoutLabel, cqDamScene7UploadserviceConnectionmaxperrouteLabel)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param getCacheExpirationUnit  (optional)
   * @param getCacheExpirationValue  (optional)
   * @return ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo
   */
  def comDayCqDamStockIntegrationImplCacheStockCacheConfigurationSer(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, getCacheExpirationUnit: Option[String] = None, getCacheExpirationValue: Option[Integer] = None): Option[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo] = {
    val await = Try(Await.result(comDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerAsync(post, apply, delete, action, location, propertylist, getCacheExpirationUnit, getCacheExpirationValue), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param getCacheExpirationUnit  (optional)
   * @param getCacheExpirationValue  (optional)
   * @return Future(ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo)
   */
  def comDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, getCacheExpirationUnit: Option[String] = None, getCacheExpirationValue: Option[Integer] = None): Future[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo] = {
      helper.comDayCqDamStockIntegrationImplCacheStockCacheConfigurationSer(post, apply, delete, action, location, propertylist, getCacheExpirationUnit, getCacheExpirationValue)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param locale  (optional)
   * @param imsConfig  (optional)
   * @return ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo
   */
  def comDayCqDamStockIntegrationImplConfigurationStockConfiguration(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, locale: Option[String] = None, imsConfig: Option[String] = None): Option[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo] = {
    val await = Try(Await.result(comDayCqDamStockIntegrationImplConfigurationStockConfigurationAsync(post, apply, delete, action, location, propertylist, name, locale, imsConfig), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param locale  (optional)
   * @param imsConfig  (optional)
   * @return Future(ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo)
   */
  def comDayCqDamStockIntegrationImplConfigurationStockConfigurationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, locale: Option[String] = None, imsConfig: Option[String] = None): Future[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo] = {
      helper.comDayCqDamStockIntegrationImplConfigurationStockConfiguration(post, apply, delete, action, location, propertylist, name, locale, imsConfig)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return ComDayCqDamVideoImplServletVideoTestServletInfo
   */
  def comDayCqDamVideoImplServletVideoTestServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Option[ComDayCqDamVideoImplServletVideoTestServletInfo] = {
    val await = Try(Await.result(comDayCqDamVideoImplServletVideoTestServletAsync(post, apply, delete, action, location, propertylist, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return Future(ComDayCqDamVideoImplServletVideoTestServletInfo)
   */
  def comDayCqDamVideoImplServletVideoTestServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Future[ComDayCqDamVideoImplServletVideoTestServletInfo] = {
      helper.comDayCqDamVideoImplServletVideoTestServlet(post, apply, delete, action, location, propertylist, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxWidth  (optional)
   * @param maxHeight  (optional)
   * @return ComDayCqExtwidgetServletsImageSpriteServletInfo
   */
  def comDayCqExtwidgetServletsImageSpriteServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxWidth: Option[Integer] = None, maxHeight: Option[Integer] = None): Option[ComDayCqExtwidgetServletsImageSpriteServletInfo] = {
    val await = Try(Await.result(comDayCqExtwidgetServletsImageSpriteServletAsync(post, apply, delete, action, location, propertylist, maxWidth, maxHeight), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxWidth  (optional)
   * @param maxHeight  (optional)
   * @return Future(ComDayCqExtwidgetServletsImageSpriteServletInfo)
   */
  def comDayCqExtwidgetServletsImageSpriteServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxWidth: Option[Integer] = None, maxHeight: Option[Integer] = None): Future[ComDayCqExtwidgetServletsImageSpriteServletInfo] = {
      helper.comDayCqExtwidgetServletsImageSpriteServlet(post, apply, delete, action, location, propertylist, maxWidth, maxHeight)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fontpath  (optional)
   * @param oversamplingFactor  (optional)
   * @return ComDayCqImageInternalFontFontHelperInfo
   */
  def comDayCqImageInternalFontFontHelper(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fontpath: Option[List[String]] = None, oversamplingFactor: Option[Integer] = None): Option[ComDayCqImageInternalFontFontHelperInfo] = {
    val await = Try(Await.result(comDayCqImageInternalFontFontHelperAsync(post, apply, delete, action, location, propertylist, fontpath, oversamplingFactor), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fontpath  (optional)
   * @param oversamplingFactor  (optional)
   * @return Future(ComDayCqImageInternalFontFontHelperInfo)
   */
  def comDayCqImageInternalFontFontHelperAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fontpath: Option[List[String]] = None, oversamplingFactor: Option[Integer] = None): Future[ComDayCqImageInternalFontFontHelperInfo] = {
      helper.comDayCqImageInternalFontFontHelper(post, apply, delete, action, location, propertylist, fontpath, oversamplingFactor)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param clusterLevelEnable  (optional)
   * @param clusterMasterLevel  (optional)
   * @param clusterSlaveLevel  (optional)
   * @return ComDayCqJcrclustersupportClusterStartLevelControllerInfo
   */
  def comDayCqJcrclustersupportClusterStartLevelController(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, clusterLevelEnable: Option[Boolean] = None, clusterMasterLevel: Option[Integer] = None, clusterSlaveLevel: Option[Integer] = None): Option[ComDayCqJcrclustersupportClusterStartLevelControllerInfo] = {
    val await = Try(Await.result(comDayCqJcrclustersupportClusterStartLevelControllerAsync(post, apply, delete, action, location, propertylist, clusterLevelEnable, clusterMasterLevel, clusterSlaveLevel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param clusterLevelEnable  (optional)
   * @param clusterMasterLevel  (optional)
   * @param clusterSlaveLevel  (optional)
   * @return Future(ComDayCqJcrclustersupportClusterStartLevelControllerInfo)
   */
  def comDayCqJcrclustersupportClusterStartLevelControllerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, clusterLevelEnable: Option[Boolean] = None, clusterMasterLevel: Option[Integer] = None, clusterSlaveLevel: Option[Integer] = None): Future[ComDayCqJcrclustersupportClusterStartLevelControllerInfo] = {
      helper.comDayCqJcrclustersupportClusterStartLevelController(post, apply, delete, action, location, propertylist, clusterLevelEnable, clusterMasterLevel, clusterSlaveLevel)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param smtpHost  (optional)
   * @param smtpPort  (optional)
   * @param smtpUser  (optional)
   * @param smtpPassword  (optional)
   * @param fromAddress  (optional)
   * @param smtpSsl  (optional)
   * @param smtpStarttls  (optional)
   * @param debugEmail  (optional)
   * @return ComDayCqMailerDefaultMailServiceInfo
   */
  def comDayCqMailerDefaultMailService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, smtpHost: Option[String] = None, smtpPort: Option[Integer] = None, smtpUser: Option[String] = None, smtpPassword: Option[String] = None, fromAddress: Option[String] = None, smtpSsl: Option[Boolean] = None, smtpStarttls: Option[Boolean] = None, debugEmail: Option[Boolean] = None): Option[ComDayCqMailerDefaultMailServiceInfo] = {
    val await = Try(Await.result(comDayCqMailerDefaultMailServiceAsync(post, apply, delete, action, location, propertylist, smtpHost, smtpPort, smtpUser, smtpPassword, fromAddress, smtpSsl, smtpStarttls, debugEmail), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param smtpHost  (optional)
   * @param smtpPort  (optional)
   * @param smtpUser  (optional)
   * @param smtpPassword  (optional)
   * @param fromAddress  (optional)
   * @param smtpSsl  (optional)
   * @param smtpStarttls  (optional)
   * @param debugEmail  (optional)
   * @return Future(ComDayCqMailerDefaultMailServiceInfo)
   */
  def comDayCqMailerDefaultMailServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, smtpHost: Option[String] = None, smtpPort: Option[Integer] = None, smtpUser: Option[String] = None, smtpPassword: Option[String] = None, fromAddress: Option[String] = None, smtpSsl: Option[Boolean] = None, smtpStarttls: Option[Boolean] = None, debugEmail: Option[Boolean] = None): Future[ComDayCqMailerDefaultMailServiceInfo] = {
      helper.comDayCqMailerDefaultMailService(post, apply, delete, action, location, propertylist, smtpHost, smtpPort, smtpUser, smtpPassword, fromAddress, smtpSsl, smtpStarttls, debugEmail)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxRecipientCount  (optional)
   * @return ComDayCqMailerImplCqMailingServiceInfo
   */
  def comDayCqMailerImplCqMailingService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxRecipientCount: Option[String] = None): Option[ComDayCqMailerImplCqMailingServiceInfo] = {
    val await = Try(Await.result(comDayCqMailerImplCqMailingServiceAsync(post, apply, delete, action, location, propertylist, maxRecipientCount), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxRecipientCount  (optional)
   * @return Future(ComDayCqMailerImplCqMailingServiceInfo)
   */
  def comDayCqMailerImplCqMailingServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxRecipientCount: Option[String] = None): Future[ComDayCqMailerImplCqMailingServiceInfo] = {
      helper.comDayCqMailerImplCqMailingService(post, apply, delete, action, location, propertylist, maxRecipientCount)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mailerEmailCharset  (optional)
   * @return ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo
   */
  def comDayCqMailerImplEmailCqEmailTemplateFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mailerEmailCharset: Option[String] = None): Option[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo] = {
    val await = Try(Await.result(comDayCqMailerImplEmailCqEmailTemplateFactoryAsync(post, apply, delete, action, location, propertylist, mailerEmailCharset), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mailerEmailCharset  (optional)
   * @return Future(ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo)
   */
  def comDayCqMailerImplEmailCqEmailTemplateFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mailerEmailCharset: Option[String] = None): Future[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo] = {
      helper.comDayCqMailerImplEmailCqEmailTemplateFactory(post, apply, delete, action, location, propertylist, mailerEmailCharset)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mailerEmailEmbed  (optional)
   * @param mailerEmailCharset  (optional)
   * @param mailerEmailRetrieverUserID  (optional)
   * @param mailerEmailRetrieverUserPWD  (optional)
   * @return ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo
   */
  def comDayCqMailerImplEmailCqRetrieverTemplateFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mailerEmailEmbed: Option[Boolean] = None, mailerEmailCharset: Option[String] = None, mailerEmailRetrieverUserID: Option[String] = None, mailerEmailRetrieverUserPWD: Option[String] = None): Option[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo] = {
    val await = Try(Await.result(comDayCqMailerImplEmailCqRetrieverTemplateFactoryAsync(post, apply, delete, action, location, propertylist, mailerEmailEmbed, mailerEmailCharset, mailerEmailRetrieverUserID, mailerEmailRetrieverUserPWD), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mailerEmailEmbed  (optional)
   * @param mailerEmailCharset  (optional)
   * @param mailerEmailRetrieverUserID  (optional)
   * @param mailerEmailRetrieverUserPWD  (optional)
   * @return Future(ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo)
   */
  def comDayCqMailerImplEmailCqRetrieverTemplateFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mailerEmailEmbed: Option[Boolean] = None, mailerEmailCharset: Option[String] = None, mailerEmailRetrieverUserID: Option[String] = None, mailerEmailRetrieverUserPWD: Option[String] = None): Future[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo] = {
      helper.comDayCqMailerImplEmailCqRetrieverTemplateFactory(post, apply, delete, action, location, propertylist, mailerEmailEmbed, mailerEmailCharset, mailerEmailRetrieverUserID, mailerEmailRetrieverUserPWD)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param aemMcmCampaignFormConstraints  (optional)
   * @param aemMcmCampaignPublicUrl  (optional)
   * @param aemMcmCampaignRelaxedSSL  (optional)
   * @return ComDayCqMcmCampaignImplIntegrationConfigImplInfo
   */
  def comDayCqMcmCampaignImplIntegrationConfigImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, aemMcmCampaignFormConstraints: Option[List[String]] = None, aemMcmCampaignPublicUrl: Option[String] = None, aemMcmCampaignRelaxedSSL: Option[Boolean] = None): Option[ComDayCqMcmCampaignImplIntegrationConfigImplInfo] = {
    val await = Try(Await.result(comDayCqMcmCampaignImplIntegrationConfigImplAsync(post, apply, delete, action, location, propertylist, aemMcmCampaignFormConstraints, aemMcmCampaignPublicUrl, aemMcmCampaignRelaxedSSL), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param aemMcmCampaignFormConstraints  (optional)
   * @param aemMcmCampaignPublicUrl  (optional)
   * @param aemMcmCampaignRelaxedSSL  (optional)
   * @return Future(ComDayCqMcmCampaignImplIntegrationConfigImplInfo)
   */
  def comDayCqMcmCampaignImplIntegrationConfigImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, aemMcmCampaignFormConstraints: Option[List[String]] = None, aemMcmCampaignPublicUrl: Option[String] = None, aemMcmCampaignRelaxedSSL: Option[Boolean] = None): Future[ComDayCqMcmCampaignImplIntegrationConfigImplInfo] = {
      helper.comDayCqMcmCampaignImplIntegrationConfigImpl(post, apply, delete, action, location, propertylist, aemMcmCampaignFormConstraints, aemMcmCampaignPublicUrl, aemMcmCampaignRelaxedSSL)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo
   */
  def comDayCqMcmCampaignImporterPersonalizedTextHandlerFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo] = {
    val await = Try(Await.result(comDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo)
   */
  def comDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo] = {
      helper.comDayCqMcmCampaignImporterPersonalizedTextHandlerFactory(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fromAddress  (optional)
   * @param senderHost  (optional)
   * @param maxBounceCount  (optional)
   * @return ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo
   */
  def comDayCqMcmCoreNewsletterNewsletterEmailServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fromAddress: Option[String] = None, senderHost: Option[String] = None, maxBounceCount: Option[String] = None): Option[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo] = {
    val await = Try(Await.result(comDayCqMcmCoreNewsletterNewsletterEmailServiceImplAsync(post, apply, delete, action, location, propertylist, fromAddress, senderHost, maxBounceCount), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fromAddress  (optional)
   * @param senderHost  (optional)
   * @param maxBounceCount  (optional)
   * @return Future(ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo)
   */
  def comDayCqMcmCoreNewsletterNewsletterEmailServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fromAddress: Option[String] = None, senderHost: Option[String] = None, maxBounceCount: Option[String] = None): Future[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo] = {
      helper.comDayCqMcmCoreNewsletterNewsletterEmailServiceImpl(post, apply, delete, action, location, propertylist, fromAddress, senderHost, maxBounceCount)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param experienceIndirection  (optional)
   * @param touchpointIndirection  (optional)
   * @return ComDayCqMcmImplMCMConfigurationInfo
   */
  def comDayCqMcmImplMCMConfiguration(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, experienceIndirection: Option[List[String]] = None, touchpointIndirection: Option[List[String]] = None): Option[ComDayCqMcmImplMCMConfigurationInfo] = {
    val await = Try(Await.result(comDayCqMcmImplMCMConfigurationAsync(post, apply, delete, action, location, propertylist, experienceIndirection, touchpointIndirection), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param experienceIndirection  (optional)
   * @param touchpointIndirection  (optional)
   * @return Future(ComDayCqMcmImplMCMConfigurationInfo)
   */
  def comDayCqMcmImplMCMConfigurationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, experienceIndirection: Option[List[String]] = None, touchpointIndirection: Option[List[String]] = None): Future[ComDayCqMcmImplMCMConfigurationInfo] = {
      helper.comDayCqMcmImplMCMConfiguration(post, apply, delete, action, location, propertylist, experienceIndirection, touchpointIndirection)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo
   */
  def comDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponen(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Option[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo] = {
    val await = Try(Await.result(comDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return Future(ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo)
   */
  def comDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Future[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo] = {
      helper.comDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponen(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo
   */
  def comDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThroug(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Option[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo] = {
    val await = Try(Await.result(comDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return Future(ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo)
   */
  def comDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Future[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo] = {
      helper.comDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThroug(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo
   */
  def comDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponent(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo] = {
    val await = Try(Await.result(comDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo)
   */
  def comDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo] = {
      helper.comDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponent(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo
   */
  def comDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHa(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo] = {
    val await = Try(Await.result(comDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo)
   */
  def comDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo] = {
      helper.comDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHa(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo
   */
  def comDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagH(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Option[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo] = {
    val await = Try(Await.result(comDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return Future(ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo)
   */
  def comDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Future[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo] = {
      helper.comDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagH(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @return ComDayCqNotificationImplNotificationServiceImplInfo
   */
  def comDayCqNotificationImplNotificationServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None): Option[ComDayCqNotificationImplNotificationServiceImplInfo] = {
    val await = Try(Await.result(comDayCqNotificationImplNotificationServiceImplAsync(post, apply, delete, action, location, propertylist, eventFilter), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @return Future(ComDayCqNotificationImplNotificationServiceImplInfo)
   */
  def comDayCqNotificationImplNotificationServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None): Future[ComDayCqNotificationImplNotificationServiceImplInfo] = {
      helper.comDayCqNotificationImplNotificationServiceImpl(post, apply, delete, action, location, propertylist, eventFilter)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param forcelocation  (optional)
   * @return ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo
   */
  def comDayCqPersonalizationImplServletsTargetingConfigurationServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, forcelocation: Option[Boolean] = None): Option[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo] = {
    val await = Try(Await.result(comDayCqPersonalizationImplServletsTargetingConfigurationServletAsync(post, apply, delete, action, location, propertylist, forcelocation), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param forcelocation  (optional)
   * @return Future(ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo)
   */
  def comDayCqPersonalizationImplServletsTargetingConfigurationServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, forcelocation: Option[Boolean] = None): Future[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo] = {
      helper.comDayCqPersonalizationImplServletsTargetingConfigurationServlet(post, apply, delete, action, location, propertylist, forcelocation)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param id  (optional)
   * @param enabled  (optional)
   * @param reference  (optional)
   * @param interval  (optional)
   * @param expression  (optional)
   * @param source  (optional)
   * @param target  (optional)
   * @param login  (optional)
   * @param password  (optional)
   * @return ComDayCqPollingImporterImplManagedPollConfigImplInfo
   */
  def comDayCqPollingImporterImplManagedPollConfigImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, id: Option[String] = None, enabled: Option[Boolean] = None, reference: Option[Boolean] = None, interval: Option[Integer] = None, expression: Option[String] = None, source: Option[String] = None, target: Option[String] = None, login: Option[String] = None, password: Option[String] = None): Option[ComDayCqPollingImporterImplManagedPollConfigImplInfo] = {
    val await = Try(Await.result(comDayCqPollingImporterImplManagedPollConfigImplAsync(post, apply, delete, action, location, propertylist, id, enabled, reference, interval, expression, source, target, login, password), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param id  (optional)
   * @param enabled  (optional)
   * @param reference  (optional)
   * @param interval  (optional)
   * @param expression  (optional)
   * @param source  (optional)
   * @param target  (optional)
   * @param login  (optional)
   * @param password  (optional)
   * @return Future(ComDayCqPollingImporterImplManagedPollConfigImplInfo)
   */
  def comDayCqPollingImporterImplManagedPollConfigImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, id: Option[String] = None, enabled: Option[Boolean] = None, reference: Option[Boolean] = None, interval: Option[Integer] = None, expression: Option[String] = None, source: Option[String] = None, target: Option[String] = None, login: Option[String] = None, password: Option[String] = None): Future[ComDayCqPollingImporterImplManagedPollConfigImplInfo] = {
      helper.comDayCqPollingImporterImplManagedPollConfigImpl(post, apply, delete, action, location, propertylist, id, enabled, reference, interval, expression, source, target, login, password)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param importerUser  (optional)
   * @return ComDayCqPollingImporterImplManagedPollingImporterImplInfo
   */
  def comDayCqPollingImporterImplManagedPollingImporterImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, importerUser: Option[String] = None): Option[ComDayCqPollingImporterImplManagedPollingImporterImplInfo] = {
    val await = Try(Await.result(comDayCqPollingImporterImplManagedPollingImporterImplAsync(post, apply, delete, action, location, propertylist, importerUser), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param importerUser  (optional)
   * @return Future(ComDayCqPollingImporterImplManagedPollingImporterImplInfo)
   */
  def comDayCqPollingImporterImplManagedPollingImporterImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, importerUser: Option[String] = None): Future[ComDayCqPollingImporterImplManagedPollingImporterImplInfo] = {
      helper.comDayCqPollingImporterImplManagedPollingImporterImpl(post, apply, delete, action, location, propertylist, importerUser)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param importerMinInterval  (optional)
   * @param importerUser  (optional)
   * @param excludePaths  (optional)
   * @param includePaths  (optional)
   * @return ComDayCqPollingImporterImplPollingImporterImplInfo
   */
  def comDayCqPollingImporterImplPollingImporterImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, importerMinInterval: Option[Integer] = None, importerUser: Option[String] = None, excludePaths: Option[List[String]] = None, includePaths: Option[List[String]] = None): Option[ComDayCqPollingImporterImplPollingImporterImplInfo] = {
    val await = Try(Await.result(comDayCqPollingImporterImplPollingImporterImplAsync(post, apply, delete, action, location, propertylist, importerMinInterval, importerUser, excludePaths, includePaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param importerMinInterval  (optional)
   * @param importerUser  (optional)
   * @param excludePaths  (optional)
   * @param includePaths  (optional)
   * @return Future(ComDayCqPollingImporterImplPollingImporterImplInfo)
   */
  def comDayCqPollingImporterImplPollingImporterImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, importerMinInterval: Option[Integer] = None, importerUser: Option[String] = None, excludePaths: Option[List[String]] = None, includePaths: Option[List[String]] = None): Future[ComDayCqPollingImporterImplPollingImporterImplInfo] = {
      helper.comDayCqPollingImporterImplPollingImporterImpl(post, apply, delete, action, location, propertylist, importerMinInterval, importerUser, excludePaths, includePaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @return ComDayCqReplicationAuditReplicationEventListenerInfo
   */
  def comDayCqReplicationAuditReplicationEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None): Option[ComDayCqReplicationAuditReplicationEventListenerInfo] = {
    val await = Try(Await.result(comDayCqReplicationAuditReplicationEventListenerAsync(post, apply, delete, action, location, propertylist, serviceRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @return Future(ComDayCqReplicationAuditReplicationEventListenerInfo)
   */
  def comDayCqReplicationAuditReplicationEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None): Future[ComDayCqReplicationAuditReplicationEventListenerInfo] = {
      helper.comDayCqReplicationAuditReplicationEventListener(post, apply, delete, action, location, propertylist, serviceRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param host  (optional)
   * @param port  (optional)
   * @return ComDayCqReplicationContentStaticContentBuilderInfo
   */
  def comDayCqReplicationContentStaticContentBuilder(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, host: Option[String] = None, port: Option[Integer] = None): Option[ComDayCqReplicationContentStaticContentBuilderInfo] = {
    val await = Try(Await.result(comDayCqReplicationContentStaticContentBuilderAsync(post, apply, delete, action, location, propertylist, host, port), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param host  (optional)
   * @param port  (optional)
   * @return Future(ComDayCqReplicationContentStaticContentBuilderInfo)
   */
  def comDayCqReplicationContentStaticContentBuilderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, host: Option[String] = None, port: Option[Integer] = None): Future[ComDayCqReplicationContentStaticContentBuilderInfo] = {
      helper.comDayCqReplicationContentStaticContentBuilder(post, apply, delete, action, location, propertylist, host, port)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jobTopics  (optional)
   * @param serviceUserTarget  (optional)
   * @param agentProviderTarget  (optional)
   * @return ComDayCqReplicationImplAgentManagerImplInfo
   */
  def comDayCqReplicationImplAgentManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jobTopics: Option[String] = None, serviceUserTarget: Option[String] = None, agentProviderTarget: Option[String] = None): Option[ComDayCqReplicationImplAgentManagerImplInfo] = {
    val await = Try(Await.result(comDayCqReplicationImplAgentManagerImplAsync(post, apply, delete, action, location, propertylist, jobTopics, serviceUserTarget, agentProviderTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jobTopics  (optional)
   * @param serviceUserTarget  (optional)
   * @param agentProviderTarget  (optional)
   * @return Future(ComDayCqReplicationImplAgentManagerImplInfo)
   */
  def comDayCqReplicationImplAgentManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jobTopics: Option[String] = None, serviceUserTarget: Option[String] = None, agentProviderTarget: Option[String] = None): Future[ComDayCqReplicationImplAgentManagerImplInfo] = {
      helper.comDayCqReplicationImplAgentManagerImpl(post, apply, delete, action, location, propertylist, jobTopics, serviceUserTarget, agentProviderTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param binaryThreshold  (optional)
   * @return ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo
   */
  def comDayCqReplicationImplContentDurboBinaryLessContentBuilder(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, binaryThreshold: Option[Integer] = None): Option[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo] = {
    val await = Try(Await.result(comDayCqReplicationImplContentDurboBinaryLessContentBuilderAsync(post, apply, delete, action, location, propertylist, binaryThreshold), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param binaryThreshold  (optional)
   * @return Future(ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo)
   */
  def comDayCqReplicationImplContentDurboBinaryLessContentBuilderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, binaryThreshold: Option[Integer] = None): Future[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo] = {
      helper.comDayCqReplicationImplContentDurboBinaryLessContentBuilder(post, apply, delete, action, location, propertylist, binaryThreshold)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param preserveHierarchyNodes  (optional)
   * @param ignoreVersioning  (optional)
   * @param importAcl  (optional)
   * @param saveThreshold  (optional)
   * @param preserveUserPaths  (optional)
   * @param preserveUuid  (optional)
   * @param preserveUuidNodetypes  (optional)
   * @param preserveUuidSubtrees  (optional)
   * @param autoCommit  (optional)
   * @return ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo
   */
  def comDayCqReplicationImplContentDurboDurboImportConfigurationProv(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, preserveHierarchyNodes: Option[Boolean] = None, ignoreVersioning: Option[Boolean] = None, importAcl: Option[Boolean] = None, saveThreshold: Option[Integer] = None, preserveUserPaths: Option[Boolean] = None, preserveUuid: Option[Boolean] = None, preserveUuidNodetypes: Option[List[String]] = None, preserveUuidSubtrees: Option[List[String]] = None, autoCommit: Option[Boolean] = None): Option[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo] = {
    val await = Try(Await.result(comDayCqReplicationImplContentDurboDurboImportConfigurationProvAsync(post, apply, delete, action, location, propertylist, preserveHierarchyNodes, ignoreVersioning, importAcl, saveThreshold, preserveUserPaths, preserveUuid, preserveUuidNodetypes, preserveUuidSubtrees, autoCommit), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param preserveHierarchyNodes  (optional)
   * @param ignoreVersioning  (optional)
   * @param importAcl  (optional)
   * @param saveThreshold  (optional)
   * @param preserveUserPaths  (optional)
   * @param preserveUuid  (optional)
   * @param preserveUuidNodetypes  (optional)
   * @param preserveUuidSubtrees  (optional)
   * @param autoCommit  (optional)
   * @return Future(ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo)
   */
  def comDayCqReplicationImplContentDurboDurboImportConfigurationProvAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, preserveHierarchyNodes: Option[Boolean] = None, ignoreVersioning: Option[Boolean] = None, importAcl: Option[Boolean] = None, saveThreshold: Option[Integer] = None, preserveUserPaths: Option[Boolean] = None, preserveUuid: Option[Boolean] = None, preserveUuidNodetypes: Option[List[String]] = None, preserveUuidSubtrees: Option[List[String]] = None, autoCommit: Option[Boolean] = None): Future[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo] = {
      helper.comDayCqReplicationImplContentDurboDurboImportConfigurationProv(post, apply, delete, action, location, propertylist, preserveHierarchyNodes, ignoreVersioning, importAcl, saveThreshold, preserveUserPaths, preserveUuid, preserveUuidNodetypes, preserveUuidSubtrees, autoCommit)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param replicationContentUseFileStorage  (optional)
   * @param replicationContentMaxCommitAttempts  (optional)
   * @return ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo
   */
  def comDayCqReplicationImplReplicationContentFactoryProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, replicationContentUseFileStorage: Option[Boolean] = None, replicationContentMaxCommitAttempts: Option[Integer] = None): Option[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo] = {
    val await = Try(Await.result(comDayCqReplicationImplReplicationContentFactoryProviderImplAsync(post, apply, delete, action, location, propertylist, replicationContentUseFileStorage, replicationContentMaxCommitAttempts), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param replicationContentUseFileStorage  (optional)
   * @param replicationContentMaxCommitAttempts  (optional)
   * @return Future(ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo)
   */
  def comDayCqReplicationImplReplicationContentFactoryProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, replicationContentUseFileStorage: Option[Boolean] = None, replicationContentMaxCommitAttempts: Option[Integer] = None): Future[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo] = {
      helper.comDayCqReplicationImplReplicationContentFactoryProviderImpl(post, apply, delete, action, location, propertylist, replicationContentUseFileStorage, replicationContentMaxCommitAttempts)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param receiverTmpfileThreshold  (optional)
   * @param receiverPackagesUseInstall  (optional)
   * @return ComDayCqReplicationImplReplicationReceiverImplInfo
   */
  def comDayCqReplicationImplReplicationReceiverImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, receiverTmpfileThreshold: Option[Integer] = None, receiverPackagesUseInstall: Option[Boolean] = None): Option[ComDayCqReplicationImplReplicationReceiverImplInfo] = {
    val await = Try(Await.result(comDayCqReplicationImplReplicationReceiverImplAsync(post, apply, delete, action, location, propertylist, receiverTmpfileThreshold, receiverPackagesUseInstall), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param receiverTmpfileThreshold  (optional)
   * @param receiverPackagesUseInstall  (optional)
   * @return Future(ComDayCqReplicationImplReplicationReceiverImplInfo)
   */
  def comDayCqReplicationImplReplicationReceiverImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, receiverTmpfileThreshold: Option[Integer] = None, receiverPackagesUseInstall: Option[Boolean] = None): Future[ComDayCqReplicationImplReplicationReceiverImplInfo] = {
      helper.comDayCqReplicationImplReplicationReceiverImpl(post, apply, delete, action, location, propertylist, receiverTmpfileThreshold, receiverPackagesUseInstall)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param distributeEvents  (optional)
   * @return ComDayCqReplicationImplReplicatorImplInfo
   */
  def comDayCqReplicationImplReplicatorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, distributeEvents: Option[Boolean] = None): Option[ComDayCqReplicationImplReplicatorImplInfo] = {
    val await = Try(Await.result(comDayCqReplicationImplReplicatorImplAsync(post, apply, delete, action, location, propertylist, distributeEvents), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param distributeEvents  (optional)
   * @return Future(ComDayCqReplicationImplReplicatorImplInfo)
   */
  def comDayCqReplicationImplReplicatorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, distributeEvents: Option[Boolean] = None): Future[ComDayCqReplicationImplReplicatorImplInfo] = {
      helper.comDayCqReplicationImplReplicatorImpl(post, apply, delete, action, location, propertylist, distributeEvents)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerPeriod  (optional)
   * @return ComDayCqReplicationImplReverseReplicatorInfo
   */
  def comDayCqReplicationImplReverseReplicator(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerPeriod: Option[Integer] = None): Option[ComDayCqReplicationImplReverseReplicatorInfo] = {
    val await = Try(Await.result(comDayCqReplicationImplReverseReplicatorAsync(post, apply, delete, action, location, propertylist, schedulerPeriod), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerPeriod  (optional)
   * @return Future(ComDayCqReplicationImplReverseReplicatorInfo)
   */
  def comDayCqReplicationImplReverseReplicatorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerPeriod: Option[Integer] = None): Future[ComDayCqReplicationImplReverseReplicatorInfo] = {
      helper.comDayCqReplicationImplReverseReplicator(post, apply, delete, action, location, propertylist, schedulerPeriod)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disabledCipherSuites  (optional)
   * @param enabledCipherSuites  (optional)
   * @return ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo
   */
  def comDayCqReplicationImplTransportBinaryLessTransportHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disabledCipherSuites: Option[List[String]] = None, enabledCipherSuites: Option[List[String]] = None): Option[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo] = {
    val await = Try(Await.result(comDayCqReplicationImplTransportBinaryLessTransportHandlerAsync(post, apply, delete, action, location, propertylist, disabledCipherSuites, enabledCipherSuites), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disabledCipherSuites  (optional)
   * @param enabledCipherSuites  (optional)
   * @return Future(ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo)
   */
  def comDayCqReplicationImplTransportBinaryLessTransportHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disabledCipherSuites: Option[List[String]] = None, enabledCipherSuites: Option[List[String]] = None): Future[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo] = {
      helper.comDayCqReplicationImplTransportBinaryLessTransportHandler(post, apply, delete, action, location, propertylist, disabledCipherSuites, enabledCipherSuites)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disabledCipherSuites  (optional)
   * @param enabledCipherSuites  (optional)
   * @return ComDayCqReplicationImplTransportHttpInfo
   */
  def comDayCqReplicationImplTransportHttp(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disabledCipherSuites: Option[List[String]] = None, enabledCipherSuites: Option[List[String]] = None): Option[ComDayCqReplicationImplTransportHttpInfo] = {
    val await = Try(Await.result(comDayCqReplicationImplTransportHttpAsync(post, apply, delete, action, location, propertylist, disabledCipherSuites, enabledCipherSuites), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disabledCipherSuites  (optional)
   * @param enabledCipherSuites  (optional)
   * @return Future(ComDayCqReplicationImplTransportHttpInfo)
   */
  def comDayCqReplicationImplTransportHttpAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disabledCipherSuites: Option[List[String]] = None, enabledCipherSuites: Option[List[String]] = None): Future[ComDayCqReplicationImplTransportHttpInfo] = {
      helper.comDayCqReplicationImplTransportHttp(post, apply, delete, action, location, propertylist, disabledCipherSuites, enabledCipherSuites)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param repcacheEnable  (optional)
   * @param repcacheTtl  (optional)
   * @param repcacheMax  (optional)
   * @return ComDayCqReportingImplCacheCacheImplInfo
   */
  def comDayCqReportingImplCacheCacheImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, repcacheEnable: Option[Boolean] = None, repcacheTtl: Option[Integer] = None, repcacheMax: Option[Integer] = None): Option[ComDayCqReportingImplCacheCacheImplInfo] = {
    val await = Try(Await.result(comDayCqReportingImplCacheCacheImplAsync(post, apply, delete, action, location, propertylist, repcacheEnable, repcacheTtl, repcacheMax), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param repcacheEnable  (optional)
   * @param repcacheTtl  (optional)
   * @param repcacheMax  (optional)
   * @return Future(ComDayCqReportingImplCacheCacheImplInfo)
   */
  def comDayCqReportingImplCacheCacheImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, repcacheEnable: Option[Boolean] = None, repcacheTtl: Option[Integer] = None, repcacheMax: Option[Integer] = None): Future[ComDayCqReportingImplCacheCacheImplInfo] = {
      helper.comDayCqReportingImplCacheCacheImpl(post, apply, delete, action, location, propertylist, repcacheEnable, repcacheTtl, repcacheMax)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param repconfTimezone  (optional)
   * @param repconfLocale  (optional)
   * @param repconfSnapshots  (optional)
   * @param repconfRepdir  (optional)
   * @param repconfHourofday  (optional)
   * @param repconfMinofhour  (optional)
   * @param repconfMaxrows  (optional)
   * @param repconfFakedata  (optional)
   * @param repconfSnapshotuser  (optional)
   * @param repconfEnforcesnapshotuser  (optional)
   * @return ComDayCqReportingImplConfigServiceImplInfo
   */
  def comDayCqReportingImplConfigServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, repconfTimezone: Option[String] = None, repconfLocale: Option[String] = None, repconfSnapshots: Option[String] = None, repconfRepdir: Option[String] = None, repconfHourofday: Option[Integer] = None, repconfMinofhour: Option[Integer] = None, repconfMaxrows: Option[Integer] = None, repconfFakedata: Option[Boolean] = None, repconfSnapshotuser: Option[String] = None, repconfEnforcesnapshotuser: Option[Boolean] = None): Option[ComDayCqReportingImplConfigServiceImplInfo] = {
    val await = Try(Await.result(comDayCqReportingImplConfigServiceImplAsync(post, apply, delete, action, location, propertylist, repconfTimezone, repconfLocale, repconfSnapshots, repconfRepdir, repconfHourofday, repconfMinofhour, repconfMaxrows, repconfFakedata, repconfSnapshotuser, repconfEnforcesnapshotuser), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param repconfTimezone  (optional)
   * @param repconfLocale  (optional)
   * @param repconfSnapshots  (optional)
   * @param repconfRepdir  (optional)
   * @param repconfHourofday  (optional)
   * @param repconfMinofhour  (optional)
   * @param repconfMaxrows  (optional)
   * @param repconfFakedata  (optional)
   * @param repconfSnapshotuser  (optional)
   * @param repconfEnforcesnapshotuser  (optional)
   * @return Future(ComDayCqReportingImplConfigServiceImplInfo)
   */
  def comDayCqReportingImplConfigServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, repconfTimezone: Option[String] = None, repconfLocale: Option[String] = None, repconfSnapshots: Option[String] = None, repconfRepdir: Option[String] = None, repconfHourofday: Option[Integer] = None, repconfMinofhour: Option[Integer] = None, repconfMaxrows: Option[Integer] = None, repconfFakedata: Option[Boolean] = None, repconfSnapshotuser: Option[String] = None, repconfEnforcesnapshotuser: Option[Boolean] = None): Future[ComDayCqReportingImplConfigServiceImplInfo] = {
      helper.comDayCqReportingImplConfigServiceImpl(post, apply, delete, action, location, propertylist, repconfTimezone, repconfLocale, repconfSnapshots, repconfRepdir, repconfHourofday, repconfMinofhour, repconfMaxrows, repconfFakedata, repconfSnapshotuser, repconfEnforcesnapshotuser)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param requestLogOutput  (optional)
   * @return ComDayCqReportingImplRLogAnalyzerInfo
   */
  def comDayCqReportingImplRLogAnalyzer(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, requestLogOutput: Option[String] = None): Option[ComDayCqReportingImplRLogAnalyzerInfo] = {
    val await = Try(Await.result(comDayCqReportingImplRLogAnalyzerAsync(post, apply, delete, action, location, propertylist, requestLogOutput), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param requestLogOutput  (optional)
   * @return Future(ComDayCqReportingImplRLogAnalyzerInfo)
   */
  def comDayCqReportingImplRLogAnalyzerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, requestLogOutput: Option[String] = None): Future[ComDayCqReportingImplRLogAnalyzerInfo] = {
      helper.comDayCqReportingImplRLogAnalyzer(post, apply, delete, action, location, propertylist, requestLogOutput)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerPeriod  (optional)
   * @param schedulerConcurrent  (optional)
   * @param serviceBadLinkToleranceInterval  (optional)
   * @param serviceCheckOverridePatterns  (optional)
   * @param serviceCacheBrokenInternalLinks  (optional)
   * @param serviceSpecialLinkPrefix  (optional)
   * @param serviceSpecialLinkPatterns  (optional)
   * @return ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo
   */
  def comDayCqRewriterLinkcheckerImplLinkCheckerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerPeriod: Option[Integer] = None, schedulerConcurrent: Option[Boolean] = None, serviceBadLinkToleranceInterval: Option[Integer] = None, serviceCheckOverridePatterns: Option[List[String]] = None, serviceCacheBrokenInternalLinks: Option[Boolean] = None, serviceSpecialLinkPrefix: Option[List[String]] = None, serviceSpecialLinkPatterns: Option[List[String]] = None): Option[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo] = {
    val await = Try(Await.result(comDayCqRewriterLinkcheckerImplLinkCheckerImplAsync(post, apply, delete, action, location, propertylist, schedulerPeriod, schedulerConcurrent, serviceBadLinkToleranceInterval, serviceCheckOverridePatterns, serviceCacheBrokenInternalLinks, serviceSpecialLinkPrefix, serviceSpecialLinkPatterns), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerPeriod  (optional)
   * @param schedulerConcurrent  (optional)
   * @param serviceBadLinkToleranceInterval  (optional)
   * @param serviceCheckOverridePatterns  (optional)
   * @param serviceCacheBrokenInternalLinks  (optional)
   * @param serviceSpecialLinkPrefix  (optional)
   * @param serviceSpecialLinkPatterns  (optional)
   * @return Future(ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo)
   */
  def comDayCqRewriterLinkcheckerImplLinkCheckerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerPeriod: Option[Integer] = None, schedulerConcurrent: Option[Boolean] = None, serviceBadLinkToleranceInterval: Option[Integer] = None, serviceCheckOverridePatterns: Option[List[String]] = None, serviceCacheBrokenInternalLinks: Option[Boolean] = None, serviceSpecialLinkPrefix: Option[List[String]] = None, serviceSpecialLinkPatterns: Option[List[String]] = None): Future[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo] = {
      helper.comDayCqRewriterLinkcheckerImplLinkCheckerImpl(post, apply, delete, action, location, propertylist, schedulerPeriod, schedulerConcurrent, serviceBadLinkToleranceInterval, serviceCheckOverridePatterns, serviceCacheBrokenInternalLinks, serviceSpecialLinkPrefix, serviceSpecialLinkPatterns)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerPeriod  (optional)
   * @param schedulerConcurrent  (optional)
   * @param goodLinkTestInterval  (optional)
   * @param badLinkTestInterval  (optional)
   * @param linkUnusedInterval  (optional)
   * @param connectionTimeout  (optional)
   * @return ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo
   */
  def comDayCqRewriterLinkcheckerImplLinkCheckerTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerPeriod: Option[Integer] = None, schedulerConcurrent: Option[Boolean] = None, goodLinkTestInterval: Option[Integer] = None, badLinkTestInterval: Option[Integer] = None, linkUnusedInterval: Option[Integer] = None, connectionTimeout: Option[Integer] = None): Option[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo] = {
    val await = Try(Await.result(comDayCqRewriterLinkcheckerImplLinkCheckerTaskAsync(post, apply, delete, action, location, propertylist, schedulerPeriod, schedulerConcurrent, goodLinkTestInterval, badLinkTestInterval, linkUnusedInterval, connectionTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerPeriod  (optional)
   * @param schedulerConcurrent  (optional)
   * @param goodLinkTestInterval  (optional)
   * @param badLinkTestInterval  (optional)
   * @param linkUnusedInterval  (optional)
   * @param connectionTimeout  (optional)
   * @return Future(ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo)
   */
  def comDayCqRewriterLinkcheckerImplLinkCheckerTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerPeriod: Option[Integer] = None, schedulerConcurrent: Option[Boolean] = None, goodLinkTestInterval: Option[Integer] = None, badLinkTestInterval: Option[Integer] = None, linkUnusedInterval: Option[Integer] = None, connectionTimeout: Option[Integer] = None): Future[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo] = {
      helper.comDayCqRewriterLinkcheckerImplLinkCheckerTask(post, apply, delete, action, location, propertylist, schedulerPeriod, schedulerConcurrent, goodLinkTestInterval, badLinkTestInterval, linkUnusedInterval, connectionTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param linkcheckertransformerDisableRewriting  (optional)
   * @param linkcheckertransformerDisableChecking  (optional)
   * @param linkcheckertransformerMapCacheSize  (optional)
   * @param linkcheckertransformerStrictExtensionCheck  (optional)
   * @param linkcheckertransformerStripHtmltExtension  (optional)
   * @param linkcheckertransformerRewriteElements  (optional)
   * @param linkcheckertransformerStripExtensionPathBlacklist  (optional)
   * @return ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo
   */
  def comDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, linkcheckertransformerDisableRewriting: Option[Boolean] = None, linkcheckertransformerDisableChecking: Option[Boolean] = None, linkcheckertransformerMapCacheSize: Option[Integer] = None, linkcheckertransformerStrictExtensionCheck: Option[Boolean] = None, linkcheckertransformerStripHtmltExtension: Option[Boolean] = None, linkcheckertransformerRewriteElements: Option[List[String]] = None, linkcheckertransformerStripExtensionPathBlacklist: Option[List[String]] = None): Option[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo] = {
    val await = Try(Await.result(comDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryAsync(post, apply, delete, action, location, propertylist, linkcheckertransformerDisableRewriting, linkcheckertransformerDisableChecking, linkcheckertransformerMapCacheSize, linkcheckertransformerStrictExtensionCheck, linkcheckertransformerStripHtmltExtension, linkcheckertransformerRewriteElements, linkcheckertransformerStripExtensionPathBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param linkcheckertransformerDisableRewriting  (optional)
   * @param linkcheckertransformerDisableChecking  (optional)
   * @param linkcheckertransformerMapCacheSize  (optional)
   * @param linkcheckertransformerStrictExtensionCheck  (optional)
   * @param linkcheckertransformerStripHtmltExtension  (optional)
   * @param linkcheckertransformerRewriteElements  (optional)
   * @param linkcheckertransformerStripExtensionPathBlacklist  (optional)
   * @return Future(ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo)
   */
  def comDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, linkcheckertransformerDisableRewriting: Option[Boolean] = None, linkcheckertransformerDisableChecking: Option[Boolean] = None, linkcheckertransformerMapCacheSize: Option[Integer] = None, linkcheckertransformerStrictExtensionCheck: Option[Boolean] = None, linkcheckertransformerStripHtmltExtension: Option[Boolean] = None, linkcheckertransformerRewriteElements: Option[List[String]] = None, linkcheckertransformerStripExtensionPathBlacklist: Option[List[String]] = None): Future[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo] = {
      helper.comDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactory(post, apply, delete, action, location, propertylist, linkcheckertransformerDisableRewriting, linkcheckertransformerDisableChecking, linkcheckertransformerMapCacheSize, linkcheckertransformerStrictExtensionCheck, linkcheckertransformerStripHtmltExtension, linkcheckertransformerRewriteElements, linkcheckertransformerStripExtensionPathBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceMaxLinksPerHost  (optional)
   * @param serviceSaveExternalLinkReferences  (optional)
   * @return ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo
   */
  def comDayCqRewriterLinkcheckerImplLinkInfoStorageImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceMaxLinksPerHost: Option[Integer] = None, serviceSaveExternalLinkReferences: Option[Boolean] = None): Option[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo] = {
    val await = Try(Await.result(comDayCqRewriterLinkcheckerImplLinkInfoStorageImplAsync(post, apply, delete, action, location, propertylist, serviceMaxLinksPerHost, serviceSaveExternalLinkReferences), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceMaxLinksPerHost  (optional)
   * @param serviceSaveExternalLinkReferences  (optional)
   * @return Future(ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo)
   */
  def comDayCqRewriterLinkcheckerImplLinkInfoStorageImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceMaxLinksPerHost: Option[Integer] = None, serviceSaveExternalLinkReferences: Option[Boolean] = None): Future[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo] = {
      helper.comDayCqRewriterLinkcheckerImplLinkInfoStorageImpl(post, apply, delete, action, location, propertylist, serviceMaxLinksPerHost, serviceSaveExternalLinkReferences)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param htmlparserProcessTags  (optional)
   * @param htmlparserPreserveCamelCase  (optional)
   * @return ComDayCqRewriterProcessorImplHtmlParserFactoryInfo
   */
  def comDayCqRewriterProcessorImplHtmlParserFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, htmlparserProcessTags: Option[List[String]] = None, htmlparserPreserveCamelCase: Option[Boolean] = None): Option[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo] = {
    val await = Try(Await.result(comDayCqRewriterProcessorImplHtmlParserFactoryAsync(post, apply, delete, action, location, propertylist, htmlparserProcessTags, htmlparserPreserveCamelCase), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param htmlparserProcessTags  (optional)
   * @param htmlparserPreserveCamelCase  (optional)
   * @return Future(ComDayCqRewriterProcessorImplHtmlParserFactoryInfo)
   */
  def comDayCqRewriterProcessorImplHtmlParserFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, htmlparserProcessTags: Option[List[String]] = None, htmlparserPreserveCamelCase: Option[Boolean] = None): Future[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo] = {
      helper.comDayCqRewriterProcessorImplHtmlParserFactory(post, apply, delete, action, location, propertylist, htmlparserProcessTags, htmlparserPreserveCamelCase)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param excerptProperties  (optional)
   * @param cacheMaxEntries  (optional)
   * @param cacheEntryLifetime  (optional)
   * @param xpathUnion  (optional)
   * @return ComDayCqSearchImplBuilderQueryBuilderImplInfo
   */
  def comDayCqSearchImplBuilderQueryBuilderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, excerptProperties: Option[List[String]] = None, cacheMaxEntries: Option[Integer] = None, cacheEntryLifetime: Option[Integer] = None, xpathUnion: Option[Boolean] = None): Option[ComDayCqSearchImplBuilderQueryBuilderImplInfo] = {
    val await = Try(Await.result(comDayCqSearchImplBuilderQueryBuilderImplAsync(post, apply, delete, action, location, propertylist, excerptProperties, cacheMaxEntries, cacheEntryLifetime, xpathUnion), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param excerptProperties  (optional)
   * @param cacheMaxEntries  (optional)
   * @param cacheEntryLifetime  (optional)
   * @param xpathUnion  (optional)
   * @return Future(ComDayCqSearchImplBuilderQueryBuilderImplInfo)
   */
  def comDayCqSearchImplBuilderQueryBuilderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, excerptProperties: Option[List[String]] = None, cacheMaxEntries: Option[Integer] = None, cacheEntryLifetime: Option[Integer] = None, xpathUnion: Option[Boolean] = None): Future[ComDayCqSearchImplBuilderQueryBuilderImplInfo] = {
      helper.comDayCqSearchImplBuilderQueryBuilderImpl(post, apply, delete, action, location, propertylist, excerptProperties, cacheMaxEntries, cacheEntryLifetime, xpathUnion)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pathBuilderTarget  (optional)
   * @param suggestBasepath  (optional)
   * @return ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo
   */
  def comDayCqSearchSuggestImplSuggestionIndexManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pathBuilderTarget: Option[String] = None, suggestBasepath: Option[String] = None): Option[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo] = {
    val await = Try(Await.result(comDayCqSearchSuggestImplSuggestionIndexManagerImplAsync(post, apply, delete, action, location, propertylist, pathBuilderTarget, suggestBasepath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pathBuilderTarget  (optional)
   * @param suggestBasepath  (optional)
   * @return Future(ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo)
   */
  def comDayCqSearchSuggestImplSuggestionIndexManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pathBuilderTarget: Option[String] = None, suggestBasepath: Option[String] = None): Future[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo] = {
      helper.comDayCqSearchSuggestImplSuggestionIndexManagerImpl(post, apply, delete, action, location, propertylist, pathBuilderTarget, suggestBasepath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSearchpromoteConfighandlerEnabled  (optional)
   * @return ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo
   */
  def comDayCqSearchpromoteImplPublishSearchPromoteConfigHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSearchpromoteConfighandlerEnabled: Option[Boolean] = None): Option[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo] = {
    val await = Try(Await.result(comDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerAsync(post, apply, delete, action, location, propertylist, cqSearchpromoteConfighandlerEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSearchpromoteConfighandlerEnabled  (optional)
   * @return Future(ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo)
   */
  def comDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSearchpromoteConfighandlerEnabled: Option[Boolean] = None): Future[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo] = {
      helper.comDayCqSearchpromoteImplPublishSearchPromoteConfigHandler(post, apply, delete, action, location, propertylist, cqSearchpromoteConfighandlerEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSearchpromoteConfigurationServerUri  (optional)
   * @param cqSearchpromoteConfigurationEnvironment  (optional)
   * @param connectionTimeout  (optional)
   * @param socketTimeout  (optional)
   * @return ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo
   */
  def comDayCqSearchpromoteImplSearchPromoteServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSearchpromoteConfigurationServerUri: Option[String] = None, cqSearchpromoteConfigurationEnvironment: Option[String] = None, connectionTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None): Option[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo] = {
    val await = Try(Await.result(comDayCqSearchpromoteImplSearchPromoteServiceImplAsync(post, apply, delete, action, location, propertylist, cqSearchpromoteConfigurationServerUri, cqSearchpromoteConfigurationEnvironment, connectionTimeout, socketTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqSearchpromoteConfigurationServerUri  (optional)
   * @param cqSearchpromoteConfigurationEnvironment  (optional)
   * @param connectionTimeout  (optional)
   * @param socketTimeout  (optional)
   * @return Future(ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo)
   */
  def comDayCqSearchpromoteImplSearchPromoteServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqSearchpromoteConfigurationServerUri: Option[String] = None, cqSearchpromoteConfigurationEnvironment: Option[String] = None, connectionTimeout: Option[Integer] = None, socketTimeout: Option[Integer] = None): Future[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo] = {
      helper.comDayCqSearchpromoteImplSearchPromoteServiceImpl(post, apply, delete, action, location, propertylist, cqSearchpromoteConfigurationServerUri, cqSearchpromoteConfigurationEnvironment, connectionTimeout, socketTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAclsetupRules  (optional)
   * @return ComDayCqSecurityACLSetupInfo
   */
  def comDayCqSecurityACLSetup(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAclsetupRules: Option[List[String]] = None): Option[ComDayCqSecurityACLSetupInfo] = {
    val await = Try(Await.result(comDayCqSecurityACLSetupAsync(post, apply, delete, action, location, propertylist, cqAclsetupRules), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqAclsetupRules  (optional)
   * @return Future(ComDayCqSecurityACLSetupInfo)
   */
  def comDayCqSecurityACLSetupAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqAclsetupRules: Option[List[String]] = None): Future[ComDayCqSecurityACLSetupInfo] = {
      helper.comDayCqSecurityACLSetup(post, apply, delete, action, location, propertylist, cqAclsetupRules)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerPeriod  (optional)
   * @param schedulerConcurrent  (optional)
   * @param `path`  (optional)
   * @param workspace  (optional)
   * @param keywordsPath  (optional)
   * @param asyncEntries  (optional)
   * @return ComDayCqStatisticsImplStatisticsServiceImplInfo
   */
  def comDayCqStatisticsImplStatisticsServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerPeriod: Option[Integer] = None, schedulerConcurrent: Option[Boolean] = None, `path`: Option[String] = None, workspace: Option[String] = None, keywordsPath: Option[String] = None, asyncEntries: Option[Boolean] = None): Option[ComDayCqStatisticsImplStatisticsServiceImplInfo] = {
    val await = Try(Await.result(comDayCqStatisticsImplStatisticsServiceImplAsync(post, apply, delete, action, location, propertylist, schedulerPeriod, schedulerConcurrent, `path`, workspace, keywordsPath, asyncEntries), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerPeriod  (optional)
   * @param schedulerConcurrent  (optional)
   * @param `path`  (optional)
   * @param workspace  (optional)
   * @param keywordsPath  (optional)
   * @param asyncEntries  (optional)
   * @return Future(ComDayCqStatisticsImplStatisticsServiceImplInfo)
   */
  def comDayCqStatisticsImplStatisticsServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerPeriod: Option[Integer] = None, schedulerConcurrent: Option[Boolean] = None, `path`: Option[String] = None, workspace: Option[String] = None, keywordsPath: Option[String] = None, asyncEntries: Option[Boolean] = None): Future[ComDayCqStatisticsImplStatisticsServiceImplInfo] = {
      helper.comDayCqStatisticsImplStatisticsServiceImpl(post, apply, delete, action, location, propertylist, schedulerPeriod, schedulerConcurrent, `path`, workspace, keywordsPath, asyncEntries)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param validationEnabled  (optional)
   * @return ComDayCqTaggingImplJcrTagManagerFactoryImplInfo
   */
  def comDayCqTaggingImplJcrTagManagerFactoryImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, validationEnabled: Option[Boolean] = None): Option[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo] = {
    val await = Try(Await.result(comDayCqTaggingImplJcrTagManagerFactoryImplAsync(post, apply, delete, action, location, propertylist, validationEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param validationEnabled  (optional)
   * @return Future(ComDayCqTaggingImplJcrTagManagerFactoryImplInfo)
   */
  def comDayCqTaggingImplJcrTagManagerFactoryImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, validationEnabled: Option[Boolean] = None): Future[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo] = {
      helper.comDayCqTaggingImplJcrTagManagerFactoryImpl(post, apply, delete, action, location, propertylist, validationEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param ignorePath  (optional)
   * @return ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo
   */
  def comDayCqTaggingImplSearchTagPredicateEvaluator(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, ignorePath: Option[Boolean] = None): Option[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo] = {
    val await = Try(Await.result(comDayCqTaggingImplSearchTagPredicateEvaluatorAsync(post, apply, delete, action, location, propertylist, ignorePath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param ignorePath  (optional)
   * @return Future(ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo)
   */
  def comDayCqTaggingImplSearchTagPredicateEvaluatorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, ignorePath: Option[Boolean] = None): Future[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo] = {
      helper.comDayCqTaggingImplSearchTagPredicateEvaluator(post, apply, delete, action, location, propertylist, ignorePath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @return ComDayCqTaggingImplTagGarbageCollectorInfo
   */
  def comDayCqTaggingImplTagGarbageCollector(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None): Option[ComDayCqTaggingImplTagGarbageCollectorInfo] = {
    val await = Try(Await.result(comDayCqTaggingImplTagGarbageCollectorAsync(post, apply, delete, action, location, propertylist, schedulerExpression), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @return Future(ComDayCqTaggingImplTagGarbageCollectorInfo)
   */
  def comDayCqTaggingImplTagGarbageCollectorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None): Future[ComDayCqTaggingImplTagGarbageCollectorInfo] = {
      helper.comDayCqTaggingImplTagGarbageCollector(post, apply, delete, action, location, propertylist, schedulerExpression)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqPagesupdatehandlerImageresourcetypes  (optional)
   * @return ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo
   */
  def comDayCqWcmContentsyncImplHandlerPagesUpdateHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqPagesupdatehandlerImageresourcetypes: Option[List[String]] = None): Option[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo] = {
    val await = Try(Await.result(comDayCqWcmContentsyncImplHandlerPagesUpdateHandlerAsync(post, apply, delete, action, location, propertylist, cqPagesupdatehandlerImageresourcetypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqPagesupdatehandlerImageresourcetypes  (optional)
   * @return Future(ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo)
   */
  def comDayCqWcmContentsyncImplHandlerPagesUpdateHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqPagesupdatehandlerImageresourcetypes: Option[List[String]] = None): Future[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo] = {
      helper.comDayCqWcmContentsyncImplHandlerPagesUpdateHandler(post, apply, delete, action, location, propertylist, cqPagesupdatehandlerImageresourcetypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqContentsyncPathrewritertransformerMappingLinks  (optional)
   * @param cqContentsyncPathrewritertransformerMappingClientlibs  (optional)
   * @param cqContentsyncPathrewritertransformerMappingImages  (optional)
   * @param cqContentsyncPathrewritertransformerAttributePattern  (optional)
   * @param cqContentsyncPathrewritertransformerClientlibraryPattern  (optional)
   * @param cqContentsyncPathrewritertransformerClientlibraryReplace  (optional)
   * @return ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo
   */
  def comDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqContentsyncPathrewritertransformerMappingLinks: Option[List[String]] = None, cqContentsyncPathrewritertransformerMappingClientlibs: Option[List[String]] = None, cqContentsyncPathrewritertransformerMappingImages: Option[List[String]] = None, cqContentsyncPathrewritertransformerAttributePattern: Option[String] = None, cqContentsyncPathrewritertransformerClientlibraryPattern: Option[String] = None, cqContentsyncPathrewritertransformerClientlibraryReplace: Option[String] = None): Option[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo] = {
    val await = Try(Await.result(comDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorAsync(post, apply, delete, action, location, propertylist, cqContentsyncPathrewritertransformerMappingLinks, cqContentsyncPathrewritertransformerMappingClientlibs, cqContentsyncPathrewritertransformerMappingImages, cqContentsyncPathrewritertransformerAttributePattern, cqContentsyncPathrewritertransformerClientlibraryPattern, cqContentsyncPathrewritertransformerClientlibraryReplace), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqContentsyncPathrewritertransformerMappingLinks  (optional)
   * @param cqContentsyncPathrewritertransformerMappingClientlibs  (optional)
   * @param cqContentsyncPathrewritertransformerMappingImages  (optional)
   * @param cqContentsyncPathrewritertransformerAttributePattern  (optional)
   * @param cqContentsyncPathrewritertransformerClientlibraryPattern  (optional)
   * @param cqContentsyncPathrewritertransformerClientlibraryReplace  (optional)
   * @return Future(ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo)
   */
  def comDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqContentsyncPathrewritertransformerMappingLinks: Option[List[String]] = None, cqContentsyncPathrewritertransformerMappingClientlibs: Option[List[String]] = None, cqContentsyncPathrewritertransformerMappingImages: Option[List[String]] = None, cqContentsyncPathrewritertransformerAttributePattern: Option[String] = None, cqContentsyncPathrewritertransformerClientlibraryPattern: Option[String] = None, cqContentsyncPathrewritertransformerClientlibraryReplace: Option[String] = None): Future[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo] = {
      helper.comDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactor(post, apply, delete, action, location, propertylist, cqContentsyncPathrewritertransformerMappingLinks, cqContentsyncPathrewritertransformerMappingClientlibs, cqContentsyncPathrewritertransformerMappingImages, cqContentsyncPathrewritertransformerAttributePattern, cqContentsyncPathrewritertransformerClientlibraryPattern, cqContentsyncPathrewritertransformerClientlibraryReplace)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param authoringUIModeServiceDefault  (optional)
   * @return ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo
   */
  def comDayCqWcmCoreImplAuthoringUIModeServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, authoringUIModeServiceDefault: Option[String] = None): Option[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplAuthoringUIModeServiceImplAsync(post, apply, delete, action, location, propertylist, authoringUIModeServiceDefault), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param authoringUIModeServiceDefault  (optional)
   * @return Future(ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo)
   */
  def comDayCqWcmCoreImplAuthoringUIModeServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, authoringUIModeServiceDefault: Option[String] = None): Future[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo] = {
      helper.comDayCqWcmCoreImplAuthoringUIModeServiceImpl(post, apply, delete, action, location, propertylist, authoringUIModeServiceDefault)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param wcmcommandservletDeleteWhitelist  (optional)
   * @return ComDayCqWcmCoreImplCommandsWCMCommandServletInfo
   */
  def comDayCqWcmCoreImplCommandsWCMCommandServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, wcmcommandservletDeleteWhitelist: Option[List[String]] = None): Option[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplCommandsWCMCommandServletAsync(post, apply, delete, action, location, propertylist, wcmcommandservletDeleteWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param wcmcommandservletDeleteWhitelist  (optional)
   * @return Future(ComDayCqWcmCoreImplCommandsWCMCommandServletInfo)
   */
  def comDayCqWcmCoreImplCommandsWCMCommandServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, wcmcommandservletDeleteWhitelist: Option[List[String]] = None): Future[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo] = {
      helper.comDayCqWcmCoreImplCommandsWCMCommandServlet(post, apply, delete, action, location, propertylist, wcmcommandservletDeleteWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param dimDefaultMode  (optional)
   * @param dimAppcacheEnabled  (optional)
   * @return ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo
   */
  def comDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, dimDefaultMode: Option[String] = None, dimAppcacheEnabled: Option[Boolean] = None): Option[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplAsync(post, apply, delete, action, location, propertylist, dimDefaultMode, dimAppcacheEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param dimDefaultMode  (optional)
   * @param dimAppcacheEnabled  (optional)
   * @return Future(ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo)
   */
  def comDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, dimDefaultMode: Option[String] = None, dimAppcacheEnabled: Option[Boolean] = None): Future[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo] = {
      helper.comDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImpl(post, apply, delete, action, location, propertylist, dimDefaultMode, dimAppcacheEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param configured  (optional)
   * @return ComDayCqWcmCoreImplEventPageEventAuditListenerInfo
   */
  def comDayCqWcmCoreImplEventPageEventAuditListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, configured: Option[String] = None): Option[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplEventPageEventAuditListenerAsync(post, apply, delete, action, location, propertylist, configured), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param configured  (optional)
   * @return Future(ComDayCqWcmCoreImplEventPageEventAuditListenerInfo)
   */
  def comDayCqWcmCoreImplEventPageEventAuditListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, configured: Option[String] = None): Future[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo] = {
      helper.comDayCqWcmCoreImplEventPageEventAuditListener(post, apply, delete, action, location, propertylist, configured)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param paths  (optional)
   * @return ComDayCqWcmCoreImplEventPagePostProcessorInfo
   */
  def comDayCqWcmCoreImplEventPagePostProcessor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, paths: Option[List[String]] = None): Option[ComDayCqWcmCoreImplEventPagePostProcessorInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplEventPagePostProcessorAsync(post, apply, delete, action, location, propertylist, paths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param paths  (optional)
   * @return Future(ComDayCqWcmCoreImplEventPagePostProcessorInfo)
   */
  def comDayCqWcmCoreImplEventPagePostProcessorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, paths: Option[List[String]] = None): Future[ComDayCqWcmCoreImplEventPagePostProcessorInfo] = {
      helper.comDayCqWcmCoreImplEventPagePostProcessor(post, apply, delete, action, location, propertylist, paths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param paths  (optional)
   * @param excludedPaths  (optional)
   * @return ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo
   */
  def comDayCqWcmCoreImplEventRepositoryChangeEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, paths: Option[List[String]] = None, excludedPaths: Option[List[String]] = None): Option[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplEventRepositoryChangeEventListenerAsync(post, apply, delete, action, location, propertylist, paths, excludedPaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param paths  (optional)
   * @param excludedPaths  (optional)
   * @return Future(ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo)
   */
  def comDayCqWcmCoreImplEventRepositoryChangeEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, paths: Option[List[String]] = None, excludedPaths: Option[List[String]] = None): Future[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo] = {
      helper.comDayCqWcmCoreImplEventRepositoryChangeEventListener(post, apply, delete, action, location, propertylist, paths, excludedPaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param paths  (optional)
   * @return ComDayCqWcmCoreImplEventTemplatePostProcessorInfo
   */
  def comDayCqWcmCoreImplEventTemplatePostProcessor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, paths: Option[String] = None): Option[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplEventTemplatePostProcessorAsync(post, apply, delete, action, location, propertylist, paths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param paths  (optional)
   * @return Future(ComDayCqWcmCoreImplEventTemplatePostProcessorInfo)
   */
  def comDayCqWcmCoreImplEventTemplatePostProcessorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, paths: Option[String] = None): Future[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo] = {
      helper.comDayCqWcmCoreImplEventTemplatePostProcessor(post, apply, delete, action, location, propertylist, paths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param langmgrListPath  (optional)
   * @param langmgrCountryDefault  (optional)
   * @return ComDayCqWcmCoreImplLanguageManagerImplInfo
   */
  def comDayCqWcmCoreImplLanguageManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, langmgrListPath: Option[String] = None, langmgrCountryDefault: Option[List[String]] = None): Option[ComDayCqWcmCoreImplLanguageManagerImplInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplLanguageManagerImplAsync(post, apply, delete, action, location, propertylist, langmgrListPath, langmgrCountryDefault), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param langmgrListPath  (optional)
   * @param langmgrCountryDefault  (optional)
   * @return Future(ComDayCqWcmCoreImplLanguageManagerImplInfo)
   */
  def comDayCqWcmCoreImplLanguageManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, langmgrListPath: Option[String] = None, langmgrCountryDefault: Option[List[String]] = None): Future[ComDayCqWcmCoreImplLanguageManagerImplInfo] = {
      helper.comDayCqWcmCoreImplLanguageManagerImpl(post, apply, delete, action, location, propertylist, langmgrListPath, langmgrCountryDefault)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param linkExpiredPrefix  (optional)
   * @param linkExpiredRemove  (optional)
   * @param linkExpiredSuffix  (optional)
   * @param linkInvalidPrefix  (optional)
   * @param linkInvalidRemove  (optional)
   * @param linkInvalidSuffix  (optional)
   * @param linkPredatedPrefix  (optional)
   * @param linkPredatedRemove  (optional)
   * @param linkPredatedSuffix  (optional)
   * @param linkWcmmodes  (optional)
   * @return ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo
   */
  def comDayCqWcmCoreImplLinkCheckerConfigurationFactoryImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, linkExpiredPrefix: Option[String] = None, linkExpiredRemove: Option[Boolean] = None, linkExpiredSuffix: Option[String] = None, linkInvalidPrefix: Option[String] = None, linkInvalidRemove: Option[Boolean] = None, linkInvalidSuffix: Option[String] = None, linkPredatedPrefix: Option[String] = None, linkPredatedRemove: Option[Boolean] = None, linkPredatedSuffix: Option[String] = None, linkWcmmodes: Option[List[String]] = None): Option[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplAsync(post, apply, delete, action, location, propertylist, linkExpiredPrefix, linkExpiredRemove, linkExpiredSuffix, linkInvalidPrefix, linkInvalidRemove, linkInvalidSuffix, linkPredatedPrefix, linkPredatedRemove, linkPredatedSuffix, linkWcmmodes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param linkExpiredPrefix  (optional)
   * @param linkExpiredRemove  (optional)
   * @param linkExpiredSuffix  (optional)
   * @param linkInvalidPrefix  (optional)
   * @param linkInvalidRemove  (optional)
   * @param linkInvalidSuffix  (optional)
   * @param linkPredatedPrefix  (optional)
   * @param linkPredatedRemove  (optional)
   * @param linkPredatedSuffix  (optional)
   * @param linkWcmmodes  (optional)
   * @return Future(ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo)
   */
  def comDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, linkExpiredPrefix: Option[String] = None, linkExpiredRemove: Option[Boolean] = None, linkExpiredSuffix: Option[String] = None, linkInvalidPrefix: Option[String] = None, linkInvalidRemove: Option[Boolean] = None, linkInvalidSuffix: Option[String] = None, linkPredatedPrefix: Option[String] = None, linkPredatedRemove: Option[Boolean] = None, linkPredatedSuffix: Option[String] = None, linkWcmmodes: Option[List[String]] = None): Future[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo] = {
      helper.comDayCqWcmCoreImplLinkCheckerConfigurationFactoryImpl(post, apply, delete, action, location, propertylist, linkExpiredPrefix, linkExpiredRemove, linkExpiredSuffix, linkInvalidPrefix, linkInvalidRemove, linkInvalidSuffix, linkPredatedPrefix, linkPredatedRemove, linkPredatedSuffix, linkWcmmodes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pageInfoProviderPropertyRegexDefault  (optional)
   * @param pageInfoProviderPropertyName  (optional)
   * @return ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo
   */
  def comDayCqWcmCoreImplPagePageInfoAggregatorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pageInfoProviderPropertyRegexDefault: Option[String] = None, pageInfoProviderPropertyName: Option[String] = None): Option[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplPagePageInfoAggregatorImplAsync(post, apply, delete, action, location, propertylist, pageInfoProviderPropertyRegexDefault, pageInfoProviderPropertyName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pageInfoProviderPropertyRegexDefault  (optional)
   * @param pageInfoProviderPropertyName  (optional)
   * @return Future(ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo)
   */
  def comDayCqWcmCoreImplPagePageInfoAggregatorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pageInfoProviderPropertyRegexDefault: Option[String] = None, pageInfoProviderPropertyName: Option[String] = None): Future[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo] = {
      helper.comDayCqWcmCoreImplPagePageInfoAggregatorImpl(post, apply, delete, action, location, propertylist, pageInfoProviderPropertyRegexDefault, pageInfoProviderPropertyName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param illegalCharMapping  (optional)
   * @param pageSubTreeActivationCheck  (optional)
   * @return ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo
   */
  def comDayCqWcmCoreImplPagePageManagerFactoryImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, illegalCharMapping: Option[String] = None, pageSubTreeActivationCheck: Option[Boolean] = None): Option[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplPagePageManagerFactoryImplAsync(post, apply, delete, action, location, propertylist, illegalCharMapping, pageSubTreeActivationCheck), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param illegalCharMapping  (optional)
   * @param pageSubTreeActivationCheck  (optional)
   * @return Future(ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo)
   */
  def comDayCqWcmCoreImplPagePageManagerFactoryImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, illegalCharMapping: Option[String] = None, pageSubTreeActivationCheck: Option[Boolean] = None): Future[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo] = {
      helper.comDayCqWcmCoreImplPagePageManagerFactoryImpl(post, apply, delete, action, location, propertylist, illegalCharMapping, pageSubTreeActivationCheck)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param contentReferenceConfigResourceTypes  (optional)
   * @return ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo
   */
  def comDayCqWcmCoreImplReferencesContentContentReferenceConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, contentReferenceConfigResourceTypes: Option[List[String]] = None): Option[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplReferencesContentContentReferenceConfigAsync(post, apply, delete, action, location, propertylist, contentReferenceConfigResourceTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param contentReferenceConfigResourceTypes  (optional)
   * @return Future(ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo)
   */
  def comDayCqWcmCoreImplReferencesContentContentReferenceConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, contentReferenceConfigResourceTypes: Option[List[String]] = None): Future[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo] = {
      helper.comDayCqWcmCoreImplReferencesContentContentReferenceConfig(post, apply, delete, action, location, propertylist, contentReferenceConfigResourceTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param damShowexpired  (optional)
   * @param damShowhidden  (optional)
   * @param tagTitleSearch  (optional)
   * @param guessTotal  (optional)
   * @param damExpiryProperty  (optional)
   * @return ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo
   */
  def comDayCqWcmCoreImplServletsContentfinderAssetViewHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, damShowexpired: Option[Boolean] = None, damShowhidden: Option[Boolean] = None, tagTitleSearch: Option[Boolean] = None, guessTotal: Option[String] = None, damExpiryProperty: Option[String] = None): Option[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplServletsContentfinderAssetViewHandlerAsync(post, apply, delete, action, location, propertylist, damShowexpired, damShowhidden, tagTitleSearch, guessTotal, damExpiryProperty), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param damShowexpired  (optional)
   * @param damShowhidden  (optional)
   * @param tagTitleSearch  (optional)
   * @param guessTotal  (optional)
   * @param damExpiryProperty  (optional)
   * @return Future(ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo)
   */
  def comDayCqWcmCoreImplServletsContentfinderAssetViewHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, damShowexpired: Option[Boolean] = None, damShowhidden: Option[Boolean] = None, tagTitleSearch: Option[Boolean] = None, guessTotal: Option[String] = None, damExpiryProperty: Option[String] = None): Future[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo] = {
      helper.comDayCqWcmCoreImplServletsContentfinderAssetViewHandler(post, apply, delete, action, location, propertylist, damShowexpired, damShowhidden, tagTitleSearch, guessTotal, damExpiryProperty)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param itemResourceTypes  (optional)
   * @return ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo
   */
  def comDayCqWcmCoreImplServletsContentfinderConnectorConnectorVie(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, itemResourceTypes: Option[List[String]] = None): Option[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieAsync(post, apply, delete, action, location, propertylist, itemResourceTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param itemResourceTypes  (optional)
   * @return Future(ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo)
   */
  def comDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, itemResourceTypes: Option[List[String]] = None): Future[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo] = {
      helper.comDayCqWcmCoreImplServletsContentfinderConnectorConnectorVie(post, apply, delete, action, location, propertylist, itemResourceTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param guessTotal  (optional)
   * @param tagTitleSearch  (optional)
   * @return ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo
   */
  def comDayCqWcmCoreImplServletsContentfinderPageViewHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, guessTotal: Option[String] = None, tagTitleSearch: Option[Boolean] = None): Option[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplServletsContentfinderPageViewHandlerAsync(post, apply, delete, action, location, propertylist, guessTotal, tagTitleSearch), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param guessTotal  (optional)
   * @param tagTitleSearch  (optional)
   * @return Future(ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo)
   */
  def comDayCqWcmCoreImplServletsContentfinderPageViewHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, guessTotal: Option[String] = None, tagTitleSearch: Option[Boolean] = None): Future[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo] = {
      helper.comDayCqWcmCoreImplServletsContentfinderPageViewHandler(post, apply, delete, action, location, propertylist, guessTotal, tagTitleSearch)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param scope  (optional)
   * @return ComDayCqWcmCoreImplServletsFindReplaceServletInfo
   */
  def comDayCqWcmCoreImplServletsFindReplaceServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, scope: Option[List[String]] = None): Option[ComDayCqWcmCoreImplServletsFindReplaceServletInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplServletsFindReplaceServletAsync(post, apply, delete, action, location, propertylist, scope), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param scope  (optional)
   * @return Future(ComDayCqWcmCoreImplServletsFindReplaceServletInfo)
   */
  def comDayCqWcmCoreImplServletsFindReplaceServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, scope: Option[List[String]] = None): Future[ComDayCqWcmCoreImplServletsFindReplaceServletInfo] = {
      helper.comDayCqWcmCoreImplServletsFindReplaceServlet(post, apply, delete, action, location, propertylist, scope)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param referencesearchservletMaxReferencesPerPage  (optional)
   * @param referencesearchservletMaxPages  (optional)
   * @return ComDayCqWcmCoreImplServletsReferenceSearchServletInfo
   */
  def comDayCqWcmCoreImplServletsReferenceSearchServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, referencesearchservletMaxReferencesPerPage: Option[Integer] = None, referencesearchservletMaxPages: Option[Integer] = None): Option[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplServletsReferenceSearchServletAsync(post, apply, delete, action, location, propertylist, referencesearchservletMaxReferencesPerPage, referencesearchservletMaxPages), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param referencesearchservletMaxReferencesPerPage  (optional)
   * @param referencesearchservletMaxPages  (optional)
   * @return Future(ComDayCqWcmCoreImplServletsReferenceSearchServletInfo)
   */
  def comDayCqWcmCoreImplServletsReferenceSearchServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, referencesearchservletMaxReferencesPerPage: Option[Integer] = None, referencesearchservletMaxPages: Option[Integer] = None): Future[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo] = {
      helper.comDayCqWcmCoreImplServletsReferenceSearchServlet(post, apply, delete, action, location, propertylist, referencesearchservletMaxReferencesPerPage, referencesearchservletMaxPages)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param workspace  (optional)
   * @param dimensions  (optional)
   * @return ComDayCqWcmCoreImplServletsThumbnailServletInfo
   */
  def comDayCqWcmCoreImplServletsThumbnailServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, workspace: Option[String] = None, dimensions: Option[List[String]] = None): Option[ComDayCqWcmCoreImplServletsThumbnailServletInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplServletsThumbnailServletAsync(post, apply, delete, action, location, propertylist, workspace, dimensions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param workspace  (optional)
   * @param dimensions  (optional)
   * @return Future(ComDayCqWcmCoreImplServletsThumbnailServletInfo)
   */
  def comDayCqWcmCoreImplServletsThumbnailServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, workspace: Option[String] = None, dimensions: Option[List[String]] = None): Future[ComDayCqWcmCoreImplServletsThumbnailServletInfo] = {
      helper.comDayCqWcmCoreImplServletsThumbnailServlet(post, apply, delete, action, location, propertylist, workspace, dimensions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param nonValidChars  (optional)
   * @return ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo
   */
  def comDayCqWcmCoreImplUtilsDefaultPageNameValidator(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, nonValidChars: Option[String] = None): Option[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplUtilsDefaultPageNameValidatorAsync(post, apply, delete, action, location, propertylist, nonValidChars), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param nonValidChars  (optional)
   * @return Future(ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo)
   */
  def comDayCqWcmCoreImplUtilsDefaultPageNameValidatorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, nonValidChars: Option[String] = None): Future[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo] = {
      helper.comDayCqWcmCoreImplUtilsDefaultPageNameValidator(post, apply, delete, action, location, propertylist, nonValidChars)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultExternalizerDomain  (optional)
   * @return ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo
   */
  def comDayCqWcmCoreImplVariantsPageVariantsProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultExternalizerDomain: Option[String] = None): Option[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplVariantsPageVariantsProviderImplAsync(post, apply, delete, action, location, propertylist, defaultExternalizerDomain), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultExternalizerDomain  (optional)
   * @return Future(ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo)
   */
  def comDayCqWcmCoreImplVariantsPageVariantsProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultExternalizerDomain: Option[String] = None): Future[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo] = {
      helper.comDayCqWcmCoreImplVariantsPageVariantsProviderImpl(post, apply, delete, action, location, propertylist, defaultExternalizerDomain)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param versionmanagerCreateVersionOnActivation  (optional)
   * @param versionmanagerPurgingEnabled  (optional)
   * @param versionmanagerPurgePaths  (optional)
   * @param versionmanagerIvPaths  (optional)
   * @param versionmanagerMaxAgeDays  (optional)
   * @param versionmanagerMaxNumberVersions  (optional)
   * @param versionmanagerMinNumberVersions  (optional)
   * @return ComDayCqWcmCoreImplVersionManagerImplInfo
   */
  def comDayCqWcmCoreImplVersionManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, versionmanagerCreateVersionOnActivation: Option[Boolean] = None, versionmanagerPurgingEnabled: Option[Boolean] = None, versionmanagerPurgePaths: Option[List[String]] = None, versionmanagerIvPaths: Option[List[String]] = None, versionmanagerMaxAgeDays: Option[Integer] = None, versionmanagerMaxNumberVersions: Option[Integer] = None, versionmanagerMinNumberVersions: Option[Integer] = None): Option[ComDayCqWcmCoreImplVersionManagerImplInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplVersionManagerImplAsync(post, apply, delete, action, location, propertylist, versionmanagerCreateVersionOnActivation, versionmanagerPurgingEnabled, versionmanagerPurgePaths, versionmanagerIvPaths, versionmanagerMaxAgeDays, versionmanagerMaxNumberVersions, versionmanagerMinNumberVersions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param versionmanagerCreateVersionOnActivation  (optional)
   * @param versionmanagerPurgingEnabled  (optional)
   * @param versionmanagerPurgePaths  (optional)
   * @param versionmanagerIvPaths  (optional)
   * @param versionmanagerMaxAgeDays  (optional)
   * @param versionmanagerMaxNumberVersions  (optional)
   * @param versionmanagerMinNumberVersions  (optional)
   * @return Future(ComDayCqWcmCoreImplVersionManagerImplInfo)
   */
  def comDayCqWcmCoreImplVersionManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, versionmanagerCreateVersionOnActivation: Option[Boolean] = None, versionmanagerPurgingEnabled: Option[Boolean] = None, versionmanagerPurgePaths: Option[List[String]] = None, versionmanagerIvPaths: Option[List[String]] = None, versionmanagerMaxAgeDays: Option[Integer] = None, versionmanagerMaxNumberVersions: Option[Integer] = None, versionmanagerMinNumberVersions: Option[Integer] = None): Future[ComDayCqWcmCoreImplVersionManagerImplInfo] = {
      helper.comDayCqWcmCoreImplVersionManagerImpl(post, apply, delete, action, location, propertylist, versionmanagerCreateVersionOnActivation, versionmanagerPurgingEnabled, versionmanagerPurgePaths, versionmanagerIvPaths, versionmanagerMaxAgeDays, versionmanagerMaxNumberVersions, versionmanagerMinNumberVersions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param versionpurgePaths  (optional)
   * @param versionpurgeRecursive  (optional)
   * @param versionpurgeMaxVersions  (optional)
   * @param versionpurgeMinVersions  (optional)
   * @param versionpurgeMaxAgeDays  (optional)
   * @return ComDayCqWcmCoreImplVersionPurgeTaskInfo
   */
  def comDayCqWcmCoreImplVersionPurgeTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, versionpurgePaths: Option[List[String]] = None, versionpurgeRecursive: Option[Boolean] = None, versionpurgeMaxVersions: Option[Integer] = None, versionpurgeMinVersions: Option[Integer] = None, versionpurgeMaxAgeDays: Option[Integer] = None): Option[ComDayCqWcmCoreImplVersionPurgeTaskInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplVersionPurgeTaskAsync(post, apply, delete, action, location, propertylist, versionpurgePaths, versionpurgeRecursive, versionpurgeMaxVersions, versionpurgeMinVersions, versionpurgeMaxAgeDays), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param versionpurgePaths  (optional)
   * @param versionpurgeRecursive  (optional)
   * @param versionpurgeMaxVersions  (optional)
   * @param versionpurgeMinVersions  (optional)
   * @param versionpurgeMaxAgeDays  (optional)
   * @return Future(ComDayCqWcmCoreImplVersionPurgeTaskInfo)
   */
  def comDayCqWcmCoreImplVersionPurgeTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, versionpurgePaths: Option[List[String]] = None, versionpurgeRecursive: Option[Boolean] = None, versionpurgeMaxVersions: Option[Integer] = None, versionpurgeMinVersions: Option[Integer] = None, versionpurgeMaxAgeDays: Option[Integer] = None): Future[ComDayCqWcmCoreImplVersionPurgeTaskInfo] = {
      helper.comDayCqWcmCoreImplVersionPurgeTask(post, apply, delete, action, location, propertylist, versionpurgePaths, versionpurgeRecursive, versionpurgeMaxVersions, versionpurgeMinVersions, versionpurgeMaxAgeDays)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param wcmdbgfilterEnabled  (optional)
   * @param wcmdbgfilterJspDebug  (optional)
   * @return ComDayCqWcmCoreImplWCMDebugFilterInfo
   */
  def comDayCqWcmCoreImplWCMDebugFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, wcmdbgfilterEnabled: Option[Boolean] = None, wcmdbgfilterJspDebug: Option[Boolean] = None): Option[ComDayCqWcmCoreImplWCMDebugFilterInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplWCMDebugFilterAsync(post, apply, delete, action, location, propertylist, wcmdbgfilterEnabled, wcmdbgfilterJspDebug), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param wcmdbgfilterEnabled  (optional)
   * @param wcmdbgfilterJspDebug  (optional)
   * @return Future(ComDayCqWcmCoreImplWCMDebugFilterInfo)
   */
  def comDayCqWcmCoreImplWCMDebugFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, wcmdbgfilterEnabled: Option[Boolean] = None, wcmdbgfilterJspDebug: Option[Boolean] = None): Future[ComDayCqWcmCoreImplWCMDebugFilterInfo] = {
      helper.comDayCqWcmCoreImplWCMDebugFilter(post, apply, delete, action, location, propertylist, wcmdbgfilterEnabled, wcmdbgfilterJspDebug)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param wcmdevmodefilterEnabled  (optional)
   * @return ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo
   */
  def comDayCqWcmCoreImplWCMDeveloperModeFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, wcmdevmodefilterEnabled: Option[Boolean] = None): Option[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplWCMDeveloperModeFilterAsync(post, apply, delete, action, location, propertylist, wcmdevmodefilterEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param wcmdevmodefilterEnabled  (optional)
   * @return Future(ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo)
   */
  def comDayCqWcmCoreImplWCMDeveloperModeFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, wcmdevmodefilterEnabled: Option[Boolean] = None): Future[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo] = {
      helper.comDayCqWcmCoreImplWCMDeveloperModeFilter(post, apply, delete, action, location, propertylist, wcmdevmodefilterEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param filterOrder  (optional)
   * @param filterScope  (optional)
   * @return ComDayCqWcmCoreImplWarpTimeWarpFilterInfo
   */
  def comDayCqWcmCoreImplWarpTimeWarpFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, filterOrder: Option[String] = None, filterScope: Option[String] = None): Option[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreImplWarpTimeWarpFilterAsync(post, apply, delete, action, location, propertylist, filterOrder, filterScope), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param filterOrder  (optional)
   * @param filterScope  (optional)
   * @return Future(ComDayCqWcmCoreImplWarpTimeWarpFilterInfo)
   */
  def comDayCqWcmCoreImplWarpTimeWarpFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, filterOrder: Option[String] = None, filterScope: Option[String] = None): Future[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo] = {
      helper.comDayCqWcmCoreImplWarpTimeWarpFilter(post, apply, delete, action, location, propertylist, filterOrder, filterScope)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mvtstatisticsTrackingurl  (optional)
   * @return ComDayCqWcmCoreMvtMVTStatisticsImplInfo
   */
  def comDayCqWcmCoreMvtMVTStatisticsImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mvtstatisticsTrackingurl: Option[String] = None): Option[ComDayCqWcmCoreMvtMVTStatisticsImplInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreMvtMVTStatisticsImplAsync(post, apply, delete, action, location, propertylist, mvtstatisticsTrackingurl), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mvtstatisticsTrackingurl  (optional)
   * @return Future(ComDayCqWcmCoreMvtMVTStatisticsImplInfo)
   */
  def comDayCqWcmCoreMvtMVTStatisticsImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mvtstatisticsTrackingurl: Option[String] = None): Future[ComDayCqWcmCoreMvtMVTStatisticsImplInfo] = {
      helper.comDayCqWcmCoreMvtMVTStatisticsImpl(post, apply, delete, action, location, propertylist, mvtstatisticsTrackingurl)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pageviewstatisticsTrackingurl  (optional)
   * @param pageviewstatisticsTrackingscriptEnabled  (optional)
   * @return ComDayCqWcmCoreStatsPageViewStatisticsImplInfo
   */
  def comDayCqWcmCoreStatsPageViewStatisticsImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pageviewstatisticsTrackingurl: Option[String] = None, pageviewstatisticsTrackingscriptEnabled: Option[String] = None): Option[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreStatsPageViewStatisticsImplAsync(post, apply, delete, action, location, propertylist, pageviewstatisticsTrackingurl, pageviewstatisticsTrackingscriptEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pageviewstatisticsTrackingurl  (optional)
   * @param pageviewstatisticsTrackingscriptEnabled  (optional)
   * @return Future(ComDayCqWcmCoreStatsPageViewStatisticsImplInfo)
   */
  def comDayCqWcmCoreStatsPageViewStatisticsImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pageviewstatisticsTrackingurl: Option[String] = None, pageviewstatisticsTrackingscriptEnabled: Option[String] = None): Future[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo] = {
      helper.comDayCqWcmCoreStatsPageViewStatisticsImpl(post, apply, delete, action, location, propertylist, pageviewstatisticsTrackingurl, pageviewstatisticsTrackingscriptEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param wcmfilterMode  (optional)
   * @return ComDayCqWcmCoreWCMRequestFilterInfo
   */
  def comDayCqWcmCoreWCMRequestFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, wcmfilterMode: Option[String] = None): Option[ComDayCqWcmCoreWCMRequestFilterInfo] = {
    val await = Try(Await.result(comDayCqWcmCoreWCMRequestFilterAsync(post, apply, delete, action, location, propertylist, wcmfilterMode), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param wcmfilterMode  (optional)
   * @return Future(ComDayCqWcmCoreWCMRequestFilterInfo)
   */
  def comDayCqWcmCoreWCMRequestFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, wcmfilterMode: Option[String] = None): Future[ComDayCqWcmCoreWCMRequestFilterInfo] = {
      helper.comDayCqWcmCoreWCMRequestFilter(post, apply, delete, action, location, propertylist, wcmfilterMode)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param extractFilter  (optional)
   * @return ComDayCqWcmDesignimporterDesignPackageImporterInfo
   */
  def comDayCqWcmDesignimporterDesignPackageImporter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, extractFilter: Option[List[String]] = None): Option[ComDayCqWcmDesignimporterDesignPackageImporterInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterDesignPackageImporterAsync(post, apply, delete, action, location, propertylist, extractFilter), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param extractFilter  (optional)
   * @return Future(ComDayCqWcmDesignimporterDesignPackageImporterInfo)
   */
  def comDayCqWcmDesignimporterDesignPackageImporterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, extractFilter: Option[List[String]] = None): Future[ComDayCqWcmDesignimporterDesignPackageImporterInfo] = {
      helper.comDayCqWcmDesignimporterDesignPackageImporter(post, apply, delete, action, location, propertylist, extractFilter)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param filepattern  (optional)
   * @param buildPageNodes  (optional)
   * @param buildClientLibs  (optional)
   * @param buildCanvasComponent  (optional)
   * @return ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo
   */
  def comDayCqWcmDesignimporterImplCanvasBuilderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, filepattern: Option[String] = None, buildPageNodes: Option[Boolean] = None, buildClientLibs: Option[Boolean] = None, buildCanvasComponent: Option[Boolean] = None): Option[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterImplCanvasBuilderImplAsync(post, apply, delete, action, location, propertylist, filepattern, buildPageNodes, buildClientLibs, buildCanvasComponent), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param filepattern  (optional)
   * @param buildPageNodes  (optional)
   * @param buildClientLibs  (optional)
   * @param buildCanvasComponent  (optional)
   * @return Future(ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo)
   */
  def comDayCqWcmDesignimporterImplCanvasBuilderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, filepattern: Option[String] = None, buildPageNodes: Option[Boolean] = None, buildClientLibs: Option[Boolean] = None, buildCanvasComponent: Option[Boolean] = None): Future[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo] = {
      helper.comDayCqWcmDesignimporterImplCanvasBuilderImpl(post, apply, delete, action, location, propertylist, filepattern, buildPageNodes, buildClientLibs, buildCanvasComponent)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param minThreadPoolSize  (optional)
   * @param maxThreadPoolSize  (optional)
   * @return ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo
   */
  def comDayCqWcmDesignimporterImplCanvasPageDeleteHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, minThreadPoolSize: Option[Integer] = None, maxThreadPoolSize: Option[Integer] = None): Option[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterImplCanvasPageDeleteHandlerAsync(post, apply, delete, action, location, propertylist, minThreadPoolSize, maxThreadPoolSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param minThreadPoolSize  (optional)
   * @param maxThreadPoolSize  (optional)
   * @return Future(ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo)
   */
  def comDayCqWcmDesignimporterImplCanvasPageDeleteHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, minThreadPoolSize: Option[Integer] = None, maxThreadPoolSize: Option[Integer] = None): Future[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo] = {
      helper.comDayCqWcmDesignimporterImplCanvasPageDeleteHandler(post, apply, delete, action, location, propertylist, minThreadPoolSize, maxThreadPoolSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param searchPattern  (optional)
   * @param replacePattern  (optional)
   * @return ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo
   */
  def comDayCqWcmDesignimporterImplEntryPreprocessorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, searchPattern: Option[String] = None, replacePattern: Option[String] = None): Option[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterImplEntryPreprocessorImplAsync(post, apply, delete, action, location, propertylist, searchPattern, replacePattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param searchPattern  (optional)
   * @param replacePattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo)
   */
  def comDayCqWcmDesignimporterImplEntryPreprocessorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, searchPattern: Option[String] = None, replacePattern: Option[String] = None): Future[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo] = {
      helper.comDayCqWcmDesignimporterImplEntryPreprocessorImpl(post, apply, delete, action, location, propertylist, searchPattern, replacePattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param filepattern  (optional)
   * @param deviceGroups  (optional)
   * @param buildPageNodes  (optional)
   * @param buildClientLibs  (optional)
   * @param buildCanvasComponent  (optional)
   * @return ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo
   */
  def comDayCqWcmDesignimporterImplMobileCanvasBuilderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, filepattern: Option[String] = None, deviceGroups: Option[List[String]] = None, buildPageNodes: Option[Boolean] = None, buildClientLibs: Option[Boolean] = None, buildCanvasComponent: Option[Boolean] = None): Option[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterImplMobileCanvasBuilderImplAsync(post, apply, delete, action, location, propertylist, filepattern, deviceGroups, buildPageNodes, buildClientLibs, buildCanvasComponent), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param filepattern  (optional)
   * @param deviceGroups  (optional)
   * @param buildPageNodes  (optional)
   * @param buildClientLibs  (optional)
   * @param buildCanvasComponent  (optional)
   * @return Future(ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo)
   */
  def comDayCqWcmDesignimporterImplMobileCanvasBuilderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, filepattern: Option[String] = None, deviceGroups: Option[List[String]] = None, buildPageNodes: Option[Boolean] = None, buildClientLibs: Option[Boolean] = None, buildCanvasComponent: Option[Boolean] = None): Future[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo] = {
      helper.comDayCqWcmDesignimporterImplMobileCanvasBuilderImpl(post, apply, delete, action, location, propertylist, filepattern, deviceGroups, buildPageNodes, buildClientLibs, buildCanvasComponent)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryCanvasCompone(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryCanvasCompone(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultCompon(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultCompon(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHan(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHan(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandle(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandle(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHand(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHand(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryImageComponen(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryImageComponen(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandler(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptT(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptT(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandle(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandle(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandle(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandle(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagH(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagH(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryParsysCompone(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryParsysCompone(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHand(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHand(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandl(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTextComponent(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryTextComponent(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponen(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @param componentResourceType  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None, componentResourceType: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponen(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern, componentResourceType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Option[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo] = {
    val await = Try(Await.result(comDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlAsync(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param tagpattern  (optional)
   * @return Future(ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo)
   */
  def comDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, tagpattern: Option[String] = None): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo] = {
      helper.comDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandl(post, apply, delete, action, location, propertylist, serviceRanking, tagpattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceName  (optional)
   * @param slingServletResourceTypes  (optional)
   * @param slingServletSelectors  (optional)
   * @param slingServletMethods  (optional)
   * @param formsFormchooserservletAdvansesearchRequire  (optional)
   * @return ComDayCqWcmFoundationFormsImplFormChooserServletInfo
   */
  def comDayCqWcmFoundationFormsImplFormChooserServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceName: Option[String] = None, slingServletResourceTypes: Option[String] = None, slingServletSelectors: Option[String] = None, slingServletMethods: Option[List[String]] = None, formsFormchooserservletAdvansesearchRequire: Option[Boolean] = None): Option[ComDayCqWcmFoundationFormsImplFormChooserServletInfo] = {
    val await = Try(Await.result(comDayCqWcmFoundationFormsImplFormChooserServletAsync(post, apply, delete, action, location, propertylist, serviceName, slingServletResourceTypes, slingServletSelectors, slingServletMethods, formsFormchooserservletAdvansesearchRequire), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceName  (optional)
   * @param slingServletResourceTypes  (optional)
   * @param slingServletSelectors  (optional)
   * @param slingServletMethods  (optional)
   * @param formsFormchooserservletAdvansesearchRequire  (optional)
   * @return Future(ComDayCqWcmFoundationFormsImplFormChooserServletInfo)
   */
  def comDayCqWcmFoundationFormsImplFormChooserServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceName: Option[String] = None, slingServletResourceTypes: Option[String] = None, slingServletSelectors: Option[String] = None, slingServletMethods: Option[List[String]] = None, formsFormchooserservletAdvansesearchRequire: Option[Boolean] = None): Future[ComDayCqWcmFoundationFormsImplFormChooserServletInfo] = {
      helper.comDayCqWcmFoundationFormsImplFormChooserServlet(post, apply, delete, action, location, propertylist, serviceName, slingServletResourceTypes, slingServletSelectors, slingServletMethods, formsFormchooserservletAdvansesearchRequire)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param formsFormparagraphpostprocessorEnabled  (optional)
   * @param formsFormparagraphpostprocessorFormresourcetypes  (optional)
   * @return ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo
   */
  def comDayCqWcmFoundationFormsImplFormParagraphPostProcessor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, formsFormparagraphpostprocessorEnabled: Option[Boolean] = None, formsFormparagraphpostprocessorFormresourcetypes: Option[List[String]] = None): Option[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo] = {
    val await = Try(Await.result(comDayCqWcmFoundationFormsImplFormParagraphPostProcessorAsync(post, apply, delete, action, location, propertylist, formsFormparagraphpostprocessorEnabled, formsFormparagraphpostprocessorFormresourcetypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param formsFormparagraphpostprocessorEnabled  (optional)
   * @param formsFormparagraphpostprocessorFormresourcetypes  (optional)
   * @return Future(ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo)
   */
  def comDayCqWcmFoundationFormsImplFormParagraphPostProcessorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, formsFormparagraphpostprocessorEnabled: Option[Boolean] = None, formsFormparagraphpostprocessorFormresourcetypes: Option[List[String]] = None): Future[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo] = {
      helper.comDayCqWcmFoundationFormsImplFormParagraphPostProcessor(post, apply, delete, action, location, propertylist, formsFormparagraphpostprocessorEnabled, formsFormparagraphpostprocessorFormresourcetypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param nameWhitelist  (optional)
   * @param allowExpressions  (optional)
   * @return ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo
   */
  def comDayCqWcmFoundationFormsImplFormsHandlingServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, nameWhitelist: Option[String] = None, allowExpressions: Option[Boolean] = None): Option[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo] = {
    val await = Try(Await.result(comDayCqWcmFoundationFormsImplFormsHandlingServletAsync(post, apply, delete, action, location, propertylist, nameWhitelist, allowExpressions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param nameWhitelist  (optional)
   * @param allowExpressions  (optional)
   * @return Future(ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo)
   */
  def comDayCqWcmFoundationFormsImplFormsHandlingServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, nameWhitelist: Option[String] = None, allowExpressions: Option[Boolean] = None): Future[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo] = {
      helper.comDayCqWcmFoundationFormsImplFormsHandlingServlet(post, apply, delete, action, location, propertylist, nameWhitelist, allowExpressions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletResourceTypes  (optional)
   * @param slingServletSelectors  (optional)
   * @param resourceWhitelist  (optional)
   * @param resourceBlacklist  (optional)
   * @return ComDayCqWcmFoundationFormsImplMailServletInfo
   */
  def comDayCqWcmFoundationFormsImplMailServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletResourceTypes: Option[String] = None, slingServletSelectors: Option[String] = None, resourceWhitelist: Option[List[String]] = None, resourceBlacklist: Option[String] = None): Option[ComDayCqWcmFoundationFormsImplMailServletInfo] = {
    val await = Try(Await.result(comDayCqWcmFoundationFormsImplMailServletAsync(post, apply, delete, action, location, propertylist, slingServletResourceTypes, slingServletSelectors, resourceWhitelist, resourceBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletResourceTypes  (optional)
   * @param slingServletSelectors  (optional)
   * @param resourceWhitelist  (optional)
   * @param resourceBlacklist  (optional)
   * @return Future(ComDayCqWcmFoundationFormsImplMailServletInfo)
   */
  def comDayCqWcmFoundationFormsImplMailServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletResourceTypes: Option[String] = None, slingServletSelectors: Option[String] = None, resourceWhitelist: Option[List[String]] = None, resourceBlacklist: Option[String] = None): Future[ComDayCqWcmFoundationFormsImplMailServletInfo] = {
      helper.comDayCqWcmFoundationFormsImplMailServlet(post, apply, delete, action, location, propertylist, slingServletResourceTypes, slingServletSelectors, resourceWhitelist, resourceBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param adaptSupportedWidths  (optional)
   * @return ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo
   */
  def comDayCqWcmFoundationImplAdaptiveImageComponentServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, adaptSupportedWidths: Option[List[String]] = None): Option[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo] = {
    val await = Try(Await.result(comDayCqWcmFoundationImplAdaptiveImageComponentServletAsync(post, apply, delete, action, location, propertylist, adaptSupportedWidths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param adaptSupportedWidths  (optional)
   * @return Future(ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo)
   */
  def comDayCqWcmFoundationImplAdaptiveImageComponentServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, adaptSupportedWidths: Option[List[String]] = None): Future[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo] = {
      helper.comDayCqWcmFoundationImplAdaptiveImageComponentServlet(post, apply, delete, action, location, propertylist, adaptSupportedWidths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param authHttpNologin  (optional)
   * @param authHttpRealm  (optional)
   * @param authDefaultLoginpage  (optional)
   * @param authCredForm  (optional)
   * @param authCredUtf8  (optional)
   * @return ComDayCqWcmFoundationImplHTTPAuthHandlerInfo
   */
  def comDayCqWcmFoundationImplHTTPAuthHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, authHttpNologin: Option[Boolean] = None, authHttpRealm: Option[String] = None, authDefaultLoginpage: Option[String] = None, authCredForm: Option[List[String]] = None, authCredUtf8: Option[List[String]] = None): Option[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo] = {
    val await = Try(Await.result(comDayCqWcmFoundationImplHTTPAuthHandlerAsync(post, apply, delete, action, location, propertylist, `path`, authHttpNologin, authHttpRealm, authDefaultLoginpage, authCredForm, authCredUtf8), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param authHttpNologin  (optional)
   * @param authHttpRealm  (optional)
   * @param authDefaultLoginpage  (optional)
   * @param authCredForm  (optional)
   * @param authCredUtf8  (optional)
   * @return Future(ComDayCqWcmFoundationImplHTTPAuthHandlerInfo)
   */
  def comDayCqWcmFoundationImplHTTPAuthHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, authHttpNologin: Option[Boolean] = None, authHttpRealm: Option[String] = None, authDefaultLoginpage: Option[String] = None, authCredForm: Option[List[String]] = None, authCredUtf8: Option[List[String]] = None): Future[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo] = {
      helper.comDayCqWcmFoundationImplHTTPAuthHandler(post, apply, delete, action, location, propertylist, `path`, authHttpNologin, authHttpRealm, authDefaultLoginpage, authCredForm, authCredUtf8)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingAuthRequirements  (optional)
   * @return ComDayCqWcmFoundationImplPageImpressionsTrackerInfo
   */
  def comDayCqWcmFoundationImplPageImpressionsTracker(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingAuthRequirements: Option[String] = None): Option[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo] = {
    val await = Try(Await.result(comDayCqWcmFoundationImplPageImpressionsTrackerAsync(post, apply, delete, action, location, propertylist, slingAuthRequirements), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingAuthRequirements  (optional)
   * @return Future(ComDayCqWcmFoundationImplPageImpressionsTrackerInfo)
   */
  def comDayCqWcmFoundationImplPageImpressionsTrackerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingAuthRequirements: Option[String] = None): Future[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo] = {
      helper.comDayCqWcmFoundationImplPageImpressionsTracker(post, apply, delete, action, location, propertylist, slingAuthRequirements)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param excludedResourceTypes  (optional)
   * @return ComDayCqWcmFoundationImplPageRedirectServletInfo
   */
  def comDayCqWcmFoundationImplPageRedirectServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, excludedResourceTypes: Option[List[String]] = None): Option[ComDayCqWcmFoundationImplPageRedirectServletInfo] = {
    val await = Try(Await.result(comDayCqWcmFoundationImplPageRedirectServletAsync(post, apply, delete, action, location, propertylist, excludedResourceTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param excludedResourceTypes  (optional)
   * @return Future(ComDayCqWcmFoundationImplPageRedirectServletInfo)
   */
  def comDayCqWcmFoundationImplPageRedirectServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, excludedResourceTypes: Option[List[String]] = None): Future[ComDayCqWcmFoundationImplPageRedirectServletInfo] = {
      helper.comDayCqWcmFoundationImplPageRedirectServlet(post, apply, delete, action, location, propertylist, excludedResourceTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultAttachmentTypeBlacklist  (optional)
   * @param baselineAttachmentTypeBlacklist  (optional)
   * @return ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo
   */
  def comDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklist(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultAttachmentTypeBlacklist: Option[List[String]] = None, baselineAttachmentTypeBlacklist: Option[List[String]] = None): Option[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo] = {
    val await = Try(Await.result(comDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistAsync(post, apply, delete, action, location, propertylist, defaultAttachmentTypeBlacklist, baselineAttachmentTypeBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param defaultAttachmentTypeBlacklist  (optional)
   * @param baselineAttachmentTypeBlacklist  (optional)
   * @return Future(ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo)
   */
  def comDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, defaultAttachmentTypeBlacklist: Option[List[String]] = None, baselineAttachmentTypeBlacklist: Option[List[String]] = None): Future[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo] = {
      helper.comDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklist(post, apply, delete, action, location, propertylist, defaultAttachmentTypeBlacklist, baselineAttachmentTypeBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param parameterWhitelist  (optional)
   * @param parameterWhitelistPrefixes  (optional)
   * @param binaryParameterWhitelist  (optional)
   * @param modifierWhitelist  (optional)
   * @param operationWhitelist  (optional)
   * @param operationWhitelistPrefixes  (optional)
   * @param typehintWhitelist  (optional)
   * @param resourcetypeWhitelist  (optional)
   * @return ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo
   */
  def comDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, parameterWhitelist: Option[List[String]] = None, parameterWhitelistPrefixes: Option[List[String]] = None, binaryParameterWhitelist: Option[List[String]] = None, modifierWhitelist: Option[List[String]] = None, operationWhitelist: Option[List[String]] = None, operationWhitelistPrefixes: Option[List[String]] = None, typehintWhitelist: Option[List[String]] = None, resourcetypeWhitelist: Option[List[String]] = None): Option[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo] = {
    val await = Try(Await.result(comDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplAsync(post, apply, delete, action, location, propertylist, parameterWhitelist, parameterWhitelistPrefixes, binaryParameterWhitelist, modifierWhitelist, operationWhitelist, operationWhitelistPrefixes, typehintWhitelist, resourcetypeWhitelist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param parameterWhitelist  (optional)
   * @param parameterWhitelistPrefixes  (optional)
   * @param binaryParameterWhitelist  (optional)
   * @param modifierWhitelist  (optional)
   * @param operationWhitelist  (optional)
   * @param operationWhitelistPrefixes  (optional)
   * @param typehintWhitelist  (optional)
   * @param resourcetypeWhitelist  (optional)
   * @return Future(ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo)
   */
  def comDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, parameterWhitelist: Option[List[String]] = None, parameterWhitelistPrefixes: Option[List[String]] = None, binaryParameterWhitelist: Option[List[String]] = None, modifierWhitelist: Option[List[String]] = None, operationWhitelist: Option[List[String]] = None, operationWhitelistPrefixes: Option[List[String]] = None, typehintWhitelist: Option[List[String]] = None, resourcetypeWhitelist: Option[List[String]] = None): Future[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo] = {
      helper.comDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImpl(post, apply, delete, action, location, propertylist, parameterWhitelist, parameterWhitelistPrefixes, binaryParameterWhitelist, modifierWhitelist, operationWhitelist, operationWhitelistPrefixes, typehintWhitelist, resourcetypeWhitelist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param deviceInfoTransformerEnabled  (optional)
   * @param deviceInfoTransformerCssStyle  (optional)
   * @return ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo
   */
  def comDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, deviceInfoTransformerEnabled: Option[Boolean] = None, deviceInfoTransformerCssStyle: Option[String] = None): Option[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo] = {
    val await = Try(Await.result(comDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryAsync(post, apply, delete, action, location, propertylist, deviceInfoTransformerEnabled, deviceInfoTransformerCssStyle), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param deviceInfoTransformerEnabled  (optional)
   * @param deviceInfoTransformerCssStyle  (optional)
   * @return Future(ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo)
   */
  def comDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, deviceInfoTransformerEnabled: Option[Boolean] = None, deviceInfoTransformerCssStyle: Option[String] = None): Future[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo] = {
      helper.comDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactory(post, apply, delete, action, location, propertylist, deviceInfoTransformerEnabled, deviceInfoTransformerCssStyle)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param redirectEnabled  (optional)
   * @param redirectStatsEnabled  (optional)
   * @param redirectExtensions  (optional)
   * @param redirectPaths  (optional)
   * @return ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo
   */
  def comDayCqWcmMobileCoreImplRedirectRedirectFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, redirectEnabled: Option[Boolean] = None, redirectStatsEnabled: Option[Boolean] = None, redirectExtensions: Option[List[String]] = None, redirectPaths: Option[List[String]] = None): Option[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo] = {
    val await = Try(Await.result(comDayCqWcmMobileCoreImplRedirectRedirectFilterAsync(post, apply, delete, action, location, propertylist, redirectEnabled, redirectStatsEnabled, redirectExtensions, redirectPaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param redirectEnabled  (optional)
   * @param redirectStatsEnabled  (optional)
   * @param redirectExtensions  (optional)
   * @param redirectPaths  (optional)
   * @return Future(ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo)
   */
  def comDayCqWcmMobileCoreImplRedirectRedirectFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, redirectEnabled: Option[Boolean] = None, redirectStatsEnabled: Option[Boolean] = None, redirectExtensions: Option[List[String]] = None, redirectPaths: Option[List[String]] = None): Future[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo] = {
      helper.comDayCqWcmMobileCoreImplRedirectRedirectFilter(post, apply, delete, action, location, propertylist, redirectEnabled, redirectStatsEnabled, redirectExtensions, redirectPaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @param contentcopyactionOrderStyle  (optional)
   * @return ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo
   */
  def comDayCqWcmMsmImplActionsContentCopyActionFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None, contentcopyactionOrderStyle: Option[String] = None): Option[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo] = {
    val await = Try(Await.result(comDayCqWcmMsmImplActionsContentCopyActionFactoryAsync(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops, contentcopyactionOrderStyle), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @param contentcopyactionOrderStyle  (optional)
   * @return Future(ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo)
   */
  def comDayCqWcmMsmImplActionsContentCopyActionFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None, contentcopyactionOrderStyle: Option[String] = None): Future[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo] = {
      helper.comDayCqWcmMsmImplActionsContentCopyActionFactory(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops, contentcopyactionOrderStyle)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @return ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo
   */
  def comDayCqWcmMsmImplActionsContentDeleteActionFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None): Option[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo] = {
    val await = Try(Await.result(comDayCqWcmMsmImplActionsContentDeleteActionFactoryAsync(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @return Future(ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo)
   */
  def comDayCqWcmMsmImplActionsContentDeleteActionFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None): Future[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo] = {
      helper.comDayCqWcmMsmImplActionsContentDeleteActionFactory(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @param cqWcmMsmActionIgnoredMixin  (optional)
   * @return ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo
   */
  def comDayCqWcmMsmImplActionsContentUpdateActionFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None, cqWcmMsmActionIgnoredMixin: Option[List[String]] = None): Option[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo] = {
    val await = Try(Await.result(comDayCqWcmMsmImplActionsContentUpdateActionFactoryAsync(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops, cqWcmMsmActionIgnoredMixin), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @param cqWcmMsmActionIgnoredMixin  (optional)
   * @return Future(ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo)
   */
  def comDayCqWcmMsmImplActionsContentUpdateActionFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None, cqWcmMsmActionIgnoredMixin: Option[List[String]] = None): Future[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo] = {
      helper.comDayCqWcmMsmImplActionsContentUpdateActionFactory(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops, cqWcmMsmActionIgnoredMixin)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @return ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo
   */
  def comDayCqWcmMsmImplActionsOrderChildrenActionFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None): Option[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo] = {
    val await = Try(Await.result(comDayCqWcmMsmImplActionsOrderChildrenActionFactoryAsync(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @return Future(ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo)
   */
  def comDayCqWcmMsmImplActionsOrderChildrenActionFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None): Future[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo] = {
      helper.comDayCqWcmMsmImplActionsOrderChildrenActionFactory(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @param cqWcmMsmImplActionsPagemovePropReferenceUpdate  (optional)
   * @return ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo
   */
  def comDayCqWcmMsmImplActionsPageMoveActionFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None, cqWcmMsmImplActionsPagemovePropReferenceUpdate: Option[Boolean] = None): Option[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo] = {
    val await = Try(Await.result(comDayCqWcmMsmImplActionsPageMoveActionFactoryAsync(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops, cqWcmMsmImplActionsPagemovePropReferenceUpdate), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @param cqWcmMsmImplActionsPagemovePropReferenceUpdate  (optional)
   * @return Future(ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo)
   */
  def comDayCqWcmMsmImplActionsPageMoveActionFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None, cqWcmMsmImplActionsPagemovePropReferenceUpdate: Option[Boolean] = None): Future[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo] = {
      helper.comDayCqWcmMsmImplActionsPageMoveActionFactory(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops, cqWcmMsmImplActionsPagemovePropReferenceUpdate)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @param cqWcmMsmImplActionReferencesupdatePropUpdateNested  (optional)
   * @return ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo
   */
  def comDayCqWcmMsmImplActionsReferencesUpdateActionFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None, cqWcmMsmImplActionReferencesupdatePropUpdateNested: Option[Boolean] = None): Option[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo] = {
    val await = Try(Await.result(comDayCqWcmMsmImplActionsReferencesUpdateActionFactoryAsync(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops, cqWcmMsmImplActionReferencesupdatePropUpdateNested), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @param cqWcmMsmImplActionReferencesupdatePropUpdateNested  (optional)
   * @return Future(ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo)
   */
  def comDayCqWcmMsmImplActionsReferencesUpdateActionFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None, cqWcmMsmImplActionReferencesupdatePropUpdateNested: Option[Boolean] = None): Future[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo] = {
      helper.comDayCqWcmMsmImplActionsReferencesUpdateActionFactory(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops, cqWcmMsmImplActionReferencesupdatePropUpdateNested)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @return ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo
   */
  def comDayCqWcmMsmImplActionsVersionCopyActionFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None): Option[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo] = {
    val await = Try(Await.result(comDayCqWcmMsmImplActionsVersionCopyActionFactoryAsync(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmMsmActionExcludednodetypes  (optional)
   * @param cqWcmMsmActionExcludedparagraphitems  (optional)
   * @param cqWcmMsmActionExcludedprops  (optional)
   * @return Future(ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo)
   */
  def comDayCqWcmMsmImplActionsVersionCopyActionFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmMsmActionExcludednodetypes: Option[List[String]] = None, cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None, cqWcmMsmActionExcludedprops: Option[List[String]] = None): Future[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo] = {
      helper.comDayCqWcmMsmImplActionsVersionCopyActionFactory(post, apply, delete, action, location, propertylist, cqWcmMsmActionExcludednodetypes, cqWcmMsmActionExcludedparagraphitems, cqWcmMsmActionExcludedprops)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param liverelationshipmgrRelationsconfigDefault  (optional)
   * @return ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo
   */
  def comDayCqWcmMsmImplLiveRelationshipManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, liverelationshipmgrRelationsconfigDefault: Option[String] = None): Option[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo] = {
    val await = Try(Await.result(comDayCqWcmMsmImplLiveRelationshipManagerImplAsync(post, apply, delete, action, location, propertylist, liverelationshipmgrRelationsconfigDefault), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param liverelationshipmgrRelationsconfigDefault  (optional)
   * @return Future(ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo)
   */
  def comDayCqWcmMsmImplLiveRelationshipManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, liverelationshipmgrRelationsconfigDefault: Option[String] = None): Future[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo] = {
      helper.comDayCqWcmMsmImplLiveRelationshipManagerImpl(post, apply, delete, action, location, propertylist, liverelationshipmgrRelationsconfigDefault)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param rolloutmgrExcludedpropsDefault  (optional)
   * @param rolloutmgrExcludedparagraphpropsDefault  (optional)
   * @param rolloutmgrExcludednodetypesDefault  (optional)
   * @param rolloutmgrThreadpoolMaxsize  (optional)
   * @param rolloutmgrThreadpoolMaxshutdowntime  (optional)
   * @param rolloutmgrThreadpoolPriority  (optional)
   * @param rolloutmgrCommitSize  (optional)
   * @param rolloutmgrConflicthandlingEnabled  (optional)
   * @return ComDayCqWcmMsmImplRolloutManagerImplInfo
   */
  def comDayCqWcmMsmImplRolloutManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, rolloutmgrExcludedpropsDefault: Option[List[String]] = None, rolloutmgrExcludedparagraphpropsDefault: Option[List[String]] = None, rolloutmgrExcludednodetypesDefault: Option[List[String]] = None, rolloutmgrThreadpoolMaxsize: Option[Integer] = None, rolloutmgrThreadpoolMaxshutdowntime: Option[Integer] = None, rolloutmgrThreadpoolPriority: Option[String] = None, rolloutmgrCommitSize: Option[Integer] = None, rolloutmgrConflicthandlingEnabled: Option[Boolean] = None): Option[ComDayCqWcmMsmImplRolloutManagerImplInfo] = {
    val await = Try(Await.result(comDayCqWcmMsmImplRolloutManagerImplAsync(post, apply, delete, action, location, propertylist, eventFilter, rolloutmgrExcludedpropsDefault, rolloutmgrExcludedparagraphpropsDefault, rolloutmgrExcludednodetypesDefault, rolloutmgrThreadpoolMaxsize, rolloutmgrThreadpoolMaxshutdowntime, rolloutmgrThreadpoolPriority, rolloutmgrCommitSize, rolloutmgrConflicthandlingEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param rolloutmgrExcludedpropsDefault  (optional)
   * @param rolloutmgrExcludedparagraphpropsDefault  (optional)
   * @param rolloutmgrExcludednodetypesDefault  (optional)
   * @param rolloutmgrThreadpoolMaxsize  (optional)
   * @param rolloutmgrThreadpoolMaxshutdowntime  (optional)
   * @param rolloutmgrThreadpoolPriority  (optional)
   * @param rolloutmgrCommitSize  (optional)
   * @param rolloutmgrConflicthandlingEnabled  (optional)
   * @return Future(ComDayCqWcmMsmImplRolloutManagerImplInfo)
   */
  def comDayCqWcmMsmImplRolloutManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, rolloutmgrExcludedpropsDefault: Option[List[String]] = None, rolloutmgrExcludedparagraphpropsDefault: Option[List[String]] = None, rolloutmgrExcludednodetypesDefault: Option[List[String]] = None, rolloutmgrThreadpoolMaxsize: Option[Integer] = None, rolloutmgrThreadpoolMaxshutdowntime: Option[Integer] = None, rolloutmgrThreadpoolPriority: Option[String] = None, rolloutmgrCommitSize: Option[Integer] = None, rolloutmgrConflicthandlingEnabled: Option[Boolean] = None): Future[ComDayCqWcmMsmImplRolloutManagerImplInfo] = {
      helper.comDayCqWcmMsmImplRolloutManagerImpl(post, apply, delete, action, location, propertylist, eventFilter, rolloutmgrExcludedpropsDefault, rolloutmgrExcludedparagraphpropsDefault, rolloutmgrExcludednodetypesDefault, rolloutmgrThreadpoolMaxsize, rolloutmgrThreadpoolMaxshutdowntime, rolloutmgrThreadpoolPriority, rolloutmgrCommitSize, rolloutmgrConflicthandlingEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param auditlogservletDefaultEventsCount  (optional)
   * @param auditlogservletDefaultPath  (optional)
   * @return ComDayCqWcmMsmImplServletsAuditLogServletInfo
   */
  def comDayCqWcmMsmImplServletsAuditLogServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, auditlogservletDefaultEventsCount: Option[Integer] = None, auditlogservletDefaultPath: Option[String] = None): Option[ComDayCqWcmMsmImplServletsAuditLogServletInfo] = {
    val await = Try(Await.result(comDayCqWcmMsmImplServletsAuditLogServletAsync(post, apply, delete, action, location, propertylist, auditlogservletDefaultEventsCount, auditlogservletDefaultPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param auditlogservletDefaultEventsCount  (optional)
   * @param auditlogservletDefaultPath  (optional)
   * @return Future(ComDayCqWcmMsmImplServletsAuditLogServletInfo)
   */
  def comDayCqWcmMsmImplServletsAuditLogServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, auditlogservletDefaultEventsCount: Option[Integer] = None, auditlogservletDefaultPath: Option[String] = None): Future[ComDayCqWcmMsmImplServletsAuditLogServletInfo] = {
      helper.comDayCqWcmMsmImplServletsAuditLogServlet(post, apply, delete, action, location, propertylist, auditlogservletDefaultEventsCount, auditlogservletDefaultPath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param emailFrom  (optional)
   * @return ComDayCqWcmNotificationEmailImplEmailChannelInfo
   */
  def comDayCqWcmNotificationEmailImplEmailChannel(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, emailFrom: Option[String] = None): Option[ComDayCqWcmNotificationEmailImplEmailChannelInfo] = {
    val await = Try(Await.result(comDayCqWcmNotificationEmailImplEmailChannelAsync(post, apply, delete, action, location, propertylist, emailFrom), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param emailFrom  (optional)
   * @return Future(ComDayCqWcmNotificationEmailImplEmailChannelInfo)
   */
  def comDayCqWcmNotificationEmailImplEmailChannelAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, emailFrom: Option[String] = None): Future[ComDayCqWcmNotificationEmailImplEmailChannelInfo] = {
      helper.comDayCqWcmNotificationEmailImplEmailChannel(post, apply, delete, action, location, propertylist, emailFrom)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @return ComDayCqWcmNotificationImplNotificationManagerImplInfo
   */
  def comDayCqWcmNotificationImplNotificationManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[List[String]] = None): Option[ComDayCqWcmNotificationImplNotificationManagerImplInfo] = {
    val await = Try(Await.result(comDayCqWcmNotificationImplNotificationManagerImplAsync(post, apply, delete, action, location, propertylist, eventTopics), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventTopics  (optional)
   * @return Future(ComDayCqWcmNotificationImplNotificationManagerImplInfo)
   */
  def comDayCqWcmNotificationImplNotificationManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventTopics: Option[List[String]] = None): Future[ComDayCqWcmNotificationImplNotificationManagerImplInfo] = {
      helper.comDayCqWcmNotificationImplNotificationManagerImpl(post, apply, delete, action, location, propertylist, eventTopics)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comDayCqWcmScriptingBvpScriptEngines  (optional)
   * @return ComDayCqWcmScriptingImplBVPManagerInfo
   */
  def comDayCqWcmScriptingImplBVPManager(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comDayCqWcmScriptingBvpScriptEngines: Option[List[String]] = None): Option[ComDayCqWcmScriptingImplBVPManagerInfo] = {
    val await = Try(Await.result(comDayCqWcmScriptingImplBVPManagerAsync(post, apply, delete, action, location, propertylist, comDayCqWcmScriptingBvpScriptEngines), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param comDayCqWcmScriptingBvpScriptEngines  (optional)
   * @return Future(ComDayCqWcmScriptingImplBVPManagerInfo)
   */
  def comDayCqWcmScriptingImplBVPManagerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, comDayCqWcmScriptingBvpScriptEngines: Option[List[String]] = None): Future[ComDayCqWcmScriptingImplBVPManagerInfo] = {
      helper.comDayCqWcmScriptingImplBVPManager(post, apply, delete, action, location, propertylist, comDayCqWcmScriptingBvpScriptEngines)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmUndoEnabled  (optional)
   * @param cqWcmUndoPath  (optional)
   * @param cqWcmUndoValidity  (optional)
   * @param cqWcmUndoSteps  (optional)
   * @param cqWcmUndoPersistence  (optional)
   * @param cqWcmUndoPersistenceMode  (optional)
   * @param cqWcmUndoMarkermode  (optional)
   * @param cqWcmUndoWhitelist  (optional)
   * @param cqWcmUndoBlacklist  (optional)
   * @return ComDayCqWcmUndoUndoConfigInfo
   */
  def comDayCqWcmUndoUndoConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmUndoEnabled: Option[Boolean] = None, cqWcmUndoPath: Option[String] = None, cqWcmUndoValidity: Option[Integer] = None, cqWcmUndoSteps: Option[Integer] = None, cqWcmUndoPersistence: Option[String] = None, cqWcmUndoPersistenceMode: Option[Boolean] = None, cqWcmUndoMarkermode: Option[String] = None, cqWcmUndoWhitelist: Option[List[String]] = None, cqWcmUndoBlacklist: Option[List[String]] = None): Option[ComDayCqWcmUndoUndoConfigInfo] = {
    val await = Try(Await.result(comDayCqWcmUndoUndoConfigAsync(post, apply, delete, action, location, propertylist, cqWcmUndoEnabled, cqWcmUndoPath, cqWcmUndoValidity, cqWcmUndoSteps, cqWcmUndoPersistence, cqWcmUndoPersistenceMode, cqWcmUndoMarkermode, cqWcmUndoWhitelist, cqWcmUndoBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cqWcmUndoEnabled  (optional)
   * @param cqWcmUndoPath  (optional)
   * @param cqWcmUndoValidity  (optional)
   * @param cqWcmUndoSteps  (optional)
   * @param cqWcmUndoPersistence  (optional)
   * @param cqWcmUndoPersistenceMode  (optional)
   * @param cqWcmUndoMarkermode  (optional)
   * @param cqWcmUndoWhitelist  (optional)
   * @param cqWcmUndoBlacklist  (optional)
   * @return Future(ComDayCqWcmUndoUndoConfigInfo)
   */
  def comDayCqWcmUndoUndoConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cqWcmUndoEnabled: Option[Boolean] = None, cqWcmUndoPath: Option[String] = None, cqWcmUndoValidity: Option[Integer] = None, cqWcmUndoSteps: Option[Integer] = None, cqWcmUndoPersistence: Option[String] = None, cqWcmUndoPersistenceMode: Option[Boolean] = None, cqWcmUndoMarkermode: Option[String] = None, cqWcmUndoWhitelist: Option[List[String]] = None, cqWcmUndoBlacklist: Option[List[String]] = None): Future[ComDayCqWcmUndoUndoConfigInfo] = {
      helper.comDayCqWcmUndoUndoConfig(post, apply, delete, action, location, propertylist, cqWcmUndoEnabled, cqWcmUndoPath, cqWcmUndoValidity, cqWcmUndoSteps, cqWcmUndoPersistence, cqWcmUndoPersistenceMode, cqWcmUndoMarkermode, cqWcmUndoWhitelist, cqWcmUndoBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param flushAgents  (optional)
   * @return ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo
   */
  def comDayCqWcmWebservicesupportImplReplicationEventListener(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, flushAgents: Option[List[String]] = None): Option[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo] = {
    val await = Try(Await.result(comDayCqWcmWebservicesupportImplReplicationEventListenerAsync(post, apply, delete, action, location, propertylist, flushAgents), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param flushAgents  (optional)
   * @return Future(ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo)
   */
  def comDayCqWcmWebservicesupportImplReplicationEventListenerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, flushAgents: Option[List[String]] = None): Future[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo] = {
      helper.comDayCqWcmWebservicesupportImplReplicationEventListener(post, apply, delete, action, location, propertylist, flushAgents)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param minThreadPoolSize  (optional)
   * @param maxThreadPoolSize  (optional)
   * @param cqWcmWorkflowTerminateOnActivate  (optional)
   * @param cqWcmWorklfowTerminateExclusionList  (optional)
   * @return ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo
   */
  def comDayCqWcmWorkflowImplWcmWorkflowServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, minThreadPoolSize: Option[Integer] = None, maxThreadPoolSize: Option[Integer] = None, cqWcmWorkflowTerminateOnActivate: Option[Boolean] = None, cqWcmWorklfowTerminateExclusionList: Option[List[String]] = None): Option[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo] = {
    val await = Try(Await.result(comDayCqWcmWorkflowImplWcmWorkflowServiceImplAsync(post, apply, delete, action, location, propertylist, eventFilter, minThreadPoolSize, maxThreadPoolSize, cqWcmWorkflowTerminateOnActivate, cqWcmWorklfowTerminateExclusionList), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param eventFilter  (optional)
   * @param minThreadPoolSize  (optional)
   * @param maxThreadPoolSize  (optional)
   * @param cqWcmWorkflowTerminateOnActivate  (optional)
   * @param cqWcmWorklfowTerminateExclusionList  (optional)
   * @return Future(ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo)
   */
  def comDayCqWcmWorkflowImplWcmWorkflowServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, eventFilter: Option[String] = None, minThreadPoolSize: Option[Integer] = None, maxThreadPoolSize: Option[Integer] = None, cqWcmWorkflowTerminateOnActivate: Option[Boolean] = None, cqWcmWorklfowTerminateExclusionList: Option[List[String]] = None): Future[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo] = {
      helper.comDayCqWcmWorkflowImplWcmWorkflowServiceImpl(post, apply, delete, action, location, propertylist, eventFilter, minThreadPoolSize, maxThreadPoolSize, cqWcmWorkflowTerminateOnActivate, cqWcmWorklfowTerminateExclusionList)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param workflowpackageinfoproviderFilter  (optional)
   * @param workflowpackageinfoproviderFilterRootpath  (optional)
   * @return ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo
   */
  def comDayCqWcmWorkflowImplWorkflowPackageInfoProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, workflowpackageinfoproviderFilter: Option[List[String]] = None, workflowpackageinfoproviderFilterRootpath: Option[String] = None): Option[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo] = {
    val await = Try(Await.result(comDayCqWcmWorkflowImplWorkflowPackageInfoProviderAsync(post, apply, delete, action, location, propertylist, workflowpackageinfoproviderFilter, workflowpackageinfoproviderFilterRootpath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param workflowpackageinfoproviderFilter  (optional)
   * @param workflowpackageinfoproviderFilterRootpath  (optional)
   * @return Future(ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo)
   */
  def comDayCqWcmWorkflowImplWorkflowPackageInfoProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, workflowpackageinfoproviderFilter: Option[List[String]] = None, workflowpackageinfoproviderFilterRootpath: Option[String] = None): Future[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo] = {
      helper.comDayCqWcmWorkflowImplWorkflowPackageInfoProvider(post, apply, delete, action, location, propertylist, workflowpackageinfoproviderFilter, workflowpackageinfoproviderFilterRootpath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param htmllibmanagerClientmanager  (optional)
   * @param htmllibmanagerDebug  (optional)
   * @param htmllibmanagerDebugConsole  (optional)
   * @param htmllibmanagerDebugInitJs  (optional)
   * @param htmllibmanagerDefaultthemename  (optional)
   * @param htmllibmanagerDefaultuserthemename  (optional)
   * @param htmllibmanagerFirebuglitePath  (optional)
   * @param htmllibmanagerForceCQUrlInfo  (optional)
   * @param htmllibmanagerGzip  (optional)
   * @param htmllibmanagerMaxage  (optional)
   * @param htmllibmanagerMaxDataUriSize  (optional)
   * @param htmllibmanagerMinify  (optional)
   * @param htmllibmanagerPathList  (optional)
   * @param htmllibmanagerTiming  (optional)
   * @return ComDayCqWidgetImplHtmlLibraryManagerImplInfo
   */
  def comDayCqWidgetImplHtmlLibraryManagerImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, htmllibmanagerClientmanager: Option[String] = None, htmllibmanagerDebug: Option[Boolean] = None, htmllibmanagerDebugConsole: Option[Boolean] = None, htmllibmanagerDebugInitJs: Option[String] = None, htmllibmanagerDefaultthemename: Option[String] = None, htmllibmanagerDefaultuserthemename: Option[String] = None, htmllibmanagerFirebuglitePath: Option[String] = None, htmllibmanagerForceCQUrlInfo: Option[Boolean] = None, htmllibmanagerGzip: Option[Boolean] = None, htmllibmanagerMaxage: Option[Integer] = None, htmllibmanagerMaxDataUriSize: Option[Integer] = None, htmllibmanagerMinify: Option[Boolean] = None, htmllibmanagerPathList: Option[List[String]] = None, htmllibmanagerTiming: Option[Boolean] = None): Option[ComDayCqWidgetImplHtmlLibraryManagerImplInfo] = {
    val await = Try(Await.result(comDayCqWidgetImplHtmlLibraryManagerImplAsync(post, apply, delete, action, location, propertylist, htmllibmanagerClientmanager, htmllibmanagerDebug, htmllibmanagerDebugConsole, htmllibmanagerDebugInitJs, htmllibmanagerDefaultthemename, htmllibmanagerDefaultuserthemename, htmllibmanagerFirebuglitePath, htmllibmanagerForceCQUrlInfo, htmllibmanagerGzip, htmllibmanagerMaxage, htmllibmanagerMaxDataUriSize, htmllibmanagerMinify, htmllibmanagerPathList, htmllibmanagerTiming), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param htmllibmanagerClientmanager  (optional)
   * @param htmllibmanagerDebug  (optional)
   * @param htmllibmanagerDebugConsole  (optional)
   * @param htmllibmanagerDebugInitJs  (optional)
   * @param htmllibmanagerDefaultthemename  (optional)
   * @param htmllibmanagerDefaultuserthemename  (optional)
   * @param htmllibmanagerFirebuglitePath  (optional)
   * @param htmllibmanagerForceCQUrlInfo  (optional)
   * @param htmllibmanagerGzip  (optional)
   * @param htmllibmanagerMaxage  (optional)
   * @param htmllibmanagerMaxDataUriSize  (optional)
   * @param htmllibmanagerMinify  (optional)
   * @param htmllibmanagerPathList  (optional)
   * @param htmllibmanagerTiming  (optional)
   * @return Future(ComDayCqWidgetImplHtmlLibraryManagerImplInfo)
   */
  def comDayCqWidgetImplHtmlLibraryManagerImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, htmllibmanagerClientmanager: Option[String] = None, htmllibmanagerDebug: Option[Boolean] = None, htmllibmanagerDebugConsole: Option[Boolean] = None, htmllibmanagerDebugInitJs: Option[String] = None, htmllibmanagerDefaultthemename: Option[String] = None, htmllibmanagerDefaultuserthemename: Option[String] = None, htmllibmanagerFirebuglitePath: Option[String] = None, htmllibmanagerForceCQUrlInfo: Option[Boolean] = None, htmllibmanagerGzip: Option[Boolean] = None, htmllibmanagerMaxage: Option[Integer] = None, htmllibmanagerMaxDataUriSize: Option[Integer] = None, htmllibmanagerMinify: Option[Boolean] = None, htmllibmanagerPathList: Option[List[String]] = None, htmllibmanagerTiming: Option[Boolean] = None): Future[ComDayCqWidgetImplHtmlLibraryManagerImplInfo] = {
      helper.comDayCqWidgetImplHtmlLibraryManagerImpl(post, apply, delete, action, location, propertylist, htmllibmanagerClientmanager, htmllibmanagerDebug, htmllibmanagerDebugConsole, htmllibmanagerDebugInitJs, htmllibmanagerDefaultthemename, htmllibmanagerDefaultuserthemename, htmllibmanagerFirebuglitePath, htmllibmanagerForceCQUrlInfo, htmllibmanagerGzip, htmllibmanagerMaxage, htmllibmanagerMaxDataUriSize, htmllibmanagerMinify, htmllibmanagerPathList, htmllibmanagerTiming)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param extendableWidgets  (optional)
   * @param widgetextensionproviderDebug  (optional)
   * @return ComDayCqWidgetImplWidgetExtensionProviderImplInfo
   */
  def comDayCqWidgetImplWidgetExtensionProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, extendableWidgets: Option[List[String]] = None, widgetextensionproviderDebug: Option[Boolean] = None): Option[ComDayCqWidgetImplWidgetExtensionProviderImplInfo] = {
    val await = Try(Await.result(comDayCqWidgetImplWidgetExtensionProviderImplAsync(post, apply, delete, action, location, propertylist, extendableWidgets, widgetextensionproviderDebug), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param extendableWidgets  (optional)
   * @param widgetextensionproviderDebug  (optional)
   * @return Future(ComDayCqWidgetImplWidgetExtensionProviderImplInfo)
   */
  def comDayCqWidgetImplWidgetExtensionProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, extendableWidgets: Option[List[String]] = None, widgetextensionproviderDebug: Option[Boolean] = None): Future[ComDayCqWidgetImplWidgetExtensionProviderImplInfo] = {
      helper.comDayCqWidgetImplWidgetExtensionProviderImpl(post, apply, delete, action, location, propertylist, extendableWidgets, widgetextensionproviderDebug)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fromAddress  (optional)
   * @param hostPrefix  (optional)
   * @param notifyOnabort  (optional)
   * @param notifyOncomplete  (optional)
   * @param notifyOncontainercomplete  (optional)
   * @param notifyUseronly  (optional)
   * @return ComDayCqWorkflowImplEmailEMailNotificationServiceInfo
   */
  def comDayCqWorkflowImplEmailEMailNotificationService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fromAddress: Option[String] = None, hostPrefix: Option[String] = None, notifyOnabort: Option[Boolean] = None, notifyOncomplete: Option[Boolean] = None, notifyOncontainercomplete: Option[Boolean] = None, notifyUseronly: Option[Boolean] = None): Option[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo] = {
    val await = Try(Await.result(comDayCqWorkflowImplEmailEMailNotificationServiceAsync(post, apply, delete, action, location, propertylist, fromAddress, hostPrefix, notifyOnabort, notifyOncomplete, notifyOncontainercomplete, notifyUseronly), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param fromAddress  (optional)
   * @param hostPrefix  (optional)
   * @param notifyOnabort  (optional)
   * @param notifyOncomplete  (optional)
   * @param notifyOncontainercomplete  (optional)
   * @param notifyUseronly  (optional)
   * @return Future(ComDayCqWorkflowImplEmailEMailNotificationServiceInfo)
   */
  def comDayCqWorkflowImplEmailEMailNotificationServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, fromAddress: Option[String] = None, hostPrefix: Option[String] = None, notifyOnabort: Option[Boolean] = None, notifyOncomplete: Option[Boolean] = None, notifyOncontainercomplete: Option[Boolean] = None, notifyUseronly: Option[Boolean] = None): Future[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo] = {
      helper.comDayCqWorkflowImplEmailEMailNotificationService(post, apply, delete, action, location, propertylist, fromAddress, hostPrefix, notifyOnabort, notifyOncomplete, notifyOncontainercomplete, notifyUseronly)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param notifyOnupdate  (optional)
   * @param notifyOncomplete  (optional)
   * @return ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo
   */
  def comDayCqWorkflowImplEmailTaskEMailNotificationService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, notifyOnupdate: Option[Boolean] = None, notifyOncomplete: Option[Boolean] = None): Option[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo] = {
    val await = Try(Await.result(comDayCqWorkflowImplEmailTaskEMailNotificationServiceAsync(post, apply, delete, action, location, propertylist, notifyOnupdate, notifyOncomplete), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param notifyOnupdate  (optional)
   * @param notifyOncomplete  (optional)
   * @return Future(ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo)
   */
  def comDayCqWorkflowImplEmailTaskEMailNotificationServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, notifyOnupdate: Option[Boolean] = None, notifyOncomplete: Option[Boolean] = None): Future[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo] = {
      helper.comDayCqWorkflowImplEmailTaskEMailNotificationService(post, apply, delete, action, location, propertylist, notifyOnupdate, notifyOncomplete)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param tokenRequiredAttr  (optional)
   * @param tokenAlternateUrl  (optional)
   * @param tokenEncapsulated  (optional)
   * @param skipTokenRefresh  (optional)
   * @return ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo
   */
  def comDayCrxSecurityTokenImplImplTokenAuthenticationHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, tokenRequiredAttr: Option[String] = None, tokenAlternateUrl: Option[String] = None, tokenEncapsulated: Option[Boolean] = None, skipTokenRefresh: Option[List[String]] = None): Option[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo] = {
    val await = Try(Await.result(comDayCrxSecurityTokenImplImplTokenAuthenticationHandlerAsync(post, apply, delete, action, location, propertylist, `path`, tokenRequiredAttr, tokenAlternateUrl, tokenEncapsulated, skipTokenRefresh), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param tokenRequiredAttr  (optional)
   * @param tokenAlternateUrl  (optional)
   * @param tokenEncapsulated  (optional)
   * @param skipTokenRefresh  (optional)
   * @return Future(ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo)
   */
  def comDayCrxSecurityTokenImplImplTokenAuthenticationHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, tokenRequiredAttr: Option[String] = None, tokenAlternateUrl: Option[String] = None, tokenEncapsulated: Option[Boolean] = None, skipTokenRefresh: Option[List[String]] = None): Future[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo] = {
      helper.comDayCrxSecurityTokenImplImplTokenAuthenticationHandler(post, apply, delete, action, location, propertylist, `path`, tokenRequiredAttr, tokenAlternateUrl, tokenEncapsulated, skipTokenRefresh)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enableTokenCleanupTask  (optional)
   * @param schedulerExpression  (optional)
   * @param batchSize  (optional)
   * @return ComDayCrxSecurityTokenImplTokenCleanupTaskInfo
   */
  def comDayCrxSecurityTokenImplTokenCleanupTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enableTokenCleanupTask: Option[Boolean] = None, schedulerExpression: Option[String] = None, batchSize: Option[Integer] = None): Option[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo] = {
    val await = Try(Await.result(comDayCrxSecurityTokenImplTokenCleanupTaskAsync(post, apply, delete, action, location, propertylist, enableTokenCleanupTask, schedulerExpression, batchSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enableTokenCleanupTask  (optional)
   * @param schedulerExpression  (optional)
   * @param batchSize  (optional)
   * @return Future(ComDayCrxSecurityTokenImplTokenCleanupTaskInfo)
   */
  def comDayCrxSecurityTokenImplTokenCleanupTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enableTokenCleanupTask: Option[Boolean] = None, schedulerExpression: Option[String] = None, batchSize: Option[Integer] = None): Future[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo] = {
      helper.comDayCrxSecurityTokenImplTokenCleanupTask(post, apply, delete, action, location, propertylist, enableTokenCleanupTask, schedulerExpression, batchSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param supportedLocales  (optional)
   * @param localizableProperties  (optional)
   * @return GuideLocalizationServiceInfo
   */
  def guideLocalizationService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, supportedLocales: Option[List[String]] = None, localizableProperties: Option[List[String]] = None): Option[GuideLocalizationServiceInfo] = {
    val await = Try(Await.result(guideLocalizationServiceAsync(post, apply, delete, action, location, propertylist, supportedLocales, localizableProperties), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param supportedLocales  (optional)
   * @param localizableProperties  (optional)
   * @return Future(GuideLocalizationServiceInfo)
   */
  def guideLocalizationServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, supportedLocales: Option[List[String]] = None, localizableProperties: Option[List[String]] = None): Future[GuideLocalizationServiceInfo] = {
      helper.guideLocalizationService(post, apply, delete, action, location, propertylist, supportedLocales, localizableProperties)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priority  (optional)
   * @return MessagingUserComponentFactoryInfo
   */
  def messagingUserComponentFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priority: Option[Integer] = None): Option[MessagingUserComponentFactoryInfo] = {
    val await = Try(Await.result(messagingUserComponentFactoryAsync(post, apply, delete, action, location, propertylist, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param priority  (optional)
   * @return Future(MessagingUserComponentFactoryInfo)
   */
  def messagingUserComponentFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, priority: Option[Integer] = None): Future[MessagingUserComponentFactoryInfo] = {
      helper.messagingUserComponentFactory(post, apply, delete, action, location, propertylist, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param attributeChangeNotificationEnabled  (optional)
   * @return OrgApacheAriesJmxFrameworkStateConfigInfo
   */
  def orgApacheAriesJmxFrameworkStateConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, attributeChangeNotificationEnabled: Option[Boolean] = None): Option[OrgApacheAriesJmxFrameworkStateConfigInfo] = {
    val await = Try(Await.result(orgApacheAriesJmxFrameworkStateConfigAsync(post, apply, delete, action, location, propertylist, attributeChangeNotificationEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param attributeChangeNotificationEnabled  (optional)
   * @return Future(OrgApacheAriesJmxFrameworkStateConfigInfo)
   */
  def orgApacheAriesJmxFrameworkStateConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, attributeChangeNotificationEnabled: Option[Boolean] = None): Future[OrgApacheAriesJmxFrameworkStateConfigInfo] = {
      helper.orgApacheAriesJmxFrameworkStateConfig(post, apply, delete, action, location, propertylist, attributeChangeNotificationEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheFelixEventadminThreadPoolSize  (optional)
   * @param orgApacheFelixEventadminAsyncToSyncThreadRatio  (optional)
   * @param orgApacheFelixEventadminTimeout  (optional)
   * @param orgApacheFelixEventadminRequireTopic  (optional)
   * @param orgApacheFelixEventadminIgnoreTimeout  (optional)
   * @param orgApacheFelixEventadminIgnoreTopic  (optional)
   * @return OrgApacheFelixEventadminImplEventAdminInfo
   */
  def orgApacheFelixEventadminImplEventAdmin(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheFelixEventadminThreadPoolSize: Option[Integer] = None, orgApacheFelixEventadminAsyncToSyncThreadRatio: Option[Number] = None, orgApacheFelixEventadminTimeout: Option[Integer] = None, orgApacheFelixEventadminRequireTopic: Option[Boolean] = None, orgApacheFelixEventadminIgnoreTimeout: Option[List[String]] = None, orgApacheFelixEventadminIgnoreTopic: Option[List[String]] = None): Option[OrgApacheFelixEventadminImplEventAdminInfo] = {
    val await = Try(Await.result(orgApacheFelixEventadminImplEventAdminAsync(post, apply, delete, action, location, propertylist, orgApacheFelixEventadminThreadPoolSize, orgApacheFelixEventadminAsyncToSyncThreadRatio, orgApacheFelixEventadminTimeout, orgApacheFelixEventadminRequireTopic, orgApacheFelixEventadminIgnoreTimeout, orgApacheFelixEventadminIgnoreTopic), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheFelixEventadminThreadPoolSize  (optional)
   * @param orgApacheFelixEventadminAsyncToSyncThreadRatio  (optional)
   * @param orgApacheFelixEventadminTimeout  (optional)
   * @param orgApacheFelixEventadminRequireTopic  (optional)
   * @param orgApacheFelixEventadminIgnoreTimeout  (optional)
   * @param orgApacheFelixEventadminIgnoreTopic  (optional)
   * @return Future(OrgApacheFelixEventadminImplEventAdminInfo)
   */
  def orgApacheFelixEventadminImplEventAdminAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheFelixEventadminThreadPoolSize: Option[Integer] = None, orgApacheFelixEventadminAsyncToSyncThreadRatio: Option[Number] = None, orgApacheFelixEventadminTimeout: Option[Integer] = None, orgApacheFelixEventadminRequireTopic: Option[Boolean] = None, orgApacheFelixEventadminIgnoreTimeout: Option[List[String]] = None, orgApacheFelixEventadminIgnoreTopic: Option[List[String]] = None): Future[OrgApacheFelixEventadminImplEventAdminInfo] = {
      helper.orgApacheFelixEventadminImplEventAdmin(post, apply, delete, action, location, propertylist, orgApacheFelixEventadminThreadPoolSize, orgApacheFelixEventadminAsyncToSyncThreadRatio, orgApacheFelixEventadminTimeout, orgApacheFelixEventadminRequireTopic, orgApacheFelixEventadminIgnoreTimeout, orgApacheFelixEventadminIgnoreTopic)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheFelixHttpHost  (optional)
   * @param orgApacheFelixHttpEnable  (optional)
   * @param orgOsgiServiceHttpPort  (optional)
   * @param orgApacheFelixHttpTimeout  (optional)
   * @param orgApacheFelixHttpsEnable  (optional)
   * @param orgOsgiServiceHttpPortSecure  (optional)
   * @param orgApacheFelixHttpsKeystore  (optional)
   * @param orgApacheFelixHttpsKeystorePassword  (optional)
   * @param orgApacheFelixHttpsKeystoreKeyPassword  (optional)
   * @param orgApacheFelixHttpsTruststore  (optional)
   * @param orgApacheFelixHttpsTruststorePassword  (optional)
   * @param orgApacheFelixHttpsClientcertificate  (optional)
   * @param orgApacheFelixHttpContextPath  (optional)
   * @param orgApacheFelixHttpMbeans  (optional)
   * @param orgApacheFelixHttpSessionTimeout  (optional)
   * @param orgApacheFelixHttpJettyThreadpoolMax  (optional)
   * @param orgApacheFelixHttpJettyAcceptors  (optional)
   * @param orgApacheFelixHttpJettySelectors  (optional)
   * @param orgApacheFelixHttpJettyHeaderBufferSize  (optional)
   * @param orgApacheFelixHttpJettyRequestBufferSize  (optional)
   * @param orgApacheFelixHttpJettyResponseBufferSize  (optional)
   * @param orgApacheFelixHttpJettyMaxFormSize  (optional)
   * @param orgApacheFelixHttpPathExclusions  (optional)
   * @param orgApacheFelixHttpsJettyCiphersuitesExcluded  (optional)
   * @param orgApacheFelixHttpsJettyCiphersuitesIncluded  (optional)
   * @param orgApacheFelixHttpJettySendServerHeader  (optional)
   * @param orgApacheFelixHttpsJettyProtocolsIncluded  (optional)
   * @param orgApacheFelixHttpsJettyProtocolsExcluded  (optional)
   * @param orgApacheFelixProxyLoadBalancerConnectionEnable  (optional)
   * @param orgApacheFelixHttpsJettyRenegotiateAllowed  (optional)
   * @param orgApacheFelixHttpsJettySessionCookieHttpOnly  (optional)
   * @param orgApacheFelixHttpsJettySessionCookieSecure  (optional)
   * @param orgEclipseJettyServletSessionIdPathParameterName  (optional)
   * @param orgEclipseJettyServletCheckingRemoteSessionIdEncoding  (optional)
   * @param orgEclipseJettyServletSessionCookie  (optional)
   * @param orgEclipseJettyServletSessionDomain  (optional)
   * @param orgEclipseJettyServletSessionPath  (optional)
   * @param orgEclipseJettyServletMaxAge  (optional)
   * @param orgApacheFelixHttpName  (optional)
   * @param orgApacheFelixJettyGziphandlerEnable  (optional)
   * @param orgApacheFelixJettyGzipMinGzipSize  (optional)
   * @param orgApacheFelixJettyGzipCompressionLevel  (optional)
   * @param orgApacheFelixJettyGzipInflateBufferSize  (optional)
   * @param orgApacheFelixJettyGzipSyncFlush  (optional)
   * @param orgApacheFelixJettyGzipExcludedUserAgents  (optional)
   * @param orgApacheFelixJettyGzipIncludedMethods  (optional)
   * @param orgApacheFelixJettyGzipExcludedMethods  (optional)
   * @param orgApacheFelixJettyGzipIncludedPaths  (optional)
   * @param orgApacheFelixJettyGzipExcludedPaths  (optional)
   * @param orgApacheFelixJettyGzipIncludedMimeTypes  (optional)
   * @param orgApacheFelixJettyGzipExcludedMimeTypes  (optional)
   * @param orgApacheFelixHttpSessionInvalidate  (optional)
   * @param orgApacheFelixHttpSessionUniqueid  (optional)
   * @return OrgApacheFelixHttpInfo
   */
  def orgApacheFelixHttp(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheFelixHttpHost: Option[String] = None, orgApacheFelixHttpEnable: Option[Boolean] = None, orgOsgiServiceHttpPort: Option[Integer] = None, orgApacheFelixHttpTimeout: Option[Integer] = None, orgApacheFelixHttpsEnable: Option[Boolean] = None, orgOsgiServiceHttpPortSecure: Option[Integer] = None, orgApacheFelixHttpsKeystore: Option[String] = None, orgApacheFelixHttpsKeystorePassword: Option[String] = None, orgApacheFelixHttpsKeystoreKeyPassword: Option[String] = None, orgApacheFelixHttpsTruststore: Option[String] = None, orgApacheFelixHttpsTruststorePassword: Option[String] = None, orgApacheFelixHttpsClientcertificate: Option[String] = None, orgApacheFelixHttpContextPath: Option[String] = None, orgApacheFelixHttpMbeans: Option[Boolean] = None, orgApacheFelixHttpSessionTimeout: Option[Integer] = None, orgApacheFelixHttpJettyThreadpoolMax: Option[Integer] = None, orgApacheFelixHttpJettyAcceptors: Option[Integer] = None, orgApacheFelixHttpJettySelectors: Option[Integer] = None, orgApacheFelixHttpJettyHeaderBufferSize: Option[Integer] = None, orgApacheFelixHttpJettyRequestBufferSize: Option[Integer] = None, orgApacheFelixHttpJettyResponseBufferSize: Option[Integer] = None, orgApacheFelixHttpJettyMaxFormSize: Option[Integer] = None, orgApacheFelixHttpPathExclusions: Option[List[String]] = None, orgApacheFelixHttpsJettyCiphersuitesExcluded: Option[List[String]] = None, orgApacheFelixHttpsJettyCiphersuitesIncluded: Option[List[String]] = None, orgApacheFelixHttpJettySendServerHeader: Option[Boolean] = None, orgApacheFelixHttpsJettyProtocolsIncluded: Option[List[String]] = None, orgApacheFelixHttpsJettyProtocolsExcluded: Option[List[String]] = None, orgApacheFelixProxyLoadBalancerConnectionEnable: Option[Boolean] = None, orgApacheFelixHttpsJettyRenegotiateAllowed: Option[Boolean] = None, orgApacheFelixHttpsJettySessionCookieHttpOnly: Option[Boolean] = None, orgApacheFelixHttpsJettySessionCookieSecure: Option[Boolean] = None, orgEclipseJettyServletSessionIdPathParameterName: Option[String] = None, orgEclipseJettyServletCheckingRemoteSessionIdEncoding: Option[Boolean] = None, orgEclipseJettyServletSessionCookie: Option[String] = None, orgEclipseJettyServletSessionDomain: Option[String] = None, orgEclipseJettyServletSessionPath: Option[String] = None, orgEclipseJettyServletMaxAge: Option[Integer] = None, orgApacheFelixHttpName: Option[String] = None, orgApacheFelixJettyGziphandlerEnable: Option[Boolean] = None, orgApacheFelixJettyGzipMinGzipSize: Option[Integer] = None, orgApacheFelixJettyGzipCompressionLevel: Option[Integer] = None, orgApacheFelixJettyGzipInflateBufferSize: Option[Integer] = None, orgApacheFelixJettyGzipSyncFlush: Option[Boolean] = None, orgApacheFelixJettyGzipExcludedUserAgents: Option[List[String]] = None, orgApacheFelixJettyGzipIncludedMethods: Option[List[String]] = None, orgApacheFelixJettyGzipExcludedMethods: Option[List[String]] = None, orgApacheFelixJettyGzipIncludedPaths: Option[List[String]] = None, orgApacheFelixJettyGzipExcludedPaths: Option[List[String]] = None, orgApacheFelixJettyGzipIncludedMimeTypes: Option[List[String]] = None, orgApacheFelixJettyGzipExcludedMimeTypes: Option[List[String]] = None, orgApacheFelixHttpSessionInvalidate: Option[Boolean] = None, orgApacheFelixHttpSessionUniqueid: Option[Boolean] = None): Option[OrgApacheFelixHttpInfo] = {
    val await = Try(Await.result(orgApacheFelixHttpAsync(post, apply, delete, action, location, propertylist, orgApacheFelixHttpHost, orgApacheFelixHttpEnable, orgOsgiServiceHttpPort, orgApacheFelixHttpTimeout, orgApacheFelixHttpsEnable, orgOsgiServiceHttpPortSecure, orgApacheFelixHttpsKeystore, orgApacheFelixHttpsKeystorePassword, orgApacheFelixHttpsKeystoreKeyPassword, orgApacheFelixHttpsTruststore, orgApacheFelixHttpsTruststorePassword, orgApacheFelixHttpsClientcertificate, orgApacheFelixHttpContextPath, orgApacheFelixHttpMbeans, orgApacheFelixHttpSessionTimeout, orgApacheFelixHttpJettyThreadpoolMax, orgApacheFelixHttpJettyAcceptors, orgApacheFelixHttpJettySelectors, orgApacheFelixHttpJettyHeaderBufferSize, orgApacheFelixHttpJettyRequestBufferSize, orgApacheFelixHttpJettyResponseBufferSize, orgApacheFelixHttpJettyMaxFormSize, orgApacheFelixHttpPathExclusions, orgApacheFelixHttpsJettyCiphersuitesExcluded, orgApacheFelixHttpsJettyCiphersuitesIncluded, orgApacheFelixHttpJettySendServerHeader, orgApacheFelixHttpsJettyProtocolsIncluded, orgApacheFelixHttpsJettyProtocolsExcluded, orgApacheFelixProxyLoadBalancerConnectionEnable, orgApacheFelixHttpsJettyRenegotiateAllowed, orgApacheFelixHttpsJettySessionCookieHttpOnly, orgApacheFelixHttpsJettySessionCookieSecure, orgEclipseJettyServletSessionIdPathParameterName, orgEclipseJettyServletCheckingRemoteSessionIdEncoding, orgEclipseJettyServletSessionCookie, orgEclipseJettyServletSessionDomain, orgEclipseJettyServletSessionPath, orgEclipseJettyServletMaxAge, orgApacheFelixHttpName, orgApacheFelixJettyGziphandlerEnable, orgApacheFelixJettyGzipMinGzipSize, orgApacheFelixJettyGzipCompressionLevel, orgApacheFelixJettyGzipInflateBufferSize, orgApacheFelixJettyGzipSyncFlush, orgApacheFelixJettyGzipExcludedUserAgents, orgApacheFelixJettyGzipIncludedMethods, orgApacheFelixJettyGzipExcludedMethods, orgApacheFelixJettyGzipIncludedPaths, orgApacheFelixJettyGzipExcludedPaths, orgApacheFelixJettyGzipIncludedMimeTypes, orgApacheFelixJettyGzipExcludedMimeTypes, orgApacheFelixHttpSessionInvalidate, orgApacheFelixHttpSessionUniqueid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheFelixHttpHost  (optional)
   * @param orgApacheFelixHttpEnable  (optional)
   * @param orgOsgiServiceHttpPort  (optional)
   * @param orgApacheFelixHttpTimeout  (optional)
   * @param orgApacheFelixHttpsEnable  (optional)
   * @param orgOsgiServiceHttpPortSecure  (optional)
   * @param orgApacheFelixHttpsKeystore  (optional)
   * @param orgApacheFelixHttpsKeystorePassword  (optional)
   * @param orgApacheFelixHttpsKeystoreKeyPassword  (optional)
   * @param orgApacheFelixHttpsTruststore  (optional)
   * @param orgApacheFelixHttpsTruststorePassword  (optional)
   * @param orgApacheFelixHttpsClientcertificate  (optional)
   * @param orgApacheFelixHttpContextPath  (optional)
   * @param orgApacheFelixHttpMbeans  (optional)
   * @param orgApacheFelixHttpSessionTimeout  (optional)
   * @param orgApacheFelixHttpJettyThreadpoolMax  (optional)
   * @param orgApacheFelixHttpJettyAcceptors  (optional)
   * @param orgApacheFelixHttpJettySelectors  (optional)
   * @param orgApacheFelixHttpJettyHeaderBufferSize  (optional)
   * @param orgApacheFelixHttpJettyRequestBufferSize  (optional)
   * @param orgApacheFelixHttpJettyResponseBufferSize  (optional)
   * @param orgApacheFelixHttpJettyMaxFormSize  (optional)
   * @param orgApacheFelixHttpPathExclusions  (optional)
   * @param orgApacheFelixHttpsJettyCiphersuitesExcluded  (optional)
   * @param orgApacheFelixHttpsJettyCiphersuitesIncluded  (optional)
   * @param orgApacheFelixHttpJettySendServerHeader  (optional)
   * @param orgApacheFelixHttpsJettyProtocolsIncluded  (optional)
   * @param orgApacheFelixHttpsJettyProtocolsExcluded  (optional)
   * @param orgApacheFelixProxyLoadBalancerConnectionEnable  (optional)
   * @param orgApacheFelixHttpsJettyRenegotiateAllowed  (optional)
   * @param orgApacheFelixHttpsJettySessionCookieHttpOnly  (optional)
   * @param orgApacheFelixHttpsJettySessionCookieSecure  (optional)
   * @param orgEclipseJettyServletSessionIdPathParameterName  (optional)
   * @param orgEclipseJettyServletCheckingRemoteSessionIdEncoding  (optional)
   * @param orgEclipseJettyServletSessionCookie  (optional)
   * @param orgEclipseJettyServletSessionDomain  (optional)
   * @param orgEclipseJettyServletSessionPath  (optional)
   * @param orgEclipseJettyServletMaxAge  (optional)
   * @param orgApacheFelixHttpName  (optional)
   * @param orgApacheFelixJettyGziphandlerEnable  (optional)
   * @param orgApacheFelixJettyGzipMinGzipSize  (optional)
   * @param orgApacheFelixJettyGzipCompressionLevel  (optional)
   * @param orgApacheFelixJettyGzipInflateBufferSize  (optional)
   * @param orgApacheFelixJettyGzipSyncFlush  (optional)
   * @param orgApacheFelixJettyGzipExcludedUserAgents  (optional)
   * @param orgApacheFelixJettyGzipIncludedMethods  (optional)
   * @param orgApacheFelixJettyGzipExcludedMethods  (optional)
   * @param orgApacheFelixJettyGzipIncludedPaths  (optional)
   * @param orgApacheFelixJettyGzipExcludedPaths  (optional)
   * @param orgApacheFelixJettyGzipIncludedMimeTypes  (optional)
   * @param orgApacheFelixJettyGzipExcludedMimeTypes  (optional)
   * @param orgApacheFelixHttpSessionInvalidate  (optional)
   * @param orgApacheFelixHttpSessionUniqueid  (optional)
   * @return Future(OrgApacheFelixHttpInfo)
   */
  def orgApacheFelixHttpAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheFelixHttpHost: Option[String] = None, orgApacheFelixHttpEnable: Option[Boolean] = None, orgOsgiServiceHttpPort: Option[Integer] = None, orgApacheFelixHttpTimeout: Option[Integer] = None, orgApacheFelixHttpsEnable: Option[Boolean] = None, orgOsgiServiceHttpPortSecure: Option[Integer] = None, orgApacheFelixHttpsKeystore: Option[String] = None, orgApacheFelixHttpsKeystorePassword: Option[String] = None, orgApacheFelixHttpsKeystoreKeyPassword: Option[String] = None, orgApacheFelixHttpsTruststore: Option[String] = None, orgApacheFelixHttpsTruststorePassword: Option[String] = None, orgApacheFelixHttpsClientcertificate: Option[String] = None, orgApacheFelixHttpContextPath: Option[String] = None, orgApacheFelixHttpMbeans: Option[Boolean] = None, orgApacheFelixHttpSessionTimeout: Option[Integer] = None, orgApacheFelixHttpJettyThreadpoolMax: Option[Integer] = None, orgApacheFelixHttpJettyAcceptors: Option[Integer] = None, orgApacheFelixHttpJettySelectors: Option[Integer] = None, orgApacheFelixHttpJettyHeaderBufferSize: Option[Integer] = None, orgApacheFelixHttpJettyRequestBufferSize: Option[Integer] = None, orgApacheFelixHttpJettyResponseBufferSize: Option[Integer] = None, orgApacheFelixHttpJettyMaxFormSize: Option[Integer] = None, orgApacheFelixHttpPathExclusions: Option[List[String]] = None, orgApacheFelixHttpsJettyCiphersuitesExcluded: Option[List[String]] = None, orgApacheFelixHttpsJettyCiphersuitesIncluded: Option[List[String]] = None, orgApacheFelixHttpJettySendServerHeader: Option[Boolean] = None, orgApacheFelixHttpsJettyProtocolsIncluded: Option[List[String]] = None, orgApacheFelixHttpsJettyProtocolsExcluded: Option[List[String]] = None, orgApacheFelixProxyLoadBalancerConnectionEnable: Option[Boolean] = None, orgApacheFelixHttpsJettyRenegotiateAllowed: Option[Boolean] = None, orgApacheFelixHttpsJettySessionCookieHttpOnly: Option[Boolean] = None, orgApacheFelixHttpsJettySessionCookieSecure: Option[Boolean] = None, orgEclipseJettyServletSessionIdPathParameterName: Option[String] = None, orgEclipseJettyServletCheckingRemoteSessionIdEncoding: Option[Boolean] = None, orgEclipseJettyServletSessionCookie: Option[String] = None, orgEclipseJettyServletSessionDomain: Option[String] = None, orgEclipseJettyServletSessionPath: Option[String] = None, orgEclipseJettyServletMaxAge: Option[Integer] = None, orgApacheFelixHttpName: Option[String] = None, orgApacheFelixJettyGziphandlerEnable: Option[Boolean] = None, orgApacheFelixJettyGzipMinGzipSize: Option[Integer] = None, orgApacheFelixJettyGzipCompressionLevel: Option[Integer] = None, orgApacheFelixJettyGzipInflateBufferSize: Option[Integer] = None, orgApacheFelixJettyGzipSyncFlush: Option[Boolean] = None, orgApacheFelixJettyGzipExcludedUserAgents: Option[List[String]] = None, orgApacheFelixJettyGzipIncludedMethods: Option[List[String]] = None, orgApacheFelixJettyGzipExcludedMethods: Option[List[String]] = None, orgApacheFelixJettyGzipIncludedPaths: Option[List[String]] = None, orgApacheFelixJettyGzipExcludedPaths: Option[List[String]] = None, orgApacheFelixJettyGzipIncludedMimeTypes: Option[List[String]] = None, orgApacheFelixJettyGzipExcludedMimeTypes: Option[List[String]] = None, orgApacheFelixHttpSessionInvalidate: Option[Boolean] = None, orgApacheFelixHttpSessionUniqueid: Option[Boolean] = None): Future[OrgApacheFelixHttpInfo] = {
      helper.orgApacheFelixHttp(post, apply, delete, action, location, propertylist, orgApacheFelixHttpHost, orgApacheFelixHttpEnable, orgOsgiServiceHttpPort, orgApacheFelixHttpTimeout, orgApacheFelixHttpsEnable, orgOsgiServiceHttpPortSecure, orgApacheFelixHttpsKeystore, orgApacheFelixHttpsKeystorePassword, orgApacheFelixHttpsKeystoreKeyPassword, orgApacheFelixHttpsTruststore, orgApacheFelixHttpsTruststorePassword, orgApacheFelixHttpsClientcertificate, orgApacheFelixHttpContextPath, orgApacheFelixHttpMbeans, orgApacheFelixHttpSessionTimeout, orgApacheFelixHttpJettyThreadpoolMax, orgApacheFelixHttpJettyAcceptors, orgApacheFelixHttpJettySelectors, orgApacheFelixHttpJettyHeaderBufferSize, orgApacheFelixHttpJettyRequestBufferSize, orgApacheFelixHttpJettyResponseBufferSize, orgApacheFelixHttpJettyMaxFormSize, orgApacheFelixHttpPathExclusions, orgApacheFelixHttpsJettyCiphersuitesExcluded, orgApacheFelixHttpsJettyCiphersuitesIncluded, orgApacheFelixHttpJettySendServerHeader, orgApacheFelixHttpsJettyProtocolsIncluded, orgApacheFelixHttpsJettyProtocolsExcluded, orgApacheFelixProxyLoadBalancerConnectionEnable, orgApacheFelixHttpsJettyRenegotiateAllowed, orgApacheFelixHttpsJettySessionCookieHttpOnly, orgApacheFelixHttpsJettySessionCookieSecure, orgEclipseJettyServletSessionIdPathParameterName, orgEclipseJettyServletCheckingRemoteSessionIdEncoding, orgEclipseJettyServletSessionCookie, orgEclipseJettyServletSessionDomain, orgEclipseJettyServletSessionPath, orgEclipseJettyServletMaxAge, orgApacheFelixHttpName, orgApacheFelixJettyGziphandlerEnable, orgApacheFelixJettyGzipMinGzipSize, orgApacheFelixJettyGzipCompressionLevel, orgApacheFelixJettyGzipInflateBufferSize, orgApacheFelixJettyGzipSyncFlush, orgApacheFelixJettyGzipExcludedUserAgents, orgApacheFelixJettyGzipIncludedMethods, orgApacheFelixJettyGzipExcludedMethods, orgApacheFelixJettyGzipIncludedPaths, orgApacheFelixJettyGzipExcludedPaths, orgApacheFelixJettyGzipIncludedMimeTypes, orgApacheFelixJettyGzipExcludedMimeTypes, orgApacheFelixHttpSessionInvalidate, orgApacheFelixHttpSessionUniqueid)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param sslForwardHeader  (optional)
   * @param sslForwardValue  (optional)
   * @param sslForwardCertHeader  (optional)
   * @param rewriteAbsoluteUrls  (optional)
   * @return OrgApacheFelixHttpSslfilterSslFilterInfo
   */
  def orgApacheFelixHttpSslfilterSslFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, sslForwardHeader: Option[String] = None, sslForwardValue: Option[String] = None, sslForwardCertHeader: Option[String] = None, rewriteAbsoluteUrls: Option[Boolean] = None): Option[OrgApacheFelixHttpSslfilterSslFilterInfo] = {
    val await = Try(Await.result(orgApacheFelixHttpSslfilterSslFilterAsync(post, apply, delete, action, location, propertylist, sslForwardHeader, sslForwardValue, sslForwardCertHeader, rewriteAbsoluteUrls), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param sslForwardHeader  (optional)
   * @param sslForwardValue  (optional)
   * @param sslForwardCertHeader  (optional)
   * @param rewriteAbsoluteUrls  (optional)
   * @return Future(OrgApacheFelixHttpSslfilterSslFilterInfo)
   */
  def orgApacheFelixHttpSslfilterSslFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, sslForwardHeader: Option[String] = None, sslForwardValue: Option[String] = None, sslForwardCertHeader: Option[String] = None, rewriteAbsoluteUrls: Option[Boolean] = None): Future[OrgApacheFelixHttpSslfilterSslFilterInfo] = {
      helper.orgApacheFelixHttpSslfilterSslFilter(post, apply, delete, action, location, propertylist, sslForwardHeader, sslForwardValue, sslForwardCertHeader, rewriteAbsoluteUrls)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jaasControlFlag  (optional)
   * @param jaasRanking  (optional)
   * @param jaasRealmName  (optional)
   * @param jaasClassname  (optional)
   * @param jaasOptions  (optional)
   * @return OrgApacheFelixJaasConfigurationFactoryInfo
   */
  def orgApacheFelixJaasConfigurationFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jaasControlFlag: Option[String] = None, jaasRanking: Option[Integer] = None, jaasRealmName: Option[String] = None, jaasClassname: Option[String] = None, jaasOptions: Option[List[String]] = None): Option[OrgApacheFelixJaasConfigurationFactoryInfo] = {
    val await = Try(Await.result(orgApacheFelixJaasConfigurationFactoryAsync(post, apply, delete, action, location, propertylist, jaasControlFlag, jaasRanking, jaasRealmName, jaasClassname, jaasOptions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jaasControlFlag  (optional)
   * @param jaasRanking  (optional)
   * @param jaasRealmName  (optional)
   * @param jaasClassname  (optional)
   * @param jaasOptions  (optional)
   * @return Future(OrgApacheFelixJaasConfigurationFactoryInfo)
   */
  def orgApacheFelixJaasConfigurationFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jaasControlFlag: Option[String] = None, jaasRanking: Option[Integer] = None, jaasRealmName: Option[String] = None, jaasClassname: Option[String] = None, jaasOptions: Option[List[String]] = None): Future[OrgApacheFelixJaasConfigurationFactoryInfo] = {
      helper.orgApacheFelixJaasConfigurationFactory(post, apply, delete, action, location, propertylist, jaasControlFlag, jaasRanking, jaasRealmName, jaasClassname, jaasOptions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jaasDefaultRealmName  (optional)
   * @param jaasConfigProviderName  (optional)
   * @param jaasGlobalConfigPolicy  (optional)
   * @return OrgApacheFelixJaasConfigurationSpiInfo
   */
  def orgApacheFelixJaasConfigurationSpi(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jaasDefaultRealmName: Option[String] = None, jaasConfigProviderName: Option[String] = None, jaasGlobalConfigPolicy: Option[String] = None): Option[OrgApacheFelixJaasConfigurationSpiInfo] = {
    val await = Try(Await.result(orgApacheFelixJaasConfigurationSpiAsync(post, apply, delete, action, location, propertylist, jaasDefaultRealmName, jaasConfigProviderName, jaasGlobalConfigPolicy), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jaasDefaultRealmName  (optional)
   * @param jaasConfigProviderName  (optional)
   * @param jaasGlobalConfigPolicy  (optional)
   * @return Future(OrgApacheFelixJaasConfigurationSpiInfo)
   */
  def orgApacheFelixJaasConfigurationSpiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jaasDefaultRealmName: Option[String] = None, jaasConfigProviderName: Option[String] = None, jaasGlobalConfigPolicy: Option[String] = None): Future[OrgApacheFelixJaasConfigurationSpiInfo] = {
      helper.orgApacheFelixJaasConfigurationSpi(post, apply, delete, action, location, propertylist, jaasDefaultRealmName, jaasConfigProviderName, jaasGlobalConfigPolicy)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param dsLoglevel  (optional)
   * @param dsFactoryEnabled  (optional)
   * @param dsDelayedKeepInstances  (optional)
   * @param dsLockTimeoutMilliseconds  (optional)
   * @param dsStopTimeoutMilliseconds  (optional)
   * @param dsGlobalExtender  (optional)
   * @return OrgApacheFelixScrScrServiceInfo
   */
  def orgApacheFelixScrScrService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, dsLoglevel: Option[Integer] = None, dsFactoryEnabled: Option[Boolean] = None, dsDelayedKeepInstances: Option[Boolean] = None, dsLockTimeoutMilliseconds: Option[Integer] = None, dsStopTimeoutMilliseconds: Option[Integer] = None, dsGlobalExtender: Option[Boolean] = None): Option[OrgApacheFelixScrScrServiceInfo] = {
    val await = Try(Await.result(orgApacheFelixScrScrServiceAsync(post, apply, delete, action, location, propertylist, dsLoglevel, dsFactoryEnabled, dsDelayedKeepInstances, dsLockTimeoutMilliseconds, dsStopTimeoutMilliseconds, dsGlobalExtender), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param dsLoglevel  (optional)
   * @param dsFactoryEnabled  (optional)
   * @param dsDelayedKeepInstances  (optional)
   * @param dsLockTimeoutMilliseconds  (optional)
   * @param dsStopTimeoutMilliseconds  (optional)
   * @param dsGlobalExtender  (optional)
   * @return Future(OrgApacheFelixScrScrServiceInfo)
   */
  def orgApacheFelixScrScrServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, dsLoglevel: Option[Integer] = None, dsFactoryEnabled: Option[Boolean] = None, dsDelayedKeepInstances: Option[Boolean] = None, dsLockTimeoutMilliseconds: Option[Integer] = None, dsStopTimeoutMilliseconds: Option[Integer] = None, dsGlobalExtender: Option[Boolean] = None): Future[OrgApacheFelixScrScrServiceInfo] = {
      helper.orgApacheFelixScrScrService(post, apply, delete, action, location, propertylist, dsLoglevel, dsFactoryEnabled, dsDelayedKeepInstances, dsLockTimeoutMilliseconds, dsStopTimeoutMilliseconds, dsGlobalExtender)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param componentsList  (optional)
   * @param `type`  (optional)
   * @return OrgApacheFelixSystemreadyImplComponentsCheckInfo
   */
  def orgApacheFelixSystemreadyImplComponentsCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, componentsList: Option[List[String]] = None, `type`: Option[String] = None): Option[OrgApacheFelixSystemreadyImplComponentsCheckInfo] = {
    val await = Try(Await.result(orgApacheFelixSystemreadyImplComponentsCheckAsync(post, apply, delete, action, location, propertylist, componentsList, `type`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param componentsList  (optional)
   * @param `type`  (optional)
   * @return Future(OrgApacheFelixSystemreadyImplComponentsCheckInfo)
   */
  def orgApacheFelixSystemreadyImplComponentsCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, componentsList: Option[List[String]] = None, `type`: Option[String] = None): Future[OrgApacheFelixSystemreadyImplComponentsCheckInfo] = {
      helper.orgApacheFelixSystemreadyImplComponentsCheck(post, apply, delete, action, location, propertylist, componentsList, `type`)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param timeout  (optional)
   * @param targetStartLevel  (optional)
   * @param targetStartLevelPropName  (optional)
   * @param `type`  (optional)
   * @return OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo
   */
  def orgApacheFelixSystemreadyImplFrameworkStartCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, timeout: Option[Integer] = None, targetStartLevel: Option[Integer] = None, targetStartLevelPropName: Option[String] = None, `type`: Option[String] = None): Option[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo] = {
    val await = Try(Await.result(orgApacheFelixSystemreadyImplFrameworkStartCheckAsync(post, apply, delete, action, location, propertylist, timeout, targetStartLevel, targetStartLevelPropName, `type`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param timeout  (optional)
   * @param targetStartLevel  (optional)
   * @param targetStartLevelPropName  (optional)
   * @param `type`  (optional)
   * @return Future(OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo)
   */
  def orgApacheFelixSystemreadyImplFrameworkStartCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, timeout: Option[Integer] = None, targetStartLevel: Option[Integer] = None, targetStartLevelPropName: Option[String] = None, `type`: Option[String] = None): Future[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo] = {
      helper.orgApacheFelixSystemreadyImplFrameworkStartCheck(post, apply, delete, action, location, propertylist, timeout, targetStartLevel, targetStartLevelPropName, `type`)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param servicesList  (optional)
   * @param `type`  (optional)
   * @return OrgApacheFelixSystemreadyImplServicesCheckInfo
   */
  def orgApacheFelixSystemreadyImplServicesCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, servicesList: Option[List[String]] = None, `type`: Option[String] = None): Option[OrgApacheFelixSystemreadyImplServicesCheckInfo] = {
    val await = Try(Await.result(orgApacheFelixSystemreadyImplServicesCheckAsync(post, apply, delete, action, location, propertylist, servicesList, `type`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param servicesList  (optional)
   * @param `type`  (optional)
   * @return Future(OrgApacheFelixSystemreadyImplServicesCheckInfo)
   */
  def orgApacheFelixSystemreadyImplServicesCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, servicesList: Option[List[String]] = None, `type`: Option[String] = None): Future[OrgApacheFelixSystemreadyImplServicesCheckInfo] = {
      helper.orgApacheFelixSystemreadyImplServicesCheck(post, apply, delete, action, location, propertylist, servicesList, `type`)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param osgiHttpWhiteboardServletPattern  (optional)
   * @param osgiHttpWhiteboardContextSelect  (optional)
   * @return OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo
   */
  def orgApacheFelixSystemreadyImplServletSystemAliveServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, osgiHttpWhiteboardServletPattern: Option[String] = None, osgiHttpWhiteboardContextSelect: Option[String] = None): Option[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo] = {
    val await = Try(Await.result(orgApacheFelixSystemreadyImplServletSystemAliveServletAsync(post, apply, delete, action, location, propertylist, osgiHttpWhiteboardServletPattern, osgiHttpWhiteboardContextSelect), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param osgiHttpWhiteboardServletPattern  (optional)
   * @param osgiHttpWhiteboardContextSelect  (optional)
   * @return Future(OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo)
   */
  def orgApacheFelixSystemreadyImplServletSystemAliveServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, osgiHttpWhiteboardServletPattern: Option[String] = None, osgiHttpWhiteboardContextSelect: Option[String] = None): Future[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo] = {
      helper.orgApacheFelixSystemreadyImplServletSystemAliveServlet(post, apply, delete, action, location, propertylist, osgiHttpWhiteboardServletPattern, osgiHttpWhiteboardContextSelect)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param osgiHttpWhiteboardServletPattern  (optional)
   * @param osgiHttpWhiteboardContextSelect  (optional)
   * @return OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo
   */
  def orgApacheFelixSystemreadyImplServletSystemReadyServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, osgiHttpWhiteboardServletPattern: Option[String] = None, osgiHttpWhiteboardContextSelect: Option[String] = None): Option[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo] = {
    val await = Try(Await.result(orgApacheFelixSystemreadyImplServletSystemReadyServletAsync(post, apply, delete, action, location, propertylist, osgiHttpWhiteboardServletPattern, osgiHttpWhiteboardContextSelect), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param osgiHttpWhiteboardServletPattern  (optional)
   * @param osgiHttpWhiteboardContextSelect  (optional)
   * @return Future(OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo)
   */
  def orgApacheFelixSystemreadyImplServletSystemReadyServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, osgiHttpWhiteboardServletPattern: Option[String] = None, osgiHttpWhiteboardContextSelect: Option[String] = None): Future[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo] = {
      helper.orgApacheFelixSystemreadyImplServletSystemReadyServlet(post, apply, delete, action, location, propertylist, osgiHttpWhiteboardServletPattern, osgiHttpWhiteboardContextSelect)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pollInterval  (optional)
   * @return OrgApacheFelixSystemreadySystemReadyMonitorInfo
   */
  def orgApacheFelixSystemreadySystemReadyMonitor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pollInterval: Option[Integer] = None): Option[OrgApacheFelixSystemreadySystemReadyMonitorInfo] = {
    val await = Try(Await.result(orgApacheFelixSystemreadySystemReadyMonitorAsync(post, apply, delete, action, location, propertylist, pollInterval), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pollInterval  (optional)
   * @return Future(OrgApacheFelixSystemreadySystemReadyMonitorInfo)
   */
  def orgApacheFelixSystemreadySystemReadyMonitorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pollInterval: Option[Integer] = None): Future[OrgApacheFelixSystemreadySystemReadyMonitorInfo] = {
      helper.orgApacheFelixSystemreadySystemReadyMonitor(post, apply, delete, action, location, propertylist, pollInterval)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param managerRoot  (optional)
   * @param httpServiceFilter  (optional)
   * @param defaultRender  (optional)
   * @param realm  (optional)
   * @param username  (optional)
   * @param password  (optional)
   * @param category  (optional)
   * @param locale  (optional)
   * @param loglevel  (optional)
   * @param plugins  (optional)
   * @return OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo
   */
  def orgApacheFelixWebconsoleInternalServletOsgiManager(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, managerRoot: Option[String] = None, httpServiceFilter: Option[String] = None, defaultRender: Option[String] = None, realm: Option[String] = None, username: Option[String] = None, password: Option[String] = None, category: Option[String] = None, locale: Option[String] = None, loglevel: Option[Integer] = None, plugins: Option[String] = None): Option[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo] = {
    val await = Try(Await.result(orgApacheFelixWebconsoleInternalServletOsgiManagerAsync(post, apply, delete, action, location, propertylist, managerRoot, httpServiceFilter, defaultRender, realm, username, password, category, locale, loglevel, plugins), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param managerRoot  (optional)
   * @param httpServiceFilter  (optional)
   * @param defaultRender  (optional)
   * @param realm  (optional)
   * @param username  (optional)
   * @param password  (optional)
   * @param category  (optional)
   * @param locale  (optional)
   * @param loglevel  (optional)
   * @param plugins  (optional)
   * @return Future(OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo)
   */
  def orgApacheFelixWebconsoleInternalServletOsgiManagerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, managerRoot: Option[String] = None, httpServiceFilter: Option[String] = None, defaultRender: Option[String] = None, realm: Option[String] = None, username: Option[String] = None, password: Option[String] = None, category: Option[String] = None, locale: Option[String] = None, loglevel: Option[Integer] = None, plugins: Option[String] = None): Future[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo] = {
      helper.orgApacheFelixWebconsoleInternalServletOsgiManager(post, apply, delete, action, location, propertylist, managerRoot, httpServiceFilter, defaultRender, realm, username, password, category, locale, loglevel, plugins)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxSize  (optional)
   * @return OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo
   */
  def orgApacheFelixWebconsolePluginsEventInternalPluginServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxSize: Option[Integer] = None): Option[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo] = {
    val await = Try(Await.result(orgApacheFelixWebconsolePluginsEventInternalPluginServletAsync(post, apply, delete, action, location, propertylist, maxSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxSize  (optional)
   * @return Future(OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo)
   */
  def orgApacheFelixWebconsolePluginsEventInternalPluginServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxSize: Option[Integer] = None): Future[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo] = {
      helper.orgApacheFelixWebconsolePluginsEventInternalPluginServlet(post, apply, delete, action, location, propertylist, maxSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param felixMemoryusageDumpThreshold  (optional)
   * @param felixMemoryusageDumpInterval  (optional)
   * @param felixMemoryusageDumpLocation  (optional)
   * @return OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo
   */
  def orgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCo(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, felixMemoryusageDumpThreshold: Option[Integer] = None, felixMemoryusageDumpInterval: Option[Integer] = None, felixMemoryusageDumpLocation: Option[String] = None): Option[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo] = {
    val await = Try(Await.result(orgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoAsync(post, apply, delete, action, location, propertylist, felixMemoryusageDumpThreshold, felixMemoryusageDumpInterval, felixMemoryusageDumpLocation), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param felixMemoryusageDumpThreshold  (optional)
   * @param felixMemoryusageDumpInterval  (optional)
   * @param felixMemoryusageDumpLocation  (optional)
   * @return Future(OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo)
   */
  def orgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, felixMemoryusageDumpThreshold: Option[Integer] = None, felixMemoryusageDumpInterval: Option[Integer] = None, felixMemoryusageDumpLocation: Option[String] = None): Future[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo] = {
      helper.orgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCo(post, apply, delete, action, location, propertylist, felixMemoryusageDumpThreshold, felixMemoryusageDumpInterval, felixMemoryusageDumpLocation)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param proxyEnabled  (optional)
   * @param proxyHost  (optional)
   * @param proxyPort  (optional)
   * @param proxyUser  (optional)
   * @param proxyPassword  (optional)
   * @param proxyExceptions  (optional)
   * @return OrgApacheHttpProxyconfiguratorInfo
   */
  def orgApacheHttpProxyconfigurator(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, proxyEnabled: Option[Boolean] = None, proxyHost: Option[String] = None, proxyPort: Option[Integer] = None, proxyUser: Option[String] = None, proxyPassword: Option[String] = None, proxyExceptions: Option[List[String]] = None): Option[OrgApacheHttpProxyconfiguratorInfo] = {
    val await = Try(Await.result(orgApacheHttpProxyconfiguratorAsync(post, apply, delete, action, location, propertylist, proxyEnabled, proxyHost, proxyPort, proxyUser, proxyPassword, proxyExceptions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param proxyEnabled  (optional)
   * @param proxyHost  (optional)
   * @param proxyPort  (optional)
   * @param proxyUser  (optional)
   * @param proxyPassword  (optional)
   * @param proxyExceptions  (optional)
   * @return Future(OrgApacheHttpProxyconfiguratorInfo)
   */
  def orgApacheHttpProxyconfiguratorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, proxyEnabled: Option[Boolean] = None, proxyHost: Option[String] = None, proxyPort: Option[Integer] = None, proxyUser: Option[String] = None, proxyPassword: Option[String] = None, proxyExceptions: Option[List[String]] = None): Future[OrgApacheHttpProxyconfiguratorInfo] = {
      helper.orgApacheHttpProxyconfigurator(post, apply, delete, action, location, propertylist, proxyEnabled, proxyHost, proxyPort, proxyUser, proxyPassword, proxyExceptions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param dir  (optional)
   * @return OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo
   */
  def orgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, dir: Option[String] = None): Option[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderAsync(post, apply, delete, action, location, propertylist, dir), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param dir  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo)
   */
  def orgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, dir: Option[String] = None): Future[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo] = {
      helper.orgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProvider(post, apply, delete, action, location, propertylist, dir)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @return OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo
   */
  def orgApacheJackrabbitOakPluginsBlobDatastoreFileDataStore(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None): Option[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreAsync(post, apply, delete, action, location, propertylist, `path`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo)
   */
  def orgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None): Future[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo] = {
      helper.orgApacheJackrabbitOakPluginsBlobDatastoreFileDataStore(post, apply, delete, action, location, propertylist, `path`)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mongouri  (optional)
   * @param db  (optional)
   * @param socketKeepAlive  (optional)
   * @param cache  (optional)
   * @param nodeCachePercentage  (optional)
   * @param prevDocCachePercentage  (optional)
   * @param childrenCachePercentage  (optional)
   * @param diffCachePercentage  (optional)
   * @param cacheSegmentCount  (optional)
   * @param cacheStackMoveDistance  (optional)
   * @param blobCacheSize  (optional)
   * @param persistentCache  (optional)
   * @param journalCache  (optional)
   * @param customBlobStore  (optional)
   * @param journalGCInterval  (optional)
   * @param journalGCMaxAge  (optional)
   * @param prefetchExternalChanges  (optional)
   * @param role  (optional)
   * @param versionGcMaxAgeInSecs  (optional)
   * @param versionGCExpression  (optional)
   * @param versionGCTimeLimitInSecs  (optional)
   * @param blobGcMaxAgeInSecs  (optional)
   * @param blobTrackSnapshotIntervalInSecs  (optional)
   * @param repositoryHome  (optional)
   * @param maxReplicationLagInSecs  (optional)
   * @param documentStoreType  (optional)
   * @param bundlingDisabled  (optional)
   * @param updateLimit  (optional)
   * @param persistentCacheIncludes  (optional)
   * @param leaseCheckMode  (optional)
   * @return OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo
   */
  def orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mongouri: Option[String] = None, db: Option[String] = None, socketKeepAlive: Option[Boolean] = None, cache: Option[Integer] = None, nodeCachePercentage: Option[Integer] = None, prevDocCachePercentage: Option[Integer] = None, childrenCachePercentage: Option[Integer] = None, diffCachePercentage: Option[Integer] = None, cacheSegmentCount: Option[Integer] = None, cacheStackMoveDistance: Option[Integer] = None, blobCacheSize: Option[Integer] = None, persistentCache: Option[String] = None, journalCache: Option[String] = None, customBlobStore: Option[Boolean] = None, journalGCInterval: Option[Integer] = None, journalGCMaxAge: Option[Integer] = None, prefetchExternalChanges: Option[Boolean] = None, role: Option[String] = None, versionGcMaxAgeInSecs: Option[Integer] = None, versionGCExpression: Option[String] = None, versionGCTimeLimitInSecs: Option[Integer] = None, blobGcMaxAgeInSecs: Option[Integer] = None, blobTrackSnapshotIntervalInSecs: Option[Integer] = None, repositoryHome: Option[String] = None, maxReplicationLagInSecs: Option[Integer] = None, documentStoreType: Option[String] = None, bundlingDisabled: Option[Boolean] = None, updateLimit: Option[Integer] = None, persistentCacheIncludes: Option[List[String]] = None, leaseCheckMode: Option[String] = None): Option[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceAsync(post, apply, delete, action, location, propertylist, mongouri, db, socketKeepAlive, cache, nodeCachePercentage, prevDocCachePercentage, childrenCachePercentage, diffCachePercentage, cacheSegmentCount, cacheStackMoveDistance, blobCacheSize, persistentCache, journalCache, customBlobStore, journalGCInterval, journalGCMaxAge, prefetchExternalChanges, role, versionGcMaxAgeInSecs, versionGCExpression, versionGCTimeLimitInSecs, blobGcMaxAgeInSecs, blobTrackSnapshotIntervalInSecs, repositoryHome, maxReplicationLagInSecs, documentStoreType, bundlingDisabled, updateLimit, persistentCacheIncludes, leaseCheckMode), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mongouri  (optional)
   * @param db  (optional)
   * @param socketKeepAlive  (optional)
   * @param cache  (optional)
   * @param nodeCachePercentage  (optional)
   * @param prevDocCachePercentage  (optional)
   * @param childrenCachePercentage  (optional)
   * @param diffCachePercentage  (optional)
   * @param cacheSegmentCount  (optional)
   * @param cacheStackMoveDistance  (optional)
   * @param blobCacheSize  (optional)
   * @param persistentCache  (optional)
   * @param journalCache  (optional)
   * @param customBlobStore  (optional)
   * @param journalGCInterval  (optional)
   * @param journalGCMaxAge  (optional)
   * @param prefetchExternalChanges  (optional)
   * @param role  (optional)
   * @param versionGcMaxAgeInSecs  (optional)
   * @param versionGCExpression  (optional)
   * @param versionGCTimeLimitInSecs  (optional)
   * @param blobGcMaxAgeInSecs  (optional)
   * @param blobTrackSnapshotIntervalInSecs  (optional)
   * @param repositoryHome  (optional)
   * @param maxReplicationLagInSecs  (optional)
   * @param documentStoreType  (optional)
   * @param bundlingDisabled  (optional)
   * @param updateLimit  (optional)
   * @param persistentCacheIncludes  (optional)
   * @param leaseCheckMode  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo)
   */
  def orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mongouri: Option[String] = None, db: Option[String] = None, socketKeepAlive: Option[Boolean] = None, cache: Option[Integer] = None, nodeCachePercentage: Option[Integer] = None, prevDocCachePercentage: Option[Integer] = None, childrenCachePercentage: Option[Integer] = None, diffCachePercentage: Option[Integer] = None, cacheSegmentCount: Option[Integer] = None, cacheStackMoveDistance: Option[Integer] = None, blobCacheSize: Option[Integer] = None, persistentCache: Option[String] = None, journalCache: Option[String] = None, customBlobStore: Option[Boolean] = None, journalGCInterval: Option[Integer] = None, journalGCMaxAge: Option[Integer] = None, prefetchExternalChanges: Option[Boolean] = None, role: Option[String] = None, versionGcMaxAgeInSecs: Option[Integer] = None, versionGCExpression: Option[String] = None, versionGCTimeLimitInSecs: Option[Integer] = None, blobGcMaxAgeInSecs: Option[Integer] = None, blobTrackSnapshotIntervalInSecs: Option[Integer] = None, repositoryHome: Option[String] = None, maxReplicationLagInSecs: Option[Integer] = None, documentStoreType: Option[String] = None, bundlingDisabled: Option[Boolean] = None, updateLimit: Option[Integer] = None, persistentCacheIncludes: Option[List[String]] = None, leaseCheckMode: Option[String] = None): Future[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo] = {
      helper.orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreService(post, apply, delete, action, location, propertylist, mongouri, db, socketKeepAlive, cache, nodeCachePercentage, prevDocCachePercentage, childrenCachePercentage, diffCachePercentage, cacheSegmentCount, cacheStackMoveDistance, blobCacheSize, persistentCache, journalCache, customBlobStore, journalGCInterval, journalGCMaxAge, prefetchExternalChanges, role, versionGcMaxAgeInSecs, versionGCExpression, versionGCTimeLimitInSecs, blobGcMaxAgeInSecs, blobTrackSnapshotIntervalInSecs, repositoryHome, maxReplicationLagInSecs, documentStoreType, bundlingDisabled, updateLimit, persistentCacheIncludes, leaseCheckMode)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param persistentCacheIncludes  (optional)
   * @return OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo
   */
  def orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePre(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, persistentCacheIncludes: Option[List[String]] = None): Option[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreAsync(post, apply, delete, action, location, propertylist, persistentCacheIncludes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param persistentCacheIncludes  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo)
   */
  def orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, persistentCacheIncludes: Option[List[String]] = None): Future[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo] = {
      helper.orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePre(post, apply, delete, action, location, propertylist, persistentCacheIncludes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param includedPaths  (optional)
   * @param enableAsyncObserver  (optional)
   * @param observerQueueSize  (optional)
   * @return OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo
   */
  def orgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCac(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, includedPaths: Option[List[String]] = None, enableAsyncObserver: Option[Boolean] = None, observerQueueSize: Option[Integer] = None): Option[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacAsync(post, apply, delete, action, location, propertylist, includedPaths, enableAsyncObserver, observerQueueSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param includedPaths  (optional)
   * @param enableAsyncObserver  (optional)
   * @param observerQueueSize  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo)
   */
  def orgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, includedPaths: Option[List[String]] = None, enableAsyncObserver: Option[Boolean] = None, observerQueueSize: Option[Integer] = None): Future[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo] = {
      helper.orgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCac(post, apply, delete, action, location, propertylist, includedPaths, enableAsyncObserver, observerQueueSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param asyncConfigs  (optional)
   * @param leaseTimeOutMinutes  (optional)
   * @param failingIndexTimeoutSeconds  (optional)
   * @param errorWarnIntervalSeconds  (optional)
   * @return OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo
   */
  def orgApacheJackrabbitOakPluginsIndexAsyncIndexerService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, asyncConfigs: Option[List[String]] = None, leaseTimeOutMinutes: Option[Integer] = None, failingIndexTimeoutSeconds: Option[Integer] = None, errorWarnIntervalSeconds: Option[Integer] = None): Option[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceAsync(post, apply, delete, action, location, propertylist, asyncConfigs, leaseTimeOutMinutes, failingIndexTimeoutSeconds, errorWarnIntervalSeconds), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param asyncConfigs  (optional)
   * @param leaseTimeOutMinutes  (optional)
   * @param failingIndexTimeoutSeconds  (optional)
   * @param errorWarnIntervalSeconds  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo)
   */
  def orgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, asyncConfigs: Option[List[String]] = None, leaseTimeOutMinutes: Option[Integer] = None, failingIndexTimeoutSeconds: Option[Integer] = None, errorWarnIntervalSeconds: Option[Integer] = None): Future[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo] = {
      helper.orgApacheJackrabbitOakPluginsIndexAsyncIndexerService(post, apply, delete, action, location, propertylist, asyncConfigs, leaseTimeOutMinutes, failingIndexTimeoutSeconds, errorWarnIntervalSeconds)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disabled  (optional)
   * @param debug  (optional)
   * @param localIndexDir  (optional)
   * @param enableOpenIndexAsync  (optional)
   * @param threadPoolSize  (optional)
   * @param prefetchIndexFiles  (optional)
   * @param extractedTextCacheSizeInMB  (optional)
   * @param extractedTextCacheExpiryInSecs  (optional)
   * @param alwaysUsePreExtractedCache  (optional)
   * @param booleanClauseLimit  (optional)
   * @param enableHybridIndexing  (optional)
   * @param hybridQueueSize  (optional)
   * @param disableStoredIndexDefinition  (optional)
   * @param deletedBlobsCollectionEnabled  (optional)
   * @param propIndexCleanerIntervalInSecs  (optional)
   * @param enableSingleBlobIndexFiles  (optional)
   * @return OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo
   */
  def orgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServ(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disabled: Option[Boolean] = None, debug: Option[Boolean] = None, localIndexDir: Option[String] = None, enableOpenIndexAsync: Option[Boolean] = None, threadPoolSize: Option[Integer] = None, prefetchIndexFiles: Option[Boolean] = None, extractedTextCacheSizeInMB: Option[Integer] = None, extractedTextCacheExpiryInSecs: Option[Integer] = None, alwaysUsePreExtractedCache: Option[Boolean] = None, booleanClauseLimit: Option[Integer] = None, enableHybridIndexing: Option[Boolean] = None, hybridQueueSize: Option[Integer] = None, disableStoredIndexDefinition: Option[Boolean] = None, deletedBlobsCollectionEnabled: Option[Boolean] = None, propIndexCleanerIntervalInSecs: Option[Integer] = None, enableSingleBlobIndexFiles: Option[Boolean] = None): Option[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServAsync(post, apply, delete, action, location, propertylist, disabled, debug, localIndexDir, enableOpenIndexAsync, threadPoolSize, prefetchIndexFiles, extractedTextCacheSizeInMB, extractedTextCacheExpiryInSecs, alwaysUsePreExtractedCache, booleanClauseLimit, enableHybridIndexing, hybridQueueSize, disableStoredIndexDefinition, deletedBlobsCollectionEnabled, propIndexCleanerIntervalInSecs, enableSingleBlobIndexFiles), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param disabled  (optional)
   * @param debug  (optional)
   * @param localIndexDir  (optional)
   * @param enableOpenIndexAsync  (optional)
   * @param threadPoolSize  (optional)
   * @param prefetchIndexFiles  (optional)
   * @param extractedTextCacheSizeInMB  (optional)
   * @param extractedTextCacheExpiryInSecs  (optional)
   * @param alwaysUsePreExtractedCache  (optional)
   * @param booleanClauseLimit  (optional)
   * @param enableHybridIndexing  (optional)
   * @param hybridQueueSize  (optional)
   * @param disableStoredIndexDefinition  (optional)
   * @param deletedBlobsCollectionEnabled  (optional)
   * @param propIndexCleanerIntervalInSecs  (optional)
   * @param enableSingleBlobIndexFiles  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo)
   */
  def orgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, disabled: Option[Boolean] = None, debug: Option[Boolean] = None, localIndexDir: Option[String] = None, enableOpenIndexAsync: Option[Boolean] = None, threadPoolSize: Option[Integer] = None, prefetchIndexFiles: Option[Boolean] = None, extractedTextCacheSizeInMB: Option[Integer] = None, extractedTextCacheExpiryInSecs: Option[Integer] = None, alwaysUsePreExtractedCache: Option[Boolean] = None, booleanClauseLimit: Option[Integer] = None, enableHybridIndexing: Option[Boolean] = None, hybridQueueSize: Option[Integer] = None, disableStoredIndexDefinition: Option[Boolean] = None, deletedBlobsCollectionEnabled: Option[Boolean] = None, propIndexCleanerIntervalInSecs: Option[Integer] = None, enableSingleBlobIndexFiles: Option[Boolean] = None): Future[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo] = {
      helper.orgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServ(post, apply, delete, action, location, propertylist, disabled, debug, localIndexDir, enableOpenIndexAsync, threadPoolSize, prefetchIndexFiles, extractedTextCacheSizeInMB, extractedTextCacheExpiryInSecs, alwaysUsePreExtractedCache, booleanClauseLimit, enableHybridIndexing, hybridQueueSize, disableStoredIndexDefinition, deletedBlobsCollectionEnabled, propIndexCleanerIntervalInSecs, enableSingleBlobIndexFiles)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param solrHomePath  (optional)
   * @param solrCoreName  (optional)
   * @return OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCo(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, solrHomePath: Option[String] = None, solrCoreName: Option[String] = None): Option[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoAsync(post, apply, delete, action, location, propertylist, solrHomePath, solrCoreName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param solrHomePath  (optional)
   * @param solrCoreName  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo)
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, solrHomePath: Option[String] = None, solrCoreName: Option[String] = None): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo] = {
      helper.orgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCo(post, apply, delete, action, location, propertylist, solrHomePath, solrCoreName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServers(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Option[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersAsync(post, apply, delete, action, location, propertylist, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo)
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo] = {
      helper.orgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServers(post, apply, delete, action, location, propertylist, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pathDescField  (optional)
   * @param pathChildField  (optional)
   * @param pathParentField  (optional)
   * @param pathExactField  (optional)
   * @param catchAllField  (optional)
   * @param collapsedPathField  (optional)
   * @param pathDepthField  (optional)
   * @param commitPolicy  (optional)
   * @param rows  (optional)
   * @param pathRestrictions  (optional)
   * @param propertyRestrictions  (optional)
   * @param primarytypesRestrictions  (optional)
   * @param ignoredProperties  (optional)
   * @param usedProperties  (optional)
   * @param typeMappings  (optional)
   * @param propertyMappings  (optional)
   * @param collapseJcrcontentNodes  (optional)
   * @return OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfiguration(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pathDescField: Option[String] = None, pathChildField: Option[String] = None, pathParentField: Option[String] = None, pathExactField: Option[String] = None, catchAllField: Option[String] = None, collapsedPathField: Option[String] = None, pathDepthField: Option[String] = None, commitPolicy: Option[String] = None, rows: Option[Integer] = None, pathRestrictions: Option[Boolean] = None, propertyRestrictions: Option[Boolean] = None, primarytypesRestrictions: Option[Boolean] = None, ignoredProperties: Option[List[String]] = None, usedProperties: Option[List[String]] = None, typeMappings: Option[List[String]] = None, propertyMappings: Option[List[String]] = None, collapseJcrcontentNodes: Option[Boolean] = None): Option[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationAsync(post, apply, delete, action, location, propertylist, pathDescField, pathChildField, pathParentField, pathExactField, catchAllField, collapsedPathField, pathDepthField, commitPolicy, rows, pathRestrictions, propertyRestrictions, primarytypesRestrictions, ignoredProperties, usedProperties, typeMappings, propertyMappings, collapseJcrcontentNodes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param pathDescField  (optional)
   * @param pathChildField  (optional)
   * @param pathParentField  (optional)
   * @param pathExactField  (optional)
   * @param catchAllField  (optional)
   * @param collapsedPathField  (optional)
   * @param pathDepthField  (optional)
   * @param commitPolicy  (optional)
   * @param rows  (optional)
   * @param pathRestrictions  (optional)
   * @param propertyRestrictions  (optional)
   * @param primarytypesRestrictions  (optional)
   * @param ignoredProperties  (optional)
   * @param usedProperties  (optional)
   * @param typeMappings  (optional)
   * @param propertyMappings  (optional)
   * @param collapseJcrcontentNodes  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo)
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, pathDescField: Option[String] = None, pathChildField: Option[String] = None, pathParentField: Option[String] = None, pathExactField: Option[String] = None, catchAllField: Option[String] = None, collapsedPathField: Option[String] = None, pathDepthField: Option[String] = None, commitPolicy: Option[String] = None, rows: Option[Integer] = None, pathRestrictions: Option[Boolean] = None, propertyRestrictions: Option[Boolean] = None, primarytypesRestrictions: Option[Boolean] = None, ignoredProperties: Option[List[String]] = None, usedProperties: Option[List[String]] = None, typeMappings: Option[List[String]] = None, propertyMappings: Option[List[String]] = None, collapseJcrcontentNodes: Option[Boolean] = None): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo] = {
      helper.orgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfiguration(post, apply, delete, action, location, propertylist, pathDescField, pathChildField, pathParentField, pathExactField, catchAllField, collapsedPathField, pathDepthField, commitPolicy, rows, pathRestrictions, propertyRestrictions, primarytypesRestrictions, ignoredProperties, usedProperties, typeMappings, propertyMappings, collapseJcrcontentNodes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param solrHttpUrl  (optional)
   * @param solrZkHost  (optional)
   * @param solrCollection  (optional)
   * @param solrSocketTimeout  (optional)
   * @param solrConnectionTimeout  (optional)
   * @param solrShardsNo  (optional)
   * @param solrReplicationFactor  (optional)
   * @param solrConfDir  (optional)
   * @return OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConf(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, solrHttpUrl: Option[String] = None, solrZkHost: Option[String] = None, solrCollection: Option[String] = None, solrSocketTimeout: Option[Integer] = None, solrConnectionTimeout: Option[Integer] = None, solrShardsNo: Option[Integer] = None, solrReplicationFactor: Option[Integer] = None, solrConfDir: Option[String] = None): Option[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfAsync(post, apply, delete, action, location, propertylist, solrHttpUrl, solrZkHost, solrCollection, solrSocketTimeout, solrConnectionTimeout, solrShardsNo, solrReplicationFactor, solrConfDir), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param solrHttpUrl  (optional)
   * @param solrZkHost  (optional)
   * @param solrCollection  (optional)
   * @param solrSocketTimeout  (optional)
   * @param solrConnectionTimeout  (optional)
   * @param solrShardsNo  (optional)
   * @param solrReplicationFactor  (optional)
   * @param solrConfDir  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo)
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, solrHttpUrl: Option[String] = None, solrZkHost: Option[String] = None, solrCollection: Option[String] = None, solrSocketTimeout: Option[Integer] = None, solrConnectionTimeout: Option[Integer] = None, solrShardsNo: Option[Integer] = None, solrReplicationFactor: Option[Integer] = None, solrConfDir: Option[String] = None): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo] = {
      helper.orgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConf(post, apply, delete, action, location, propertylist, solrHttpUrl, solrZkHost, solrCollection, solrSocketTimeout, solrConnectionTimeout, solrShardsNo, solrReplicationFactor, solrConfDir)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queryAggregation  (optional)
   * @return OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvid(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queryAggregation: Option[Boolean] = None): Option[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidAsync(post, apply, delete, action, location, propertylist, queryAggregation), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queryAggregation  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo)
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queryAggregation: Option[Boolean] = None): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo] = {
      helper.orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvid(post, apply, delete, action, location, propertylist, queryAggregation)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serverType  (optional)
   * @return OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSe(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serverType: Option[String] = None): Option[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeAsync(post, apply, delete, action, location, propertylist, serverType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serverType  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo)
   */
  def orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serverType: Option[String] = None): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo] = {
      helper.orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSe(post, apply, delete, action, location, propertylist, serverType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerType  (optional)
   * @return OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo
   */
  def orgApacheJackrabbitOakPluginsMetricStatisticsProviderFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerType: Option[String] = None): Option[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryAsync(post, apply, delete, action, location, propertylist, providerType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerType  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo)
   */
  def orgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerType: Option[String] = None): Future[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo] = {
      helper.orgApacheJackrabbitOakPluginsMetricStatisticsProviderFactory(post, apply, delete, action, location, propertylist, providerType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxItems  (optional)
   * @param maxPathDepth  (optional)
   * @param enabled  (optional)
   * @return OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo
   */
  def orgApacheJackrabbitOakPluginsObservationChangeCollectorProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxItems: Option[Integer] = None, maxPathDepth: Option[Integer] = None, enabled: Option[Boolean] = None): Option[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakPluginsObservationChangeCollectorProviderAsync(post, apply, delete, action, location, propertylist, maxItems, maxPathDepth, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxItems  (optional)
   * @param maxPathDepth  (optional)
   * @param enabled  (optional)
   * @return Future(OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo)
   */
  def orgApacheJackrabbitOakPluginsObservationChangeCollectorProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxItems: Option[Integer] = None, maxPathDepth: Option[Integer] = None, enabled: Option[Boolean] = None): Future[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo] = {
      helper.orgApacheJackrabbitOakPluginsObservationChangeCollectorProvider(post, apply, delete, action, location, propertylist, maxItems, maxPathDepth, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queryLimitInMemory  (optional)
   * @param queryLimitReads  (optional)
   * @param queryFailTraversal  (optional)
   * @param fastQuerySize  (optional)
   * @return OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo
   */
  def orgApacheJackrabbitOakQueryQueryEngineSettingsService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queryLimitInMemory: Option[Integer] = None, queryLimitReads: Option[Integer] = None, queryFailTraversal: Option[Boolean] = None, fastQuerySize: Option[Boolean] = None): Option[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakQueryQueryEngineSettingsServiceAsync(post, apply, delete, action, location, propertylist, queryLimitInMemory, queryLimitReads, queryFailTraversal, fastQuerySize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queryLimitInMemory  (optional)
   * @param queryLimitReads  (optional)
   * @param queryFailTraversal  (optional)
   * @param fastQuerySize  (optional)
   * @return Future(OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo)
   */
  def orgApacheJackrabbitOakQueryQueryEngineSettingsServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queryLimitInMemory: Option[Integer] = None, queryLimitReads: Option[Integer] = None, queryFailTraversal: Option[Boolean] = None, fastQuerySize: Option[Boolean] = None): Future[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo] = {
      helper.orgApacheJackrabbitOakQueryQueryEngineSettingsService(post, apply, delete, action, location, propertylist, queryLimitInMemory, queryLimitReads, queryFailTraversal, fastQuerySize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheJackrabbitOakAuthenticationAppName  (optional)
   * @param orgApacheJackrabbitOakAuthenticationConfigSpiName  (optional)
   * @return OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo
   */
  def orgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheJackrabbitOakAuthenticationAppName: Option[String] = None, orgApacheJackrabbitOakAuthenticationConfigSpiName: Option[String] = None): Option[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigAsync(post, apply, delete, action, location, propertylist, orgApacheJackrabbitOakAuthenticationAppName, orgApacheJackrabbitOakAuthenticationConfigSpiName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheJackrabbitOakAuthenticationAppName  (optional)
   * @param orgApacheJackrabbitOakAuthenticationConfigSpiName  (optional)
   * @return Future(OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo)
   */
  def orgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheJackrabbitOakAuthenticationAppName: Option[String] = None, orgApacheJackrabbitOakAuthenticationConfigSpiName: Option[String] = None): Future[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo] = {
      helper.orgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfig(post, apply, delete, action, location, propertylist, orgApacheJackrabbitOakAuthenticationAppName, orgApacheJackrabbitOakAuthenticationConfigSpiName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerName  (optional)
   * @param hostName  (optional)
   * @param hostPort  (optional)
   * @param hostSsl  (optional)
   * @param hostTls  (optional)
   * @param hostNoCertCheck  (optional)
   * @param bindDn  (optional)
   * @param bindPassword  (optional)
   * @param searchTimeout  (optional)
   * @param adminPoolMaxActive  (optional)
   * @param adminPoolLookupOnValidate  (optional)
   * @param userPoolMaxActive  (optional)
   * @param userPoolLookupOnValidate  (optional)
   * @param userBaseDN  (optional)
   * @param userObjectclass  (optional)
   * @param userIdAttribute  (optional)
   * @param userExtraFilter  (optional)
   * @param userMakeDnPath  (optional)
   * @param groupBaseDN  (optional)
   * @param groupObjectclass  (optional)
   * @param groupNameAttribute  (optional)
   * @param groupExtraFilter  (optional)
   * @param groupMakeDnPath  (optional)
   * @param groupMemberAttribute  (optional)
   * @param useUidForExtId  (optional)
   * @param customattributes  (optional)
   * @return OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo
   */
  def orgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdenti(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerName: Option[String] = None, hostName: Option[String] = None, hostPort: Option[Integer] = None, hostSsl: Option[Boolean] = None, hostTls: Option[Boolean] = None, hostNoCertCheck: Option[Boolean] = None, bindDn: Option[String] = None, bindPassword: Option[String] = None, searchTimeout: Option[String] = None, adminPoolMaxActive: Option[Integer] = None, adminPoolLookupOnValidate: Option[Boolean] = None, userPoolMaxActive: Option[Integer] = None, userPoolLookupOnValidate: Option[Boolean] = None, userBaseDN: Option[String] = None, userObjectclass: Option[List[String]] = None, userIdAttribute: Option[String] = None, userExtraFilter: Option[String] = None, userMakeDnPath: Option[Boolean] = None, groupBaseDN: Option[String] = None, groupObjectclass: Option[List[String]] = None, groupNameAttribute: Option[String] = None, groupExtraFilter: Option[String] = None, groupMakeDnPath: Option[Boolean] = None, groupMemberAttribute: Option[String] = None, useUidForExtId: Option[Boolean] = None, customattributes: Option[List[String]] = None): Option[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiAsync(post, apply, delete, action, location, propertylist, providerName, hostName, hostPort, hostSsl, hostTls, hostNoCertCheck, bindDn, bindPassword, searchTimeout, adminPoolMaxActive, adminPoolLookupOnValidate, userPoolMaxActive, userPoolLookupOnValidate, userBaseDN, userObjectclass, userIdAttribute, userExtraFilter, userMakeDnPath, groupBaseDN, groupObjectclass, groupNameAttribute, groupExtraFilter, groupMakeDnPath, groupMemberAttribute, useUidForExtId, customattributes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerName  (optional)
   * @param hostName  (optional)
   * @param hostPort  (optional)
   * @param hostSsl  (optional)
   * @param hostTls  (optional)
   * @param hostNoCertCheck  (optional)
   * @param bindDn  (optional)
   * @param bindPassword  (optional)
   * @param searchTimeout  (optional)
   * @param adminPoolMaxActive  (optional)
   * @param adminPoolLookupOnValidate  (optional)
   * @param userPoolMaxActive  (optional)
   * @param userPoolLookupOnValidate  (optional)
   * @param userBaseDN  (optional)
   * @param userObjectclass  (optional)
   * @param userIdAttribute  (optional)
   * @param userExtraFilter  (optional)
   * @param userMakeDnPath  (optional)
   * @param groupBaseDN  (optional)
   * @param groupObjectclass  (optional)
   * @param groupNameAttribute  (optional)
   * @param groupExtraFilter  (optional)
   * @param groupMakeDnPath  (optional)
   * @param groupMemberAttribute  (optional)
   * @param useUidForExtId  (optional)
   * @param customattributes  (optional)
   * @return Future(OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo)
   */
  def orgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerName: Option[String] = None, hostName: Option[String] = None, hostPort: Option[Integer] = None, hostSsl: Option[Boolean] = None, hostTls: Option[Boolean] = None, hostNoCertCheck: Option[Boolean] = None, bindDn: Option[String] = None, bindPassword: Option[String] = None, searchTimeout: Option[String] = None, adminPoolMaxActive: Option[Integer] = None, adminPoolLookupOnValidate: Option[Boolean] = None, userPoolMaxActive: Option[Integer] = None, userPoolLookupOnValidate: Option[Boolean] = None, userBaseDN: Option[String] = None, userObjectclass: Option[List[String]] = None, userIdAttribute: Option[String] = None, userExtraFilter: Option[String] = None, userMakeDnPath: Option[Boolean] = None, groupBaseDN: Option[String] = None, groupObjectclass: Option[List[String]] = None, groupNameAttribute: Option[String] = None, groupExtraFilter: Option[String] = None, groupMakeDnPath: Option[Boolean] = None, groupMemberAttribute: Option[String] = None, useUidForExtId: Option[Boolean] = None, customattributes: Option[List[String]] = None): Future[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo] = {
      helper.orgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdenti(post, apply, delete, action, location, propertylist, providerName, hostName, hostPort, hostSsl, hostTls, hostNoCertCheck, bindDn, bindPassword, searchTimeout, adminPoolMaxActive, adminPoolLookupOnValidate, userPoolMaxActive, userPoolLookupOnValidate, userBaseDN, userObjectclass, userIdAttribute, userExtraFilter, userMakeDnPath, groupBaseDN, groupObjectclass, groupNameAttribute, groupExtraFilter, groupMakeDnPath, groupMemberAttribute, useUidForExtId, customattributes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param tokenExpiration  (optional)
   * @param tokenLength  (optional)
   * @param tokenRefresh  (optional)
   * @param tokenCleanupThreshold  (optional)
   * @param passwordHashAlgorithm  (optional)
   * @param passwordHashIterations  (optional)
   * @param passwordSaltSize  (optional)
   * @return OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo
   */
  def orgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfigura(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, tokenExpiration: Option[String] = None, tokenLength: Option[String] = None, tokenRefresh: Option[Boolean] = None, tokenCleanupThreshold: Option[Integer] = None, passwordHashAlgorithm: Option[String] = None, passwordHashIterations: Option[Integer] = None, passwordSaltSize: Option[Integer] = None): Option[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraAsync(post, apply, delete, action, location, propertylist, tokenExpiration, tokenLength, tokenRefresh, tokenCleanupThreshold, passwordHashAlgorithm, passwordHashIterations, passwordSaltSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param tokenExpiration  (optional)
   * @param tokenLength  (optional)
   * @param tokenRefresh  (optional)
   * @param tokenCleanupThreshold  (optional)
   * @param passwordHashAlgorithm  (optional)
   * @param passwordHashIterations  (optional)
   * @param passwordSaltSize  (optional)
   * @return Future(OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo)
   */
  def orgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, tokenExpiration: Option[String] = None, tokenLength: Option[String] = None, tokenRefresh: Option[Boolean] = None, tokenCleanupThreshold: Option[Integer] = None, passwordHashAlgorithm: Option[String] = None, passwordHashIterations: Option[Integer] = None, passwordSaltSize: Option[Integer] = None): Future[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo] = {
      helper.orgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfigura(post, apply, delete, action, location, propertylist, tokenExpiration, tokenLength, tokenRefresh, tokenCleanupThreshold, passwordHashAlgorithm, passwordHashIterations, passwordSaltSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param permissionsJr2  (optional)
   * @param importBehavior  (optional)
   * @param readPaths  (optional)
   * @param administrativePrincipals  (optional)
   * @param configurationRanking  (optional)
   * @return OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo
   */
  def orgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigur(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, permissionsJr2: Option[String] = None, importBehavior: Option[String] = None, readPaths: Option[List[String]] = None, administrativePrincipals: Option[List[String]] = None, configurationRanking: Option[Integer] = None): Option[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurAsync(post, apply, delete, action, location, propertylist, permissionsJr2, importBehavior, readPaths, administrativePrincipals, configurationRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param permissionsJr2  (optional)
   * @param importBehavior  (optional)
   * @param readPaths  (optional)
   * @param administrativePrincipals  (optional)
   * @param configurationRanking  (optional)
   * @return Future(OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo)
   */
  def orgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, permissionsJr2: Option[String] = None, importBehavior: Option[String] = None, readPaths: Option[List[String]] = None, administrativePrincipals: Option[List[String]] = None, configurationRanking: Option[Integer] = None): Future[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo] = {
      helper.orgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigur(post, apply, delete, action, location, propertylist, permissionsJr2, importBehavior, readPaths, administrativePrincipals, configurationRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param requiredServicePids  (optional)
   * @param authorizationCompositionType  (optional)
   * @return OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo
   */
  def orgApacheJackrabbitOakSecurityInternalSecurityProviderRegistrati(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, requiredServicePids: Option[List[String]] = None, authorizationCompositionType: Option[String] = None): Option[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiAsync(post, apply, delete, action, location, propertylist, requiredServicePids, authorizationCompositionType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param requiredServicePids  (optional)
   * @param authorizationCompositionType  (optional)
   * @return Future(OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo)
   */
  def orgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, requiredServicePids: Option[List[String]] = None, authorizationCompositionType: Option[String] = None): Future[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo] = {
      helper.orgApacheJackrabbitOakSecurityInternalSecurityProviderRegistrati(post, apply, delete, action, location, propertylist, requiredServicePids, authorizationCompositionType)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param length  (optional)
   * @return OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo
   */
  def orgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeName(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, length: Option[Integer] = None): Option[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameAsync(post, apply, delete, action, location, propertylist, length), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param length  (optional)
   * @return Future(OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo)
   */
  def orgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, length: Option[Integer] = None): Future[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo] = {
      helper.orgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeName(post, apply, delete, action, location, propertylist, length)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param usersPath  (optional)
   * @param groupsPath  (optional)
   * @param systemRelativePath  (optional)
   * @param defaultDepth  (optional)
   * @param importBehavior  (optional)
   * @param passwordHashAlgorithm  (optional)
   * @param passwordHashIterations  (optional)
   * @param passwordSaltSize  (optional)
   * @param omitAdminPw  (optional)
   * @param supportAutoSave  (optional)
   * @param passwordMaxAge  (optional)
   * @param initialPasswordChange  (optional)
   * @param passwordHistorySize  (optional)
   * @param passwordExpiryForAdmin  (optional)
   * @param cacheExpiration  (optional)
   * @param enableRFC7613UsercaseMappedProfile  (optional)
   * @return OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo
   */
  def orgApacheJackrabbitOakSecurityUserUserConfigurationImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, usersPath: Option[String] = None, groupsPath: Option[String] = None, systemRelativePath: Option[String] = None, defaultDepth: Option[Integer] = None, importBehavior: Option[String] = None, passwordHashAlgorithm: Option[String] = None, passwordHashIterations: Option[Integer] = None, passwordSaltSize: Option[Integer] = None, omitAdminPw: Option[Boolean] = None, supportAutoSave: Option[Boolean] = None, passwordMaxAge: Option[Integer] = None, initialPasswordChange: Option[Boolean] = None, passwordHistorySize: Option[Integer] = None, passwordExpiryForAdmin: Option[Boolean] = None, cacheExpiration: Option[Integer] = None, enableRFC7613UsercaseMappedProfile: Option[Boolean] = None): Option[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSecurityUserUserConfigurationImplAsync(post, apply, delete, action, location, propertylist, usersPath, groupsPath, systemRelativePath, defaultDepth, importBehavior, passwordHashAlgorithm, passwordHashIterations, passwordSaltSize, omitAdminPw, supportAutoSave, passwordMaxAge, initialPasswordChange, passwordHistorySize, passwordExpiryForAdmin, cacheExpiration, enableRFC7613UsercaseMappedProfile), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param usersPath  (optional)
   * @param groupsPath  (optional)
   * @param systemRelativePath  (optional)
   * @param defaultDepth  (optional)
   * @param importBehavior  (optional)
   * @param passwordHashAlgorithm  (optional)
   * @param passwordHashIterations  (optional)
   * @param passwordSaltSize  (optional)
   * @param omitAdminPw  (optional)
   * @param supportAutoSave  (optional)
   * @param passwordMaxAge  (optional)
   * @param initialPasswordChange  (optional)
   * @param passwordHistorySize  (optional)
   * @param passwordExpiryForAdmin  (optional)
   * @param cacheExpiration  (optional)
   * @param enableRFC7613UsercaseMappedProfile  (optional)
   * @return Future(OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo)
   */
  def orgApacheJackrabbitOakSecurityUserUserConfigurationImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, usersPath: Option[String] = None, groupsPath: Option[String] = None, systemRelativePath: Option[String] = None, defaultDepth: Option[Integer] = None, importBehavior: Option[String] = None, passwordHashAlgorithm: Option[String] = None, passwordHashIterations: Option[Integer] = None, passwordSaltSize: Option[Integer] = None, omitAdminPw: Option[Boolean] = None, supportAutoSave: Option[Boolean] = None, passwordMaxAge: Option[Integer] = None, initialPasswordChange: Option[Boolean] = None, passwordHistorySize: Option[Integer] = None, passwordExpiryForAdmin: Option[Boolean] = None, cacheExpiration: Option[Integer] = None, enableRFC7613UsercaseMappedProfile: Option[Boolean] = None): Future[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo] = {
      helper.orgApacheJackrabbitOakSecurityUserUserConfigurationImpl(post, apply, delete, action, location, propertylist, usersPath, groupsPath, systemRelativePath, defaultDepth, importBehavior, passwordHashAlgorithm, passwordHashIterations, passwordSaltSize, omitAdminPw, supportAutoSave, passwordMaxAge, initialPasswordChange, passwordHistorySize, passwordExpiryForAdmin, cacheExpiration, enableRFC7613UsercaseMappedProfile)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param accountName  (optional)
   * @param containerName  (optional)
   * @param accessKey  (optional)
   * @param rootPath  (optional)
   * @param connectionURL  (optional)
   * @return OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo
   */
  def orgApacheJackrabbitOakSegmentAzureAzureSegmentStoreService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, accountName: Option[String] = None, containerName: Option[String] = None, accessKey: Option[String] = None, rootPath: Option[String] = None, connectionURL: Option[String] = None): Option[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceAsync(post, apply, delete, action, location, propertylist, accountName, containerName, accessKey, rootPath, connectionURL), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param accountName  (optional)
   * @param containerName  (optional)
   * @param accessKey  (optional)
   * @param rootPath  (optional)
   * @param connectionURL  (optional)
   * @return Future(OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo)
   */
  def orgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, accountName: Option[String] = None, containerName: Option[String] = None, accessKey: Option[String] = None, rootPath: Option[String] = None, connectionURL: Option[String] = None): Future[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo] = {
      helper.orgApacheJackrabbitOakSegmentAzureAzureSegmentStoreService(post, apply, delete, action, location, propertylist, accountName, containerName, accessKey, rootPath, connectionURL)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param repositoryHome  (optional)
   * @param tarmkMode  (optional)
   * @param tarmkSize  (optional)
   * @param segmentCacheSize  (optional)
   * @param stringCacheSize  (optional)
   * @param templateCacheSize  (optional)
   * @param stringDeduplicationCacheSize  (optional)
   * @param templateDeduplicationCacheSize  (optional)
   * @param nodeDeduplicationCacheSize  (optional)
   * @param pauseCompaction  (optional)
   * @param compactionRetryCount  (optional)
   * @param compactionForceTimeout  (optional)
   * @param compactionSizeDeltaEstimation  (optional)
   * @param compactionDisableEstimation  (optional)
   * @param compactionRetainedGenerations  (optional)
   * @param compactionMemoryThreshold  (optional)
   * @param compactionProgressLog  (optional)
   * @param standby  (optional)
   * @param customBlobStore  (optional)
   * @param customSegmentStore  (optional)
   * @param splitPersistence  (optional)
   * @param repositoryBackupDir  (optional)
   * @param blobGcMaxAgeInSecs  (optional)
   * @param blobTrackSnapshotIntervalInSecs  (optional)
   * @param role  (optional)
   * @param registerDescriptors  (optional)
   * @param dispatchChanges  (optional)
   * @return OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo
   */
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, repositoryHome: Option[String] = None, tarmkMode: Option[String] = None, tarmkSize: Option[Integer] = None, segmentCacheSize: Option[Integer] = None, stringCacheSize: Option[Integer] = None, templateCacheSize: Option[Integer] = None, stringDeduplicationCacheSize: Option[Integer] = None, templateDeduplicationCacheSize: Option[Integer] = None, nodeDeduplicationCacheSize: Option[Integer] = None, pauseCompaction: Option[Boolean] = None, compactionRetryCount: Option[Integer] = None, compactionForceTimeout: Option[Integer] = None, compactionSizeDeltaEstimation: Option[Integer] = None, compactionDisableEstimation: Option[Boolean] = None, compactionRetainedGenerations: Option[Integer] = None, compactionMemoryThreshold: Option[Integer] = None, compactionProgressLog: Option[Integer] = None, standby: Option[Boolean] = None, customBlobStore: Option[Boolean] = None, customSegmentStore: Option[Boolean] = None, splitPersistence: Option[Boolean] = None, repositoryBackupDir: Option[String] = None, blobGcMaxAgeInSecs: Option[Integer] = None, blobTrackSnapshotIntervalInSecs: Option[Integer] = None, role: Option[String] = None, registerDescriptors: Option[Boolean] = None, dispatchChanges: Option[Boolean] = None): Option[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryAsync(post, apply, delete, action, location, propertylist, repositoryHome, tarmkMode, tarmkSize, segmentCacheSize, stringCacheSize, templateCacheSize, stringDeduplicationCacheSize, templateDeduplicationCacheSize, nodeDeduplicationCacheSize, pauseCompaction, compactionRetryCount, compactionForceTimeout, compactionSizeDeltaEstimation, compactionDisableEstimation, compactionRetainedGenerations, compactionMemoryThreshold, compactionProgressLog, standby, customBlobStore, customSegmentStore, splitPersistence, repositoryBackupDir, blobGcMaxAgeInSecs, blobTrackSnapshotIntervalInSecs, role, registerDescriptors, dispatchChanges), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param repositoryHome  (optional)
   * @param tarmkMode  (optional)
   * @param tarmkSize  (optional)
   * @param segmentCacheSize  (optional)
   * @param stringCacheSize  (optional)
   * @param templateCacheSize  (optional)
   * @param stringDeduplicationCacheSize  (optional)
   * @param templateDeduplicationCacheSize  (optional)
   * @param nodeDeduplicationCacheSize  (optional)
   * @param pauseCompaction  (optional)
   * @param compactionRetryCount  (optional)
   * @param compactionForceTimeout  (optional)
   * @param compactionSizeDeltaEstimation  (optional)
   * @param compactionDisableEstimation  (optional)
   * @param compactionRetainedGenerations  (optional)
   * @param compactionMemoryThreshold  (optional)
   * @param compactionProgressLog  (optional)
   * @param standby  (optional)
   * @param customBlobStore  (optional)
   * @param customSegmentStore  (optional)
   * @param splitPersistence  (optional)
   * @param repositoryBackupDir  (optional)
   * @param blobGcMaxAgeInSecs  (optional)
   * @param blobTrackSnapshotIntervalInSecs  (optional)
   * @param role  (optional)
   * @param registerDescriptors  (optional)
   * @param dispatchChanges  (optional)
   * @return Future(OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo)
   */
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, repositoryHome: Option[String] = None, tarmkMode: Option[String] = None, tarmkSize: Option[Integer] = None, segmentCacheSize: Option[Integer] = None, stringCacheSize: Option[Integer] = None, templateCacheSize: Option[Integer] = None, stringDeduplicationCacheSize: Option[Integer] = None, templateDeduplicationCacheSize: Option[Integer] = None, nodeDeduplicationCacheSize: Option[Integer] = None, pauseCompaction: Option[Boolean] = None, compactionRetryCount: Option[Integer] = None, compactionForceTimeout: Option[Integer] = None, compactionSizeDeltaEstimation: Option[Integer] = None, compactionDisableEstimation: Option[Boolean] = None, compactionRetainedGenerations: Option[Integer] = None, compactionMemoryThreshold: Option[Integer] = None, compactionProgressLog: Option[Integer] = None, standby: Option[Boolean] = None, customBlobStore: Option[Boolean] = None, customSegmentStore: Option[Boolean] = None, splitPersistence: Option[Boolean] = None, repositoryBackupDir: Option[String] = None, blobGcMaxAgeInSecs: Option[Integer] = None, blobTrackSnapshotIntervalInSecs: Option[Integer] = None, role: Option[String] = None, registerDescriptors: Option[Boolean] = None, dispatchChanges: Option[Boolean] = None): Future[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo] = {
      helper.orgApacheJackrabbitOakSegmentSegmentNodeStoreFactory(post, apply, delete, action, location, propertylist, repositoryHome, tarmkMode, tarmkSize, segmentCacheSize, stringCacheSize, templateCacheSize, stringDeduplicationCacheSize, templateDeduplicationCacheSize, nodeDeduplicationCacheSize, pauseCompaction, compactionRetryCount, compactionForceTimeout, compactionSizeDeltaEstimation, compactionDisableEstimation, compactionRetainedGenerations, compactionMemoryThreshold, compactionProgressLog, standby, customBlobStore, customSegmentStore, splitPersistence, repositoryBackupDir, blobGcMaxAgeInSecs, blobTrackSnapshotIntervalInSecs, role, registerDescriptors, dispatchChanges)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param commitsTrackerWriterGroups  (optional)
   * @return OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo
   */
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, commitsTrackerWriterGroups: Option[List[String]] = None): Option[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceAsync(post, apply, delete, action, location, propertylist, commitsTrackerWriterGroups), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param commitsTrackerWriterGroups  (optional)
   * @return Future(OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo)
   */
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, commitsTrackerWriterGroups: Option[List[String]] = None): Future[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo] = {
      helper.orgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorService(post, apply, delete, action, location, propertylist, commitsTrackerWriterGroups)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param repositoryHome  (optional)
   * @param tarmkMode  (optional)
   * @param tarmkSize  (optional)
   * @param segmentCacheSize  (optional)
   * @param stringCacheSize  (optional)
   * @param templateCacheSize  (optional)
   * @param stringDeduplicationCacheSize  (optional)
   * @param templateDeduplicationCacheSize  (optional)
   * @param nodeDeduplicationCacheSize  (optional)
   * @param pauseCompaction  (optional)
   * @param compactionRetryCount  (optional)
   * @param compactionForceTimeout  (optional)
   * @param compactionSizeDeltaEstimation  (optional)
   * @param compactionDisableEstimation  (optional)
   * @param compactionRetainedGenerations  (optional)
   * @param compactionMemoryThreshold  (optional)
   * @param compactionProgressLog  (optional)
   * @param standby  (optional)
   * @param customBlobStore  (optional)
   * @param customSegmentStore  (optional)
   * @param splitPersistence  (optional)
   * @param repositoryBackupDir  (optional)
   * @param blobGcMaxAgeInSecs  (optional)
   * @param blobTrackSnapshotIntervalInSecs  (optional)
   * @return OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo
   */
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, repositoryHome: Option[String] = None, tarmkMode: Option[String] = None, tarmkSize: Option[Integer] = None, segmentCacheSize: Option[Integer] = None, stringCacheSize: Option[Integer] = None, templateCacheSize: Option[Integer] = None, stringDeduplicationCacheSize: Option[Integer] = None, templateDeduplicationCacheSize: Option[Integer] = None, nodeDeduplicationCacheSize: Option[Integer] = None, pauseCompaction: Option[Boolean] = None, compactionRetryCount: Option[Integer] = None, compactionForceTimeout: Option[Integer] = None, compactionSizeDeltaEstimation: Option[Integer] = None, compactionDisableEstimation: Option[Boolean] = None, compactionRetainedGenerations: Option[Integer] = None, compactionMemoryThreshold: Option[Integer] = None, compactionProgressLog: Option[Integer] = None, standby: Option[Boolean] = None, customBlobStore: Option[Boolean] = None, customSegmentStore: Option[Boolean] = None, splitPersistence: Option[Boolean] = None, repositoryBackupDir: Option[String] = None, blobGcMaxAgeInSecs: Option[Integer] = None, blobTrackSnapshotIntervalInSecs: Option[Integer] = None): Option[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSegmentSegmentNodeStoreServiceAsync(post, apply, delete, action, location, propertylist, repositoryHome, tarmkMode, tarmkSize, segmentCacheSize, stringCacheSize, templateCacheSize, stringDeduplicationCacheSize, templateDeduplicationCacheSize, nodeDeduplicationCacheSize, pauseCompaction, compactionRetryCount, compactionForceTimeout, compactionSizeDeltaEstimation, compactionDisableEstimation, compactionRetainedGenerations, compactionMemoryThreshold, compactionProgressLog, standby, customBlobStore, customSegmentStore, splitPersistence, repositoryBackupDir, blobGcMaxAgeInSecs, blobTrackSnapshotIntervalInSecs), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param repositoryHome  (optional)
   * @param tarmkMode  (optional)
   * @param tarmkSize  (optional)
   * @param segmentCacheSize  (optional)
   * @param stringCacheSize  (optional)
   * @param templateCacheSize  (optional)
   * @param stringDeduplicationCacheSize  (optional)
   * @param templateDeduplicationCacheSize  (optional)
   * @param nodeDeduplicationCacheSize  (optional)
   * @param pauseCompaction  (optional)
   * @param compactionRetryCount  (optional)
   * @param compactionForceTimeout  (optional)
   * @param compactionSizeDeltaEstimation  (optional)
   * @param compactionDisableEstimation  (optional)
   * @param compactionRetainedGenerations  (optional)
   * @param compactionMemoryThreshold  (optional)
   * @param compactionProgressLog  (optional)
   * @param standby  (optional)
   * @param customBlobStore  (optional)
   * @param customSegmentStore  (optional)
   * @param splitPersistence  (optional)
   * @param repositoryBackupDir  (optional)
   * @param blobGcMaxAgeInSecs  (optional)
   * @param blobTrackSnapshotIntervalInSecs  (optional)
   * @return Future(OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo)
   */
  def orgApacheJackrabbitOakSegmentSegmentNodeStoreServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, repositoryHome: Option[String] = None, tarmkMode: Option[String] = None, tarmkSize: Option[Integer] = None, segmentCacheSize: Option[Integer] = None, stringCacheSize: Option[Integer] = None, templateCacheSize: Option[Integer] = None, stringDeduplicationCacheSize: Option[Integer] = None, templateDeduplicationCacheSize: Option[Integer] = None, nodeDeduplicationCacheSize: Option[Integer] = None, pauseCompaction: Option[Boolean] = None, compactionRetryCount: Option[Integer] = None, compactionForceTimeout: Option[Integer] = None, compactionSizeDeltaEstimation: Option[Integer] = None, compactionDisableEstimation: Option[Boolean] = None, compactionRetainedGenerations: Option[Integer] = None, compactionMemoryThreshold: Option[Integer] = None, compactionProgressLog: Option[Integer] = None, standby: Option[Boolean] = None, customBlobStore: Option[Boolean] = None, customSegmentStore: Option[Boolean] = None, splitPersistence: Option[Boolean] = None, repositoryBackupDir: Option[String] = None, blobGcMaxAgeInSecs: Option[Integer] = None, blobTrackSnapshotIntervalInSecs: Option[Integer] = None): Future[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo] = {
      helper.orgApacheJackrabbitOakSegmentSegmentNodeStoreService(post, apply, delete, action, location, propertylist, repositoryHome, tarmkMode, tarmkSize, segmentCacheSize, stringCacheSize, templateCacheSize, stringDeduplicationCacheSize, templateDeduplicationCacheSize, nodeDeduplicationCacheSize, pauseCompaction, compactionRetryCount, compactionForceTimeout, compactionSizeDeltaEstimation, compactionDisableEstimation, compactionRetainedGenerations, compactionMemoryThreshold, compactionProgressLog, standby, customBlobStore, customSegmentStore, splitPersistence, repositoryBackupDir, blobGcMaxAgeInSecs, blobTrackSnapshotIntervalInSecs)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingInstallerConfigurationPersist  (optional)
   * @param mode  (optional)
   * @param port  (optional)
   * @param primaryHost  (optional)
   * @param interval  (optional)
   * @param primaryAllowedClientIpRanges  (optional)
   * @param secure  (optional)
   * @param standbyReadtimeout  (optional)
   * @param standbyAutoclean  (optional)
   * @return OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo
   */
  def orgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingInstallerConfigurationPersist: Option[Boolean] = None, mode: Option[String] = None, port: Option[Integer] = None, primaryHost: Option[String] = None, interval: Option[Integer] = None, primaryAllowedClientIpRanges: Option[List[String]] = None, secure: Option[Boolean] = None, standbyReadtimeout: Option[Integer] = None, standbyAutoclean: Option[Boolean] = None): Option[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceAsync(post, apply, delete, action, location, propertylist, orgApacheSlingInstallerConfigurationPersist, mode, port, primaryHost, interval, primaryAllowedClientIpRanges, secure, standbyReadtimeout, standbyAutoclean), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingInstallerConfigurationPersist  (optional)
   * @param mode  (optional)
   * @param port  (optional)
   * @param primaryHost  (optional)
   * @param interval  (optional)
   * @param primaryAllowedClientIpRanges  (optional)
   * @param secure  (optional)
   * @param standbyReadtimeout  (optional)
   * @param standbyAutoclean  (optional)
   * @return Future(OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo)
   */
  def orgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingInstallerConfigurationPersist: Option[Boolean] = None, mode: Option[String] = None, port: Option[Integer] = None, primaryHost: Option[String] = None, interval: Option[Integer] = None, primaryAllowedClientIpRanges: Option[List[String]] = None, secure: Option[Boolean] = None, standbyReadtimeout: Option[Integer] = None, standbyAutoclean: Option[Boolean] = None): Future[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo] = {
      helper.orgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreService(post, apply, delete, action, location, propertylist, orgApacheSlingInstallerConfigurationPersist, mode, port, primaryHost, interval, primaryAllowedClientIpRanges, secure, standbyReadtimeout, standbyAutoclean)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param handlerName  (optional)
   * @param userExpirationTime  (optional)
   * @param userAutoMembership  (optional)
   * @param userPropertyMapping  (optional)
   * @param userPathPrefix  (optional)
   * @param userMembershipExpTime  (optional)
   * @param userMembershipNestingDepth  (optional)
   * @param userDynamicMembership  (optional)
   * @param userDisableMissing  (optional)
   * @param groupExpirationTime  (optional)
   * @param groupAutoMembership  (optional)
   * @param groupPropertyMapping  (optional)
   * @param groupPathPrefix  (optional)
   * @param enableRFC7613UsercaseMappedProfile  (optional)
   * @return OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo
   */
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDe(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, handlerName: Option[String] = None, userExpirationTime: Option[String] = None, userAutoMembership: Option[List[String]] = None, userPropertyMapping: Option[List[String]] = None, userPathPrefix: Option[String] = None, userMembershipExpTime: Option[String] = None, userMembershipNestingDepth: Option[Integer] = None, userDynamicMembership: Option[Boolean] = None, userDisableMissing: Option[Boolean] = None, groupExpirationTime: Option[String] = None, groupAutoMembership: Option[List[String]] = None, groupPropertyMapping: Option[List[String]] = None, groupPathPrefix: Option[String] = None, enableRFC7613UsercaseMappedProfile: Option[Boolean] = None): Option[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeAsync(post, apply, delete, action, location, propertylist, handlerName, userExpirationTime, userAutoMembership, userPropertyMapping, userPathPrefix, userMembershipExpTime, userMembershipNestingDepth, userDynamicMembership, userDisableMissing, groupExpirationTime, groupAutoMembership, groupPropertyMapping, groupPathPrefix, enableRFC7613UsercaseMappedProfile), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param handlerName  (optional)
   * @param userExpirationTime  (optional)
   * @param userAutoMembership  (optional)
   * @param userPropertyMapping  (optional)
   * @param userPathPrefix  (optional)
   * @param userMembershipExpTime  (optional)
   * @param userMembershipNestingDepth  (optional)
   * @param userDynamicMembership  (optional)
   * @param userDisableMissing  (optional)
   * @param groupExpirationTime  (optional)
   * @param groupAutoMembership  (optional)
   * @param groupPropertyMapping  (optional)
   * @param groupPathPrefix  (optional)
   * @param enableRFC7613UsercaseMappedProfile  (optional)
   * @return Future(OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo)
   */
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, handlerName: Option[String] = None, userExpirationTime: Option[String] = None, userAutoMembership: Option[List[String]] = None, userPropertyMapping: Option[List[String]] = None, userPathPrefix: Option[String] = None, userMembershipExpTime: Option[String] = None, userMembershipNestingDepth: Option[Integer] = None, userDynamicMembership: Option[Boolean] = None, userDisableMissing: Option[Boolean] = None, groupExpirationTime: Option[String] = None, groupAutoMembership: Option[List[String]] = None, groupPropertyMapping: Option[List[String]] = None, groupPathPrefix: Option[String] = None, enableRFC7613UsercaseMappedProfile: Option[Boolean] = None): Future[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo] = {
      helper.orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDe(post, apply, delete, action, location, propertylist, handlerName, userExpirationTime, userAutoMembership, userPropertyMapping, userPathPrefix, userMembershipExpTime, userMembershipNestingDepth, userDynamicMembership, userDisableMissing, groupExpirationTime, groupAutoMembership, groupPropertyMapping, groupPathPrefix, enableRFC7613UsercaseMappedProfile)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jaasRanking  (optional)
   * @param jaasControlFlag  (optional)
   * @param jaasRealmName  (optional)
   * @param idpName  (optional)
   * @param syncHandlerName  (optional)
   * @return OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo
   */
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplEx(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jaasRanking: Option[Integer] = None, jaasControlFlag: Option[String] = None, jaasRealmName: Option[String] = None, idpName: Option[String] = None, syncHandlerName: Option[String] = None): Option[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExAsync(post, apply, delete, action, location, propertylist, jaasRanking, jaasControlFlag, jaasRealmName, idpName, syncHandlerName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jaasRanking  (optional)
   * @param jaasControlFlag  (optional)
   * @param jaasRealmName  (optional)
   * @param idpName  (optional)
   * @param syncHandlerName  (optional)
   * @return Future(OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo)
   */
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jaasRanking: Option[Integer] = None, jaasControlFlag: Option[String] = None, jaasRealmName: Option[String] = None, idpName: Option[String] = None, syncHandlerName: Option[String] = None): Future[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo] = {
      helper.orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplEx(post, apply, delete, action, location, propertylist, jaasRanking, jaasControlFlag, jaasRealmName, idpName, syncHandlerName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param protectExternalId  (optional)
   * @return OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo
   */
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPr(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, protectExternalId: Option[Boolean] = None): Option[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrAsync(post, apply, delete, action, location, propertylist, protectExternalId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param protectExternalId  (optional)
   * @return Future(OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo)
   */
  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, protectExternalId: Option[Boolean] = None): Future[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo] = {
      helper.orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPr(post, apply, delete, action, location, propertylist, protectExternalId)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cugSupportedPaths  (optional)
   * @param cugEnabled  (optional)
   * @param configurationRanking  (optional)
   * @return OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo
   */
  def orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfi(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cugSupportedPaths: Option[List[String]] = None, cugEnabled: Option[Boolean] = None, configurationRanking: Option[Integer] = None): Option[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiAsync(post, apply, delete, action, location, propertylist, cugSupportedPaths, cugEnabled, configurationRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param cugSupportedPaths  (optional)
   * @param cugEnabled  (optional)
   * @param configurationRanking  (optional)
   * @return Future(OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo)
   */
  def orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, cugSupportedPaths: Option[List[String]] = None, cugEnabled: Option[Boolean] = None, configurationRanking: Option[Integer] = None): Future[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo] = {
      helper.orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfi(post, apply, delete, action, location, propertylist, cugSupportedPaths, cugEnabled, configurationRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param principalNames  (optional)
   * @return OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo
   */
  def orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExclu(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, principalNames: Option[List[String]] = None): Option[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluAsync(post, apply, delete, action, location, propertylist, principalNames), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param principalNames  (optional)
   * @return Future(OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo)
   */
  def orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, principalNames: Option[List[String]] = None): Future[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo] = {
      helper.orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExclu(post, apply, delete, action, location, propertylist, principalNames)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabledActions  (optional)
   * @param userPrivilegeNames  (optional)
   * @param groupPrivilegeNames  (optional)
   * @param constraint  (optional)
   * @return OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo
   */
  def orgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizable(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabledActions: Option[String] = None, userPrivilegeNames: Option[List[String]] = None, groupPrivilegeNames: Option[List[String]] = None, constraint: Option[String] = None): Option[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableAsync(post, apply, delete, action, location, propertylist, enabledActions, userPrivilegeNames, groupPrivilegeNames, constraint), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabledActions  (optional)
   * @param userPrivilegeNames  (optional)
   * @param groupPrivilegeNames  (optional)
   * @param constraint  (optional)
   * @return Future(OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo)
   */
  def orgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabledActions: Option[String] = None, userPrivilegeNames: Option[List[String]] = None, groupPrivilegeNames: Option[List[String]] = None, constraint: Option[String] = None): Future[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo] = {
      helper.orgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizable(post, apply, delete, action, location, propertylist, enabledActions, userPrivilegeNames, groupPrivilegeNames, constraint)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param packageRoots  (optional)
   * @return OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo
   */
  def orgApacheJackrabbitVaultPackagingImplPackagingImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, packageRoots: Option[List[String]] = None): Option[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitVaultPackagingImplPackagingImplAsync(post, apply, delete, action, location, propertylist, packageRoots), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param packageRoots  (optional)
   * @return Future(OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo)
   */
  def orgApacheJackrabbitVaultPackagingImplPackagingImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, packageRoots: Option[List[String]] = None): Future[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo] = {
      helper.orgApacheJackrabbitVaultPackagingImplPackagingImpl(post, apply, delete, action, location, propertylist, packageRoots)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param homePath  (optional)
   * @return OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo
   */
  def orgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistry(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, homePath: Option[String] = None): Option[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo] = {
    val await = Try(Await.result(orgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryAsync(post, apply, delete, action, location, propertylist, homePath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param homePath  (optional)
   * @return Future(OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo)
   */
  def orgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, homePath: Option[String] = None): Future[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo] = {
      helper.orgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistry(post, apply, delete, action, location, propertylist, homePath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletMethods  (optional)
   * @param slingServletPaths  (optional)
   * @return OrgApacheSlingAuthCoreImplLogoutServletInfo
   */
  def orgApacheSlingAuthCoreImplLogoutServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletMethods: Option[List[String]] = None, slingServletPaths: Option[String] = None): Option[OrgApacheSlingAuthCoreImplLogoutServletInfo] = {
    val await = Try(Await.result(orgApacheSlingAuthCoreImplLogoutServletAsync(post, apply, delete, action, location, propertylist, slingServletMethods, slingServletPaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletMethods  (optional)
   * @param slingServletPaths  (optional)
   * @return Future(OrgApacheSlingAuthCoreImplLogoutServletInfo)
   */
  def orgApacheSlingAuthCoreImplLogoutServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletMethods: Option[List[String]] = None, slingServletPaths: Option[String] = None): Future[OrgApacheSlingAuthCoreImplLogoutServletInfo] = {
      helper.orgApacheSlingAuthCoreImplLogoutServlet(post, apply, delete, action, location, propertylist, slingServletMethods, slingServletPaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo
   */
  def orgApacheSlingCaconfigImplConfigurationBindingsValueProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Option[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo] = {
    val await = Try(Await.result(orgApacheSlingCaconfigImplConfigurationBindingsValueProviderAsync(post, apply, delete, action, location, propertylist, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return Future(OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo)
   */
  def orgApacheSlingCaconfigImplConfigurationBindingsValueProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Future[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo] = {
      helper.orgApacheSlingCaconfigImplConfigurationBindingsValueProvider(post, apply, delete, action, location, propertylist, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param configBucketNames  (optional)
   * @return OrgApacheSlingCaconfigImplConfigurationResolverImplInfo
   */
  def orgApacheSlingCaconfigImplConfigurationResolverImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, configBucketNames: Option[List[String]] = None): Option[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo] = {
    val await = Try(Await.result(orgApacheSlingCaconfigImplConfigurationResolverImplAsync(post, apply, delete, action, location, propertylist, configBucketNames), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param configBucketNames  (optional)
   * @return Future(OrgApacheSlingCaconfigImplConfigurationResolverImplInfo)
   */
  def orgApacheSlingCaconfigImplConfigurationResolverImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, configBucketNames: Option[List[String]] = None): Future[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo] = {
      helper.orgApacheSlingCaconfigImplConfigurationResolverImpl(post, apply, delete, action, location, propertylist, configBucketNames)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param configPropertyInheritancePropertyNames  (optional)
   * @return OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo
   */
  def orgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStra(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, configPropertyInheritancePropertyNames: Option[List[String]] = None): Option[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo] = {
    val await = Try(Await.result(orgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraAsync(post, apply, delete, action, location, propertylist, enabled, configPropertyInheritancePropertyNames), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param configPropertyInheritancePropertyNames  (optional)
   * @return Future(OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo)
   */
  def orgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, configPropertyInheritancePropertyNames: Option[List[String]] = None): Future[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo] = {
      helper.orgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStra(post, apply, delete, action, location, propertylist, enabled, configPropertyInheritancePropertyNames)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo
   */
  def orgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStra(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Option[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo] = {
    val await = Try(Await.result(orgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraAsync(post, apply, delete, action, location, propertylist, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @return Future(OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo)
   */
  def orgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None): Future[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo] = {
      helper.orgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStra(post, apply, delete, action, location, propertylist, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param description  (optional)
   * @param overrides  (optional)
   * @param enabled  (optional)
   * @param serviceRanking  (optional)
   * @return OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo
   */
  def orgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProvi(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, description: Option[String] = None, overrides: Option[List[String]] = None, enabled: Option[Boolean] = None, serviceRanking: Option[Integer] = None): Option[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo] = {
    val await = Try(Await.result(orgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviAsync(post, apply, delete, action, location, propertylist, description, overrides, enabled, serviceRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param description  (optional)
   * @param overrides  (optional)
   * @param enabled  (optional)
   * @param serviceRanking  (optional)
   * @return Future(OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo)
   */
  def orgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, description: Option[String] = None, overrides: Option[List[String]] = None, enabled: Option[Boolean] = None, serviceRanking: Option[Integer] = None): Future[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo] = {
      helper.orgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProvi(post, apply, delete, action, location, propertylist, description, overrides, enabled, serviceRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param serviceRanking  (optional)
   * @return OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo
   */
  def orgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOve(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, serviceRanking: Option[Integer] = None): Option[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo] = {
    val await = Try(Await.result(orgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveAsync(post, apply, delete, action, location, propertylist, enabled, serviceRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param serviceRanking  (optional)
   * @return Future(OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo)
   */
  def orgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, serviceRanking: Option[Integer] = None): Future[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo] = {
      helper.orgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOve(post, apply, delete, action, location, propertylist, enabled, serviceRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param ignorePropertyNameRegex  (optional)
   * @param configCollectionPropertiesResourceNames  (optional)
   * @return OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo
   */
  def orgApacheSlingCaconfigManagementImplConfigurationManagementSetti(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, ignorePropertyNameRegex: Option[List[String]] = None, configCollectionPropertiesResourceNames: Option[List[String]] = None): Option[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo] = {
    val await = Try(Await.result(orgApacheSlingCaconfigManagementImplConfigurationManagementSettiAsync(post, apply, delete, action, location, propertylist, ignorePropertyNameRegex, configCollectionPropertiesResourceNames), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param ignorePropertyNameRegex  (optional)
   * @param configCollectionPropertiesResourceNames  (optional)
   * @return Future(OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo)
   */
  def orgApacheSlingCaconfigManagementImplConfigurationManagementSettiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, ignorePropertyNameRegex: Option[List[String]] = None, configCollectionPropertiesResourceNames: Option[List[String]] = None): Future[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo] = {
      helper.orgApacheSlingCaconfigManagementImplConfigurationManagementSetti(post, apply, delete, action, location, propertylist, ignorePropertyNameRegex, configCollectionPropertiesResourceNames)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param configPath  (optional)
   * @param fallbackPaths  (optional)
   * @param configCollectionInheritancePropertyNames  (optional)
   * @return OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo
   */
  def orgApacheSlingCaconfigResourceImplDefDefaultConfigurationResour(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, configPath: Option[String] = None, fallbackPaths: Option[List[String]] = None, configCollectionInheritancePropertyNames: Option[List[String]] = None): Option[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo] = {
    val await = Try(Await.result(orgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourAsync(post, apply, delete, action, location, propertylist, enabled, configPath, fallbackPaths, configCollectionInheritancePropertyNames), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param configPath  (optional)
   * @param fallbackPaths  (optional)
   * @param configCollectionInheritancePropertyNames  (optional)
   * @return Future(OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo)
   */
  def orgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, configPath: Option[String] = None, fallbackPaths: Option[List[String]] = None, configCollectionInheritancePropertyNames: Option[List[String]] = None): Future[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo] = {
      helper.orgApacheSlingCaconfigResourceImplDefDefaultConfigurationResour(post, apply, delete, action, location, propertylist, enabled, configPath, fallbackPaths, configCollectionInheritancePropertyNames)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param configRefResourceNames  (optional)
   * @param configRefPropertyNames  (optional)
   * @param serviceRanking  (optional)
   * @return OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo
   */
  def orgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategy(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, configRefResourceNames: Option[List[String]] = None, configRefPropertyNames: Option[List[String]] = None, serviceRanking: Option[Integer] = None): Option[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo] = {
    val await = Try(Await.result(orgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyAsync(post, apply, delete, action, location, propertylist, enabled, configRefResourceNames, configRefPropertyNames, serviceRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param enabled  (optional)
   * @param configRefResourceNames  (optional)
   * @param configRefPropertyNames  (optional)
   * @param serviceRanking  (optional)
   * @return Future(OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo)
   */
  def orgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, enabled: Option[Boolean] = None, configRefResourceNames: Option[List[String]] = None, configRefPropertyNames: Option[List[String]] = None, serviceRanking: Option[Integer] = None): Future[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo] = {
      helper.orgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategy(post, apply, delete, action, location, propertylist, enabled, configRefResourceNames, configRefPropertyNames, serviceRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param parserFeatures  (optional)
   * @return OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo
   */
  def orgApacheSlingCommonsHtmlInternalTagsoupHtmlParser(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, parserFeatures: Option[List[String]] = None): Option[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo] = {
    val await = Try(Await.result(orgApacheSlingCommonsHtmlInternalTagsoupHtmlParserAsync(post, apply, delete, action, location, propertylist, parserFeatures), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param parserFeatures  (optional)
   * @return Future(OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo)
   */
  def orgApacheSlingCommonsHtmlInternalTagsoupHtmlParserAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, parserFeatures: Option[List[String]] = None): Future[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo] = {
      helper.orgApacheSlingCommonsHtmlInternalTagsoupHtmlParser(post, apply, delete, action, location, propertylist, parserFeatures)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingCommonsLogLevel  (optional)
   * @param orgApacheSlingCommonsLogFile  (optional)
   * @param orgApacheSlingCommonsLogFileNumber  (optional)
   * @param orgApacheSlingCommonsLogFileSize  (optional)
   * @param orgApacheSlingCommonsLogPattern  (optional)
   * @param orgApacheSlingCommonsLogConfigurationFile  (optional)
   * @param orgApacheSlingCommonsLogPackagingDataEnabled  (optional)
   * @param orgApacheSlingCommonsLogMaxCallerDataDepth  (optional)
   * @param orgApacheSlingCommonsLogMaxOldFileCountInDump  (optional)
   * @param orgApacheSlingCommonsLogNumOfLines  (optional)
   * @return OrgApacheSlingCommonsLogLogManagerInfo
   */
  def orgApacheSlingCommonsLogLogManager(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingCommonsLogLevel: Option[String] = None, orgApacheSlingCommonsLogFile: Option[String] = None, orgApacheSlingCommonsLogFileNumber: Option[Integer] = None, orgApacheSlingCommonsLogFileSize: Option[String] = None, orgApacheSlingCommonsLogPattern: Option[String] = None, orgApacheSlingCommonsLogConfigurationFile: Option[String] = None, orgApacheSlingCommonsLogPackagingDataEnabled: Option[Boolean] = None, orgApacheSlingCommonsLogMaxCallerDataDepth: Option[Integer] = None, orgApacheSlingCommonsLogMaxOldFileCountInDump: Option[Integer] = None, orgApacheSlingCommonsLogNumOfLines: Option[Integer] = None): Option[OrgApacheSlingCommonsLogLogManagerInfo] = {
    val await = Try(Await.result(orgApacheSlingCommonsLogLogManagerAsync(post, apply, delete, action, location, propertylist, orgApacheSlingCommonsLogLevel, orgApacheSlingCommonsLogFile, orgApacheSlingCommonsLogFileNumber, orgApacheSlingCommonsLogFileSize, orgApacheSlingCommonsLogPattern, orgApacheSlingCommonsLogConfigurationFile, orgApacheSlingCommonsLogPackagingDataEnabled, orgApacheSlingCommonsLogMaxCallerDataDepth, orgApacheSlingCommonsLogMaxOldFileCountInDump, orgApacheSlingCommonsLogNumOfLines), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingCommonsLogLevel  (optional)
   * @param orgApacheSlingCommonsLogFile  (optional)
   * @param orgApacheSlingCommonsLogFileNumber  (optional)
   * @param orgApacheSlingCommonsLogFileSize  (optional)
   * @param orgApacheSlingCommonsLogPattern  (optional)
   * @param orgApacheSlingCommonsLogConfigurationFile  (optional)
   * @param orgApacheSlingCommonsLogPackagingDataEnabled  (optional)
   * @param orgApacheSlingCommonsLogMaxCallerDataDepth  (optional)
   * @param orgApacheSlingCommonsLogMaxOldFileCountInDump  (optional)
   * @param orgApacheSlingCommonsLogNumOfLines  (optional)
   * @return Future(OrgApacheSlingCommonsLogLogManagerInfo)
   */
  def orgApacheSlingCommonsLogLogManagerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingCommonsLogLevel: Option[String] = None, orgApacheSlingCommonsLogFile: Option[String] = None, orgApacheSlingCommonsLogFileNumber: Option[Integer] = None, orgApacheSlingCommonsLogFileSize: Option[String] = None, orgApacheSlingCommonsLogPattern: Option[String] = None, orgApacheSlingCommonsLogConfigurationFile: Option[String] = None, orgApacheSlingCommonsLogPackagingDataEnabled: Option[Boolean] = None, orgApacheSlingCommonsLogMaxCallerDataDepth: Option[Integer] = None, orgApacheSlingCommonsLogMaxOldFileCountInDump: Option[Integer] = None, orgApacheSlingCommonsLogNumOfLines: Option[Integer] = None): Future[OrgApacheSlingCommonsLogLogManagerInfo] = {
      helper.orgApacheSlingCommonsLogLogManager(post, apply, delete, action, location, propertylist, orgApacheSlingCommonsLogLevel, orgApacheSlingCommonsLogFile, orgApacheSlingCommonsLogFileNumber, orgApacheSlingCommonsLogFileSize, orgApacheSlingCommonsLogPattern, orgApacheSlingCommonsLogConfigurationFile, orgApacheSlingCommonsLogPackagingDataEnabled, orgApacheSlingCommonsLogMaxCallerDataDepth, orgApacheSlingCommonsLogMaxOldFileCountInDump, orgApacheSlingCommonsLogNumOfLines)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingCommonsLogLevel  (optional)
   * @param orgApacheSlingCommonsLogFile  (optional)
   * @param orgApacheSlingCommonsLogPattern  (optional)
   * @param orgApacheSlingCommonsLogNames  (optional)
   * @param orgApacheSlingCommonsLogAdditiv  (optional)
   * @return OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo
   */
  def orgApacheSlingCommonsLogLogManagerFactoryConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingCommonsLogLevel: Option[String] = None, orgApacheSlingCommonsLogFile: Option[String] = None, orgApacheSlingCommonsLogPattern: Option[String] = None, orgApacheSlingCommonsLogNames: Option[List[String]] = None, orgApacheSlingCommonsLogAdditiv: Option[Boolean] = None): Option[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo] = {
    val await = Try(Await.result(orgApacheSlingCommonsLogLogManagerFactoryConfigAsync(post, apply, delete, action, location, propertylist, orgApacheSlingCommonsLogLevel, orgApacheSlingCommonsLogFile, orgApacheSlingCommonsLogPattern, orgApacheSlingCommonsLogNames, orgApacheSlingCommonsLogAdditiv), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingCommonsLogLevel  (optional)
   * @param orgApacheSlingCommonsLogFile  (optional)
   * @param orgApacheSlingCommonsLogPattern  (optional)
   * @param orgApacheSlingCommonsLogNames  (optional)
   * @param orgApacheSlingCommonsLogAdditiv  (optional)
   * @return Future(OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo)
   */
  def orgApacheSlingCommonsLogLogManagerFactoryConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingCommonsLogLevel: Option[String] = None, orgApacheSlingCommonsLogFile: Option[String] = None, orgApacheSlingCommonsLogPattern: Option[String] = None, orgApacheSlingCommonsLogNames: Option[List[String]] = None, orgApacheSlingCommonsLogAdditiv: Option[Boolean] = None): Future[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo] = {
      helper.orgApacheSlingCommonsLogLogManagerFactoryConfig(post, apply, delete, action, location, propertylist, orgApacheSlingCommonsLogLevel, orgApacheSlingCommonsLogFile, orgApacheSlingCommonsLogPattern, orgApacheSlingCommonsLogNames, orgApacheSlingCommonsLogAdditiv)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingCommonsLogFile  (optional)
   * @param orgApacheSlingCommonsLogFileNumber  (optional)
   * @param orgApacheSlingCommonsLogFileSize  (optional)
   * @param orgApacheSlingCommonsLogFileBuffered  (optional)
   * @return OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo
   */
  def orgApacheSlingCommonsLogLogManagerFactoryWriter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingCommonsLogFile: Option[String] = None, orgApacheSlingCommonsLogFileNumber: Option[Integer] = None, orgApacheSlingCommonsLogFileSize: Option[String] = None, orgApacheSlingCommonsLogFileBuffered: Option[Boolean] = None): Option[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo] = {
    val await = Try(Await.result(orgApacheSlingCommonsLogLogManagerFactoryWriterAsync(post, apply, delete, action, location, propertylist, orgApacheSlingCommonsLogFile, orgApacheSlingCommonsLogFileNumber, orgApacheSlingCommonsLogFileSize, orgApacheSlingCommonsLogFileBuffered), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingCommonsLogFile  (optional)
   * @param orgApacheSlingCommonsLogFileNumber  (optional)
   * @param orgApacheSlingCommonsLogFileSize  (optional)
   * @param orgApacheSlingCommonsLogFileBuffered  (optional)
   * @return Future(OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo)
   */
  def orgApacheSlingCommonsLogLogManagerFactoryWriterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingCommonsLogFile: Option[String] = None, orgApacheSlingCommonsLogFileNumber: Option[Integer] = None, orgApacheSlingCommonsLogFileSize: Option[String] = None, orgApacheSlingCommonsLogFileBuffered: Option[Boolean] = None): Future[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo] = {
      helper.orgApacheSlingCommonsLogLogManagerFactoryWriter(post, apply, delete, action, location, propertylist, orgApacheSlingCommonsLogFile, orgApacheSlingCommonsLogFileNumber, orgApacheSlingCommonsLogFileSize, orgApacheSlingCommonsLogFileBuffered)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param period  (optional)
   * @param timeUnit  (optional)
   * @param level  (optional)
   * @param loggerName  (optional)
   * @param prefix  (optional)
   * @param pattern  (optional)
   * @param registryName  (optional)
   * @return OrgApacheSlingCommonsMetricsInternalLogReporterInfo
   */
  def orgApacheSlingCommonsMetricsInternalLogReporter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, period: Option[Integer] = None, timeUnit: Option[String] = None, level: Option[String] = None, loggerName: Option[String] = None, prefix: Option[String] = None, pattern: Option[String] = None, registryName: Option[String] = None): Option[OrgApacheSlingCommonsMetricsInternalLogReporterInfo] = {
    val await = Try(Await.result(orgApacheSlingCommonsMetricsInternalLogReporterAsync(post, apply, delete, action, location, propertylist, period, timeUnit, level, loggerName, prefix, pattern, registryName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param period  (optional)
   * @param timeUnit  (optional)
   * @param level  (optional)
   * @param loggerName  (optional)
   * @param prefix  (optional)
   * @param pattern  (optional)
   * @param registryName  (optional)
   * @return Future(OrgApacheSlingCommonsMetricsInternalLogReporterInfo)
   */
  def orgApacheSlingCommonsMetricsInternalLogReporterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, period: Option[Integer] = None, timeUnit: Option[String] = None, level: Option[String] = None, loggerName: Option[String] = None, prefix: Option[String] = None, pattern: Option[String] = None, registryName: Option[String] = None): Future[OrgApacheSlingCommonsMetricsInternalLogReporterInfo] = {
      helper.orgApacheSlingCommonsMetricsInternalLogReporter(post, apply, delete, action, location, propertylist, period, timeUnit, level, loggerName, prefix, pattern, registryName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param datasources  (optional)
   * @param step  (optional)
   * @param archives  (optional)
   * @param `path`  (optional)
   * @return OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo
   */
  def orgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, datasources: Option[List[String]] = None, step: Option[Integer] = None, archives: Option[List[String]] = None, `path`: Option[String] = None): Option[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo] = {
    val await = Try(Await.result(orgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterAsync(post, apply, delete, action, location, propertylist, datasources, step, archives, `path`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param datasources  (optional)
   * @param step  (optional)
   * @param archives  (optional)
   * @param `path`  (optional)
   * @return Future(OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo)
   */
  def orgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, datasources: Option[List[String]] = None, step: Option[Integer] = None, archives: Option[List[String]] = None, `path`: Option[String] = None): Future[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo] = {
      helper.orgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporter(post, apply, delete, action, location, propertylist, datasources, step, archives, `path`)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mimeTypes  (optional)
   * @return OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo
   */
  def orgApacheSlingCommonsMimeInternalMimeTypeServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mimeTypes: Option[List[String]] = None): Option[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo] = {
    val await = Try(Await.result(orgApacheSlingCommonsMimeInternalMimeTypeServiceImplAsync(post, apply, delete, action, location, propertylist, mimeTypes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mimeTypes  (optional)
   * @return Future(OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo)
   */
  def orgApacheSlingCommonsMimeInternalMimeTypeServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mimeTypes: Option[List[String]] = None): Future[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo] = {
      helper.orgApacheSlingCommonsMimeInternalMimeTypeServiceImpl(post, apply, delete, action, location, propertylist, mimeTypes)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param poolName  (optional)
   * @param allowedPoolNames  (optional)
   * @param schedulerUseleaderforsingle  (optional)
   * @param metricsFilters  (optional)
   * @param slowThresholdMillis  (optional)
   * @return OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo
   */
  def orgApacheSlingCommonsSchedulerImplQuartzScheduler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, poolName: Option[String] = None, allowedPoolNames: Option[List[String]] = None, schedulerUseleaderforsingle: Option[Boolean] = None, metricsFilters: Option[List[String]] = None, slowThresholdMillis: Option[Integer] = None): Option[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo] = {
    val await = Try(Await.result(orgApacheSlingCommonsSchedulerImplQuartzSchedulerAsync(post, apply, delete, action, location, propertylist, poolName, allowedPoolNames, schedulerUseleaderforsingle, metricsFilters, slowThresholdMillis), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param poolName  (optional)
   * @param allowedPoolNames  (optional)
   * @param schedulerUseleaderforsingle  (optional)
   * @param metricsFilters  (optional)
   * @param slowThresholdMillis  (optional)
   * @return Future(OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo)
   */
  def orgApacheSlingCommonsSchedulerImplQuartzSchedulerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, poolName: Option[String] = None, allowedPoolNames: Option[List[String]] = None, schedulerUseleaderforsingle: Option[Boolean] = None, metricsFilters: Option[List[String]] = None, slowThresholdMillis: Option[Integer] = None): Future[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo] = {
      helper.orgApacheSlingCommonsSchedulerImplQuartzScheduler(post, apply, delete, action, location, propertylist, poolName, allowedPoolNames, schedulerUseleaderforsingle, metricsFilters, slowThresholdMillis)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxQuartzJobDurationAcceptable  (optional)
   * @return OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo
   */
  def orgApacheSlingCommonsSchedulerImplSchedulerHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxQuartzJobDurationAcceptable: Option[Integer] = None): Option[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo] = {
    val await = Try(Await.result(orgApacheSlingCommonsSchedulerImplSchedulerHealthCheckAsync(post, apply, delete, action, location, propertylist, maxQuartzJobDurationAcceptable), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxQuartzJobDurationAcceptable  (optional)
   * @return Future(OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo)
   */
  def orgApacheSlingCommonsSchedulerImplSchedulerHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxQuartzJobDurationAcceptable: Option[Integer] = None): Future[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo] = {
      helper.orgApacheSlingCommonsSchedulerImplSchedulerHealthCheck(post, apply, delete, action, location, propertylist, maxQuartzJobDurationAcceptable)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param minPoolSize  (optional)
   * @param maxPoolSize  (optional)
   * @param queueSize  (optional)
   * @param maxThreadAge  (optional)
   * @param keepAliveTime  (optional)
   * @param blockPolicy  (optional)
   * @param shutdownGraceful  (optional)
   * @param daemon  (optional)
   * @param shutdownWaitTime  (optional)
   * @param priority  (optional)
   * @return OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo
   */
  def orgApacheSlingCommonsThreadsImplDefaultThreadPoolFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, minPoolSize: Option[Integer] = None, maxPoolSize: Option[Integer] = None, queueSize: Option[Integer] = None, maxThreadAge: Option[Integer] = None, keepAliveTime: Option[Integer] = None, blockPolicy: Option[String] = None, shutdownGraceful: Option[Boolean] = None, daemon: Option[Boolean] = None, shutdownWaitTime: Option[Integer] = None, priority: Option[String] = None): Option[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo] = {
    val await = Try(Await.result(orgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryAsync(post, apply, delete, action, location, propertylist, name, minPoolSize, maxPoolSize, queueSize, maxThreadAge, keepAliveTime, blockPolicy, shutdownGraceful, daemon, shutdownWaitTime, priority), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param minPoolSize  (optional)
   * @param maxPoolSize  (optional)
   * @param queueSize  (optional)
   * @param maxThreadAge  (optional)
   * @param keepAliveTime  (optional)
   * @param blockPolicy  (optional)
   * @param shutdownGraceful  (optional)
   * @param daemon  (optional)
   * @param shutdownWaitTime  (optional)
   * @param priority  (optional)
   * @return Future(OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo)
   */
  def orgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, minPoolSize: Option[Integer] = None, maxPoolSize: Option[Integer] = None, queueSize: Option[Integer] = None, maxThreadAge: Option[Integer] = None, keepAliveTime: Option[Integer] = None, blockPolicy: Option[String] = None, shutdownGraceful: Option[Boolean] = None, daemon: Option[Boolean] = None, shutdownWaitTime: Option[Integer] = None, priority: Option[String] = None): Future[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo] = {
      helper.orgApacheSlingCommonsThreadsImplDefaultThreadPoolFactory(post, apply, delete, action, location, propertylist, name, minPoolSize, maxPoolSize, queueSize, maxThreadAge, keepAliveTime, blockPolicy, shutdownGraceful, daemon, shutdownWaitTime, priority)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param datasourceName  (optional)
   * @param datasourceSvcPropName  (optional)
   * @param driverClassName  (optional)
   * @param url  (optional)
   * @param username  (optional)
   * @param password  (optional)
   * @param defaultAutoCommit  (optional)
   * @param defaultReadOnly  (optional)
   * @param defaultTransactionIsolation  (optional)
   * @param defaultCatalog  (optional)
   * @param maxActive  (optional)
   * @param maxIdle  (optional)
   * @param minIdle  (optional)
   * @param initialSize  (optional)
   * @param maxWait  (optional)
   * @param maxAge  (optional)
   * @param testOnBorrow  (optional)
   * @param testOnReturn  (optional)
   * @param testWhileIdle  (optional)
   * @param validationQuery  (optional)
   * @param validationQueryTimeout  (optional)
   * @param timeBetweenEvictionRunsMillis  (optional)
   * @param minEvictableIdleTimeMillis  (optional)
   * @param connectionProperties  (optional)
   * @param initSQL  (optional)
   * @param jdbcInterceptors  (optional)
   * @param validationInterval  (optional)
   * @param logValidationErrors  (optional)
   * @param datasourceSvcProperties  (optional)
   * @return OrgApacheSlingDatasourceDataSourceFactoryInfo
   */
  def orgApacheSlingDatasourceDataSourceFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, datasourceName: Option[String] = None, datasourceSvcPropName: Option[String] = None, driverClassName: Option[String] = None, url: Option[String] = None, username: Option[String] = None, password: Option[String] = None, defaultAutoCommit: Option[String] = None, defaultReadOnly: Option[String] = None, defaultTransactionIsolation: Option[String] = None, defaultCatalog: Option[String] = None, maxActive: Option[Integer] = None, maxIdle: Option[Integer] = None, minIdle: Option[Integer] = None, initialSize: Option[Integer] = None, maxWait: Option[Integer] = None, maxAge: Option[Integer] = None, testOnBorrow: Option[Boolean] = None, testOnReturn: Option[Boolean] = None, testWhileIdle: Option[Boolean] = None, validationQuery: Option[String] = None, validationQueryTimeout: Option[Integer] = None, timeBetweenEvictionRunsMillis: Option[Integer] = None, minEvictableIdleTimeMillis: Option[Integer] = None, connectionProperties: Option[String] = None, initSQL: Option[String] = None, jdbcInterceptors: Option[String] = None, validationInterval: Option[Integer] = None, logValidationErrors: Option[Boolean] = None, datasourceSvcProperties: Option[List[String]] = None): Option[OrgApacheSlingDatasourceDataSourceFactoryInfo] = {
    val await = Try(Await.result(orgApacheSlingDatasourceDataSourceFactoryAsync(post, apply, delete, action, location, propertylist, datasourceName, datasourceSvcPropName, driverClassName, url, username, password, defaultAutoCommit, defaultReadOnly, defaultTransactionIsolation, defaultCatalog, maxActive, maxIdle, minIdle, initialSize, maxWait, maxAge, testOnBorrow, testOnReturn, testWhileIdle, validationQuery, validationQueryTimeout, timeBetweenEvictionRunsMillis, minEvictableIdleTimeMillis, connectionProperties, initSQL, jdbcInterceptors, validationInterval, logValidationErrors, datasourceSvcProperties), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param datasourceName  (optional)
   * @param datasourceSvcPropName  (optional)
   * @param driverClassName  (optional)
   * @param url  (optional)
   * @param username  (optional)
   * @param password  (optional)
   * @param defaultAutoCommit  (optional)
   * @param defaultReadOnly  (optional)
   * @param defaultTransactionIsolation  (optional)
   * @param defaultCatalog  (optional)
   * @param maxActive  (optional)
   * @param maxIdle  (optional)
   * @param minIdle  (optional)
   * @param initialSize  (optional)
   * @param maxWait  (optional)
   * @param maxAge  (optional)
   * @param testOnBorrow  (optional)
   * @param testOnReturn  (optional)
   * @param testWhileIdle  (optional)
   * @param validationQuery  (optional)
   * @param validationQueryTimeout  (optional)
   * @param timeBetweenEvictionRunsMillis  (optional)
   * @param minEvictableIdleTimeMillis  (optional)
   * @param connectionProperties  (optional)
   * @param initSQL  (optional)
   * @param jdbcInterceptors  (optional)
   * @param validationInterval  (optional)
   * @param logValidationErrors  (optional)
   * @param datasourceSvcProperties  (optional)
   * @return Future(OrgApacheSlingDatasourceDataSourceFactoryInfo)
   */
  def orgApacheSlingDatasourceDataSourceFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, datasourceName: Option[String] = None, datasourceSvcPropName: Option[String] = None, driverClassName: Option[String] = None, url: Option[String] = None, username: Option[String] = None, password: Option[String] = None, defaultAutoCommit: Option[String] = None, defaultReadOnly: Option[String] = None, defaultTransactionIsolation: Option[String] = None, defaultCatalog: Option[String] = None, maxActive: Option[Integer] = None, maxIdle: Option[Integer] = None, minIdle: Option[Integer] = None, initialSize: Option[Integer] = None, maxWait: Option[Integer] = None, maxAge: Option[Integer] = None, testOnBorrow: Option[Boolean] = None, testOnReturn: Option[Boolean] = None, testWhileIdle: Option[Boolean] = None, validationQuery: Option[String] = None, validationQueryTimeout: Option[Integer] = None, timeBetweenEvictionRunsMillis: Option[Integer] = None, minEvictableIdleTimeMillis: Option[Integer] = None, connectionProperties: Option[String] = None, initSQL: Option[String] = None, jdbcInterceptors: Option[String] = None, validationInterval: Option[Integer] = None, logValidationErrors: Option[Boolean] = None, datasourceSvcProperties: Option[List[String]] = None): Future[OrgApacheSlingDatasourceDataSourceFactoryInfo] = {
      helper.orgApacheSlingDatasourceDataSourceFactory(post, apply, delete, action, location, propertylist, datasourceName, datasourceSvcPropName, driverClassName, url, username, password, defaultAutoCommit, defaultReadOnly, defaultTransactionIsolation, defaultCatalog, maxActive, maxIdle, minIdle, initialSize, maxWait, maxAge, testOnBorrow, testOnReturn, testWhileIdle, validationQuery, validationQueryTimeout, timeBetweenEvictionRunsMillis, minEvictableIdleTimeMillis, connectionProperties, initSQL, jdbcInterceptors, validationInterval, logValidationErrors, datasourceSvcProperties)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param datasourceName  (optional)
   * @param datasourceSvcPropName  (optional)
   * @param datasourceJndiName  (optional)
   * @param jndiProperties  (optional)
   * @return OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo
   */
  def orgApacheSlingDatasourceJNDIDataSourceFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, datasourceName: Option[String] = None, datasourceSvcPropName: Option[String] = None, datasourceJndiName: Option[String] = None, jndiProperties: Option[List[String]] = None): Option[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo] = {
    val await = Try(Await.result(orgApacheSlingDatasourceJNDIDataSourceFactoryAsync(post, apply, delete, action, location, propertylist, datasourceName, datasourceSvcPropName, datasourceJndiName, jndiProperties), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param datasourceName  (optional)
   * @param datasourceSvcPropName  (optional)
   * @param datasourceJndiName  (optional)
   * @param jndiProperties  (optional)
   * @return Future(OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo)
   */
  def orgApacheSlingDatasourceJNDIDataSourceFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, datasourceName: Option[String] = None, datasourceSvcPropName: Option[String] = None, datasourceJndiName: Option[String] = None, jndiProperties: Option[List[String]] = None): Future[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo] = {
      helper.orgApacheSlingDatasourceJNDIDataSourceFactory(post, apply, delete, action, location, propertylist, datasourceName, datasourceSvcPropName, datasourceJndiName, jndiProperties)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param connectorPingTimeout  (optional)
   * @param connectorPingInterval  (optional)
   * @param discoveryLiteCheckInterval  (optional)
   * @param clusterSyncServiceTimeout  (optional)
   * @param clusterSyncServiceInterval  (optional)
   * @param enableSyncToken  (optional)
   * @param minEventDelay  (optional)
   * @param socketConnectTimeout  (optional)
   * @param soTimeout  (optional)
   * @param topologyConnectorUrls  (optional)
   * @param topologyConnectorWhitelist  (optional)
   * @param autoStopLocalLoopEnabled  (optional)
   * @param gzipConnectorRequestsEnabled  (optional)
   * @param hmacEnabled  (optional)
   * @param enableEncryption  (optional)
   * @param sharedKey  (optional)
   * @param hmacSharedKeyTTL  (optional)
   * @param backoffStandbyFactor  (optional)
   * @param backoffStableFactor  (optional)
   * @return OrgApacheSlingDiscoveryOakConfigInfo
   */
  def orgApacheSlingDiscoveryOakConfig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, connectorPingTimeout: Option[Integer] = None, connectorPingInterval: Option[Integer] = None, discoveryLiteCheckInterval: Option[Integer] = None, clusterSyncServiceTimeout: Option[Integer] = None, clusterSyncServiceInterval: Option[Integer] = None, enableSyncToken: Option[Boolean] = None, minEventDelay: Option[Integer] = None, socketConnectTimeout: Option[Integer] = None, soTimeout: Option[Integer] = None, topologyConnectorUrls: Option[List[String]] = None, topologyConnectorWhitelist: Option[List[String]] = None, autoStopLocalLoopEnabled: Option[Boolean] = None, gzipConnectorRequestsEnabled: Option[Boolean] = None, hmacEnabled: Option[Boolean] = None, enableEncryption: Option[Boolean] = None, sharedKey: Option[String] = None, hmacSharedKeyTTL: Option[Integer] = None, backoffStandbyFactor: Option[String] = None, backoffStableFactor: Option[String] = None): Option[OrgApacheSlingDiscoveryOakConfigInfo] = {
    val await = Try(Await.result(orgApacheSlingDiscoveryOakConfigAsync(post, apply, delete, action, location, propertylist, connectorPingTimeout, connectorPingInterval, discoveryLiteCheckInterval, clusterSyncServiceTimeout, clusterSyncServiceInterval, enableSyncToken, minEventDelay, socketConnectTimeout, soTimeout, topologyConnectorUrls, topologyConnectorWhitelist, autoStopLocalLoopEnabled, gzipConnectorRequestsEnabled, hmacEnabled, enableEncryption, sharedKey, hmacSharedKeyTTL, backoffStandbyFactor, backoffStableFactor), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param connectorPingTimeout  (optional)
   * @param connectorPingInterval  (optional)
   * @param discoveryLiteCheckInterval  (optional)
   * @param clusterSyncServiceTimeout  (optional)
   * @param clusterSyncServiceInterval  (optional)
   * @param enableSyncToken  (optional)
   * @param minEventDelay  (optional)
   * @param socketConnectTimeout  (optional)
   * @param soTimeout  (optional)
   * @param topologyConnectorUrls  (optional)
   * @param topologyConnectorWhitelist  (optional)
   * @param autoStopLocalLoopEnabled  (optional)
   * @param gzipConnectorRequestsEnabled  (optional)
   * @param hmacEnabled  (optional)
   * @param enableEncryption  (optional)
   * @param sharedKey  (optional)
   * @param hmacSharedKeyTTL  (optional)
   * @param backoffStandbyFactor  (optional)
   * @param backoffStableFactor  (optional)
   * @return Future(OrgApacheSlingDiscoveryOakConfigInfo)
   */
  def orgApacheSlingDiscoveryOakConfigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, connectorPingTimeout: Option[Integer] = None, connectorPingInterval: Option[Integer] = None, discoveryLiteCheckInterval: Option[Integer] = None, clusterSyncServiceTimeout: Option[Integer] = None, clusterSyncServiceInterval: Option[Integer] = None, enableSyncToken: Option[Boolean] = None, minEventDelay: Option[Integer] = None, socketConnectTimeout: Option[Integer] = None, soTimeout: Option[Integer] = None, topologyConnectorUrls: Option[List[String]] = None, topologyConnectorWhitelist: Option[List[String]] = None, autoStopLocalLoopEnabled: Option[Boolean] = None, gzipConnectorRequestsEnabled: Option[Boolean] = None, hmacEnabled: Option[Boolean] = None, enableEncryption: Option[Boolean] = None, sharedKey: Option[String] = None, hmacSharedKeyTTL: Option[Integer] = None, backoffStandbyFactor: Option[String] = None, backoffStableFactor: Option[String] = None): Future[OrgApacheSlingDiscoveryOakConfigInfo] = {
      helper.orgApacheSlingDiscoveryOakConfig(post, apply, delete, action, location, propertylist, connectorPingTimeout, connectorPingInterval, discoveryLiteCheckInterval, clusterSyncServiceTimeout, clusterSyncServiceInterval, enableSyncToken, minEventDelay, socketConnectTimeout, soTimeout, topologyConnectorUrls, topologyConnectorWhitelist, autoStopLocalLoopEnabled, gzipConnectorRequestsEnabled, hmacEnabled, enableEncryption, sharedKey, hmacSharedKeyTTL, backoffStandbyFactor, backoffStableFactor)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @return OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo
   */
  def orgApacheSlingDiscoveryOakSynchronizedClocksHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None): Option[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo] = {
    val await = Try(Await.result(orgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckAsync(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @return Future(OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo)
   */
  def orgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None): Future[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo] = {
      helper.orgApacheSlingDiscoveryOakSynchronizedClocksHealthCheck(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param title  (optional)
   * @param details  (optional)
   * @param enabled  (optional)
   * @param serviceName  (optional)
   * @param logLevel  (optional)
   * @param allowedRoots  (optional)
   * @param queueProcessingEnabled  (optional)
   * @param packageImporterEndpoints  (optional)
   * @param passiveQueues  (optional)
   * @param priorityQueues  (optional)
   * @param retryStrategy  (optional)
   * @param retryAttempts  (optional)
   * @param requestAuthorizationStrategyTarget  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @param packageBuilderTarget  (optional)
   * @param triggersTarget  (optional)
   * @param queueProvider  (optional)
   * @param asyncDelivery  (optional)
   * @param httpConnTimeout  (optional)
   * @return OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo
   */
  def orgApacheSlingDistributionAgentImplForwardDistributionAgentFacto(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, title: Option[String] = None, details: Option[String] = None, enabled: Option[Boolean] = None, serviceName: Option[String] = None, logLevel: Option[String] = None, allowedRoots: Option[List[String]] = None, queueProcessingEnabled: Option[Boolean] = None, packageImporterEndpoints: Option[List[String]] = None, passiveQueues: Option[List[String]] = None, priorityQueues: Option[List[String]] = None, retryStrategy: Option[String] = None, retryAttempts: Option[Integer] = None, requestAuthorizationStrategyTarget: Option[String] = None, transportSecretProviderTarget: Option[String] = None, packageBuilderTarget: Option[String] = None, triggersTarget: Option[String] = None, queueProvider: Option[String] = None, asyncDelivery: Option[Boolean] = None, httpConnTimeout: Option[Integer] = None): Option[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionAgentImplForwardDistributionAgentFactoAsync(post, apply, delete, action, location, propertylist, name, title, details, enabled, serviceName, logLevel, allowedRoots, queueProcessingEnabled, packageImporterEndpoints, passiveQueues, priorityQueues, retryStrategy, retryAttempts, requestAuthorizationStrategyTarget, transportSecretProviderTarget, packageBuilderTarget, triggersTarget, queueProvider, asyncDelivery, httpConnTimeout), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param title  (optional)
   * @param details  (optional)
   * @param enabled  (optional)
   * @param serviceName  (optional)
   * @param logLevel  (optional)
   * @param allowedRoots  (optional)
   * @param queueProcessingEnabled  (optional)
   * @param packageImporterEndpoints  (optional)
   * @param passiveQueues  (optional)
   * @param priorityQueues  (optional)
   * @param retryStrategy  (optional)
   * @param retryAttempts  (optional)
   * @param requestAuthorizationStrategyTarget  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @param packageBuilderTarget  (optional)
   * @param triggersTarget  (optional)
   * @param queueProvider  (optional)
   * @param asyncDelivery  (optional)
   * @param httpConnTimeout  (optional)
   * @return Future(OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo)
   */
  def orgApacheSlingDistributionAgentImplForwardDistributionAgentFactoAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, title: Option[String] = None, details: Option[String] = None, enabled: Option[Boolean] = None, serviceName: Option[String] = None, logLevel: Option[String] = None, allowedRoots: Option[List[String]] = None, queueProcessingEnabled: Option[Boolean] = None, packageImporterEndpoints: Option[List[String]] = None, passiveQueues: Option[List[String]] = None, priorityQueues: Option[List[String]] = None, retryStrategy: Option[String] = None, retryAttempts: Option[Integer] = None, requestAuthorizationStrategyTarget: Option[String] = None, transportSecretProviderTarget: Option[String] = None, packageBuilderTarget: Option[String] = None, triggersTarget: Option[String] = None, queueProvider: Option[String] = None, asyncDelivery: Option[Boolean] = None, httpConnTimeout: Option[Integer] = None): Future[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo] = {
      helper.orgApacheSlingDistributionAgentImplForwardDistributionAgentFacto(post, apply, delete, action, location, propertylist, name, title, details, enabled, serviceName, logLevel, allowedRoots, queueProcessingEnabled, packageImporterEndpoints, passiveQueues, priorityQueues, retryStrategy, retryAttempts, requestAuthorizationStrategyTarget, transportSecretProviderTarget, packageBuilderTarget, triggersTarget, queueProvider, asyncDelivery, httpConnTimeout)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param jcrPrivilege  (optional)
   * @return OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo
   */
  def orgApacheSlingDistributionAgentImplPrivilegeDistributionRequestA(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, jcrPrivilege: Option[String] = None): Option[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAAsync(post, apply, delete, action, location, propertylist, name, jcrPrivilege), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param jcrPrivilege  (optional)
   * @return Future(OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo)
   */
  def orgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, jcrPrivilege: Option[String] = None): Future[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo] = {
      helper.orgApacheSlingDistributionAgentImplPrivilegeDistributionRequestA(post, apply, delete, action, location, propertylist, name, jcrPrivilege)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param title  (optional)
   * @param details  (optional)
   * @param enabled  (optional)
   * @param serviceName  (optional)
   * @param logLevel  (optional)
   * @param allowedRoots  (optional)
   * @param requestAuthorizationStrategyTarget  (optional)
   * @param queueProviderFactoryTarget  (optional)
   * @param packageBuilderTarget  (optional)
   * @param triggersTarget  (optional)
   * @param priorityQueues  (optional)
   * @return OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo
   */
  def orgApacheSlingDistributionAgentImplQueueDistributionAgentFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, title: Option[String] = None, details: Option[String] = None, enabled: Option[Boolean] = None, serviceName: Option[String] = None, logLevel: Option[String] = None, allowedRoots: Option[List[String]] = None, requestAuthorizationStrategyTarget: Option[String] = None, queueProviderFactoryTarget: Option[String] = None, packageBuilderTarget: Option[String] = None, triggersTarget: Option[String] = None, priorityQueues: Option[List[String]] = None): Option[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryAsync(post, apply, delete, action, location, propertylist, name, title, details, enabled, serviceName, logLevel, allowedRoots, requestAuthorizationStrategyTarget, queueProviderFactoryTarget, packageBuilderTarget, triggersTarget, priorityQueues), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param title  (optional)
   * @param details  (optional)
   * @param enabled  (optional)
   * @param serviceName  (optional)
   * @param logLevel  (optional)
   * @param allowedRoots  (optional)
   * @param requestAuthorizationStrategyTarget  (optional)
   * @param queueProviderFactoryTarget  (optional)
   * @param packageBuilderTarget  (optional)
   * @param triggersTarget  (optional)
   * @param priorityQueues  (optional)
   * @return Future(OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo)
   */
  def orgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, title: Option[String] = None, details: Option[String] = None, enabled: Option[Boolean] = None, serviceName: Option[String] = None, logLevel: Option[String] = None, allowedRoots: Option[List[String]] = None, requestAuthorizationStrategyTarget: Option[String] = None, queueProviderFactoryTarget: Option[String] = None, packageBuilderTarget: Option[String] = None, triggersTarget: Option[String] = None, priorityQueues: Option[List[String]] = None): Future[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo] = {
      helper.orgApacheSlingDistributionAgentImplQueueDistributionAgentFactory(post, apply, delete, action, location, propertylist, name, title, details, enabled, serviceName, logLevel, allowedRoots, requestAuthorizationStrategyTarget, queueProviderFactoryTarget, packageBuilderTarget, triggersTarget, priorityQueues)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param title  (optional)
   * @param details  (optional)
   * @param enabled  (optional)
   * @param serviceName  (optional)
   * @param logLevel  (optional)
   * @param queueProcessingEnabled  (optional)
   * @param packageExporterEndpoints  (optional)
   * @param pullItems  (optional)
   * @param httpConnTimeout  (optional)
   * @param requestAuthorizationStrategyTarget  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @param packageBuilderTarget  (optional)
   * @param triggersTarget  (optional)
   * @return OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo
   */
  def orgApacheSlingDistributionAgentImplReverseDistributionAgentFacto(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, title: Option[String] = None, details: Option[String] = None, enabled: Option[Boolean] = None, serviceName: Option[String] = None, logLevel: Option[String] = None, queueProcessingEnabled: Option[Boolean] = None, packageExporterEndpoints: Option[List[String]] = None, pullItems: Option[Integer] = None, httpConnTimeout: Option[Integer] = None, requestAuthorizationStrategyTarget: Option[String] = None, transportSecretProviderTarget: Option[String] = None, packageBuilderTarget: Option[String] = None, triggersTarget: Option[String] = None): Option[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionAgentImplReverseDistributionAgentFactoAsync(post, apply, delete, action, location, propertylist, name, title, details, enabled, serviceName, logLevel, queueProcessingEnabled, packageExporterEndpoints, pullItems, httpConnTimeout, requestAuthorizationStrategyTarget, transportSecretProviderTarget, packageBuilderTarget, triggersTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param title  (optional)
   * @param details  (optional)
   * @param enabled  (optional)
   * @param serviceName  (optional)
   * @param logLevel  (optional)
   * @param queueProcessingEnabled  (optional)
   * @param packageExporterEndpoints  (optional)
   * @param pullItems  (optional)
   * @param httpConnTimeout  (optional)
   * @param requestAuthorizationStrategyTarget  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @param packageBuilderTarget  (optional)
   * @param triggersTarget  (optional)
   * @return Future(OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo)
   */
  def orgApacheSlingDistributionAgentImplReverseDistributionAgentFactoAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, title: Option[String] = None, details: Option[String] = None, enabled: Option[Boolean] = None, serviceName: Option[String] = None, logLevel: Option[String] = None, queueProcessingEnabled: Option[Boolean] = None, packageExporterEndpoints: Option[List[String]] = None, pullItems: Option[Integer] = None, httpConnTimeout: Option[Integer] = None, requestAuthorizationStrategyTarget: Option[String] = None, transportSecretProviderTarget: Option[String] = None, packageBuilderTarget: Option[String] = None, triggersTarget: Option[String] = None): Future[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo] = {
      helper.orgApacheSlingDistributionAgentImplReverseDistributionAgentFacto(post, apply, delete, action, location, propertylist, name, title, details, enabled, serviceName, logLevel, queueProcessingEnabled, packageExporterEndpoints, pullItems, httpConnTimeout, requestAuthorizationStrategyTarget, transportSecretProviderTarget, packageBuilderTarget, triggersTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param title  (optional)
   * @param details  (optional)
   * @param enabled  (optional)
   * @param serviceName  (optional)
   * @param logLevel  (optional)
   * @param queueProcessingEnabled  (optional)
   * @param packageExporterTarget  (optional)
   * @param packageImporterTarget  (optional)
   * @param requestAuthorizationStrategyTarget  (optional)
   * @param triggersTarget  (optional)
   * @return OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo
   */
  def orgApacheSlingDistributionAgentImplSimpleDistributionAgentFactor(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, title: Option[String] = None, details: Option[String] = None, enabled: Option[Boolean] = None, serviceName: Option[String] = None, logLevel: Option[String] = None, queueProcessingEnabled: Option[Boolean] = None, packageExporterTarget: Option[String] = None, packageImporterTarget: Option[String] = None, requestAuthorizationStrategyTarget: Option[String] = None, triggersTarget: Option[String] = None): Option[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorAsync(post, apply, delete, action, location, propertylist, name, title, details, enabled, serviceName, logLevel, queueProcessingEnabled, packageExporterTarget, packageImporterTarget, requestAuthorizationStrategyTarget, triggersTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param title  (optional)
   * @param details  (optional)
   * @param enabled  (optional)
   * @param serviceName  (optional)
   * @param logLevel  (optional)
   * @param queueProcessingEnabled  (optional)
   * @param packageExporterTarget  (optional)
   * @param packageImporterTarget  (optional)
   * @param requestAuthorizationStrategyTarget  (optional)
   * @param triggersTarget  (optional)
   * @return Future(OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo)
   */
  def orgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, title: Option[String] = None, details: Option[String] = None, enabled: Option[Boolean] = None, serviceName: Option[String] = None, logLevel: Option[String] = None, queueProcessingEnabled: Option[Boolean] = None, packageExporterTarget: Option[String] = None, packageImporterTarget: Option[String] = None, requestAuthorizationStrategyTarget: Option[String] = None, triggersTarget: Option[String] = None): Future[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo] = {
      helper.orgApacheSlingDistributionAgentImplSimpleDistributionAgentFactor(post, apply, delete, action, location, propertylist, name, title, details, enabled, serviceName, logLevel, queueProcessingEnabled, packageExporterTarget, packageImporterTarget, requestAuthorizationStrategyTarget, triggersTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param title  (optional)
   * @param details  (optional)
   * @param enabled  (optional)
   * @param serviceName  (optional)
   * @param logLevel  (optional)
   * @param queueProcessingEnabled  (optional)
   * @param passiveQueues  (optional)
   * @param packageExporterEndpoints  (optional)
   * @param packageImporterEndpoints  (optional)
   * @param retryStrategy  (optional)
   * @param retryAttempts  (optional)
   * @param pullItems  (optional)
   * @param httpConnTimeout  (optional)
   * @param requestAuthorizationStrategyTarget  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @param packageBuilderTarget  (optional)
   * @param triggersTarget  (optional)
   * @return OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo
   */
  def orgApacheSlingDistributionAgentImplSyncDistributionAgentFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, title: Option[String] = None, details: Option[String] = None, enabled: Option[Boolean] = None, serviceName: Option[String] = None, logLevel: Option[String] = None, queueProcessingEnabled: Option[Boolean] = None, passiveQueues: Option[List[String]] = None, packageExporterEndpoints: Option[List[String]] = None, packageImporterEndpoints: Option[List[String]] = None, retryStrategy: Option[String] = None, retryAttempts: Option[Integer] = None, pullItems: Option[Integer] = None, httpConnTimeout: Option[Integer] = None, requestAuthorizationStrategyTarget: Option[String] = None, transportSecretProviderTarget: Option[String] = None, packageBuilderTarget: Option[String] = None, triggersTarget: Option[String] = None): Option[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryAsync(post, apply, delete, action, location, propertylist, name, title, details, enabled, serviceName, logLevel, queueProcessingEnabled, passiveQueues, packageExporterEndpoints, packageImporterEndpoints, retryStrategy, retryAttempts, pullItems, httpConnTimeout, requestAuthorizationStrategyTarget, transportSecretProviderTarget, packageBuilderTarget, triggersTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param title  (optional)
   * @param details  (optional)
   * @param enabled  (optional)
   * @param serviceName  (optional)
   * @param logLevel  (optional)
   * @param queueProcessingEnabled  (optional)
   * @param passiveQueues  (optional)
   * @param packageExporterEndpoints  (optional)
   * @param packageImporterEndpoints  (optional)
   * @param retryStrategy  (optional)
   * @param retryAttempts  (optional)
   * @param pullItems  (optional)
   * @param httpConnTimeout  (optional)
   * @param requestAuthorizationStrategyTarget  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @param packageBuilderTarget  (optional)
   * @param triggersTarget  (optional)
   * @return Future(OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo)
   */
  def orgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, title: Option[String] = None, details: Option[String] = None, enabled: Option[Boolean] = None, serviceName: Option[String] = None, logLevel: Option[String] = None, queueProcessingEnabled: Option[Boolean] = None, passiveQueues: Option[List[String]] = None, packageExporterEndpoints: Option[List[String]] = None, packageImporterEndpoints: Option[List[String]] = None, retryStrategy: Option[String] = None, retryAttempts: Option[Integer] = None, pullItems: Option[Integer] = None, httpConnTimeout: Option[Integer] = None, requestAuthorizationStrategyTarget: Option[String] = None, transportSecretProviderTarget: Option[String] = None, packageBuilderTarget: Option[String] = None, triggersTarget: Option[String] = None): Future[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo] = {
      helper.orgApacheSlingDistributionAgentImplSyncDistributionAgentFactory(post, apply, delete, action, location, propertylist, name, title, details, enabled, serviceName, logLevel, queueProcessingEnabled, passiveQueues, packageExporterEndpoints, packageImporterEndpoints, retryStrategy, retryAttempts, pullItems, httpConnTimeout, requestAuthorizationStrategyTarget, transportSecretProviderTarget, packageBuilderTarget, triggersTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @param numberOfRetriesAllowed  (optional)
   * @return OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo
   */
  def orgApacheSlingDistributionMonitorDistributionQueueHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None, numberOfRetriesAllowed: Option[Integer] = None): Option[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionMonitorDistributionQueueHealthCheckAsync(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName, numberOfRetriesAllowed), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @param numberOfRetriesAllowed  (optional)
   * @return Future(OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo)
   */
  def orgApacheSlingDistributionMonitorDistributionQueueHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None, numberOfRetriesAllowed: Option[Integer] = None): Future[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo] = {
      helper.orgApacheSlingDistributionMonitorDistributionQueueHealthCheck(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName, numberOfRetriesAllowed)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param queue  (optional)
   * @param dropInvalidItems  (optional)
   * @param agentTarget  (optional)
   * @return OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo
   */
  def orgApacheSlingDistributionPackagingImplExporterAgentDistributio(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, queue: Option[String] = None, dropInvalidItems: Option[Boolean] = None, agentTarget: Option[String] = None): Option[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionPackagingImplExporterAgentDistributioAsync(post, apply, delete, action, location, propertylist, name, queue, dropInvalidItems, agentTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param queue  (optional)
   * @param dropInvalidItems  (optional)
   * @param agentTarget  (optional)
   * @return Future(OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo)
   */
  def orgApacheSlingDistributionPackagingImplExporterAgentDistributioAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, queue: Option[String] = None, dropInvalidItems: Option[Boolean] = None, agentTarget: Option[String] = None): Future[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo] = {
      helper.orgApacheSlingDistributionPackagingImplExporterAgentDistributio(post, apply, delete, action, location, propertylist, name, queue, dropInvalidItems, agentTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param packageBuilderTarget  (optional)
   * @return OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo
   */
  def orgApacheSlingDistributionPackagingImplExporterLocalDistributio(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, packageBuilderTarget: Option[String] = None): Option[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionPackagingImplExporterLocalDistributioAsync(post, apply, delete, action, location, propertylist, name, packageBuilderTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param packageBuilderTarget  (optional)
   * @return Future(OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo)
   */
  def orgApacheSlingDistributionPackagingImplExporterLocalDistributioAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, packageBuilderTarget: Option[String] = None): Future[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo] = {
      helper.orgApacheSlingDistributionPackagingImplExporterLocalDistributio(post, apply, delete, action, location, propertylist, name, packageBuilderTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param endpoints  (optional)
   * @param pullItems  (optional)
   * @param packageBuilderTarget  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @return OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo
   */
  def orgApacheSlingDistributionPackagingImplExporterRemoteDistributi(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, endpoints: Option[List[String]] = None, pullItems: Option[Integer] = None, packageBuilderTarget: Option[String] = None, transportSecretProviderTarget: Option[String] = None): Option[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionPackagingImplExporterRemoteDistributiAsync(post, apply, delete, action, location, propertylist, name, endpoints, pullItems, packageBuilderTarget, transportSecretProviderTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param endpoints  (optional)
   * @param pullItems  (optional)
   * @param packageBuilderTarget  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @return Future(OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo)
   */
  def orgApacheSlingDistributionPackagingImplExporterRemoteDistributiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, endpoints: Option[List[String]] = None, pullItems: Option[Integer] = None, packageBuilderTarget: Option[String] = None, transportSecretProviderTarget: Option[String] = None): Future[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo] = {
      helper.orgApacheSlingDistributionPackagingImplExporterRemoteDistributi(post, apply, delete, action, location, propertylist, name, endpoints, pullItems, packageBuilderTarget, transportSecretProviderTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param packageBuilderTarget  (optional)
   * @return OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo
   */
  def orgApacheSlingDistributionPackagingImplImporterLocalDistributio(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, packageBuilderTarget: Option[String] = None): Option[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionPackagingImplImporterLocalDistributioAsync(post, apply, delete, action, location, propertylist, name, packageBuilderTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param packageBuilderTarget  (optional)
   * @return Future(OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo)
   */
  def orgApacheSlingDistributionPackagingImplImporterLocalDistributioAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, packageBuilderTarget: Option[String] = None): Future[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo] = {
      helper.orgApacheSlingDistributionPackagingImplImporterLocalDistributio(post, apply, delete, action, location, propertylist, name, packageBuilderTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param endpoints  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @return OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo
   */
  def orgApacheSlingDistributionPackagingImplImporterRemoteDistributi(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, endpoints: Option[List[String]] = None, transportSecretProviderTarget: Option[String] = None): Option[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionPackagingImplImporterRemoteDistributiAsync(post, apply, delete, action, location, propertylist, name, endpoints, transportSecretProviderTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param endpoints  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @return Future(OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo)
   */
  def orgApacheSlingDistributionPackagingImplImporterRemoteDistributiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, endpoints: Option[List[String]] = None, transportSecretProviderTarget: Option[String] = None): Future[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo] = {
      helper.orgApacheSlingDistributionPackagingImplImporterRemoteDistributi(post, apply, delete, action, location, propertylist, name, endpoints, transportSecretProviderTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param serviceName  (optional)
   * @param `path`  (optional)
   * @param privilegeName  (optional)
   * @return OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo
   */
  def orgApacheSlingDistributionPackagingImplImporterRepositoryDistri(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, serviceName: Option[String] = None, `path`: Option[String] = None, privilegeName: Option[String] = None): Option[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionPackagingImplImporterRepositoryDistriAsync(post, apply, delete, action, location, propertylist, name, serviceName, `path`, privilegeName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param serviceName  (optional)
   * @param `path`  (optional)
   * @param privilegeName  (optional)
   * @return Future(OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo)
   */
  def orgApacheSlingDistributionPackagingImplImporterRepositoryDistriAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, serviceName: Option[String] = None, `path`: Option[String] = None, privilegeName: Option[String] = None): Future[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo] = {
      helper.orgApacheSlingDistributionPackagingImplImporterRepositoryDistri(post, apply, delete, action, location, propertylist, name, serviceName, `path`, privilegeName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerRoots  (optional)
   * @param kind  (optional)
   * @return OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo
   */
  def orgApacheSlingDistributionResourcesImplDistributionConfiguration(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerRoots: Option[String] = None, kind: Option[String] = None): Option[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionResourcesImplDistributionConfigurationAsync(post, apply, delete, action, location, propertylist, providerRoots, kind), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerRoots  (optional)
   * @param kind  (optional)
   * @return Future(OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo)
   */
  def orgApacheSlingDistributionResourcesImplDistributionConfigurationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerRoots: Option[String] = None, kind: Option[String] = None): Future[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo] = {
      helper.orgApacheSlingDistributionResourcesImplDistributionConfiguration(post, apply, delete, action, location, propertylist, providerRoots, kind)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerRoots  (optional)
   * @param kind  (optional)
   * @return OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo
   */
  def orgApacheSlingDistributionResourcesImplDistributionServiceResour(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerRoots: Option[String] = None, kind: Option[String] = None): Option[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionResourcesImplDistributionServiceResourAsync(post, apply, delete, action, location, propertylist, providerRoots, kind), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerRoots  (optional)
   * @param kind  (optional)
   * @return Future(OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo)
   */
  def orgApacheSlingDistributionResourcesImplDistributionServiceResourAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerRoots: Option[String] = None, kind: Option[String] = None): Future[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo] = {
      helper.orgApacheSlingDistributionResourcesImplDistributionServiceResour(post, apply, delete, action, location, propertylist, providerRoots, kind)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `type`  (optional)
   * @param formatTarget  (optional)
   * @param tempFsFolder  (optional)
   * @param fileThreshold  (optional)
   * @param memoryUnit  (optional)
   * @param useOffHeapMemory  (optional)
   * @param digestAlgorithm  (optional)
   * @param monitoringQueueSize  (optional)
   * @param cleanupDelay  (optional)
   * @param packageFilters  (optional)
   * @param propertyFilters  (optional)
   * @return OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo
   */
  def orgApacheSlingDistributionSerializationImplDistributionPackageBu(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `type`: Option[String] = None, formatTarget: Option[String] = None, tempFsFolder: Option[String] = None, fileThreshold: Option[Integer] = None, memoryUnit: Option[String] = None, useOffHeapMemory: Option[Boolean] = None, digestAlgorithm: Option[String] = None, monitoringQueueSize: Option[Integer] = None, cleanupDelay: Option[Integer] = None, packageFilters: Option[List[String]] = None, propertyFilters: Option[List[String]] = None): Option[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionSerializationImplDistributionPackageBuAsync(post, apply, delete, action, location, propertylist, name, `type`, formatTarget, tempFsFolder, fileThreshold, memoryUnit, useOffHeapMemory, digestAlgorithm, monitoringQueueSize, cleanupDelay, packageFilters, propertyFilters), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `type`  (optional)
   * @param formatTarget  (optional)
   * @param tempFsFolder  (optional)
   * @param fileThreshold  (optional)
   * @param memoryUnit  (optional)
   * @param useOffHeapMemory  (optional)
   * @param digestAlgorithm  (optional)
   * @param monitoringQueueSize  (optional)
   * @param cleanupDelay  (optional)
   * @param packageFilters  (optional)
   * @param propertyFilters  (optional)
   * @return Future(OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo)
   */
  def orgApacheSlingDistributionSerializationImplDistributionPackageBuAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `type`: Option[String] = None, formatTarget: Option[String] = None, tempFsFolder: Option[String] = None, fileThreshold: Option[Integer] = None, memoryUnit: Option[String] = None, useOffHeapMemory: Option[Boolean] = None, digestAlgorithm: Option[String] = None, monitoringQueueSize: Option[Integer] = None, cleanupDelay: Option[Integer] = None, packageFilters: Option[List[String]] = None, propertyFilters: Option[List[String]] = None): Future[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo] = {
      helper.orgApacheSlingDistributionSerializationImplDistributionPackageBu(post, apply, delete, action, location, propertylist, name, `type`, formatTarget, tempFsFolder, fileThreshold, memoryUnit, useOffHeapMemory, digestAlgorithm, monitoringQueueSize, cleanupDelay, packageFilters, propertyFilters)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `type`  (optional)
   * @param importMode  (optional)
   * @param aclHandling  (optional)
   * @param packageRoots  (optional)
   * @param packageFilters  (optional)
   * @param propertyFilters  (optional)
   * @param tempFsFolder  (optional)
   * @param useBinaryReferences  (optional)
   * @param autoSaveThreshold  (optional)
   * @param cleanupDelay  (optional)
   * @param fileThreshold  (optional)
   * @param MEGA_BYTES  (optional)
   * @param useOffHeapMemory  (optional)
   * @param digestAlgorithm  (optional)
   * @param monitoringQueueSize  (optional)
   * @param pathsMapping  (optional)
   * @param strictImport  (optional)
   * @return OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo
   */
  def orgApacheSlingDistributionSerializationImplVltVaultDistribution(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `type`: Option[String] = None, importMode: Option[String] = None, aclHandling: Option[String] = None, packageRoots: Option[String] = None, packageFilters: Option[List[String]] = None, propertyFilters: Option[List[String]] = None, tempFsFolder: Option[String] = None, useBinaryReferences: Option[Boolean] = None, autoSaveThreshold: Option[Integer] = None, cleanupDelay: Option[Integer] = None, fileThreshold: Option[Integer] = None, MEGA_BYTES: Option[String] = None, useOffHeapMemory: Option[Boolean] = None, digestAlgorithm: Option[String] = None, monitoringQueueSize: Option[Integer] = None, pathsMapping: Option[List[String]] = None, strictImport: Option[Boolean] = None): Option[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionSerializationImplVltVaultDistributionAsync(post, apply, delete, action, location, propertylist, name, `type`, importMode, aclHandling, packageRoots, packageFilters, propertyFilters, tempFsFolder, useBinaryReferences, autoSaveThreshold, cleanupDelay, fileThreshold, MEGA_BYTES, useOffHeapMemory, digestAlgorithm, monitoringQueueSize, pathsMapping, strictImport), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `type`  (optional)
   * @param importMode  (optional)
   * @param aclHandling  (optional)
   * @param packageRoots  (optional)
   * @param packageFilters  (optional)
   * @param propertyFilters  (optional)
   * @param tempFsFolder  (optional)
   * @param useBinaryReferences  (optional)
   * @param autoSaveThreshold  (optional)
   * @param cleanupDelay  (optional)
   * @param fileThreshold  (optional)
   * @param MEGA_BYTES  (optional)
   * @param useOffHeapMemory  (optional)
   * @param digestAlgorithm  (optional)
   * @param monitoringQueueSize  (optional)
   * @param pathsMapping  (optional)
   * @param strictImport  (optional)
   * @return Future(OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo)
   */
  def orgApacheSlingDistributionSerializationImplVltVaultDistributionAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `type`: Option[String] = None, importMode: Option[String] = None, aclHandling: Option[String] = None, packageRoots: Option[String] = None, packageFilters: Option[List[String]] = None, propertyFilters: Option[List[String]] = None, tempFsFolder: Option[String] = None, useBinaryReferences: Option[Boolean] = None, autoSaveThreshold: Option[Integer] = None, cleanupDelay: Option[Integer] = None, fileThreshold: Option[Integer] = None, MEGA_BYTES: Option[String] = None, useOffHeapMemory: Option[Boolean] = None, digestAlgorithm: Option[String] = None, monitoringQueueSize: Option[Integer] = None, pathsMapping: Option[List[String]] = None, strictImport: Option[Boolean] = None): Future[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo] = {
      helper.orgApacheSlingDistributionSerializationImplVltVaultDistribution(post, apply, delete, action, location, propertylist, name, `type`, importMode, aclHandling, packageRoots, packageFilters, propertyFilters, tempFsFolder, useBinaryReferences, autoSaveThreshold, cleanupDelay, fileThreshold, MEGA_BYTES, useOffHeapMemory, digestAlgorithm, monitoringQueueSize, pathsMapping, strictImport)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param username  (optional)
   * @param password  (optional)
   * @return OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo
   */
  def orgApacheSlingDistributionTransportImplUserCredentialsDistributi(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, username: Option[String] = None, password: Option[String] = None): Option[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionTransportImplUserCredentialsDistributiAsync(post, apply, delete, action, location, propertylist, name, username, password), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param username  (optional)
   * @param password  (optional)
   * @return Future(OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo)
   */
  def orgApacheSlingDistributionTransportImplUserCredentialsDistributiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, username: Option[String] = None, password: Option[String] = None): Future[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo] = {
      helper.orgApacheSlingDistributionTransportImplUserCredentialsDistributi(post, apply, delete, action, location, propertylist, name, username, password)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `path`  (optional)
   * @return OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo
   */
  def orgApacheSlingDistributionTriggerImplDistributionEventDistribute(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `path`: Option[String] = None): Option[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionTriggerImplDistributionEventDistributeAsync(post, apply, delete, action, location, propertylist, name, `path`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `path`  (optional)
   * @return Future(OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo)
   */
  def orgApacheSlingDistributionTriggerImplDistributionEventDistributeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `path`: Option[String] = None): Future[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo] = {
      helper.orgApacheSlingDistributionTriggerImplDistributionEventDistribute(post, apply, delete, action, location, propertylist, name, `path`)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `path`  (optional)
   * @param ignoredPathsPatterns  (optional)
   * @param serviceName  (optional)
   * @param deep  (optional)
   * @return OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo
   */
  def orgApacheSlingDistributionTriggerImplJcrEventDistributionTrigger(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `path`: Option[String] = None, ignoredPathsPatterns: Option[List[String]] = None, serviceName: Option[String] = None, deep: Option[Boolean] = None): Option[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerAsync(post, apply, delete, action, location, propertylist, name, `path`, ignoredPathsPatterns, serviceName, deep), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `path`  (optional)
   * @param ignoredPathsPatterns  (optional)
   * @param serviceName  (optional)
   * @param deep  (optional)
   * @return Future(OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo)
   */
  def orgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `path`: Option[String] = None, ignoredPathsPatterns: Option[List[String]] = None, serviceName: Option[String] = None, deep: Option[Boolean] = None): Future[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo] = {
      helper.orgApacheSlingDistributionTriggerImplJcrEventDistributionTrigger(post, apply, delete, action, location, propertylist, name, `path`, ignoredPathsPatterns, serviceName, deep)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `path`  (optional)
   * @param serviceName  (optional)
   * @param nuggetsPath  (optional)
   * @return OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo
   */
  def orgApacheSlingDistributionTriggerImplPersistedJcrEventDistributi(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `path`: Option[String] = None, serviceName: Option[String] = None, nuggetsPath: Option[String] = None): Option[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiAsync(post, apply, delete, action, location, propertylist, name, `path`, serviceName, nuggetsPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `path`  (optional)
   * @param serviceName  (optional)
   * @param nuggetsPath  (optional)
   * @return Future(OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo)
   */
  def orgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `path`: Option[String] = None, serviceName: Option[String] = None, nuggetsPath: Option[String] = None): Future[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo] = {
      helper.orgApacheSlingDistributionTriggerImplPersistedJcrEventDistributi(post, apply, delete, action, location, propertylist, name, `path`, serviceName, nuggetsPath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param endpoint  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @return OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo
   */
  def orgApacheSlingDistributionTriggerImplRemoteEventDistributionTrig(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, endpoint: Option[String] = None, transportSecretProviderTarget: Option[String] = None): Option[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigAsync(post, apply, delete, action, location, propertylist, name, endpoint, transportSecretProviderTarget), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param endpoint  (optional)
   * @param transportSecretProviderTarget  (optional)
   * @return Future(OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo)
   */
  def orgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, endpoint: Option[String] = None, transportSecretProviderTarget: Option[String] = None): Future[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo] = {
      helper.orgApacheSlingDistributionTriggerImplRemoteEventDistributionTrig(post, apply, delete, action, location, propertylist, name, endpoint, transportSecretProviderTarget)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `path`  (optional)
   * @return OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo
   */
  def orgApacheSlingDistributionTriggerImplResourceEventDistributionTr(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `path`: Option[String] = None): Option[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionTriggerImplResourceEventDistributionTrAsync(post, apply, delete, action, location, propertylist, name, `path`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `path`  (optional)
   * @return Future(OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo)
   */
  def orgApacheSlingDistributionTriggerImplResourceEventDistributionTrAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `path`: Option[String] = None): Future[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo] = {
      helper.orgApacheSlingDistributionTriggerImplResourceEventDistributionTr(post, apply, delete, action, location, propertylist, name, `path`)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `path`  (optional)
   * @param seconds  (optional)
   * @param serviceName  (optional)
   * @return OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo
   */
  def orgApacheSlingDistributionTriggerImplScheduledDistributionTrigge(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `path`: Option[String] = None, seconds: Option[String] = None, serviceName: Option[String] = None): Option[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo] = {
    val await = Try(Await.result(orgApacheSlingDistributionTriggerImplScheduledDistributionTriggeAsync(post, apply, delete, action, location, propertylist, name, `path`, seconds, serviceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param `path`  (optional)
   * @param seconds  (optional)
   * @param serviceName  (optional)
   * @return Future(OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo)
   */
  def orgApacheSlingDistributionTriggerImplScheduledDistributionTriggeAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, `path`: Option[String] = None, seconds: Option[String] = None, serviceName: Option[String] = None): Future[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo] = {
      helper.orgApacheSlingDistributionTriggerImplScheduledDistributionTrigge(post, apply, delete, action, location, propertylist, name, `path`, seconds, serviceName)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param osgiHttpWhiteboardContextSelect  (optional)
   * @param osgiHttpWhiteboardListener  (optional)
   * @param authSudoCookie  (optional)
   * @param authSudoParameter  (optional)
   * @param authAnnonymous  (optional)
   * @param slingAuthRequirements  (optional)
   * @param slingAuthAnonymousUser  (optional)
   * @param slingAuthAnonymousPassword  (optional)
   * @param authHttp  (optional)
   * @param authHttpRealm  (optional)
   * @param authUriSuffix  (optional)
   * @return OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo
   */
  def orgApacheSlingEngineImplAuthSlingAuthenticator(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, osgiHttpWhiteboardContextSelect: Option[String] = None, osgiHttpWhiteboardListener: Option[String] = None, authSudoCookie: Option[String] = None, authSudoParameter: Option[String] = None, authAnnonymous: Option[Boolean] = None, slingAuthRequirements: Option[List[String]] = None, slingAuthAnonymousUser: Option[String] = None, slingAuthAnonymousPassword: Option[String] = None, authHttp: Option[String] = None, authHttpRealm: Option[String] = None, authUriSuffix: Option[List[String]] = None): Option[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo] = {
    val await = Try(Await.result(orgApacheSlingEngineImplAuthSlingAuthenticatorAsync(post, apply, delete, action, location, propertylist, osgiHttpWhiteboardContextSelect, osgiHttpWhiteboardListener, authSudoCookie, authSudoParameter, authAnnonymous, slingAuthRequirements, slingAuthAnonymousUser, slingAuthAnonymousPassword, authHttp, authHttpRealm, authUriSuffix), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param osgiHttpWhiteboardContextSelect  (optional)
   * @param osgiHttpWhiteboardListener  (optional)
   * @param authSudoCookie  (optional)
   * @param authSudoParameter  (optional)
   * @param authAnnonymous  (optional)
   * @param slingAuthRequirements  (optional)
   * @param slingAuthAnonymousUser  (optional)
   * @param slingAuthAnonymousPassword  (optional)
   * @param authHttp  (optional)
   * @param authHttpRealm  (optional)
   * @param authUriSuffix  (optional)
   * @return Future(OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo)
   */
  def orgApacheSlingEngineImplAuthSlingAuthenticatorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, osgiHttpWhiteboardContextSelect: Option[String] = None, osgiHttpWhiteboardListener: Option[String] = None, authSudoCookie: Option[String] = None, authSudoParameter: Option[String] = None, authAnnonymous: Option[Boolean] = None, slingAuthRequirements: Option[List[String]] = None, slingAuthAnonymousUser: Option[String] = None, slingAuthAnonymousPassword: Option[String] = None, authHttp: Option[String] = None, authHttpRealm: Option[String] = None, authUriSuffix: Option[List[String]] = None): Future[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo] = {
      helper.orgApacheSlingEngineImplAuthSlingAuthenticator(post, apply, delete, action, location, propertylist, osgiHttpWhiteboardContextSelect, osgiHttpWhiteboardListener, authSudoCookie, authSudoParameter, authAnnonymous, slingAuthRequirements, slingAuthAnonymousUser, slingAuthAnonymousPassword, authHttp, authHttpRealm, authUriSuffix)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param extensions  (optional)
   * @param minDurationMs  (optional)
   * @param maxDurationMs  (optional)
   * @param compactLogFormat  (optional)
   * @return OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo
   */
  def orgApacheSlingEngineImplDebugRequestProgressTrackerLogFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, extensions: Option[List[String]] = None, minDurationMs: Option[Integer] = None, maxDurationMs: Option[Integer] = None, compactLogFormat: Option[Boolean] = None): Option[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo] = {
    val await = Try(Await.result(orgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterAsync(post, apply, delete, action, location, propertylist, extensions, minDurationMs, maxDurationMs, compactLogFormat), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param extensions  (optional)
   * @param minDurationMs  (optional)
   * @param maxDurationMs  (optional)
   * @param compactLogFormat  (optional)
   * @return Future(OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo)
   */
  def orgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, extensions: Option[List[String]] = None, minDurationMs: Option[Integer] = None, maxDurationMs: Option[Integer] = None, compactLogFormat: Option[Boolean] = None): Future[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo] = {
      helper.orgApacheSlingEngineImplDebugRequestProgressTrackerLogFilter(post, apply, delete, action, location, propertylist, extensions, minDurationMs, maxDurationMs, compactLogFormat)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param requestLogOutput  (optional)
   * @param requestLogOutputtype  (optional)
   * @param requestLogEnabled  (optional)
   * @param accessLogOutput  (optional)
   * @param accessLogOutputtype  (optional)
   * @param accessLogEnabled  (optional)
   * @return OrgApacheSlingEngineImplLogRequestLoggerInfo
   */
  def orgApacheSlingEngineImplLogRequestLogger(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, requestLogOutput: Option[String] = None, requestLogOutputtype: Option[Integer] = None, requestLogEnabled: Option[Boolean] = None, accessLogOutput: Option[String] = None, accessLogOutputtype: Option[Integer] = None, accessLogEnabled: Option[Boolean] = None): Option[OrgApacheSlingEngineImplLogRequestLoggerInfo] = {
    val await = Try(Await.result(orgApacheSlingEngineImplLogRequestLoggerAsync(post, apply, delete, action, location, propertylist, requestLogOutput, requestLogOutputtype, requestLogEnabled, accessLogOutput, accessLogOutputtype, accessLogEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param requestLogOutput  (optional)
   * @param requestLogOutputtype  (optional)
   * @param requestLogEnabled  (optional)
   * @param accessLogOutput  (optional)
   * @param accessLogOutputtype  (optional)
   * @param accessLogEnabled  (optional)
   * @return Future(OrgApacheSlingEngineImplLogRequestLoggerInfo)
   */
  def orgApacheSlingEngineImplLogRequestLoggerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, requestLogOutput: Option[String] = None, requestLogOutputtype: Option[Integer] = None, requestLogEnabled: Option[Boolean] = None, accessLogOutput: Option[String] = None, accessLogOutputtype: Option[Integer] = None, accessLogEnabled: Option[Boolean] = None): Future[OrgApacheSlingEngineImplLogRequestLoggerInfo] = {
      helper.orgApacheSlingEngineImplLogRequestLogger(post, apply, delete, action, location, propertylist, requestLogOutput, requestLogOutputtype, requestLogEnabled, accessLogOutput, accessLogOutputtype, accessLogEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param requestLogServiceFormat  (optional)
   * @param requestLogServiceOutput  (optional)
   * @param requestLogServiceOutputtype  (optional)
   * @param requestLogServiceOnentry  (optional)
   * @return OrgApacheSlingEngineImplLogRequestLoggerServiceInfo
   */
  def orgApacheSlingEngineImplLogRequestLoggerService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, requestLogServiceFormat: Option[String] = None, requestLogServiceOutput: Option[String] = None, requestLogServiceOutputtype: Option[Integer] = None, requestLogServiceOnentry: Option[Boolean] = None): Option[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo] = {
    val await = Try(Await.result(orgApacheSlingEngineImplLogRequestLoggerServiceAsync(post, apply, delete, action, location, propertylist, requestLogServiceFormat, requestLogServiceOutput, requestLogServiceOutputtype, requestLogServiceOnentry), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param requestLogServiceFormat  (optional)
   * @param requestLogServiceOutput  (optional)
   * @param requestLogServiceOutputtype  (optional)
   * @param requestLogServiceOnentry  (optional)
   * @return Future(OrgApacheSlingEngineImplLogRequestLoggerServiceInfo)
   */
  def orgApacheSlingEngineImplLogRequestLoggerServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, requestLogServiceFormat: Option[String] = None, requestLogServiceOutput: Option[String] = None, requestLogServiceOutputtype: Option[Integer] = None, requestLogServiceOnentry: Option[Boolean] = None): Future[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo] = {
      helper.orgApacheSlingEngineImplLogRequestLoggerService(post, apply, delete, action, location, propertylist, requestLogServiceFormat, requestLogServiceOutput, requestLogServiceOutputtype, requestLogServiceOnentry)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingMaxCalls  (optional)
   * @param slingMaxInclusions  (optional)
   * @param slingTraceAllow  (optional)
   * @param slingMaxRecordRequests  (optional)
   * @param slingStorePatternRequests  (optional)
   * @param slingServerinfo  (optional)
   * @param slingAdditionalResponseHeaders  (optional)
   * @return OrgApacheSlingEngineImplSlingMainServletInfo
   */
  def orgApacheSlingEngineImplSlingMainServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingMaxCalls: Option[Integer] = None, slingMaxInclusions: Option[Integer] = None, slingTraceAllow: Option[Boolean] = None, slingMaxRecordRequests: Option[Integer] = None, slingStorePatternRequests: Option[List[String]] = None, slingServerinfo: Option[String] = None, slingAdditionalResponseHeaders: Option[List[String]] = None): Option[OrgApacheSlingEngineImplSlingMainServletInfo] = {
    val await = Try(Await.result(orgApacheSlingEngineImplSlingMainServletAsync(post, apply, delete, action, location, propertylist, slingMaxCalls, slingMaxInclusions, slingTraceAllow, slingMaxRecordRequests, slingStorePatternRequests, slingServerinfo, slingAdditionalResponseHeaders), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingMaxCalls  (optional)
   * @param slingMaxInclusions  (optional)
   * @param slingTraceAllow  (optional)
   * @param slingMaxRecordRequests  (optional)
   * @param slingStorePatternRequests  (optional)
   * @param slingServerinfo  (optional)
   * @param slingAdditionalResponseHeaders  (optional)
   * @return Future(OrgApacheSlingEngineImplSlingMainServletInfo)
   */
  def orgApacheSlingEngineImplSlingMainServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingMaxCalls: Option[Integer] = None, slingMaxInclusions: Option[Integer] = None, slingTraceAllow: Option[Boolean] = None, slingMaxRecordRequests: Option[Integer] = None, slingStorePatternRequests: Option[List[String]] = None, slingServerinfo: Option[String] = None, slingAdditionalResponseHeaders: Option[List[String]] = None): Future[OrgApacheSlingEngineImplSlingMainServletInfo] = {
      helper.orgApacheSlingEngineImplSlingMainServlet(post, apply, delete, action, location, propertylist, slingMaxCalls, slingMaxInclusions, slingTraceAllow, slingMaxRecordRequests, slingStorePatternRequests, slingServerinfo, slingAdditionalResponseHeaders)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingDefaultParameterEncoding  (optional)
   * @param slingDefaultMaxParameters  (optional)
   * @param fileLocation  (optional)
   * @param fileThreshold  (optional)
   * @param fileMax  (optional)
   * @param requestMax  (optional)
   * @param slingDefaultParameterCheckForAdditionalContainerParameters  (optional)
   * @return OrgApacheSlingEngineParametersInfo
   */
  def orgApacheSlingEngineParameters(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingDefaultParameterEncoding: Option[String] = None, slingDefaultMaxParameters: Option[Integer] = None, fileLocation: Option[String] = None, fileThreshold: Option[Integer] = None, fileMax: Option[Integer] = None, requestMax: Option[Integer] = None, slingDefaultParameterCheckForAdditionalContainerParameters: Option[Boolean] = None): Option[OrgApacheSlingEngineParametersInfo] = {
    val await = Try(Await.result(orgApacheSlingEngineParametersAsync(post, apply, delete, action, location, propertylist, slingDefaultParameterEncoding, slingDefaultMaxParameters, fileLocation, fileThreshold, fileMax, requestMax, slingDefaultParameterCheckForAdditionalContainerParameters), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingDefaultParameterEncoding  (optional)
   * @param slingDefaultMaxParameters  (optional)
   * @param fileLocation  (optional)
   * @param fileThreshold  (optional)
   * @param fileMax  (optional)
   * @param requestMax  (optional)
   * @param slingDefaultParameterCheckForAdditionalContainerParameters  (optional)
   * @return Future(OrgApacheSlingEngineParametersInfo)
   */
  def orgApacheSlingEngineParametersAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingDefaultParameterEncoding: Option[String] = None, slingDefaultMaxParameters: Option[Integer] = None, fileLocation: Option[String] = None, fileThreshold: Option[Integer] = None, fileMax: Option[Integer] = None, requestMax: Option[Integer] = None, slingDefaultParameterCheckForAdditionalContainerParameters: Option[Boolean] = None): Future[OrgApacheSlingEngineParametersInfo] = {
      helper.orgApacheSlingEngineParameters(post, apply, delete, action, location, propertylist, slingDefaultParameterEncoding, slingDefaultMaxParameters, fileLocation, fileThreshold, fileMax, requestMax, slingDefaultParameterCheckForAdditionalContainerParameters)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param minPoolSize  (optional)
   * @return OrgApacheSlingEventImplEventingThreadPoolInfo
   */
  def orgApacheSlingEventImplEventingThreadPool(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, minPoolSize: Option[Integer] = None): Option[OrgApacheSlingEventImplEventingThreadPoolInfo] = {
    val await = Try(Await.result(orgApacheSlingEventImplEventingThreadPoolAsync(post, apply, delete, action, location, propertylist, minPoolSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param minPoolSize  (optional)
   * @return Future(OrgApacheSlingEventImplEventingThreadPoolInfo)
   */
  def orgApacheSlingEventImplEventingThreadPoolAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, minPoolSize: Option[Integer] = None): Future[OrgApacheSlingEventImplEventingThreadPoolInfo] = {
      helper.orgApacheSlingEventImplEventingThreadPool(post, apply, delete, action, location, propertylist, minPoolSize)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queuePriority  (optional)
   * @param queueRetries  (optional)
   * @param queueRetrydelay  (optional)
   * @param queueMaxparallel  (optional)
   * @return OrgApacheSlingEventImplJobsDefaultJobManagerInfo
   */
  def orgApacheSlingEventImplJobsDefaultJobManager(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queuePriority: Option[String] = None, queueRetries: Option[Integer] = None, queueRetrydelay: Option[Integer] = None, queueMaxparallel: Option[Integer] = None): Option[OrgApacheSlingEventImplJobsDefaultJobManagerInfo] = {
    val await = Try(Await.result(orgApacheSlingEventImplJobsDefaultJobManagerAsync(post, apply, delete, action, location, propertylist, queuePriority, queueRetries, queueRetrydelay, queueMaxparallel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queuePriority  (optional)
   * @param queueRetries  (optional)
   * @param queueRetrydelay  (optional)
   * @param queueMaxparallel  (optional)
   * @return Future(OrgApacheSlingEventImplJobsDefaultJobManagerInfo)
   */
  def orgApacheSlingEventImplJobsDefaultJobManagerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queuePriority: Option[String] = None, queueRetries: Option[Integer] = None, queueRetrydelay: Option[Integer] = None, queueMaxparallel: Option[Integer] = None): Future[OrgApacheSlingEventImplJobsDefaultJobManagerInfo] = {
      helper.orgApacheSlingEventImplJobsDefaultJobManager(post, apply, delete, action, location, propertylist, queuePriority, queueRetries, queueRetrydelay, queueMaxparallel)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jobConsumermanagerDisableDistribution  (optional)
   * @param startupDelay  (optional)
   * @param cleanupPeriod  (optional)
   * @return OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo
   */
  def orgApacheSlingEventImplJobsJcrPersistenceHandler(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jobConsumermanagerDisableDistribution: Option[Boolean] = None, startupDelay: Option[Integer] = None, cleanupPeriod: Option[Integer] = None): Option[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo] = {
    val await = Try(Await.result(orgApacheSlingEventImplJobsJcrPersistenceHandlerAsync(post, apply, delete, action, location, propertylist, jobConsumermanagerDisableDistribution, startupDelay, cleanupPeriod), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jobConsumermanagerDisableDistribution  (optional)
   * @param startupDelay  (optional)
   * @param cleanupPeriod  (optional)
   * @return Future(OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo)
   */
  def orgApacheSlingEventImplJobsJcrPersistenceHandlerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jobConsumermanagerDisableDistribution: Option[Boolean] = None, startupDelay: Option[Integer] = None, cleanupPeriod: Option[Integer] = None): Future[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo] = {
      helper.orgApacheSlingEventImplJobsJcrPersistenceHandler(post, apply, delete, action, location, propertylist, jobConsumermanagerDisableDistribution, startupDelay, cleanupPeriod)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingInstallerConfigurationPersist  (optional)
   * @param jobConsumermanagerWhitelist  (optional)
   * @param jobConsumermanagerBlacklist  (optional)
   * @return OrgApacheSlingEventImplJobsJobConsumerManagerInfo
   */
  def orgApacheSlingEventImplJobsJobConsumerManager(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingInstallerConfigurationPersist: Option[Boolean] = None, jobConsumermanagerWhitelist: Option[List[String]] = None, jobConsumermanagerBlacklist: Option[List[String]] = None): Option[OrgApacheSlingEventImplJobsJobConsumerManagerInfo] = {
    val await = Try(Await.result(orgApacheSlingEventImplJobsJobConsumerManagerAsync(post, apply, delete, action, location, propertylist, orgApacheSlingInstallerConfigurationPersist, jobConsumermanagerWhitelist, jobConsumermanagerBlacklist), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingInstallerConfigurationPersist  (optional)
   * @param jobConsumermanagerWhitelist  (optional)
   * @param jobConsumermanagerBlacklist  (optional)
   * @return Future(OrgApacheSlingEventImplJobsJobConsumerManagerInfo)
   */
  def orgApacheSlingEventImplJobsJobConsumerManagerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingInstallerConfigurationPersist: Option[Boolean] = None, jobConsumermanagerWhitelist: Option[List[String]] = None, jobConsumermanagerBlacklist: Option[List[String]] = None): Future[OrgApacheSlingEventImplJobsJobConsumerManagerInfo] = {
      helper.orgApacheSlingEventImplJobsJobConsumerManager(post, apply, delete, action, location, propertylist, orgApacheSlingInstallerConfigurationPersist, jobConsumermanagerWhitelist, jobConsumermanagerBlacklist)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queueName  (optional)
   * @param queueTopics  (optional)
   * @param queueType  (optional)
   * @param queuePriority  (optional)
   * @param queueRetries  (optional)
   * @param queueRetrydelay  (optional)
   * @param queueMaxparallel  (optional)
   * @param queueKeepJobs  (optional)
   * @param queuePreferRunOnCreationInstance  (optional)
   * @param queueThreadPoolSize  (optional)
   * @param serviceRanking  (optional)
   * @return OrgApacheSlingEventJobsQueueConfigurationInfo
   */
  def orgApacheSlingEventJobsQueueConfiguration(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queueName: Option[String] = None, queueTopics: Option[List[String]] = None, queueType: Option[String] = None, queuePriority: Option[String] = None, queueRetries: Option[Integer] = None, queueRetrydelay: Option[Integer] = None, queueMaxparallel: Option[Number] = None, queueKeepJobs: Option[Boolean] = None, queuePreferRunOnCreationInstance: Option[Boolean] = None, queueThreadPoolSize: Option[Integer] = None, serviceRanking: Option[Integer] = None): Option[OrgApacheSlingEventJobsQueueConfigurationInfo] = {
    val await = Try(Await.result(orgApacheSlingEventJobsQueueConfigurationAsync(post, apply, delete, action, location, propertylist, queueName, queueTopics, queueType, queuePriority, queueRetries, queueRetrydelay, queueMaxparallel, queueKeepJobs, queuePreferRunOnCreationInstance, queueThreadPoolSize, serviceRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param queueName  (optional)
   * @param queueTopics  (optional)
   * @param queueType  (optional)
   * @param queuePriority  (optional)
   * @param queueRetries  (optional)
   * @param queueRetrydelay  (optional)
   * @param queueMaxparallel  (optional)
   * @param queueKeepJobs  (optional)
   * @param queuePreferRunOnCreationInstance  (optional)
   * @param queueThreadPoolSize  (optional)
   * @param serviceRanking  (optional)
   * @return Future(OrgApacheSlingEventJobsQueueConfigurationInfo)
   */
  def orgApacheSlingEventJobsQueueConfigurationAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, queueName: Option[String] = None, queueTopics: Option[List[String]] = None, queueType: Option[String] = None, queuePriority: Option[String] = None, queueRetries: Option[Integer] = None, queueRetrydelay: Option[Integer] = None, queueMaxparallel: Option[Number] = None, queueKeepJobs: Option[Boolean] = None, queuePreferRunOnCreationInstance: Option[Boolean] = None, queueThreadPoolSize: Option[Integer] = None, serviceRanking: Option[Integer] = None): Future[OrgApacheSlingEventJobsQueueConfigurationInfo] = {
      helper.orgApacheSlingEventJobsQueueConfiguration(post, apply, delete, action, location, propertylist, queueName, queueTopics, queueType, queuePriority, queueRetries, queueRetrydelay, queueMaxparallel, queueKeepJobs, queuePreferRunOnCreationInstance, queueThreadPoolSize, serviceRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param users  (optional)
   * @param groups  (optional)
   * @return OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo
   */
  def orgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingW(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, users: Option[List[String]] = None, groups: Option[List[String]] = None): Option[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo] = {
    val await = Try(Await.result(orgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWAsync(post, apply, delete, action, location, propertylist, users, groups), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param users  (optional)
   * @param groups  (optional)
   * @return Future(OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo)
   */
  def orgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, users: Option[List[String]] = None, groups: Option[List[String]] = None): Future[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo] = {
      helper.orgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingW(post, apply, delete, action, location, propertylist, users, groups)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param description  (optional)
   * @param enabled  (optional)
   * @return OrgApacheSlingFeatureflagsFeatureInfo
   */
  def orgApacheSlingFeatureflagsFeature(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, description: Option[String] = None, enabled: Option[Boolean] = None): Option[OrgApacheSlingFeatureflagsFeatureInfo] = {
    val await = Try(Await.result(orgApacheSlingFeatureflagsFeatureAsync(post, apply, delete, action, location, propertylist, name, description, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param description  (optional)
   * @param enabled  (optional)
   * @return Future(OrgApacheSlingFeatureflagsFeatureInfo)
   */
  def orgApacheSlingFeatureflagsFeatureAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, description: Option[String] = None, enabled: Option[Boolean] = None): Future[OrgApacheSlingFeatureflagsFeatureInfo] = {
      helper.orgApacheSlingFeatureflagsFeature(post, apply, delete, action, location, propertylist, name, description, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param description  (optional)
   * @param enabled  (optional)
   * @return OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo
   */
  def orgApacheSlingFeatureflagsImplConfiguredFeature(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, description: Option[String] = None, enabled: Option[Boolean] = None): Option[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo] = {
    val await = Try(Await.result(orgApacheSlingFeatureflagsImplConfiguredFeatureAsync(post, apply, delete, action, location, propertylist, name, description, enabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param name  (optional)
   * @param description  (optional)
   * @param enabled  (optional)
   * @return Future(OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo)
   */
  def orgApacheSlingFeatureflagsImplConfiguredFeatureAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, name: Option[String] = None, description: Option[String] = None, enabled: Option[Boolean] = None): Future[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo] = {
      helper.orgApacheSlingFeatureflagsImplConfiguredFeature(post, apply, delete, action, location, propertylist, name, description, enabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingHapiToolsResourcetype  (optional)
   * @param orgApacheSlingHapiToolsCollectionresourcetype  (optional)
   * @param orgApacheSlingHapiToolsSearchpaths  (optional)
   * @param orgApacheSlingHapiToolsExternalurl  (optional)
   * @param orgApacheSlingHapiToolsEnabled  (optional)
   * @return OrgApacheSlingHapiImplHApiUtilImplInfo
   */
  def orgApacheSlingHapiImplHApiUtilImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingHapiToolsResourcetype: Option[String] = None, orgApacheSlingHapiToolsCollectionresourcetype: Option[String] = None, orgApacheSlingHapiToolsSearchpaths: Option[List[String]] = None, orgApacheSlingHapiToolsExternalurl: Option[String] = None, orgApacheSlingHapiToolsEnabled: Option[Boolean] = None): Option[OrgApacheSlingHapiImplHApiUtilImplInfo] = {
    val await = Try(Await.result(orgApacheSlingHapiImplHApiUtilImplAsync(post, apply, delete, action, location, propertylist, orgApacheSlingHapiToolsResourcetype, orgApacheSlingHapiToolsCollectionresourcetype, orgApacheSlingHapiToolsSearchpaths, orgApacheSlingHapiToolsExternalurl, orgApacheSlingHapiToolsEnabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingHapiToolsResourcetype  (optional)
   * @param orgApacheSlingHapiToolsCollectionresourcetype  (optional)
   * @param orgApacheSlingHapiToolsSearchpaths  (optional)
   * @param orgApacheSlingHapiToolsExternalurl  (optional)
   * @param orgApacheSlingHapiToolsEnabled  (optional)
   * @return Future(OrgApacheSlingHapiImplHApiUtilImplInfo)
   */
  def orgApacheSlingHapiImplHApiUtilImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingHapiToolsResourcetype: Option[String] = None, orgApacheSlingHapiToolsCollectionresourcetype: Option[String] = None, orgApacheSlingHapiToolsSearchpaths: Option[List[String]] = None, orgApacheSlingHapiToolsExternalurl: Option[String] = None, orgApacheSlingHapiToolsEnabled: Option[Boolean] = None): Future[OrgApacheSlingHapiImplHApiUtilImplInfo] = {
      helper.orgApacheSlingHapiImplHApiUtilImpl(post, apply, delete, action, location, propertylist, orgApacheSlingHapiToolsResourcetype, orgApacheSlingHapiToolsCollectionresourcetype, orgApacheSlingHapiToolsSearchpaths, orgApacheSlingHapiToolsExternalurl, orgApacheSlingHapiToolsEnabled)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @param filterTags  (optional)
   * @param filterCombineTagsWithOr  (optional)
   * @return OrgApacheSlingHcCoreImplCompositeHealthCheckInfo
   */
  def orgApacheSlingHcCoreImplCompositeHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None, filterTags: Option[List[String]] = None, filterCombineTagsWithOr: Option[Boolean] = None): Option[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo] = {
    val await = Try(Await.result(orgApacheSlingHcCoreImplCompositeHealthCheckAsync(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName, filterTags, filterCombineTagsWithOr), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @param filterTags  (optional)
   * @param filterCombineTagsWithOr  (optional)
   * @return Future(OrgApacheSlingHcCoreImplCompositeHealthCheckInfo)
   */
  def orgApacheSlingHcCoreImplCompositeHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None, filterTags: Option[List[String]] = None, filterCombineTagsWithOr: Option[Boolean] = None): Future[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo] = {
      helper.orgApacheSlingHcCoreImplCompositeHealthCheck(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName, filterTags, filterCombineTagsWithOr)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param timeoutInMs  (optional)
   * @param longRunningFutureThresholdForCriticalMs  (optional)
   * @param resultCacheTtlInMs  (optional)
   * @return OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo
   */
  def orgApacheSlingHcCoreImplExecutorHealthCheckExecutorImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, timeoutInMs: Option[Integer] = None, longRunningFutureThresholdForCriticalMs: Option[Integer] = None, resultCacheTtlInMs: Option[Integer] = None): Option[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo] = {
    val await = Try(Await.result(orgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplAsync(post, apply, delete, action, location, propertylist, timeoutInMs, longRunningFutureThresholdForCriticalMs, resultCacheTtlInMs), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param timeoutInMs  (optional)
   * @param longRunningFutureThresholdForCriticalMs  (optional)
   * @param resultCacheTtlInMs  (optional)
   * @return Future(OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo)
   */
  def orgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, timeoutInMs: Option[Integer] = None, longRunningFutureThresholdForCriticalMs: Option[Integer] = None, resultCacheTtlInMs: Option[Integer] = None): Future[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo] = {
      helper.orgApacheSlingHcCoreImplExecutorHealthCheckExecutorImpl(post, apply, delete, action, location, propertylist, timeoutInMs, longRunningFutureThresholdForCriticalMs, resultCacheTtlInMs)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @param mbeanName  (optional)
   * @param attributeName  (optional)
   * @param attributeValueConstraint  (optional)
   * @return OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo
   */
  def orgApacheSlingHcCoreImplJmxAttributeHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None, mbeanName: Option[String] = None, attributeName: Option[String] = None, attributeValueConstraint: Option[String] = None): Option[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo] = {
    val await = Try(Await.result(orgApacheSlingHcCoreImplJmxAttributeHealthCheckAsync(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName, mbeanName, attributeName, attributeValueConstraint), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @param mbeanName  (optional)
   * @param attributeName  (optional)
   * @param attributeValueConstraint  (optional)
   * @return Future(OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo)
   */
  def orgApacheSlingHcCoreImplJmxAttributeHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None, mbeanName: Option[String] = None, attributeName: Option[String] = None, attributeValueConstraint: Option[String] = None): Future[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo] = {
      helper.orgApacheSlingHcCoreImplJmxAttributeHealthCheck(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName, mbeanName, attributeName, attributeValueConstraint)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @param expression  (optional)
   * @param languageExtension  (optional)
   * @return OrgApacheSlingHcCoreImplScriptableHealthCheckInfo
   */
  def orgApacheSlingHcCoreImplScriptableHealthCheck(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None, expression: Option[String] = None, languageExtension: Option[String] = None): Option[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo] = {
    val await = Try(Await.result(orgApacheSlingHcCoreImplScriptableHealthCheckAsync(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName, expression, languageExtension), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param hcName  (optional)
   * @param hcTags  (optional)
   * @param hcMbeanName  (optional)
   * @param expression  (optional)
   * @param languageExtension  (optional)
   * @return Future(OrgApacheSlingHcCoreImplScriptableHealthCheckInfo)
   */
  def orgApacheSlingHcCoreImplScriptableHealthCheckAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, hcName: Option[String] = None, hcTags: Option[List[String]] = None, hcMbeanName: Option[String] = None, expression: Option[String] = None, languageExtension: Option[String] = None): Future[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo] = {
      helper.orgApacheSlingHcCoreImplScriptableHealthCheck(post, apply, delete, action, location, propertylist, hcName, hcTags, hcMbeanName, expression, languageExtension)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param servletPath  (optional)
   * @param disabled  (optional)
   * @param corsAccessControlAllowOrigin  (optional)
   * @return OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo
   */
  def orgApacheSlingHcCoreImplServletHealthCheckExecutorServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, servletPath: Option[String] = None, disabled: Option[Boolean] = None, corsAccessControlAllowOrigin: Option[String] = None): Option[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo] = {
    val await = Try(Await.result(orgApacheSlingHcCoreImplServletHealthCheckExecutorServletAsync(post, apply, delete, action, location, propertylist, servletPath, disabled, corsAccessControlAllowOrigin), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param servletPath  (optional)
   * @param disabled  (optional)
   * @param corsAccessControlAllowOrigin  (optional)
   * @return Future(OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo)
   */
  def orgApacheSlingHcCoreImplServletHealthCheckExecutorServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, servletPath: Option[String] = None, disabled: Option[Boolean] = None, corsAccessControlAllowOrigin: Option[String] = None): Future[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo] = {
      helper.orgApacheSlingHcCoreImplServletHealthCheckExecutorServlet(post, apply, delete, action, location, propertylist, servletPath, disabled, corsAccessControlAllowOrigin)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param totalWidth  (optional)
   * @param colWidthName  (optional)
   * @param colWidthResult  (optional)
   * @param colWidthTiming  (optional)
   * @return OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo
   */
  def orgApacheSlingHcCoreImplServletResultTxtVerboseSerializer(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, totalWidth: Option[Integer] = None, colWidthName: Option[Integer] = None, colWidthResult: Option[Integer] = None, colWidthTiming: Option[Integer] = None): Option[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo] = {
    val await = Try(Await.result(orgApacheSlingHcCoreImplServletResultTxtVerboseSerializerAsync(post, apply, delete, action, location, propertylist, totalWidth, colWidthName, colWidthResult, colWidthTiming), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param totalWidth  (optional)
   * @param colWidthName  (optional)
   * @param colWidthResult  (optional)
   * @param colWidthTiming  (optional)
   * @return Future(OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo)
   */
  def orgApacheSlingHcCoreImplServletResultTxtVerboseSerializerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, totalWidth: Option[Integer] = None, colWidthName: Option[Integer] = None, colWidthResult: Option[Integer] = None, colWidthTiming: Option[Integer] = None): Future[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo] = {
      helper.orgApacheSlingHcCoreImplServletResultTxtVerboseSerializer(post, apply, delete, action, location, propertylist, totalWidth, colWidthName, colWidthResult, colWidthTiming)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param slingFilterScope  (optional)
   * @return OrgApacheSlingI18nImplI18NFilterInfo
   */
  def orgApacheSlingI18nImplI18NFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, slingFilterScope: Option[List[String]] = None): Option[OrgApacheSlingI18nImplI18NFilterInfo] = {
    val await = Try(Await.result(orgApacheSlingI18nImplI18NFilterAsync(post, apply, delete, action, location, propertylist, serviceRanking, slingFilterScope), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param slingFilterScope  (optional)
   * @return Future(OrgApacheSlingI18nImplI18NFilterInfo)
   */
  def orgApacheSlingI18nImplI18NFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, slingFilterScope: Option[List[String]] = None): Future[OrgApacheSlingI18nImplI18NFilterInfo] = {
      helper.orgApacheSlingI18nImplI18NFilter(post, apply, delete, action, location, propertylist, serviceRanking, slingFilterScope)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param localeDefault  (optional)
   * @param preloadBundles  (optional)
   * @param invalidationDelay  (optional)
   * @return OrgApacheSlingI18nImplJcrResourceBundleProviderInfo
   */
  def orgApacheSlingI18nImplJcrResourceBundleProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, localeDefault: Option[String] = None, preloadBundles: Option[Boolean] = None, invalidationDelay: Option[Integer] = None): Option[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo] = {
    val await = Try(Await.result(orgApacheSlingI18nImplJcrResourceBundleProviderAsync(post, apply, delete, action, location, propertylist, localeDefault, preloadBundles, invalidationDelay), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param localeDefault  (optional)
   * @param preloadBundles  (optional)
   * @param invalidationDelay  (optional)
   * @return Future(OrgApacheSlingI18nImplJcrResourceBundleProviderInfo)
   */
  def orgApacheSlingI18nImplJcrResourceBundleProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, localeDefault: Option[String] = None, preloadBundles: Option[Boolean] = None, invalidationDelay: Option[Integer] = None): Future[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo] = {
      helper.orgApacheSlingI18nImplJcrResourceBundleProvider(post, apply, delete, action, location, propertylist, localeDefault, preloadBundles, invalidationDelay)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param handlerSchemes  (optional)
   * @param slingJcrinstallFolderNameRegexp  (optional)
   * @param slingJcrinstallFolderMaxDepth  (optional)
   * @param slingJcrinstallSearchPath  (optional)
   * @param slingJcrinstallNewConfigPath  (optional)
   * @param slingJcrinstallSignalPath  (optional)
   * @param slingJcrinstallEnableWriteback  (optional)
   * @return OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo
   */
  def orgApacheSlingInstallerProviderJcrImplJcrInstaller(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, handlerSchemes: Option[List[String]] = None, slingJcrinstallFolderNameRegexp: Option[String] = None, slingJcrinstallFolderMaxDepth: Option[Integer] = None, slingJcrinstallSearchPath: Option[List[String]] = None, slingJcrinstallNewConfigPath: Option[String] = None, slingJcrinstallSignalPath: Option[String] = None, slingJcrinstallEnableWriteback: Option[Boolean] = None): Option[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo] = {
    val await = Try(Await.result(orgApacheSlingInstallerProviderJcrImplJcrInstallerAsync(post, apply, delete, action, location, propertylist, handlerSchemes, slingJcrinstallFolderNameRegexp, slingJcrinstallFolderMaxDepth, slingJcrinstallSearchPath, slingJcrinstallNewConfigPath, slingJcrinstallSignalPath, slingJcrinstallEnableWriteback), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param handlerSchemes  (optional)
   * @param slingJcrinstallFolderNameRegexp  (optional)
   * @param slingJcrinstallFolderMaxDepth  (optional)
   * @param slingJcrinstallSearchPath  (optional)
   * @param slingJcrinstallNewConfigPath  (optional)
   * @param slingJcrinstallSignalPath  (optional)
   * @param slingJcrinstallEnableWriteback  (optional)
   * @return Future(OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo)
   */
  def orgApacheSlingInstallerProviderJcrImplJcrInstallerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, handlerSchemes: Option[List[String]] = None, slingJcrinstallFolderNameRegexp: Option[String] = None, slingJcrinstallFolderMaxDepth: Option[Integer] = None, slingJcrinstallSearchPath: Option[List[String]] = None, slingJcrinstallNewConfigPath: Option[String] = None, slingJcrinstallSignalPath: Option[String] = None, slingJcrinstallEnableWriteback: Option[Boolean] = None): Future[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo] = {
      helper.orgApacheSlingInstallerProviderJcrImplJcrInstaller(post, apply, delete, action, location, propertylist, handlerSchemes, slingJcrinstallFolderNameRegexp, slingJcrinstallFolderMaxDepth, slingJcrinstallSearchPath, slingJcrinstallNewConfigPath, slingJcrinstallSignalPath, slingJcrinstallEnableWriteback)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param whitelistBypass  (optional)
   * @param whitelistBundlesRegexp  (optional)
   * @return OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo
   */
  def orgApacheSlingJcrBaseInternalLoginAdminWhitelist(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, whitelistBypass: Option[Boolean] = None, whitelistBundlesRegexp: Option[String] = None): Option[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrBaseInternalLoginAdminWhitelistAsync(post, apply, delete, action, location, propertylist, whitelistBypass, whitelistBundlesRegexp), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param whitelistBypass  (optional)
   * @param whitelistBundlesRegexp  (optional)
   * @return Future(OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo)
   */
  def orgApacheSlingJcrBaseInternalLoginAdminWhitelistAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, whitelistBypass: Option[Boolean] = None, whitelistBundlesRegexp: Option[String] = None): Future[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo] = {
      helper.orgApacheSlingJcrBaseInternalLoginAdminWhitelist(post, apply, delete, action, location, propertylist, whitelistBypass, whitelistBundlesRegexp)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param whitelistName  (optional)
   * @param whitelistBundles  (optional)
   * @return OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo
   */
  def orgApacheSlingJcrBaseInternalLoginAdminWhitelistFragment(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, whitelistName: Option[String] = None, whitelistBundles: Option[List[String]] = None): Option[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentAsync(post, apply, delete, action, location, propertylist, whitelistName, whitelistBundles), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param whitelistName  (optional)
   * @param whitelistBundles  (optional)
   * @return Future(OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo)
   */
  def orgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, whitelistName: Option[String] = None, whitelistBundles: Option[List[String]] = None): Future[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo] = {
      helper.orgApacheSlingJcrBaseInternalLoginAdminWhitelistFragment(post, apply, delete, action, location, propertylist, whitelistName, whitelistBundles)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param alias  (optional)
   * @param davCreateAbsoluteUri  (optional)
   * @param davProtectedhandlers  (optional)
   * @return OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo
   */
  def orgApacheSlingJcrDavexImplServletsSlingDavExServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, alias: Option[String] = None, davCreateAbsoluteUri: Option[Boolean] = None, davProtectedhandlers: Option[String] = None): Option[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrDavexImplServletsSlingDavExServletAsync(post, apply, delete, action, location, propertylist, alias, davCreateAbsoluteUri, davProtectedhandlers), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param alias  (optional)
   * @param davCreateAbsoluteUri  (optional)
   * @param davProtectedhandlers  (optional)
   * @return Future(OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo)
   */
  def orgApacheSlingJcrDavexImplServletsSlingDavExServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, alias: Option[String] = None, davCreateAbsoluteUri: Option[Boolean] = None, davProtectedhandlers: Option[String] = None): Future[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo] = {
      helper.orgApacheSlingJcrDavexImplServletsSlingDavExServlet(post, apply, delete, action, location, propertylist, alias, davCreateAbsoluteUri, davProtectedhandlers)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param javaNamingFactoryInitial  (optional)
   * @param javaNamingProviderUrl  (optional)
   * @return OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo
   */
  def orgApacheSlingJcrJackrabbitServerJndiRegistrationSupport(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, javaNamingFactoryInitial: Option[String] = None, javaNamingProviderUrl: Option[String] = None): Option[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrJackrabbitServerJndiRegistrationSupportAsync(post, apply, delete, action, location, propertylist, javaNamingFactoryInitial, javaNamingProviderUrl), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param javaNamingFactoryInitial  (optional)
   * @param javaNamingProviderUrl  (optional)
   * @return Future(OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo)
   */
  def orgApacheSlingJcrJackrabbitServerJndiRegistrationSupportAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, javaNamingFactoryInitial: Option[String] = None, javaNamingProviderUrl: Option[String] = None): Future[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo] = {
      helper.orgApacheSlingJcrJackrabbitServerJndiRegistrationSupport(post, apply, delete, action, location, propertylist, javaNamingFactoryInitial, javaNamingProviderUrl)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param port  (optional)
   * @return OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo
   */
  def orgApacheSlingJcrJackrabbitServerRmiRegistrationSupport(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, port: Option[Integer] = None): Option[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrJackrabbitServerRmiRegistrationSupportAsync(post, apply, delete, action, location, propertylist, port), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param port  (optional)
   * @return Future(OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo)
   */
  def orgApacheSlingJcrJackrabbitServerRmiRegistrationSupportAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, port: Option[Integer] = None): Future[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo] = {
      helper.orgApacheSlingJcrJackrabbitServerRmiRegistrationSupport(post, apply, delete, action, location, propertylist, port)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param references  (optional)
   * @return OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo
   */
  def orgApacheSlingJcrRepoinitImplRepositoryInitializer(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, references: Option[List[String]] = None): Option[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrRepoinitImplRepositoryInitializerAsync(post, apply, delete, action, location, propertylist, references), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param references  (optional)
   * @return Future(OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo)
   */
  def orgApacheSlingJcrRepoinitImplRepositoryInitializerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, references: Option[List[String]] = None): Future[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo] = {
      helper.orgApacheSlingJcrRepoinitImplRepositoryInitializer(post, apply, delete, action, location, propertylist, references)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param references  (optional)
   * @param scripts  (optional)
   * @return OrgApacheSlingJcrRepoinitRepositoryInitializerInfo
   */
  def orgApacheSlingJcrRepoinitRepositoryInitializer(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, references: Option[List[String]] = None, scripts: Option[List[String]] = None): Option[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrRepoinitRepositoryInitializerAsync(post, apply, delete, action, location, propertylist, references, scripts), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param references  (optional)
   * @param scripts  (optional)
   * @return Future(OrgApacheSlingJcrRepoinitRepositoryInitializerInfo)
   */
  def orgApacheSlingJcrRepoinitRepositoryInitializerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, references: Option[List[String]] = None, scripts: Option[List[String]] = None): Future[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo] = {
      helper.orgApacheSlingJcrRepoinitRepositoryInitializer(post, apply, delete, action, location, propertylist, references, scripts)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param resourceResolverSearchpath  (optional)
   * @param resourceResolverManglenamespaces  (optional)
   * @param resourceResolverAllowDirect  (optional)
   * @param resourceResolverRequiredProviders  (optional)
   * @param resourceResolverRequiredProvidernames  (optional)
   * @param resourceResolverVirtual  (optional)
   * @param resourceResolverMapping  (optional)
   * @param resourceResolverMapLocation  (optional)
   * @param resourceResolverMapObservation  (optional)
   * @param resourceResolverDefaultVanityRedirectStatus  (optional)
   * @param resourceResolverEnableVanitypath  (optional)
   * @param resourceResolverVanitypathMaxEntries  (optional)
   * @param resourceResolverVanitypathMaxEntriesStartup  (optional)
   * @param resourceResolverVanitypathBloomfilterMaxBytes  (optional)
   * @param resourceResolverOptimizeAliasResolution  (optional)
   * @param resourceResolverVanitypathWhitelist  (optional)
   * @param resourceResolverVanitypathBlacklist  (optional)
   * @param resourceResolverVanityPrecedence  (optional)
   * @param resourceResolverProviderhandlingParanoid  (optional)
   * @param resourceResolverLogClosing  (optional)
   * @param resourceResolverLogUnclosed  (optional)
   * @return OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo
   */
  def orgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, resourceResolverSearchpath: Option[List[String]] = None, resourceResolverManglenamespaces: Option[Boolean] = None, resourceResolverAllowDirect: Option[Boolean] = None, resourceResolverRequiredProviders: Option[List[String]] = None, resourceResolverRequiredProvidernames: Option[List[String]] = None, resourceResolverVirtual: Option[List[String]] = None, resourceResolverMapping: Option[List[String]] = None, resourceResolverMapLocation: Option[String] = None, resourceResolverMapObservation: Option[List[String]] = None, resourceResolverDefaultVanityRedirectStatus: Option[Integer] = None, resourceResolverEnableVanitypath: Option[Boolean] = None, resourceResolverVanitypathMaxEntries: Option[Integer] = None, resourceResolverVanitypathMaxEntriesStartup: Option[Boolean] = None, resourceResolverVanitypathBloomfilterMaxBytes: Option[Integer] = None, resourceResolverOptimizeAliasResolution: Option[Boolean] = None, resourceResolverVanitypathWhitelist: Option[List[String]] = None, resourceResolverVanitypathBlacklist: Option[List[String]] = None, resourceResolverVanityPrecedence: Option[Boolean] = None, resourceResolverProviderhandlingParanoid: Option[Boolean] = None, resourceResolverLogClosing: Option[Boolean] = None, resourceResolverLogUnclosed: Option[Boolean] = None): Option[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplAsync(post, apply, delete, action, location, propertylist, resourceResolverSearchpath, resourceResolverManglenamespaces, resourceResolverAllowDirect, resourceResolverRequiredProviders, resourceResolverRequiredProvidernames, resourceResolverVirtual, resourceResolverMapping, resourceResolverMapLocation, resourceResolverMapObservation, resourceResolverDefaultVanityRedirectStatus, resourceResolverEnableVanitypath, resourceResolverVanitypathMaxEntries, resourceResolverVanitypathMaxEntriesStartup, resourceResolverVanitypathBloomfilterMaxBytes, resourceResolverOptimizeAliasResolution, resourceResolverVanitypathWhitelist, resourceResolverVanitypathBlacklist, resourceResolverVanityPrecedence, resourceResolverProviderhandlingParanoid, resourceResolverLogClosing, resourceResolverLogUnclosed), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param resourceResolverSearchpath  (optional)
   * @param resourceResolverManglenamespaces  (optional)
   * @param resourceResolverAllowDirect  (optional)
   * @param resourceResolverRequiredProviders  (optional)
   * @param resourceResolverRequiredProvidernames  (optional)
   * @param resourceResolverVirtual  (optional)
   * @param resourceResolverMapping  (optional)
   * @param resourceResolverMapLocation  (optional)
   * @param resourceResolverMapObservation  (optional)
   * @param resourceResolverDefaultVanityRedirectStatus  (optional)
   * @param resourceResolverEnableVanitypath  (optional)
   * @param resourceResolverVanitypathMaxEntries  (optional)
   * @param resourceResolverVanitypathMaxEntriesStartup  (optional)
   * @param resourceResolverVanitypathBloomfilterMaxBytes  (optional)
   * @param resourceResolverOptimizeAliasResolution  (optional)
   * @param resourceResolverVanitypathWhitelist  (optional)
   * @param resourceResolverVanitypathBlacklist  (optional)
   * @param resourceResolverVanityPrecedence  (optional)
   * @param resourceResolverProviderhandlingParanoid  (optional)
   * @param resourceResolverLogClosing  (optional)
   * @param resourceResolverLogUnclosed  (optional)
   * @return Future(OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo)
   */
  def orgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, resourceResolverSearchpath: Option[List[String]] = None, resourceResolverManglenamespaces: Option[Boolean] = None, resourceResolverAllowDirect: Option[Boolean] = None, resourceResolverRequiredProviders: Option[List[String]] = None, resourceResolverRequiredProvidernames: Option[List[String]] = None, resourceResolverVirtual: Option[List[String]] = None, resourceResolverMapping: Option[List[String]] = None, resourceResolverMapLocation: Option[String] = None, resourceResolverMapObservation: Option[List[String]] = None, resourceResolverDefaultVanityRedirectStatus: Option[Integer] = None, resourceResolverEnableVanitypath: Option[Boolean] = None, resourceResolverVanitypathMaxEntries: Option[Integer] = None, resourceResolverVanitypathMaxEntriesStartup: Option[Boolean] = None, resourceResolverVanitypathBloomfilterMaxBytes: Option[Integer] = None, resourceResolverOptimizeAliasResolution: Option[Boolean] = None, resourceResolverVanitypathWhitelist: Option[List[String]] = None, resourceResolverVanitypathBlacklist: Option[List[String]] = None, resourceResolverVanityPrecedence: Option[Boolean] = None, resourceResolverProviderhandlingParanoid: Option[Boolean] = None, resourceResolverLogClosing: Option[Boolean] = None, resourceResolverLogUnclosed: Option[Boolean] = None): Future[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo] = {
      helper.orgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImpl(post, apply, delete, action, location, propertylist, resourceResolverSearchpath, resourceResolverManglenamespaces, resourceResolverAllowDirect, resourceResolverRequiredProviders, resourceResolverRequiredProvidernames, resourceResolverVirtual, resourceResolverMapping, resourceResolverMapLocation, resourceResolverMapObservation, resourceResolverDefaultVanityRedirectStatus, resourceResolverEnableVanitypath, resourceResolverVanitypathMaxEntries, resourceResolverVanitypathMaxEntriesStartup, resourceResolverVanitypathBloomfilterMaxBytes, resourceResolverOptimizeAliasResolution, resourceResolverVanitypathWhitelist, resourceResolverVanitypathBlacklist, resourceResolverVanityPrecedence, resourceResolverProviderhandlingParanoid, resourceResolverLogClosing, resourceResolverLogUnclosed)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param allowOnlySystemUser  (optional)
   * @return OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo
   */
  def orgApacheSlingJcrResourceInternalJcrSystemUserValidator(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, allowOnlySystemUser: Option[Boolean] = None): Option[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrResourceInternalJcrSystemUserValidatorAsync(post, apply, delete, action, location, propertylist, allowOnlySystemUser), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param allowOnlySystemUser  (optional)
   * @return Future(OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo)
   */
  def orgApacheSlingJcrResourceInternalJcrSystemUserValidatorAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, allowOnlySystemUser: Option[Boolean] = None): Future[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo] = {
      helper.orgApacheSlingJcrResourceInternalJcrSystemUserValidator(post, apply, delete, action, location, propertylist, allowOnlySystemUser)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param checkpathPrefix  (optional)
   * @param jcrPath  (optional)
   * @return OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo
   */
  def orgApacheSlingJcrResourcesecurityImplResourceAccessGateFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, checkpathPrefix: Option[String] = None, jcrPath: Option[String] = None): Option[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryAsync(post, apply, delete, action, location, propertylist, `path`, checkpathPrefix, jcrPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param `path`  (optional)
   * @param checkpathPrefix  (optional)
   * @param jcrPath  (optional)
   * @return Future(OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo)
   */
  def orgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, `path`: Option[String] = None, checkpathPrefix: Option[String] = None, jcrPath: Option[String] = None): Future[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo] = {
      helper.orgApacheSlingJcrResourcesecurityImplResourceAccessGateFactory(post, apply, delete, action, location, propertylist, `path`, checkpathPrefix, jcrPath)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param typeCollections  (optional)
   * @param typeNoncollections  (optional)
   * @param typeContent  (optional)
   * @return OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo
   */
  def orgApacheSlingJcrWebdavImplHandlerDefaultHandlerService(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, typeCollections: Option[String] = None, typeNoncollections: Option[String] = None, typeContent: Option[String] = None): Option[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceAsync(post, apply, delete, action, location, propertylist, serviceRanking, typeCollections, typeNoncollections, typeContent), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param typeCollections  (optional)
   * @param typeNoncollections  (optional)
   * @param typeContent  (optional)
   * @return Future(OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo)
   */
  def orgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, typeCollections: Option[String] = None, typeNoncollections: Option[String] = None, typeContent: Option[String] = None): Future[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo] = {
      helper.orgApacheSlingJcrWebdavImplHandlerDefaultHandlerService(post, apply, delete, action, location, propertylist, serviceRanking, typeCollections, typeNoncollections, typeContent)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @return OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo
   */
  def orgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServic(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None): Option[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicAsync(post, apply, delete, action, location, propertylist, serviceRanking), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @return Future(OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo)
   */
  def orgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None): Future[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo] = {
      helper.orgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServic(post, apply, delete, action, location, propertylist, serviceRanking)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param davRoot  (optional)
   * @param davCreateAbsoluteUri  (optional)
   * @param davRealm  (optional)
   * @param collectionTypes  (optional)
   * @param filterPrefixes  (optional)
   * @param filterTypes  (optional)
   * @param filterUris  (optional)
   * @param typeCollections  (optional)
   * @param typeNoncollections  (optional)
   * @param typeContent  (optional)
   * @return OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo
   */
  def orgApacheSlingJcrWebdavImplServletsSimpleWebDavServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, davRoot: Option[String] = None, davCreateAbsoluteUri: Option[Boolean] = None, davRealm: Option[String] = None, collectionTypes: Option[List[String]] = None, filterPrefixes: Option[List[String]] = None, filterTypes: Option[String] = None, filterUris: Option[String] = None, typeCollections: Option[String] = None, typeNoncollections: Option[String] = None, typeContent: Option[String] = None): Option[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo] = {
    val await = Try(Await.result(orgApacheSlingJcrWebdavImplServletsSimpleWebDavServletAsync(post, apply, delete, action, location, propertylist, davRoot, davCreateAbsoluteUri, davRealm, collectionTypes, filterPrefixes, filterTypes, filterUris, typeCollections, typeNoncollections, typeContent), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param davRoot  (optional)
   * @param davCreateAbsoluteUri  (optional)
   * @param davRealm  (optional)
   * @param collectionTypes  (optional)
   * @param filterPrefixes  (optional)
   * @param filterTypes  (optional)
   * @param filterUris  (optional)
   * @param typeCollections  (optional)
   * @param typeNoncollections  (optional)
   * @param typeContent  (optional)
   * @return Future(OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo)
   */
  def orgApacheSlingJcrWebdavImplServletsSimpleWebDavServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, davRoot: Option[String] = None, davCreateAbsoluteUri: Option[Boolean] = None, davRealm: Option[String] = None, collectionTypes: Option[List[String]] = None, filterPrefixes: Option[List[String]] = None, filterTypes: Option[String] = None, filterUris: Option[String] = None, typeCollections: Option[String] = None, typeNoncollections: Option[String] = None, typeContent: Option[String] = None): Future[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo] = {
      helper.orgApacheSlingJcrWebdavImplServletsSimpleWebDavServlet(post, apply, delete, action, location, propertylist, davRoot, davCreateAbsoluteUri, davRealm, collectionTypes, filterPrefixes, filterTypes, filterUris, typeCollections, typeNoncollections, typeContent)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerRoots  (optional)
   * @return OrgApacheSlingJmxProviderImplJMXResourceProviderInfo
   */
  def orgApacheSlingJmxProviderImplJMXResourceProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerRoots: Option[String] = None): Option[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo] = {
    val await = Try(Await.result(orgApacheSlingJmxProviderImplJMXResourceProviderAsync(post, apply, delete, action, location, propertylist, providerRoots), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param providerRoots  (optional)
   * @return Future(OrgApacheSlingJmxProviderImplJMXResourceProviderInfo)
   */
  def orgApacheSlingJmxProviderImplJMXResourceProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, providerRoots: Option[String] = None): Future[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo] = {
      helper.orgApacheSlingJmxProviderImplJMXResourceProvider(post, apply, delete, action, location, propertylist, providerRoots)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param osgiHttpWhiteboardListener  (optional)
   * @param osgiHttpWhiteboardContextSelect  (optional)
   * @param maxRecursionDepth  (optional)
   * @param cleanupJobPeriod  (optional)
   * @return OrgApacheSlingModelsImplModelAdapterFactoryInfo
   */
  def orgApacheSlingModelsImplModelAdapterFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, osgiHttpWhiteboardListener: Option[String] = None, osgiHttpWhiteboardContextSelect: Option[String] = None, maxRecursionDepth: Option[Integer] = None, cleanupJobPeriod: Option[Integer] = None): Option[OrgApacheSlingModelsImplModelAdapterFactoryInfo] = {
    val await = Try(Await.result(orgApacheSlingModelsImplModelAdapterFactoryAsync(post, apply, delete, action, location, propertylist, osgiHttpWhiteboardListener, osgiHttpWhiteboardContextSelect, maxRecursionDepth, cleanupJobPeriod), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param osgiHttpWhiteboardListener  (optional)
   * @param osgiHttpWhiteboardContextSelect  (optional)
   * @param maxRecursionDepth  (optional)
   * @param cleanupJobPeriod  (optional)
   * @return Future(OrgApacheSlingModelsImplModelAdapterFactoryInfo)
   */
  def orgApacheSlingModelsImplModelAdapterFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, osgiHttpWhiteboardListener: Option[String] = None, osgiHttpWhiteboardContextSelect: Option[String] = None, maxRecursionDepth: Option[Integer] = None, cleanupJobPeriod: Option[Integer] = None): Future[OrgApacheSlingModelsImplModelAdapterFactoryInfo] = {
      helper.orgApacheSlingModelsImplModelAdapterFactory(post, apply, delete, action, location, propertylist, osgiHttpWhiteboardListener, osgiHttpWhiteboardContextSelect, maxRecursionDepth, cleanupJobPeriod)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxRecursionLevels  (optional)
   * @return OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo
   */
  def orgApacheSlingModelsJacksonexporterImplResourceModuleProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxRecursionLevels: Option[Integer] = None): Option[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo] = {
    val await = Try(Await.result(orgApacheSlingModelsJacksonexporterImplResourceModuleProviderAsync(post, apply, delete, action, location, propertylist, maxRecursionLevels), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param maxRecursionLevels  (optional)
   * @return Future(OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo)
   */
  def orgApacheSlingModelsJacksonexporterImplResourceModuleProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, maxRecursionLevels: Option[Integer] = None): Future[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo] = {
      helper.orgApacheSlingModelsJacksonexporterImplResourceModuleProvider(post, apply, delete, action, location, propertylist, maxRecursionLevels)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param felixInventoryPrinterName  (optional)
   * @param felixInventoryPrinterTitle  (optional)
   * @param `path`  (optional)
   * @return OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo
   */
  def orgApacheSlingResourceInventoryImplResourceInventoryPrinterFacto(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, felixInventoryPrinterName: Option[String] = None, felixInventoryPrinterTitle: Option[String] = None, `path`: Option[String] = None): Option[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo] = {
    val await = Try(Await.result(orgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoAsync(post, apply, delete, action, location, propertylist, felixInventoryPrinterName, felixInventoryPrinterTitle, `path`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param felixInventoryPrinterName  (optional)
   * @param felixInventoryPrinterTitle  (optional)
   * @param `path`  (optional)
   * @return Future(OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo)
   */
  def orgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, felixInventoryPrinterName: Option[String] = None, felixInventoryPrinterTitle: Option[String] = None, `path`: Option[String] = None): Future[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo] = {
      helper.orgApacheSlingResourceInventoryImplResourceInventoryPrinterFacto(post, apply, delete, action, location, propertylist, felixInventoryPrinterName, felixInventoryPrinterTitle, `path`)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mergeRoot  (optional)
   * @param mergeReadOnly  (optional)
   * @return OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo
   */
  def orgApacheSlingResourcemergerImplMergedResourceProviderFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mergeRoot: Option[String] = None, mergeReadOnly: Option[Boolean] = None): Option[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo] = {
    val await = Try(Await.result(orgApacheSlingResourcemergerImplMergedResourceProviderFactoryAsync(post, apply, delete, action, location, propertylist, mergeRoot, mergeReadOnly), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mergeRoot  (optional)
   * @param mergeReadOnly  (optional)
   * @return Future(OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo)
   */
  def orgApacheSlingResourcemergerImplMergedResourceProviderFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mergeRoot: Option[String] = None, mergeReadOnly: Option[Boolean] = None): Future[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo] = {
      helper.orgApacheSlingResourcemergerImplMergedResourceProviderFactory(post, apply, delete, action, location, propertylist, mergeRoot, mergeReadOnly)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mergeRoot  (optional)
   * @param mergeReadOnly  (optional)
   * @return OrgApacheSlingResourcemergerPickerOverridingInfo
   */
  def orgApacheSlingResourcemergerPickerOverriding(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mergeRoot: Option[String] = None, mergeReadOnly: Option[Boolean] = None): Option[OrgApacheSlingResourcemergerPickerOverridingInfo] = {
    val await = Try(Await.result(orgApacheSlingResourcemergerPickerOverridingAsync(post, apply, delete, action, location, propertylist, mergeRoot, mergeReadOnly), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param mergeRoot  (optional)
   * @param mergeReadOnly  (optional)
   * @return Future(OrgApacheSlingResourcemergerPickerOverridingInfo)
   */
  def orgApacheSlingResourcemergerPickerOverridingAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, mergeRoot: Option[String] = None, mergeReadOnly: Option[Boolean] = None): Future[OrgApacheSlingResourcemergerPickerOverridingInfo] = {
      helper.orgApacheSlingResourcemergerPickerOverriding(post, apply, delete, action, location, propertylist, mergeRoot, mergeReadOnly)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingScriptingCacheSize  (optional)
   * @param orgApacheSlingScriptingCacheAdditionalExtensions  (optional)
   * @return OrgApacheSlingScriptingCoreImplScriptCacheImplInfo
   */
  def orgApacheSlingScriptingCoreImplScriptCacheImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingScriptingCacheSize: Option[Integer] = None, orgApacheSlingScriptingCacheAdditionalExtensions: Option[List[String]] = None): Option[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo] = {
    val await = Try(Await.result(orgApacheSlingScriptingCoreImplScriptCacheImplAsync(post, apply, delete, action, location, propertylist, orgApacheSlingScriptingCacheSize, orgApacheSlingScriptingCacheAdditionalExtensions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingScriptingCacheSize  (optional)
   * @param orgApacheSlingScriptingCacheAdditionalExtensions  (optional)
   * @return Future(OrgApacheSlingScriptingCoreImplScriptCacheImplInfo)
   */
  def orgApacheSlingScriptingCoreImplScriptCacheImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingScriptingCacheSize: Option[Integer] = None, orgApacheSlingScriptingCacheAdditionalExtensions: Option[List[String]] = None): Future[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo] = {
      helper.orgApacheSlingScriptingCoreImplScriptCacheImpl(post, apply, delete, action, location, propertylist, orgApacheSlingScriptingCacheSize, orgApacheSlingScriptingCacheAdditionalExtensions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param logStacktraceOnclose  (optional)
   * @return OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo
   */
  def orgApacheSlingScriptingCoreImplScriptingResourceResolverProvider(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, logStacktraceOnclose: Option[Boolean] = None): Option[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo] = {
    val await = Try(Await.result(orgApacheSlingScriptingCoreImplScriptingResourceResolverProviderAsync(post, apply, delete, action, location, propertylist, logStacktraceOnclose), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param logStacktraceOnclose  (optional)
   * @return Future(OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo)
   */
  def orgApacheSlingScriptingCoreImplScriptingResourceResolverProviderAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, logStacktraceOnclose: Option[Boolean] = None): Future[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo] = {
      helper.orgApacheSlingScriptingCoreImplScriptingResourceResolverProvider(post, apply, delete, action, location, propertylist, logStacktraceOnclose)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param javaClassdebuginfo  (optional)
   * @param javaJavaEncoding  (optional)
   * @param javaCompilerSourceVM  (optional)
   * @param javaCompilerTargetVM  (optional)
   * @return OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo
   */
  def orgApacheSlingScriptingJavaImplJavaScriptEngineFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, javaClassdebuginfo: Option[Boolean] = None, javaJavaEncoding: Option[String] = None, javaCompilerSourceVM: Option[String] = None, javaCompilerTargetVM: Option[String] = None): Option[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo] = {
    val await = Try(Await.result(orgApacheSlingScriptingJavaImplJavaScriptEngineFactoryAsync(post, apply, delete, action, location, propertylist, javaClassdebuginfo, javaJavaEncoding, javaCompilerSourceVM, javaCompilerTargetVM), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param javaClassdebuginfo  (optional)
   * @param javaJavaEncoding  (optional)
   * @param javaCompilerSourceVM  (optional)
   * @param javaCompilerTargetVM  (optional)
   * @return Future(OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo)
   */
  def orgApacheSlingScriptingJavaImplJavaScriptEngineFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, javaClassdebuginfo: Option[Boolean] = None, javaJavaEncoding: Option[String] = None, javaCompilerSourceVM: Option[String] = None, javaCompilerTargetVM: Option[String] = None): Future[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo] = {
      helper.orgApacheSlingScriptingJavaImplJavaScriptEngineFactory(post, apply, delete, action, location, propertylist, javaClassdebuginfo, javaJavaEncoding, javaCompilerSourceVM, javaCompilerTargetVM)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingScriptingJavascriptRhinoOptLevel  (optional)
   * @return OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo
   */
  def orgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFa(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingScriptingJavascriptRhinoOptLevel: Option[Integer] = None): Option[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo] = {
    val await = Try(Await.result(orgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaAsync(post, apply, delete, action, location, propertylist, orgApacheSlingScriptingJavascriptRhinoOptLevel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingScriptingJavascriptRhinoOptLevel  (optional)
   * @return Future(OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo)
   */
  def orgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingScriptingJavascriptRhinoOptLevel: Option[Integer] = None): Future[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo] = {
      helper.orgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFa(post, apply, delete, action, location, propertylist, orgApacheSlingScriptingJavascriptRhinoOptLevel)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jasperCompilerTargetVM  (optional)
   * @param jasperCompilerSourceVM  (optional)
   * @param jasperClassdebuginfo  (optional)
   * @param jasperEnablePooling  (optional)
   * @param jasperIeClassId  (optional)
   * @param jasperGenStringAsCharArray  (optional)
   * @param jasperKeepgenerated  (optional)
   * @param jasperMappedfile  (optional)
   * @param jasperTrimSpaces  (optional)
   * @param jasperDisplaySourceFragments  (optional)
   * @param defaultIsSession  (optional)
   * @return OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo
   */
  def orgApacheSlingScriptingJspJspScriptEngineFactory(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jasperCompilerTargetVM: Option[String] = None, jasperCompilerSourceVM: Option[String] = None, jasperClassdebuginfo: Option[Boolean] = None, jasperEnablePooling: Option[Boolean] = None, jasperIeClassId: Option[String] = None, jasperGenStringAsCharArray: Option[Boolean] = None, jasperKeepgenerated: Option[Boolean] = None, jasperMappedfile: Option[Boolean] = None, jasperTrimSpaces: Option[Boolean] = None, jasperDisplaySourceFragments: Option[Boolean] = None, defaultIsSession: Option[Boolean] = None): Option[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo] = {
    val await = Try(Await.result(orgApacheSlingScriptingJspJspScriptEngineFactoryAsync(post, apply, delete, action, location, propertylist, jasperCompilerTargetVM, jasperCompilerSourceVM, jasperClassdebuginfo, jasperEnablePooling, jasperIeClassId, jasperGenStringAsCharArray, jasperKeepgenerated, jasperMappedfile, jasperTrimSpaces, jasperDisplaySourceFragments, defaultIsSession), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param jasperCompilerTargetVM  (optional)
   * @param jasperCompilerSourceVM  (optional)
   * @param jasperClassdebuginfo  (optional)
   * @param jasperEnablePooling  (optional)
   * @param jasperIeClassId  (optional)
   * @param jasperGenStringAsCharArray  (optional)
   * @param jasperKeepgenerated  (optional)
   * @param jasperMappedfile  (optional)
   * @param jasperTrimSpaces  (optional)
   * @param jasperDisplaySourceFragments  (optional)
   * @param defaultIsSession  (optional)
   * @return Future(OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo)
   */
  def orgApacheSlingScriptingJspJspScriptEngineFactoryAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, jasperCompilerTargetVM: Option[String] = None, jasperCompilerSourceVM: Option[String] = None, jasperClassdebuginfo: Option[Boolean] = None, jasperEnablePooling: Option[Boolean] = None, jasperIeClassId: Option[String] = None, jasperGenStringAsCharArray: Option[Boolean] = None, jasperKeepgenerated: Option[Boolean] = None, jasperMappedfile: Option[Boolean] = None, jasperTrimSpaces: Option[Boolean] = None, jasperDisplaySourceFragments: Option[Boolean] = None, defaultIsSession: Option[Boolean] = None): Future[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo] = {
      helper.orgApacheSlingScriptingJspJspScriptEngineFactory(post, apply, delete, action, location, propertylist, jasperCompilerTargetVM, jasperCompilerSourceVM, jasperClassdebuginfo, jasperEnablePooling, jasperIeClassId, jasperGenStringAsCharArray, jasperKeepgenerated, jasperMappedfile, jasperTrimSpaces, jasperDisplaySourceFragments, defaultIsSession)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingScriptingSightlyJsBindings  (optional)
   * @return OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo
   */
  def orgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProv(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingScriptingSightlyJsBindings: Option[List[String]] = None): Option[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo] = {
    val await = Try(Await.result(orgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvAsync(post, apply, delete, action, location, propertylist, orgApacheSlingScriptingSightlyJsBindings), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param orgApacheSlingScriptingSightlyJsBindings  (optional)
   * @return Future(OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo)
   */
  def orgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, orgApacheSlingScriptingSightlyJsBindings: Option[List[String]] = None): Future[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo] = {
      helper.orgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProv(post, apply, delete, action, location, propertylist, orgApacheSlingScriptingSightlyJsBindings)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingContentDispositionPaths  (optional)
   * @param slingContentDispositionExcludedPaths  (optional)
   * @param slingContentDispositionAllPaths  (optional)
   * @return OrgApacheSlingSecurityImplContentDispositionFilterInfo
   */
  def orgApacheSlingSecurityImplContentDispositionFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingContentDispositionPaths: Option[List[String]] = None, slingContentDispositionExcludedPaths: Option[List[String]] = None, slingContentDispositionAllPaths: Option[Boolean] = None): Option[OrgApacheSlingSecurityImplContentDispositionFilterInfo] = {
    val await = Try(Await.result(orgApacheSlingSecurityImplContentDispositionFilterAsync(post, apply, delete, action, location, propertylist, slingContentDispositionPaths, slingContentDispositionExcludedPaths, slingContentDispositionAllPaths), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingContentDispositionPaths  (optional)
   * @param slingContentDispositionExcludedPaths  (optional)
   * @param slingContentDispositionAllPaths  (optional)
   * @return Future(OrgApacheSlingSecurityImplContentDispositionFilterInfo)
   */
  def orgApacheSlingSecurityImplContentDispositionFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingContentDispositionPaths: Option[List[String]] = None, slingContentDispositionExcludedPaths: Option[List[String]] = None, slingContentDispositionAllPaths: Option[Boolean] = None): Future[OrgApacheSlingSecurityImplContentDispositionFilterInfo] = {
      helper.orgApacheSlingSecurityImplContentDispositionFilter(post, apply, delete, action, location, propertylist, slingContentDispositionPaths, slingContentDispositionExcludedPaths, slingContentDispositionAllPaths)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param allowEmpty  (optional)
   * @param allowHosts  (optional)
   * @param allowHostsRegexp  (optional)
   * @param filterMethods  (optional)
   * @param excludeAgentsRegexp  (optional)
   * @return OrgApacheSlingSecurityImplReferrerFilterInfo
   */
  def orgApacheSlingSecurityImplReferrerFilter(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, allowEmpty: Option[Boolean] = None, allowHosts: Option[List[String]] = None, allowHostsRegexp: Option[List[String]] = None, filterMethods: Option[List[String]] = None, excludeAgentsRegexp: Option[List[String]] = None): Option[OrgApacheSlingSecurityImplReferrerFilterInfo] = {
    val await = Try(Await.result(orgApacheSlingSecurityImplReferrerFilterAsync(post, apply, delete, action, location, propertylist, allowEmpty, allowHosts, allowHostsRegexp, filterMethods, excludeAgentsRegexp), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param allowEmpty  (optional)
   * @param allowHosts  (optional)
   * @param allowHostsRegexp  (optional)
   * @param filterMethods  (optional)
   * @param excludeAgentsRegexp  (optional)
   * @return Future(OrgApacheSlingSecurityImplReferrerFilterInfo)
   */
  def orgApacheSlingSecurityImplReferrerFilterAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, allowEmpty: Option[Boolean] = None, allowHosts: Option[List[String]] = None, allowHostsRegexp: Option[List[String]] = None, filterMethods: Option[List[String]] = None, excludeAgentsRegexp: Option[List[String]] = None): Future[OrgApacheSlingSecurityImplReferrerFilterInfo] = {
      helper.orgApacheSlingSecurityImplReferrerFilter(post, apply, delete, action, location, propertylist, allowEmpty, allowHosts, allowHostsRegexp, filterMethods, excludeAgentsRegexp)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param userMapping  (optional)
   * @param userDefault  (optional)
   * @param userEnableDefaultMapping  (optional)
   * @param requireValidation  (optional)
   * @return OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo
   */
  def orgApacheSlingServiceusermappingImplServiceUserMapperImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, userMapping: Option[List[String]] = None, userDefault: Option[String] = None, userEnableDefaultMapping: Option[Boolean] = None, requireValidation: Option[Boolean] = None): Option[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo] = {
    val await = Try(Await.result(orgApacheSlingServiceusermappingImplServiceUserMapperImplAsync(post, apply, delete, action, location, propertylist, userMapping, userDefault, userEnableDefaultMapping, requireValidation), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param userMapping  (optional)
   * @param userDefault  (optional)
   * @param userEnableDefaultMapping  (optional)
   * @param requireValidation  (optional)
   * @return Future(OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo)
   */
  def orgApacheSlingServiceusermappingImplServiceUserMapperImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, userMapping: Option[List[String]] = None, userDefault: Option[String] = None, userEnableDefaultMapping: Option[Boolean] = None, requireValidation: Option[Boolean] = None): Future[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo] = {
      helper.orgApacheSlingServiceusermappingImplServiceUserMapperImpl(post, apply, delete, action, location, propertylist, userMapping, userDefault, userEnableDefaultMapping, requireValidation)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param userMapping  (optional)
   * @return OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo
   */
  def orgApacheSlingServiceusermappingImplServiceUserMapperImplAmended(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, userMapping: Option[List[String]] = None): Option[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo] = {
    val await = Try(Await.result(orgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedAsync(post, apply, delete, action, location, propertylist, serviceRanking, userMapping), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param serviceRanking  (optional)
   * @param userMapping  (optional)
   * @return Future(OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo)
   */
  def orgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, serviceRanking: Option[Integer] = None, userMapping: Option[List[String]] = None): Future[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo] = {
      helper.orgApacheSlingServiceusermappingImplServiceUserMapperImplAmended(post, apply, delete, action, location, propertylist, serviceRanking, userMapping)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param aliases  (optional)
   * @param index  (optional)
   * @param indexFiles  (optional)
   * @param enableHtml  (optional)
   * @param enableJson  (optional)
   * @param enableTxt  (optional)
   * @param enableXml  (optional)
   * @param jsonMaximumresults  (optional)
   * @param ecmaSuport  (optional)
   * @return OrgApacheSlingServletsGetDefaultGetServletInfo
   */
  def orgApacheSlingServletsGetDefaultGetServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, aliases: Option[List[String]] = None, index: Option[Boolean] = None, indexFiles: Option[List[String]] = None, enableHtml: Option[Boolean] = None, enableJson: Option[Boolean] = None, enableTxt: Option[Boolean] = None, enableXml: Option[Boolean] = None, jsonMaximumresults: Option[Integer] = None, ecmaSuport: Option[Boolean] = None): Option[OrgApacheSlingServletsGetDefaultGetServletInfo] = {
    val await = Try(Await.result(orgApacheSlingServletsGetDefaultGetServletAsync(post, apply, delete, action, location, propertylist, aliases, index, indexFiles, enableHtml, enableJson, enableTxt, enableXml, jsonMaximumresults, ecmaSuport), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param aliases  (optional)
   * @param index  (optional)
   * @param indexFiles  (optional)
   * @param enableHtml  (optional)
   * @param enableJson  (optional)
   * @param enableTxt  (optional)
   * @param enableXml  (optional)
   * @param jsonMaximumresults  (optional)
   * @param ecmaSuport  (optional)
   * @return Future(OrgApacheSlingServletsGetDefaultGetServletInfo)
   */
  def orgApacheSlingServletsGetDefaultGetServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, aliases: Option[List[String]] = None, index: Option[Boolean] = None, indexFiles: Option[List[String]] = None, enableHtml: Option[Boolean] = None, enableJson: Option[Boolean] = None, enableTxt: Option[Boolean] = None, enableXml: Option[Boolean] = None, jsonMaximumresults: Option[Integer] = None, ecmaSuport: Option[Boolean] = None): Future[OrgApacheSlingServletsGetDefaultGetServletInfo] = {
      helper.orgApacheSlingServletsGetDefaultGetServlet(post, apply, delete, action, location, propertylist, aliases, index, indexFiles, enableHtml, enableJson, enableTxt, enableXml, jsonMaximumresults, ecmaSuport)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletSelectors  (optional)
   * @param ecmaSuport  (optional)
   * @return OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo
   */
  def orgApacheSlingServletsGetImplVersionVersionInfoServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletSelectors: Option[List[String]] = None, ecmaSuport: Option[Boolean] = None): Option[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo] = {
    val await = Try(Await.result(orgApacheSlingServletsGetImplVersionVersionInfoServletAsync(post, apply, delete, action, location, propertylist, slingServletSelectors, ecmaSuport), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingServletSelectors  (optional)
   * @param ecmaSuport  (optional)
   * @return Future(OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo)
   */
  def orgApacheSlingServletsGetImplVersionVersionInfoServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingServletSelectors: Option[List[String]] = None, ecmaSuport: Option[Boolean] = None): Future[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo] = {
      helper.orgApacheSlingServletsGetImplVersionVersionInfoServlet(post, apply, delete, action, location, propertylist, slingServletSelectors, ecmaSuport)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param schedulerConcurrent  (optional)
   * @param chunkCleanupAge  (optional)
   * @return OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo
   */
  def orgApacheSlingServletsPostImplHelperChunkCleanUpTask(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, schedulerConcurrent: Option[Boolean] = None, chunkCleanupAge: Option[Integer] = None): Option[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo] = {
    val await = Try(Await.result(orgApacheSlingServletsPostImplHelperChunkCleanUpTaskAsync(post, apply, delete, action, location, propertylist, schedulerExpression, schedulerConcurrent, chunkCleanupAge), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param schedulerExpression  (optional)
   * @param schedulerConcurrent  (optional)
   * @param chunkCleanupAge  (optional)
   * @return Future(OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo)
   */
  def orgApacheSlingServletsPostImplHelperChunkCleanUpTaskAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, schedulerExpression: Option[String] = None, schedulerConcurrent: Option[Boolean] = None, chunkCleanupAge: Option[Integer] = None): Future[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo] = {
      helper.orgApacheSlingServletsPostImplHelperChunkCleanUpTask(post, apply, delete, action, location, propertylist, schedulerExpression, schedulerConcurrent, chunkCleanupAge)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param servletPostDateFormats  (optional)
   * @param servletPostNodeNameHints  (optional)
   * @param servletPostNodeNameMaxLength  (optional)
   * @param servletPostCheckinNewVersionableNodes  (optional)
   * @param servletPostAutoCheckout  (optional)
   * @param servletPostAutoCheckin  (optional)
   * @param servletPostIgnorePattern  (optional)
   * @return OrgApacheSlingServletsPostImplSlingPostServletInfo
   */
  def orgApacheSlingServletsPostImplSlingPostServlet(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, servletPostDateFormats: Option[List[String]] = None, servletPostNodeNameHints: Option[List[String]] = None, servletPostNodeNameMaxLength: Option[Integer] = None, servletPostCheckinNewVersionableNodes: Option[Boolean] = None, servletPostAutoCheckout: Option[Boolean] = None, servletPostAutoCheckin: Option[Boolean] = None, servletPostIgnorePattern: Option[String] = None): Option[OrgApacheSlingServletsPostImplSlingPostServletInfo] = {
    val await = Try(Await.result(orgApacheSlingServletsPostImplSlingPostServletAsync(post, apply, delete, action, location, propertylist, servletPostDateFormats, servletPostNodeNameHints, servletPostNodeNameMaxLength, servletPostCheckinNewVersionableNodes, servletPostAutoCheckout, servletPostAutoCheckin, servletPostIgnorePattern), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param servletPostDateFormats  (optional)
   * @param servletPostNodeNameHints  (optional)
   * @param servletPostNodeNameMaxLength  (optional)
   * @param servletPostCheckinNewVersionableNodes  (optional)
   * @param servletPostAutoCheckout  (optional)
   * @param servletPostAutoCheckin  (optional)
   * @param servletPostIgnorePattern  (optional)
   * @return Future(OrgApacheSlingServletsPostImplSlingPostServletInfo)
   */
  def orgApacheSlingServletsPostImplSlingPostServletAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, servletPostDateFormats: Option[List[String]] = None, servletPostNodeNameHints: Option[List[String]] = None, servletPostNodeNameMaxLength: Option[Integer] = None, servletPostCheckinNewVersionableNodes: Option[Boolean] = None, servletPostAutoCheckout: Option[Boolean] = None, servletPostAutoCheckin: Option[Boolean] = None, servletPostIgnorePattern: Option[String] = None): Future[OrgApacheSlingServletsPostImplSlingPostServletInfo] = {
      helper.orgApacheSlingServletsPostImplSlingPostServlet(post, apply, delete, action, location, propertylist, servletPostDateFormats, servletPostNodeNameHints, servletPostNodeNameMaxLength, servletPostCheckinNewVersionableNodes, servletPostAutoCheckout, servletPostAutoCheckin, servletPostIgnorePattern)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param servletresolverServletRoot  (optional)
   * @param servletresolverCacheSize  (optional)
   * @param servletresolverPaths  (optional)
   * @param servletresolverDefaultExtensions  (optional)
   * @return OrgApacheSlingServletsResolverSlingServletResolverInfo
   */
  def orgApacheSlingServletsResolverSlingServletResolver(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, servletresolverServletRoot: Option[String] = None, servletresolverCacheSize: Option[Integer] = None, servletresolverPaths: Option[List[String]] = None, servletresolverDefaultExtensions: Option[List[String]] = None): Option[OrgApacheSlingServletsResolverSlingServletResolverInfo] = {
    val await = Try(Await.result(orgApacheSlingServletsResolverSlingServletResolverAsync(post, apply, delete, action, location, propertylist, servletresolverServletRoot, servletresolverCacheSize, servletresolverPaths, servletresolverDefaultExtensions), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param servletresolverServletRoot  (optional)
   * @param servletresolverCacheSize  (optional)
   * @param servletresolverPaths  (optional)
   * @param servletresolverDefaultExtensions  (optional)
   * @return Future(OrgApacheSlingServletsResolverSlingServletResolverInfo)
   */
  def orgApacheSlingServletsResolverSlingServletResolverAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, servletresolverServletRoot: Option[String] = None, servletresolverCacheSize: Option[Integer] = None, servletresolverPaths: Option[List[String]] = None, servletresolverDefaultExtensions: Option[List[String]] = None): Future[OrgApacheSlingServletsResolverSlingServletResolverInfo] = {
      helper.orgApacheSlingServletsResolverSlingServletResolver(post, apply, delete, action, location, propertylist, servletresolverServletRoot, servletresolverCacheSize, servletresolverPaths, servletresolverDefaultExtensions)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingName  (optional)
   * @param slingDescription  (optional)
   * @return OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo
   */
  def orgApacheSlingSettingsImplSlingSettingsServiceImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingName: Option[String] = None, slingDescription: Option[String] = None): Option[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo] = {
    val await = Try(Await.result(orgApacheSlingSettingsImplSlingSettingsServiceImplAsync(post, apply, delete, action, location, propertylist, slingName, slingDescription), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param slingName  (optional)
   * @param slingDescription  (optional)
   * @return Future(OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo)
   */
  def orgApacheSlingSettingsImplSlingSettingsServiceImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, slingName: Option[String] = None, slingDescription: Option[String] = None): Future[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo] = {
      helper.orgApacheSlingSettingsImplSlingSettingsServiceImpl(post, apply, delete, action, location, propertylist, slingName, slingDescription)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param activeByDefault  (optional)
   * @param defaultMessage  (optional)
   * @return OrgApacheSlingStartupfilterImplStartupFilterImplInfo
   */
  def orgApacheSlingStartupfilterImplStartupFilterImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, activeByDefault: Option[Boolean] = None, defaultMessage: Option[String] = None): Option[OrgApacheSlingStartupfilterImplStartupFilterImplInfo] = {
    val await = Try(Await.result(orgApacheSlingStartupfilterImplStartupFilterImplAsync(post, apply, delete, action, location, propertylist, activeByDefault, defaultMessage), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param activeByDefault  (optional)
   * @param defaultMessage  (optional)
   * @return Future(OrgApacheSlingStartupfilterImplStartupFilterImplInfo)
   */
  def orgApacheSlingStartupfilterImplStartupFilterImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, activeByDefault: Option[Boolean] = None, defaultMessage: Option[String] = None): Future[OrgApacheSlingStartupfilterImplStartupFilterImplInfo] = {
      helper.orgApacheSlingStartupfilterImplStartupFilterImpl(post, apply, delete, action, location, propertylist, activeByDefault, defaultMessage)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param tenantRoot  (optional)
   * @param tenantPathMatcher  (optional)
   * @return OrgApacheSlingTenantInternalTenantProviderImplInfo
   */
  def orgApacheSlingTenantInternalTenantProviderImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, tenantRoot: Option[String] = None, tenantPathMatcher: Option[List[String]] = None): Option[OrgApacheSlingTenantInternalTenantProviderImplInfo] = {
    val await = Try(Await.result(orgApacheSlingTenantInternalTenantProviderImplAsync(post, apply, delete, action, location, propertylist, tenantRoot, tenantPathMatcher), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param tenantRoot  (optional)
   * @param tenantPathMatcher  (optional)
   * @return Future(OrgApacheSlingTenantInternalTenantProviderImplInfo)
   */
  def orgApacheSlingTenantInternalTenantProviderImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, tenantRoot: Option[String] = None, tenantPathMatcher: Option[List[String]] = None): Future[OrgApacheSlingTenantInternalTenantProviderImplInfo] = {
      helper.orgApacheSlingTenantInternalTenantProviderImpl(post, apply, delete, action, location, propertylist, tenantRoot, tenantPathMatcher)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param tracerSets  (optional)
   * @param enabled  (optional)
   * @param servletEnabled  (optional)
   * @param recordingCacheSizeInMB  (optional)
   * @param recordingCacheDurationInSecs  (optional)
   * @param recordingCompressionEnabled  (optional)
   * @param gzipResponse  (optional)
   * @return OrgApacheSlingTracerInternalLogTracerInfo
   */
  def orgApacheSlingTracerInternalLogTracer(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, tracerSets: Option[List[String]] = None, enabled: Option[Boolean] = None, servletEnabled: Option[Boolean] = None, recordingCacheSizeInMB: Option[Integer] = None, recordingCacheDurationInSecs: Option[Integer] = None, recordingCompressionEnabled: Option[Boolean] = None, gzipResponse: Option[Boolean] = None): Option[OrgApacheSlingTracerInternalLogTracerInfo] = {
    val await = Try(Await.result(orgApacheSlingTracerInternalLogTracerAsync(post, apply, delete, action, location, propertylist, tracerSets, enabled, servletEnabled, recordingCacheSizeInMB, recordingCacheDurationInSecs, recordingCompressionEnabled, gzipResponse), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param tracerSets  (optional)
   * @param enabled  (optional)
   * @param servletEnabled  (optional)
   * @param recordingCacheSizeInMB  (optional)
   * @param recordingCacheDurationInSecs  (optional)
   * @param recordingCompressionEnabled  (optional)
   * @param gzipResponse  (optional)
   * @return Future(OrgApacheSlingTracerInternalLogTracerInfo)
   */
  def orgApacheSlingTracerInternalLogTracerAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, tracerSets: Option[List[String]] = None, enabled: Option[Boolean] = None, servletEnabled: Option[Boolean] = None, recordingCacheSizeInMB: Option[Integer] = None, recordingCacheDurationInSecs: Option[Integer] = None, recordingCompressionEnabled: Option[Boolean] = None, gzipResponse: Option[Boolean] = None): Future[OrgApacheSlingTracerInternalLogTracerInfo] = {
      helper.orgApacheSlingTracerInternalLogTracer(post, apply, delete, action, location, propertylist, tracerSets, enabled, servletEnabled, recordingCacheSizeInMB, recordingCacheDurationInSecs, recordingCompressionEnabled, gzipResponse)
  }

  /**
   * 
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param policyPath  (optional)
   * @return OrgApacheSlingXssImplXSSFilterImplInfo
   */
  def orgApacheSlingXssImplXSSFilterImpl(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, policyPath: Option[String] = None): Option[OrgApacheSlingXssImplXSSFilterImplInfo] = {
    val await = Try(Await.result(orgApacheSlingXssImplXSSFilterImplAsync(post, apply, delete, action, location, propertylist, policyPath), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param post  (optional)
   * @param apply  (optional)
   * @param delete  (optional)
   * @param action  (optional)
   * @param location  (optional)
   * @param propertylist  (optional)
   * @param policyPath  (optional)
   * @return Future(OrgApacheSlingXssImplXSSFilterImplInfo)
   */
  def orgApacheSlingXssImplXSSFilterImplAsync(post: Option[Boolean] = None, apply: Option[Boolean] = None, delete: Option[Boolean] = None, action: Option[String] = None, location: Option[String] = None, propertylist: Option[List[String]] = None, policyPath: Option[String] = None): Future[OrgApacheSlingXssImplXSSFilterImplInfo] = {
      helper.orgApacheSlingXssImplXSSFilterImpl(post, apply, delete, action, location, propertylist, policyPath)
  }

}

class ConfigmgrApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def adaptiveFormAndInteractiveCommunicationWebChannelConfiguration(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    showPlaceholder: Option[Boolean] = None,
    maximumCacheEntries: Option[Integer] = None,
    afScriptingCompatversion: Option[String] = None,
    makeFileNameUnique: Option[Boolean] = None,
    generatingCompliantData: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo]): Future[AdaptiveFormAndInteractiveCommunicationWebChannelConfigurationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/Adaptive Form and Interactive Communication Web Channel Configuration"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    showPlaceholder match {
      case Some(param) => queryParams += "showPlaceholder" -> param.toString
      case _ => queryParams
    }
    maximumCacheEntries match {
      case Some(param) => queryParams += "maximumCacheEntries" -> param.toString
      case _ => queryParams
    }
    afScriptingCompatversion match {
      case Some(param) => queryParams += "af.scripting.compatversion" -> param.toString
      case _ => queryParams
    }
    makeFileNameUnique match {
      case Some(param) => queryParams += "makeFileNameUnique" -> param.toString
      case _ => queryParams
    }
    generatingCompliantData match {
      case Some(param) => queryParams += "generatingCompliantData" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def adaptiveFormAndInteractiveCommunicationWebChannelThemeConfigur(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fontList: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo]): Future[AdaptiveFormAndInteractiveCommunicationWebChannelThemeConfigurInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/Adaptive Form and Interactive Communication Web Channel Theme Configuration"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fontList match {
      case Some(param) => queryParams += "fontList" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def analyticsComponentQueryCacheService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAnalyticsComponentQueryCacheSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[AnalyticsComponentQueryCacheServiceInfo]): Future[AnalyticsComponentQueryCacheServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/Analytics Component Query Cache Service"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsComponentQueryCacheSize match {
      case Some(param) => queryParams += "cq.analytics.component.query.cache.size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apacheSlingHealthCheckResultHTMLSerializer(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    styleString: Option[String] = None
    )(implicit reader: ClientResponseReader[ApacheSlingHealthCheckResultHTMLSerializerInfo]): Future[ApacheSlingHealthCheckResultHTMLSerializerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/Apache Sling Health Check Result HTML Serializer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    styleString match {
      case Some(param) => queryParams += "styleString" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeAemFormsndocumentsConfigAEMFormsManagerConfiguration(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    formsManagerConfigIncludeOOTBTemplates: Option[Boolean] = None,
    formsManagerConfigIncludeDeprecatedTemplates: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo]): Future[ComAdobeAemFormsndocumentsConfigAEMFormsManagerConfigurationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.aem.formsndocuments.config.AEMFormsManagerConfiguration"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    formsManagerConfigIncludeOOTBTemplates match {
      case Some(param) => queryParams += "formsManagerConfig.includeOOTBTemplates" -> param.toString
      case _ => queryParams
    }
    formsManagerConfigIncludeDeprecatedTemplates match {
      case Some(param) => queryParams += "formsManagerConfig.includeDeprecatedTemplates" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeAemTransactionCoreImplTransactionRecorder(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    isTransactionRecordingEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeAemTransactionCoreImplTransactionRecorderInfo]): Future[ComAdobeAemTransactionCoreImplTransactionRecorderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.aem.transaction.core.impl.TransactionRecorder"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    isTransactionRecordingEnabled match {
      case Some(param) => queryParams += "isTransactionRecordingEnabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeAemUpgradePrechecksHcImplDeprecateIndexesHC(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcName: Option[String] = None,
    hcTags: Option[List[String]] = None,
    hcMbeanName: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo]): Future[ComAdobeAemUpgradePrechecksHcImplDeprecateIndexesHCInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.aem.upgrade.prechecks.hc.impl.DeprecateIndexesHC"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcName match {
      case Some(param) => queryParams += "hc.name" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    hcMbeanName match {
      case Some(param) => queryParams += "hc.mbean.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHC(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcName: Option[String] = None,
    hcTags: Option[List[String]] = None,
    hcMbeanName: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo]): Future[ComAdobeAemUpgradePrechecksHcImplReplicationAgentsDisabledHCInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.aem.upgrade.prechecks.hc.impl.ReplicationAgentsDisabledHC"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcName match {
      case Some(param) => queryParams += "hc.name" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    hcMbeanName match {
      case Some(param) => queryParams += "hc.mbean.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    preUpgradeMaintenanceTasks: Option[List[String]] = None,
    preUpgradeHcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo]): Future[ComAdobeAemUpgradePrechecksMbeanImplPreUpgradeTasksMBeanImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.aem.upgrade.prechecks.mbean.impl.PreUpgradeTasksMBeanImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    preUpgradeMaintenanceTasks match {
      case Some(param) => queryParams += "pre-upgrade.maintenance.tasks" -> param.toString
      case _ => queryParams
    }
    preUpgradeHcTags match {
      case Some(param) => queryParams += "pre-upgrade.hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    rootPath: Option[String] = None,
    fixInconsistencies: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo]): Future[ComAdobeAemUpgradePrechecksTasksImplConsistencyCheckTaskImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.aem.upgrade.prechecks.tasks.impl.ConsistencyCheckTaskImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    rootPath match {
      case Some(param) => queryParams += "root.path" -> param.toString
      case _ => queryParams
    }
    fixInconsistencies match {
      case Some(param) => queryParams += "fix.inconsistencies" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqAccountApiAccountManagementService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAccountmanagerTokenValidityPeriod: Option[Integer] = None,
    cqAccountmanagerConfigRequestnewaccountMail: Option[String] = None,
    cqAccountmanagerConfigRequestnewpwdMail: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqAccountApiAccountManagementServiceInfo]): Future[ComAdobeCqAccountApiAccountManagementServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.account.api.AccountManagementService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAccountmanagerTokenValidityPeriod match {
      case Some(param) => queryParams += "cq.accountmanager.token.validity.period" -> param.toString
      case _ => queryParams
    }
    cqAccountmanagerConfigRequestnewaccountMail match {
      case Some(param) => queryParams += "cq.accountmanager.config.requestnewaccount.mail" -> param.toString
      case _ => queryParams
    }
    cqAccountmanagerConfigRequestnewpwdMail match {
      case Some(param) => queryParams += "cq.accountmanager.config.requestnewpwd.mail" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqAccountImplAccountManagementServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAccountmanagerConfigInformnewaccountMail: Option[String] = None,
    cqAccountmanagerConfigInformnewpwdMail: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqAccountImplAccountManagementServletInfo]): Future[ComAdobeCqAccountImplAccountManagementServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.account.impl.AccountManagementServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAccountmanagerConfigInformnewaccountMail match {
      case Some(param) => queryParams += "cq.accountmanager.config.informnewaccount.mail" -> param.toString
      case _ => queryParams
    }
    cqAccountmanagerConfigInformnewpwdMail match {
      case Some(param) => queryParams += "cq.accountmanager.config.informnewpwd.mail" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqAddressImplLocationLocationListServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAddressLocationDefaultMaxResults: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqAddressImplLocationLocationListServletInfo]): Future[ComAdobeCqAddressImplLocationLocationListServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.address.impl.location.LocationListServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAddressLocationDefaultMaxResults match {
      case Some(param) => queryParams += "cq.address.location.default.maxResults" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqAuditPurgeDam(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    auditlogRuleName: Option[String] = None,
    auditlogRuleContentpath: Option[String] = None,
    auditlogRuleMinimumage: Option[Integer] = None,
    auditlogRuleTypes: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqAuditPurgeDamInfo]): Future[ComAdobeCqAuditPurgeDamInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.audit.purge.Dam"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    auditlogRuleName match {
      case Some(param) => queryParams += "auditlog.rule.name" -> param.toString
      case _ => queryParams
    }
    auditlogRuleContentpath match {
      case Some(param) => queryParams += "auditlog.rule.contentpath" -> param.toString
      case _ => queryParams
    }
    auditlogRuleMinimumage match {
      case Some(param) => queryParams += "auditlog.rule.minimumage" -> param.toString
      case _ => queryParams
    }
    auditlogRuleTypes match {
      case Some(param) => queryParams += "auditlog.rule.types" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqAuditPurgePages(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    auditlogRuleName: Option[String] = None,
    auditlogRuleContentpath: Option[String] = None,
    auditlogRuleMinimumage: Option[Integer] = None,
    auditlogRuleTypes: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqAuditPurgePagesInfo]): Future[ComAdobeCqAuditPurgePagesInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.audit.purge.Pages"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    auditlogRuleName match {
      case Some(param) => queryParams += "auditlog.rule.name" -> param.toString
      case _ => queryParams
    }
    auditlogRuleContentpath match {
      case Some(param) => queryParams += "auditlog.rule.contentpath" -> param.toString
      case _ => queryParams
    }
    auditlogRuleMinimumage match {
      case Some(param) => queryParams += "auditlog.rule.minimumage" -> param.toString
      case _ => queryParams
    }
    auditlogRuleTypes match {
      case Some(param) => queryParams += "auditlog.rule.types" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqAuditPurgeReplication(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    auditlogRuleName: Option[String] = None,
    auditlogRuleContentpath: Option[String] = None,
    auditlogRuleMinimumage: Option[Integer] = None,
    auditlogRuleTypes: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqAuditPurgeReplicationInfo]): Future[ComAdobeCqAuditPurgeReplicationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.audit.purge.Replication"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    auditlogRuleName match {
      case Some(param) => queryParams += "auditlog.rule.name" -> param.toString
      case _ => queryParams
    }
    auditlogRuleContentpath match {
      case Some(param) => queryParams += "auditlog.rule.contentpath" -> param.toString
      case _ => queryParams
    }
    auditlogRuleMinimumage match {
      case Some(param) => queryParams += "auditlog.rule.minimumage" -> param.toString
      case _ => queryParams
    }
    auditlogRuleTypes match {
      case Some(param) => queryParams += "auditlog.rule.types" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCdnRewriterImplAWSCloudFrontRewriter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    keypairId: Option[String] = None,
    keypairAlias: Option[String] = None,
    cdnrewriterAttributes: Option[List[String]] = None,
    cdnRewriterDistributionDomain: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo]): Future[ComAdobeCqCdnRewriterImplAWSCloudFrontRewriterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.AWSCloudFrontRewriter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    keypairId match {
      case Some(param) => queryParams += "keypair.id" -> param.toString
      case _ => queryParams
    }
    keypairAlias match {
      case Some(param) => queryParams += "keypair.alias" -> param.toString
      case _ => queryParams
    }
    cdnrewriterAttributes match {
      case Some(param) => queryParams += "cdnrewriter.attributes" -> param.toString
      case _ => queryParams
    }
    cdnRewriterDistributionDomain match {
      case Some(param) => queryParams += "cdn.rewriter.distribution.domain" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCdnRewriterImplCDNConfigServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cdnConfigDistributionDomain: Option[String] = None,
    cdnConfigEnableRewriting: Option[Boolean] = None,
    cdnConfigPathPrefixes: Option[List[String]] = None,
    cdnConfigCdnttl: Option[Integer] = None,
    cdnConfigApplicationProtocol: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo]): Future[ComAdobeCqCdnRewriterImplCDNConfigServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.CDNConfigServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cdnConfigDistributionDomain match {
      case Some(param) => queryParams += "cdn.config.distribution.domain" -> param.toString
      case _ => queryParams
    }
    cdnConfigEnableRewriting match {
      case Some(param) => queryParams += "cdn.config.enable.rewriting" -> param.toString
      case _ => queryParams
    }
    cdnConfigPathPrefixes match {
      case Some(param) => queryParams += "cdn.config.path.prefixes" -> param.toString
      case _ => queryParams
    }
    cdnConfigCdnttl match {
      case Some(param) => queryParams += "cdn.config.cdnttl" -> param.toString
      case _ => queryParams
    }
    cdnConfigApplicationProtocol match {
      case Some(param) => queryParams += "cdn.config.application.protocol" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCdnRewriterImplCDNRewriter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    cdnrewriterAttributes: Option[List[String]] = None,
    cdnRewriterDistributionDomain: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCdnRewriterImplCDNRewriterInfo]): Future[ComAdobeCqCdnRewriterImplCDNRewriterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.cdn.rewriter.impl.CDNRewriter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    cdnrewriterAttributes match {
      case Some(param) => queryParams += "cdnrewriter.attributes" -> param.toString
      case _ => queryParams
    }
    cdnRewriterDistributionDomain match {
      case Some(param) => queryParams += "cdn.rewriter.distribution.domain" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandle(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    flushAgents: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo]): Future[ComAdobeCqCloudconfigCoreImplConfigurationReplicationEventHandleInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.cloudconfig.core.impl.ConfigurationReplicationEventHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    flushAgents match {
      case Some(param) => queryParams += "flush.agents" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCommerceImplAssetDynamicImageHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqCommerceAssetHandlerActive: Option[Boolean] = None,
    cqCommerceAssetHandlerName: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo]): Future[ComAdobeCqCommerceImplAssetDynamicImageHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.commerce.impl.asset.DynamicImageHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqCommerceAssetHandlerActive match {
      case Some(param) => queryParams += "cq.commerce.asset.handler.active" -> param.toString
      case _ => queryParams
    }
    cqCommerceAssetHandlerName match {
      case Some(param) => queryParams += "cq.commerce.asset.handler.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCommerceImplAssetProductAssetHandlerProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqCommerceAssetHandlerFallback: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo]): Future[ComAdobeCqCommerceImplAssetProductAssetHandlerProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.commerce.impl.asset.ProductAssetHandlerProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqCommerceAssetHandlerFallback match {
      case Some(param) => queryParams += "cq.commerce.asset.handler.fallback" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCommerceImplAssetStaticImageHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqCommerceAssetHandlerActive: Option[Boolean] = None,
    cqCommerceAssetHandlerName: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo]): Future[ComAdobeCqCommerceImplAssetStaticImageHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.commerce.impl.asset.StaticImageHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqCommerceAssetHandlerActive match {
      case Some(param) => queryParams += "cq.commerce.asset.handler.active" -> param.toString
      case _ => queryParams
    }
    cqCommerceAssetHandlerName match {
      case Some(param) => queryParams += "cq.commerce.asset.handler.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCommerceImplAssetVideoHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqCommerceAssetHandlerActive: Option[Boolean] = None,
    cqCommerceAssetHandlerName: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCommerceImplAssetVideoHandlerInfo]): Future[ComAdobeCqCommerceImplAssetVideoHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.commerce.impl.asset.VideoHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqCommerceAssetHandlerActive match {
      case Some(param) => queryParams += "cq.commerce.asset.handler.active" -> param.toString
      case _ => queryParams
    }
    cqCommerceAssetHandlerName match {
      case Some(param) => queryParams += "cq.commerce.asset.handler.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCommerceImplPromotionPromotionManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqCommercePromotionRoot: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo]): Future[ComAdobeCqCommerceImplPromotionPromotionManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.commerce.impl.promotion.PromotionManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqCommercePromotionRoot match {
      case Some(param) => queryParams += "cq.commerce.promotion.root" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqCommerceCataloggeneratorBucketsize: Option[Integer] = None,
    cqCommerceCataloggeneratorBucketname: Option[String] = None,
    cqCommerceCataloggeneratorExcludedtemplateproperties: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo]): Future[ComAdobeCqCommercePimImplCataloggeneratorCatalogGeneratorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.commerce.pim.impl.cataloggenerator.CatalogGeneratorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqCommerceCataloggeneratorBucketsize match {
      case Some(param) => queryParams += "cq.commerce.cataloggenerator.bucketsize" -> param.toString
      case _ => queryParams
    }
    cqCommerceCataloggeneratorBucketname match {
      case Some(param) => queryParams += "cq.commerce.cataloggenerator.bucketname" -> param.toString
      case _ => queryParams
    }
    cqCommerceCataloggeneratorExcludedtemplateproperties match {
      case Some(param) => queryParams += "cq.commerce.cataloggenerator.excludedtemplateproperties" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCommercePimImplPageEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqCommercePageeventlistenerEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCommercePimImplPageEventListenerInfo]): Future[ComAdobeCqCommercePimImplPageEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.commerce.pim.impl.PageEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqCommercePageeventlistenerEnabled match {
      case Some(param) => queryParams += "cq.commerce.pageeventlistener.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqCommercePimImplProductfeedProductFeedServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    feedGeneratorAlgorithm: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo]): Future[ComAdobeCqCommercePimImplProductfeedProductFeedServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.commerce.pim.impl.productfeed.ProductFeedServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    feedGeneratorAlgorithm match {
      case Some(param) => queryParams += "Feed generator algorithm" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqContentinsightImplReportingServicesSettingsProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    reportingservicesUrl: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo]): Future[ComAdobeCqContentinsightImplReportingServicesSettingsProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.contentinsight.impl.ReportingServicesSettingsProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    reportingservicesUrl match {
      case Some(param) => queryParams += "reportingservices.url" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqContentinsightImplServletsBrightEdgeProxyServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    brightedgeUrl: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo]): Future[ComAdobeCqContentinsightImplServletsBrightEdgeProxyServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.contentinsight.impl.servlets.BrightEdgeProxyServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    brightedgeUrl match {
      case Some(param) => queryParams += "brightedge.url" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqContentinsightImplServletsReportingServicesProxyServle(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    reportingservicesProxyWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo]): Future[ComAdobeCqContentinsightImplServletsReportingServicesProxyServleInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.contentinsight.impl.servlets.ReportingServicesProxyServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    reportingservicesProxyWhitelist match {
      case Some(param) => queryParams += "reportingservices.proxy.whitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamCfmImplComponentComponentConfigImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    damCfmComponentResourceType: Option[String] = None,
    damCfmComponentFileReferenceProp: Option[String] = None,
    damCfmComponentElementsProp: Option[String] = None,
    damCfmComponentVariationProp: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo]): Future[ComAdobeCqDamCfmImplComponentComponentConfigImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.cfm.impl.component.ComponentConfigImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    damCfmComponentResourceType match {
      case Some(param) => queryParams += "dam.cfm.component.resourceType" -> param.toString
      case _ => queryParams
    }
    damCfmComponentFileReferenceProp match {
      case Some(param) => queryParams += "dam.cfm.component.fileReferenceProp" -> param.toString
      case _ => queryParams
    }
    damCfmComponentElementsProp match {
      case Some(param) => queryParams += "dam.cfm.component.elementsProp" -> param.toString
      case _ => queryParams
    }
    damCfmComponentVariationProp match {
      case Some(param) => queryParams += "dam.cfm.component.variationProp" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamCfmImplConfFeatureConfigImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    damCfmResourceTypes: Option[List[String]] = None,
    damCfmReferenceProperties: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo]): Future[ComAdobeCqDamCfmImplConfFeatureConfigImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.cfm.impl.conf.FeatureConfigImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    damCfmResourceTypes match {
      case Some(param) => queryParams += "dam.cfm.resourceTypes" -> param.toString
      case _ => queryParams
    }
    damCfmReferenceProperties match {
      case Some(param) => queryParams += "dam.cfm.referenceProperties" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamCfmImplContentRewriterAssetProcessor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    pipelineType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo]): Future[ComAdobeCqDamCfmImplContentRewriterAssetProcessorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.AssetProcessor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    pipelineType match {
      case Some(param) => queryParams += "pipeline.type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamCfmImplContentRewriterParRangeFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    pipelineType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo]): Future[ComAdobeCqDamCfmImplContentRewriterParRangeFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.ParRangeFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    pipelineType match {
      case Some(param) => queryParams += "pipeline.type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamCfmImplContentRewriterPayloadFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    pipelineType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo]): Future[ComAdobeCqDamCfmImplContentRewriterPayloadFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.cfm.impl.content.rewriter.PayloadFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    pipelineType match {
      case Some(param) => queryParams += "pipeline.type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamDmProcessImagePTiffManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxMemory: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo]): Future[ComAdobeCqDamDmProcessImagePTiffManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.dm.process.image.PTiffManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxMemory match {
      case Some(param) => queryParams += "maxMemory" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorker(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    dmreplicateonmodifyEnabled: Option[Boolean] = None,
    dmreplicateonmodifyForcesyncdeletes: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo]): Future[ComAdobeCqDamIpsImplReplicationTriggerReplicateOnModifyWorkerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.ips.impl.replication.trigger.ReplicateOnModifyWorker"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    dmreplicateonmodifyEnabled match {
      case Some(param) => queryParams += "dmreplicateonmodify.enabled" -> param.toString
      case _ => queryParams
    }
    dmreplicateonmodifyForcesyncdeletes match {
      case Some(param) => queryParams += "dmreplicateonmodify.forcesyncdeletes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamMacSyncHelperImplMACSyncClientImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeDamMacSyncClientSoTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo]): Future[ComAdobeCqDamMacSyncHelperImplMACSyncClientImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.mac.sync.helper.impl.MACSyncClientImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeDamMacSyncClientSoTimeout match {
      case Some(param) => queryParams += "com.adobe.dam.mac.sync.client.so.timeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamMacSyncImplDAMSyncServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths: Option[List[String]] = None,
    comAdobeCqDamMacSyncDamsyncserviceSyncRenditions: Option[Boolean] = None,
    comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs: Option[Integer] = None,
    comAdobeCqDamMacSyncDamsyncservicePlatform: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo]): Future[ComAdobeCqDamMacSyncImplDAMSyncServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.mac.sync.impl.DAMSyncServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeCqDamMacSyncDamsyncserviceRegisteredPaths match {
      case Some(param) => queryParams += "com.adobe.cq.dam.mac.sync.damsyncservice.registered_paths" -> param.toString
      case _ => queryParams
    }
    comAdobeCqDamMacSyncDamsyncserviceSyncRenditions match {
      case Some(param) => queryParams += "com.adobe.cq.dam.mac.sync.damsyncservice.sync.renditions" -> param.toString
      case _ => queryParams
    }
    comAdobeCqDamMacSyncDamsyncserviceReplicateThreadWaitMs match {
      case Some(param) => queryParams += "com.adobe.cq.dam.mac.sync.damsyncservice.replicate.thread.wait.ms" -> param.toString
      case _ => queryParams
    }
    comAdobeCqDamMacSyncDamsyncservicePlatform match {
      case Some(param) => queryParams += "com.adobe.cq.dam.mac.sync.damsyncservice.platform" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamProcessorNuiImplNuiAssetProcessor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    nuiEnabled: Option[Boolean] = None,
    nuiServiceUrl: Option[String] = None,
    nuiApiKey: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo]): Future[ComAdobeCqDamProcessorNuiImplNuiAssetProcessorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.processor.nui.impl.NuiAssetProcessor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    nuiEnabled match {
      case Some(param) => queryParams += "nuiEnabled" -> param.toString
      case _ => queryParams
    }
    nuiServiceUrl match {
      case Some(param) => queryParams += "nuiServiceUrl" -> param.toString
      case _ => queryParams
    }
    nuiApiKey match {
      case Some(param) => queryParams += "nuiApiKey" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamS7imagingImplIsImageServerComponent(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    tcpPort: Option[String] = None,
    allowRemoteAccess: Option[Boolean] = None,
    maxRenderRgnPixels: Option[String] = None,
    maxMessageSize: Option[String] = None,
    randomAccessUrlTimeout: Option[Integer] = None,
    workerThreads: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo]): Future[ComAdobeCqDamS7imagingImplIsImageServerComponentInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.s7imaging.impl.is.ImageServerComponent"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    tcpPort match {
      case Some(param) => queryParams += "TcpPort" -> param.toString
      case _ => queryParams
    }
    allowRemoteAccess match {
      case Some(param) => queryParams += "AllowRemoteAccess" -> param.toString
      case _ => queryParams
    }
    maxRenderRgnPixels match {
      case Some(param) => queryParams += "MaxRenderRgnPixels" -> param.toString
      case _ => queryParams
    }
    maxMessageSize match {
      case Some(param) => queryParams += "MaxMessageSize" -> param.toString
      case _ => queryParams
    }
    randomAccessUrlTimeout match {
      case Some(param) => queryParams += "RandomAccessUrlTimeout" -> param.toString
      case _ => queryParams
    }
    workerThreads match {
      case Some(param) => queryParams += "WorkerThreads" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamS7imagingImplPsPlatformServerServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cacheEnable: Option[Boolean] = None,
    cacheRootPaths: Option[List[String]] = None,
    cacheMaxSize: Option[Integer] = None,
    cacheMaxEntries: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo]): Future[ComAdobeCqDamS7imagingImplPsPlatformServerServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.s7imaging.impl.ps.PlatformServerServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cacheEnable match {
      case Some(param) => queryParams += "cache.enable" -> param.toString
      case _ => queryParams
    }
    cacheRootPaths match {
      case Some(param) => queryParams += "cache.rootPaths" -> param.toString
      case _ => queryParams
    }
    cacheMaxSize match {
      case Some(param) => queryParams += "cache.maxSize" -> param.toString
      case _ => queryParams
    }
    cacheMaxEntries match {
      case Some(param) => queryParams += "cache.maxEntries" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamWebdavImplIoAssetIOHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    pathPrefix: Option[String] = None,
    createVersion: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo]): Future[ComAdobeCqDamWebdavImplIoAssetIOHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.AssetIOHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    pathPrefix match {
      case Some(param) => queryParams += "pathPrefix" -> param.toString
      case _ => queryParams
    }
    createVersion match {
      case Some(param) => queryParams += "createVersion" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJob(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamWebdavVersionLinkingEnable: Option[Boolean] = None,
    cqDamWebdavVersionLinkingSchedulerPeriod: Option[Integer] = None,
    cqDamWebdavVersionLinkingStagingTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo]): Future[ComAdobeCqDamWebdavImplIoDamWebdavVersionLinkingJobInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.DamWebdavVersionLinkingJob"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamWebdavVersionLinkingEnable match {
      case Some(param) => queryParams += "cq.dam.webdav.version.linking.enable" -> param.toString
      case _ => queryParams
    }
    cqDamWebdavVersionLinkingSchedulerPeriod match {
      case Some(param) => queryParams += "cq.dam.webdav.version.linking.scheduler.period" -> param.toString
      case _ => queryParams
    }
    cqDamWebdavVersionLinkingStagingTimeout match {
      case Some(param) => queryParams += "cq.dam.webdav.version.linking.staging.timeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDamWebdavImplIoSpecialFilesHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo]): Future[ComAdobeCqDamWebdavImplIoSpecialFilesHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dam.webdav.impl.io.SpecialFilesHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comDayCqDamCoreImplIoSpecialFilesHandlerFilepatters match {
      case Some(param) => queryParams += "com.day.cq.dam.core.impl.io.SpecialFilesHandler.filepatters" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDeserfwImplDeserializationFirewallImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    firewallDeserializationWhitelist: Option[List[String]] = None,
    firewallDeserializationBlacklist: Option[List[String]] = None,
    firewallDeserializationDiagnostics: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo]): Future[ComAdobeCqDeserfwImplDeserializationFirewallImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.deserfw.impl.DeserializationFirewallImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    firewallDeserializationWhitelist match {
      case Some(param) => queryParams += "firewall.deserialization.whitelist" -> param.toString
      case _ => queryParams
    }
    firewallDeserializationBlacklist match {
      case Some(param) => queryParams += "firewall.deserialization.blacklist" -> param.toString
      case _ => queryParams
    }
    firewallDeserializationDiagnostics match {
      case Some(param) => queryParams += "firewall.deserialization.diagnostics" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDtmImplServiceDTMWebServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    connectionTimeout: Option[Integer] = None,
    socketTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo]): Future[ComAdobeCqDtmImplServiceDTMWebServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dtm.impl.service.DTMWebServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    connectionTimeout match {
      case Some(param) => queryParams += "connection.timeout" -> param.toString
      case _ => queryParams
    }
    socketTimeout match {
      case Some(param) => queryParams += "socket.timeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDtmImplServletsDTMDeployHookServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    dtmStagingIpWhitelist: Option[List[String]] = None,
    dtmProductionIpWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo]): Future[ComAdobeCqDtmImplServletsDTMDeployHookServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dtm.impl.servlets.DTMDeployHookServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    dtmStagingIpWhitelist match {
      case Some(param) => queryParams += "dtm.staging.ip.whitelist" -> param.toString
      case _ => queryParams
    }
    dtmProductionIpWhitelist match {
      case Some(param) => queryParams += "dtm.production.ip.whitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqDtmReactorImplServiceWebServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    endpointUri: Option[String] = None,
    connectionTimeout: Option[Integer] = None,
    socketTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo]): Future[ComAdobeCqDtmReactorImplServiceWebServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.dtm.reactor.impl.service.WebServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    endpointUri match {
      case Some(param) => queryParams += "endpointUri" -> param.toString
      case _ => queryParams
    }
    connectionTimeout match {
      case Some(param) => queryParams += "connectionTimeout" -> param.toString
      case _ => queryParams
    }
    socketTimeout match {
      case Some(param) => queryParams += "socketTimeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqExperiencelogImplExperienceLogConfigServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    disabledForGroups: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo]): Future[ComAdobeCqExperiencelogImplExperienceLogConfigServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.experiencelog.impl.ExperienceLogConfigServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    disabledForGroups match {
      case Some(param) => queryParams += "disabledForGroups" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqHcContentPackagesHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcName: Option[String] = None,
    hcTags: Option[List[String]] = None,
    hcMbeanName: Option[String] = None,
    packageNames: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqHcContentPackagesHealthCheckInfo]): Future[ComAdobeCqHcContentPackagesHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.hc.ContentPackagesHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcName match {
      case Some(param) => queryParams += "hc.name" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    hcMbeanName match {
      case Some(param) => queryParams += "hc.mbean.name" -> param.toString
      case _ => queryParams
    }
    packageNames match {
      case Some(param) => queryParams += "package.names" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqHistoryImplHistoryRequestFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    historyRequestFilterExcludedSelectors: Option[List[String]] = None,
    historyRequestFilterExcludedExtensions: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqHistoryImplHistoryRequestFilterInfo]): Future[ComAdobeCqHistoryImplHistoryRequestFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.history.impl.HistoryRequestFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    historyRequestFilterExcludedSelectors match {
      case Some(param) => queryParams += "history.requestFilter.excludedSelectors" -> param.toString
      case _ => queryParams
    }
    historyRequestFilterExcludedExtensions match {
      case Some(param) => queryParams += "history.requestFilter.excludedExtensions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqHistoryImplHistoryServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    historyServiceResourceTypes: Option[List[String]] = None,
    historyServicePathFilter: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqHistoryImplHistoryServiceImplInfo]): Future[ComAdobeCqHistoryImplHistoryServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.history.impl.HistoryServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    historyServiceResourceTypes match {
      case Some(param) => queryParams += "history.service.resourceTypes" -> param.toString
      case _ => queryParams
    }
    historyServicePathFilter match {
      case Some(param) => queryParams += "history.service.pathFilter" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqInboxImplTypeproviderItemTypeProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    inboxImplTypeproviderRegistrypaths: Option[List[String]] = None,
    inboxImplTypeproviderLegacypaths: Option[List[String]] = None,
    inboxImplTypeproviderDefaulturlFailureitem: Option[String] = None,
    inboxImplTypeproviderDefaulturlWorkitem: Option[String] = None,
    inboxImplTypeproviderDefaulturlTask: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo]): Future[ComAdobeCqInboxImplTypeproviderItemTypeProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.inbox.impl.typeprovider.ItemTypeProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    inboxImplTypeproviderRegistrypaths match {
      case Some(param) => queryParams += "inbox.impl.typeprovider.registrypaths" -> param.toString
      case _ => queryParams
    }
    inboxImplTypeproviderLegacypaths match {
      case Some(param) => queryParams += "inbox.impl.typeprovider.legacypaths" -> param.toString
      case _ => queryParams
    }
    inboxImplTypeproviderDefaulturlFailureitem match {
      case Some(param) => queryParams += "inbox.impl.typeprovider.defaulturl.failureitem" -> param.toString
      case _ => queryParams
    }
    inboxImplTypeproviderDefaulturlWorkitem match {
      case Some(param) => queryParams += "inbox.impl.typeprovider.defaulturl.workitem" -> param.toString
      case _ => queryParams
    }
    inboxImplTypeproviderDefaulturlTask match {
      case Some(param) => queryParams += "inbox.impl.typeprovider.defaulturl.task" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqProjectsImplServletProjectImageServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    imageQuality: Option[String] = None,
    imageSupportedResolutions: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqProjectsImplServletProjectImageServletInfo]): Future[ComAdobeCqProjectsImplServletProjectImageServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.projects.impl.servlet.ProjectImageServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    imageQuality match {
      case Some(param) => queryParams += "image.quality" -> param.toString
      case _ => queryParams
    }
    imageSupportedResolutions match {
      case Some(param) => queryParams += "image.supported.resolutions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqProjectsPurgeScheduler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    scheduledpurgeName: Option[String] = None,
    scheduledpurgePurgeActive: Option[Boolean] = None,
    scheduledpurgeTemplates: Option[List[String]] = None,
    scheduledpurgePurgeGroups: Option[Boolean] = None,
    scheduledpurgePurgeAssets: Option[Boolean] = None,
    scheduledpurgeTerminateRunningWorkflows: Option[Boolean] = None,
    scheduledpurgeDaysold: Option[Integer] = None,
    scheduledpurgeSaveThreshold: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqProjectsPurgeSchedulerInfo]): Future[ComAdobeCqProjectsPurgeSchedulerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.projects.purge.Scheduler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    scheduledpurgeName match {
      case Some(param) => queryParams += "scheduledpurge.name" -> param.toString
      case _ => queryParams
    }
    scheduledpurgePurgeActive match {
      case Some(param) => queryParams += "scheduledpurge.purgeActive" -> param.toString
      case _ => queryParams
    }
    scheduledpurgeTemplates match {
      case Some(param) => queryParams += "scheduledpurge.templates" -> param.toString
      case _ => queryParams
    }
    scheduledpurgePurgeGroups match {
      case Some(param) => queryParams += "scheduledpurge.purgeGroups" -> param.toString
      case _ => queryParams
    }
    scheduledpurgePurgeAssets match {
      case Some(param) => queryParams += "scheduledpurge.purgeAssets" -> param.toString
      case _ => queryParams
    }
    scheduledpurgeTerminateRunningWorkflows match {
      case Some(param) => queryParams += "scheduledpurge.terminateRunningWorkflows" -> param.toString
      case _ => queryParams
    }
    scheduledpurgeDaysold match {
      case Some(param) => queryParams += "scheduledpurge.daysold" -> param.toString
      case _ => queryParams
    }
    scheduledpurgeSaveThreshold match {
      case Some(param) => queryParams += "scheduledpurge.saveThreshold" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScheduledExporterImplScheduledExporterImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    includePaths: Option[List[String]] = None,
    exporterUser: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo]): Future[ComAdobeCqScheduledExporterImplScheduledExporterImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.scheduled.exporter.impl.ScheduledExporterImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    includePaths match {
      case Some(param) => queryParams += "include.paths" -> param.toString
      case _ => queryParams
    }
    exporterUser match {
      case Some(param) => queryParams += "exporter.user" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeCqScreensAnalyticsImplUrl: Option[String] = None,
    comAdobeCqScreensAnalyticsImplApikey: Option[String] = None,
    comAdobeCqScreensAnalyticsImplProject: Option[String] = None,
    comAdobeCqScreensAnalyticsImplEnvironment: Option[String] = None,
    comAdobeCqScreensAnalyticsImplSendFrequency: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo]): Future[ComAdobeCqScreensAnalyticsImplScreensAnalyticsServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.analytics.impl.ScreensAnalyticsServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensAnalyticsImplUrl match {
      case Some(param) => queryParams += "com.adobe.cq.screens.analytics.impl.url" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensAnalyticsImplApikey match {
      case Some(param) => queryParams += "com.adobe.cq.screens.analytics.impl.apikey" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensAnalyticsImplProject match {
      case Some(param) => queryParams += "com.adobe.cq.screens.analytics.impl.project" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensAnalyticsImplEnvironment match {
      case Some(param) => queryParams += "com.adobe.cq.screens.analytics.impl.environment" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensAnalyticsImplSendFrequency match {
      case Some(param) => queryParams += "com.adobe.cq.screens.analytics.impl.sendFrequency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensDeviceImplDeviceService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeAemScreensPlayerPingfrequency: Option[Integer] = None,
    comAdobeAemScreensDevicePaswordSpecialchars: Option[String] = None,
    comAdobeAemScreensDevicePaswordMinlowercasechars: Option[Integer] = None,
    comAdobeAemScreensDevicePaswordMinuppercasechars: Option[Integer] = None,
    comAdobeAemScreensDevicePaswordMinnumberchars: Option[Integer] = None,
    comAdobeAemScreensDevicePaswordMinspecialchars: Option[Integer] = None,
    comAdobeAemScreensDevicePaswordMinlength: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensDeviceImplDeviceServiceInfo]): Future[ComAdobeCqScreensDeviceImplDeviceServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.device.impl.DeviceService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeAemScreensPlayerPingfrequency match {
      case Some(param) => queryParams += "com.adobe.aem.screens.player.pingfrequency" -> param.toString
      case _ => queryParams
    }
    comAdobeAemScreensDevicePaswordSpecialchars match {
      case Some(param) => queryParams += "com.adobe.aem.screens.device.pasword.specialchars" -> param.toString
      case _ => queryParams
    }
    comAdobeAemScreensDevicePaswordMinlowercasechars match {
      case Some(param) => queryParams += "com.adobe.aem.screens.device.pasword.minlowercasechars" -> param.toString
      case _ => queryParams
    }
    comAdobeAemScreensDevicePaswordMinuppercasechars match {
      case Some(param) => queryParams += "com.adobe.aem.screens.device.pasword.minuppercasechars" -> param.toString
      case _ => queryParams
    }
    comAdobeAemScreensDevicePaswordMinnumberchars match {
      case Some(param) => queryParams += "com.adobe.aem.screens.device.pasword.minnumberchars" -> param.toString
      case _ => queryParams
    }
    comAdobeAemScreensDevicePaswordMinspecialchars match {
      case Some(param) => queryParams += "com.adobe.aem.screens.device.pasword.minspecialchars" -> param.toString
      case _ => queryParams
    }
    comAdobeAemScreensDevicePaswordMinlength match {
      case Some(param) => queryParams += "com.adobe.aem.screens.device.pasword.minlength" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensDeviceRegistrationImplRegistrationServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    deviceRegistrationTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo]): Future[ComAdobeCqScreensDeviceRegistrationImplRegistrationServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.device.registration.impl.RegistrationServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    deviceRegistrationTimeout match {
      case Some(param) => queryParams += "deviceRegistrationTimeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensImplHandlerChannelsUpdateHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqPagesupdatehandlerImageresourcetypes: Option[List[String]] = None,
    cqPagesupdatehandlerProductresourcetypes: Option[List[String]] = None,
    cqPagesupdatehandlerVideoresourcetypes: Option[List[String]] = None,
    cqPagesupdatehandlerDynamicsequenceresourcetypes: Option[List[String]] = None,
    cqPagesupdatehandlerPreviewmodepaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo]): Future[ComAdobeCqScreensImplHandlerChannelsUpdateHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.impl.handler.ChannelsUpdateHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqPagesupdatehandlerImageresourcetypes match {
      case Some(param) => queryParams += "cq.pagesupdatehandler.imageresourcetypes" -> param.toString
      case _ => queryParams
    }
    cqPagesupdatehandlerProductresourcetypes match {
      case Some(param) => queryParams += "cq.pagesupdatehandler.productresourcetypes" -> param.toString
      case _ => queryParams
    }
    cqPagesupdatehandlerVideoresourcetypes match {
      case Some(param) => queryParams += "cq.pagesupdatehandler.videoresourcetypes" -> param.toString
      case _ => queryParams
    }
    cqPagesupdatehandlerDynamicsequenceresourcetypes match {
      case Some(param) => queryParams += "cq.pagesupdatehandler.dynamicsequenceresourcetypes" -> param.toString
      case _ => queryParams
    }
    cqPagesupdatehandlerPreviewmodepaths match {
      case Some(param) => queryParams += "cq.pagesupdatehandler.previewmodepaths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJob(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo]): Future[ComAdobeCqScreensImplJobsDistributedDevicesStatiUpdateJobInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.impl.jobs.DistributedDevicesStatiUpdateJob"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensImplRemoteImplDistributedHttpClientImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeAemScreensImplRemoteRequestTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo]): Future[ComAdobeCqScreensImplRemoteImplDistributedHttpClientImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.impl.remote.impl.DistributedHttpClientImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeAemScreensImplRemoteRequestTimeout match {
      case Some(param) => queryParams += "com.adobe.aem.screens.impl.remote.request_timeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensImplScreensChannelPostProcessor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    screensChannelsPropertiesToRemove: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensImplScreensChannelPostProcessorInfo]): Future[ComAdobeCqScreensImplScreensChannelPostProcessorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.impl.ScreensChannelPostProcessor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    screensChannelsPropertiesToRemove match {
      case Some(param) => queryParams += "screens.channels.properties.to.remove" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensMonitoringImplScreensMonitoringServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath: Option[List[String]] = None,
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency: Option[String] = None,
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout: Option[Integer] = None,
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients: Option[String] = None,
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver: Option[String] = None,
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport: Option[Integer] = None,
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls: Option[Boolean] = None,
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername: Option[String] = None,
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo]): Future[ComAdobeCqScreensMonitoringImplScreensMonitoringServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplProjectPath match {
      case Some(param) => queryParams += "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.projectPath" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplScheduleFrequency match {
      case Some(param) => queryParams += "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.scheduleFrequency" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPingTimeout match {
      case Some(param) => queryParams += "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.pingTimeout" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplRecipients match {
      case Some(param) => queryParams += "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.recipients" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpserver match {
      case Some(param) => queryParams += "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpserver" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplSmtpport match {
      case Some(param) => queryParams += "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.smtpport" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsetls match {
      case Some(param) => queryParams += "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.usetls" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplUsername match {
      case Some(param) => queryParams += "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.username" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensMonitoringImplScreensMonitoringServiceImplPassword match {
      case Some(param) => queryParams += "com.adobe.cq.screens.monitoring.impl.ScreensMonitoringServiceImpl.password" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensMqActivemqImplArtemisJMSProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    globalSize: Option[Integer] = None,
    maxDiskUsage: Option[Integer] = None,
    persistenceEnabled: Option[Boolean] = None,
    threadPoolMaxSize: Option[Integer] = None,
    scheduledThreadPoolMaxSize: Option[Integer] = None,
    gracefulShutdownTimeout: Option[Integer] = None,
    queues: Option[List[String]] = None,
    topics: Option[List[String]] = None,
    addressesMaxDeliveryAttempts: Option[Integer] = None,
    addressesExpiryDelay: Option[Integer] = None,
    addressesAddressFullMessagePolicy: Option[String] = None,
    addressesMaxSizeBytes: Option[Integer] = None,
    addressesPageSizeBytes: Option[Integer] = None,
    addressesPageCacheMaxSize: Option[Integer] = None,
    clusterUser: Option[String] = None,
    clusterPassword: Option[String] = None,
    clusterCallTimeout: Option[Integer] = None,
    clusterCallFailoverTimeout: Option[Integer] = None,
    clusterClientFailureCheckPeriod: Option[Integer] = None,
    clusterNotificationAttempts: Option[Integer] = None,
    clusterNotificationInterval: Option[Integer] = None,
    idCacheSize: Option[Integer] = None,
    clusterConfirmationWindowSize: Option[Integer] = None,
    clusterConnectionTtl: Option[Integer] = None,
    clusterDuplicateDetection: Option[Boolean] = None,
    clusterInitialConnectAttempts: Option[Integer] = None,
    clusterMaxRetryInterval: Option[Integer] = None,
    clusterMinLargeMessageSize: Option[Integer] = None,
    clusterProducerWindowSize: Option[Integer] = None,
    clusterReconnectAttempts: Option[Integer] = None,
    clusterRetryInterval: Option[Integer] = None,
    clusterRetryIntervalMultiplier: Option[Number] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo]): Future[ComAdobeCqScreensMqActivemqImplArtemisJMSProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.mq.activemq.impl.ArtemisJMSProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    globalSize match {
      case Some(param) => queryParams += "global.size" -> param.toString
      case _ => queryParams
    }
    maxDiskUsage match {
      case Some(param) => queryParams += "max.disk.usage" -> param.toString
      case _ => queryParams
    }
    persistenceEnabled match {
      case Some(param) => queryParams += "persistence.enabled" -> param.toString
      case _ => queryParams
    }
    threadPoolMaxSize match {
      case Some(param) => queryParams += "thread.pool.max.size" -> param.toString
      case _ => queryParams
    }
    scheduledThreadPoolMaxSize match {
      case Some(param) => queryParams += "scheduled.thread.pool.max.size" -> param.toString
      case _ => queryParams
    }
    gracefulShutdownTimeout match {
      case Some(param) => queryParams += "graceful.shutdown.timeout" -> param.toString
      case _ => queryParams
    }
    queues match {
      case Some(param) => queryParams += "queues" -> param.toString
      case _ => queryParams
    }
    topics match {
      case Some(param) => queryParams += "topics" -> param.toString
      case _ => queryParams
    }
    addressesMaxDeliveryAttempts match {
      case Some(param) => queryParams += "addresses.max.delivery.attempts" -> param.toString
      case _ => queryParams
    }
    addressesExpiryDelay match {
      case Some(param) => queryParams += "addresses.expiry.delay" -> param.toString
      case _ => queryParams
    }
    addressesAddressFullMessagePolicy match {
      case Some(param) => queryParams += "addresses.address.full.message.policy" -> param.toString
      case _ => queryParams
    }
    addressesMaxSizeBytes match {
      case Some(param) => queryParams += "addresses.max.size.bytes" -> param.toString
      case _ => queryParams
    }
    addressesPageSizeBytes match {
      case Some(param) => queryParams += "addresses.page.size.bytes" -> param.toString
      case _ => queryParams
    }
    addressesPageCacheMaxSize match {
      case Some(param) => queryParams += "addresses.page.cache.max.size" -> param.toString
      case _ => queryParams
    }
    clusterUser match {
      case Some(param) => queryParams += "cluster.user" -> param.toString
      case _ => queryParams
    }
    clusterPassword match {
      case Some(param) => queryParams += "cluster.password" -> param.toString
      case _ => queryParams
    }
    clusterCallTimeout match {
      case Some(param) => queryParams += "cluster.call.timeout" -> param.toString
      case _ => queryParams
    }
    clusterCallFailoverTimeout match {
      case Some(param) => queryParams += "cluster.call.failover.timeout" -> param.toString
      case _ => queryParams
    }
    clusterClientFailureCheckPeriod match {
      case Some(param) => queryParams += "cluster.client.failure.check.period" -> param.toString
      case _ => queryParams
    }
    clusterNotificationAttempts match {
      case Some(param) => queryParams += "cluster.notification.attempts" -> param.toString
      case _ => queryParams
    }
    clusterNotificationInterval match {
      case Some(param) => queryParams += "cluster.notification.interval" -> param.toString
      case _ => queryParams
    }
    idCacheSize match {
      case Some(param) => queryParams += "id.cache.size" -> param.toString
      case _ => queryParams
    }
    clusterConfirmationWindowSize match {
      case Some(param) => queryParams += "cluster.confirmation.window.size" -> param.toString
      case _ => queryParams
    }
    clusterConnectionTtl match {
      case Some(param) => queryParams += "cluster.connection.ttl" -> param.toString
      case _ => queryParams
    }
    clusterDuplicateDetection match {
      case Some(param) => queryParams += "cluster.duplicate.detection" -> param.toString
      case _ => queryParams
    }
    clusterInitialConnectAttempts match {
      case Some(param) => queryParams += "cluster.initial.connect.attempts" -> param.toString
      case _ => queryParams
    }
    clusterMaxRetryInterval match {
      case Some(param) => queryParams += "cluster.max.retry.interval" -> param.toString
      case _ => queryParams
    }
    clusterMinLargeMessageSize match {
      case Some(param) => queryParams += "cluster.min.large.message.size" -> param.toString
      case _ => queryParams
    }
    clusterProducerWindowSize match {
      case Some(param) => queryParams += "cluster.producer.window.size" -> param.toString
      case _ => queryParams
    }
    clusterReconnectAttempts match {
      case Some(param) => queryParams += "cluster.reconnect.attempts" -> param.toString
      case _ => queryParams
    }
    clusterRetryInterval match {
      case Some(param) => queryParams += "cluster.retry.interval" -> param.toString
      case _ => queryParams
    }
    clusterRetryIntervalMultiplier match {
      case Some(param) => queryParams += "cluster.retry.interval.multiplier" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath: Option[List[String]] = None,
    comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo]): Future[ComAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplProjectPath match {
      case Some(param) => queryParams += "com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.projectPath" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensOfflinecontentImplBulkOfflineUpdateServiceImplScheduleFrequency match {
      case Some(param) => queryParams += "com.adobe.cq.screens.offlinecontent.impl.BulkOfflineUpdateServiceImpl.scheduleFrequency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensOfflinecontentImplOfflineContentServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    disableSmartSync: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo]): Future[ComAdobeCqScreensOfflinecontentImplOfflineContentServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.offlinecontent.impl.OfflineContentServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    disableSmartSync match {
      case Some(param) => queryParams += "disableSmartSync" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqScreensSegmentationImplSegmentationFeatureFlag(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enableDataTriggeredContent: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo]): Future[ComAdobeCqScreensSegmentationImplSegmentationFeatureFlagInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.screens.segmentation.impl.SegmentationFeatureFlag"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enableDataTriggeredContent match {
      case Some(param) => queryParams += "enableDataTriggeredContent" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthCh(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo]): Future[ComAdobeCqSecurityHcBundlesImplHtmlLibraryManagerConfigHealthChInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.security.hc.bundles.impl.HtmlLibraryManagerConfigHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSecurityHcBundlesImplWcmFilterHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo]): Future[ComAdobeCqSecurityHcBundlesImplWcmFilterHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.security.hc.bundles.impl.WcmFilterHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None,
    dispatcherAddress: Option[String] = None,
    dispatcherFilterAllowed: Option[List[String]] = None,
    dispatcherFilterBlocked: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo]): Future[ComAdobeCqSecurityHcDispatcherImplDispatcherAccessHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.security.hc.dispatcher.impl.DispatcherAccessHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    dispatcherAddress match {
      case Some(param) => queryParams += "dispatcher.address" -> param.toString
      case _ => queryParams
    }
    dispatcherFilterAllowed match {
      case Some(param) => queryParams += "dispatcher.filter.allowed" -> param.toString
      case _ => queryParams
    }
    dispatcherFilterBlocked match {
      case Some(param) => queryParams += "dispatcher.filter.blocked" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSecurityHcPackagesImplExampleContentHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo]): Future[ComAdobeCqSecurityHcPackagesImplExampleContentHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.security.hc.packages.impl.ExampleContentHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSecurityHcWebserverImplClickjackingHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None,
    webserverAddress: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo]): Future[ComAdobeCqSecurityHcWebserverImplClickjackingHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.security.hc.webserver.impl.ClickjackingHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    webserverAddress match {
      case Some(param) => queryParams += "webserver.address" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialAccountverificationImplAccountManagementConfigIm(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enable: Option[Boolean] = None,
    ttl1: Option[Integer] = None,
    ttl2: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo]): Future[ComAdobeCqSocialAccountverificationImplAccountManagementConfigImInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.accountverification.impl.AccountManagementConfigImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enable match {
      case Some(param) => queryParams += "enable" -> param.toString
      case _ => queryParams
    }
    ttl1 match {
      case Some(param) => queryParams += "ttl1" -> param.toString
      case _ => queryParams
    }
    ttl2 match {
      case Some(param) => queryParams += "ttl2" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialActivitystreamsClientImplSocialActivityComponen(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priority: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo]): Future[ComAdobeCqSocialActivitystreamsClientImplSocialActivityComponenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.activitystreams.client.impl.SocialActivityComponentFactoryImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCo(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priority: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo]): Future[ComAdobeCqSocialActivitystreamsClientImplSocialActivityStreamCoInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.activitystreams.client.impl.SocialActivityStreamComponentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialActivitystreamsListenerImplEventListenerHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventTopics: Option[String] = None,
    eventFilter: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo]): Future[ComAdobeCqSocialActivitystreamsListenerImplEventListenerHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.EventListenerHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventTopics match {
      case Some(param) => queryParams += "event.topics" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialActivitystreamsListenerImplModerationEventExten(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    accepted: Option[Boolean] = None,
    ranked: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo]): Future[ComAdobeCqSocialActivitystreamsListenerImplModerationEventExtenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.ModerationEventExtension"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    accepted match {
      case Some(param) => queryParams += "accepted" -> param.toString
      case _ => queryParams
    }
    ranked match {
      case Some(param) => queryParams += "ranked" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialActivitystreamsListenerImplRatingEventActivityS(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    ranking: Option[Integer] = None,
    enable: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo]): Future[ComAdobeCqSocialActivitystreamsListenerImplRatingEventActivitySInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.RatingEventActivitySuppressor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    ranking match {
      case Some(param) => queryParams += "ranking" -> param.toString
      case _ => queryParams
    }
    enable match {
      case Some(param) => queryParams += "enable" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialActivitystreamsListenerImplResourceActivityStre(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    streamPath: Option[String] = None,
    streamName: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo]): Future[ComAdobeCqSocialActivitystreamsListenerImplResourceActivityStreInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.activitystreams.listener.impl.ResourceActivityStreamProviderFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    streamPath match {
      case Some(param) => queryParams += "streamPath" -> param.toString
      case _ => queryParams
    }
    streamName match {
      case Some(param) => queryParams += "streamName" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsI(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxRetry: Option[Integer] = None,
    fieldWhitelist: Option[List[String]] = None,
    attachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo]): Future[ComAdobeCqSocialCalendarClientEndpointsImplCalendarOperationsIInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.calendar.client.endpoints.impl.CalendarOperationsImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxRetry match {
      case Some(param) => queryParams += "MaxRetry" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCalendarClientOperationextensionsEventAttachmen(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    attachmentTypeBlacklist: Option[String] = None,
    extensionOrder: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo]): Future[ComAdobeCqSocialCalendarClientOperationextensionsEventAttachmenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.calendar.client.operationextensions.EventAttachment"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }
    extensionOrder match {
      case Some(param) => queryParams += "extension.order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCalendarServletsTimeZoneServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    timezonesExpirytime: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo]): Future[ComAdobeCqSocialCalendarServletsTimeZoneServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.calendar.servlets.TimeZoneServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    timezonesExpirytime match {
      case Some(param) => queryParams += "timezones.expirytime" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEvent(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    ranking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo]): Future[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentDeleteEventInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.CommentDeleteEventActivitySuppressor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    ranking match {
      case Some(param) => queryParams += "ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSe(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None,
    attachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo]): Future[ComAdobeCqSocialCommonsCommentsEndpointsImplCommentOperationSeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.CommentOperationService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperati(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None,
    attachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo]): Future[ComAdobeCqSocialCommonsCommentsEndpointsImplTranslationOperatiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.comments.endpoints.impl.TranslationOperationService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialC(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    numUserLimit: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo]): Future[ComAdobeCqSocialCommonsCommentsListingImplSearchCommentSocialCInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.comments.listing.impl.SearchCommentSocialComponentListProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    numUserLimit match {
      case Some(param) => queryParams += "numUserLimit" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPos(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enableScheduledPostsSearch: Option[Boolean] = None,
    numberOfMinutes: Option[Integer] = None,
    maxSearchLimit: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo]): Future[ComAdobeCqSocialCommonsCommentsSchedulerImplSearchScheduledPosInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.comments.scheduler.impl.SearchScheduledPosts"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enableScheduledPostsSearch match {
      case Some(param) => queryParams += "enableScheduledPostsSearch" -> param.toString
      case _ => queryParams
    }
    numberOfMinutes match {
      case Some(param) => queryParams += "numberOfMinutes" -> param.toString
      case _ => queryParams
    }
    maxSearchLimit match {
      case Some(param) => queryParams += "maxSearchLimit" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsCorsCORSAuthenticationFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    corsEnabling: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo]): Future[ComAdobeCqSocialCommonsCorsCORSAuthenticationFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.cors.CORSAuthenticationFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    corsEnabling match {
      case Some(param) => queryParams += "cors.enabling" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priorityOrder: Option[Integer] = None,
    replyEmailPatterns: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplAndroidEmailClientProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.AndroidEmailClientProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priorityOrder match {
      case Some(param) => queryParams += "priorityOrder" -> param.toString
      case _ => queryParams
    }
    replyEmailPatterns match {
      case Some(param) => queryParams += "replyEmailPatterns" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    contextPath: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailBuilderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CommentEmailBuilderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    contextPath match {
      case Some(param) => queryParams += "context.path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventTopics: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplCommentEmailEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CommentEmailEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventTopics match {
      case Some(param) => queryParams += "event.topics" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priorityOrder: Option[Integer] = None,
    replyEmailPatterns: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplCustomEmailClientProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.CustomEmailClientProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priorityOrder match {
      case Some(param) => queryParams += "priorityOrder" -> param.toString
      case _ => queryParams
    }
    replyEmailPatterns match {
      case Some(param) => queryParams += "replyEmailPatterns" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImp(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    patternTime: Option[String] = None,
    patternNewline: Option[String] = None,
    patternDayOfMonth: Option[String] = None,
    patternMonth: Option[String] = None,
    patternYear: Option[String] = None,
    patternDate: Option[String] = None,
    patternDateTime: Option[String] = None,
    patternEmail: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplEmailQuotedTextPatternsImpInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailQuotedTextPatternsImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    patternTime match {
      case Some(param) => queryParams += "pattern.time" -> param.toString
      case _ => queryParams
    }
    patternNewline match {
      case Some(param) => queryParams += "pattern.newline" -> param.toString
      case _ => queryParams
    }
    patternDayOfMonth match {
      case Some(param) => queryParams += "pattern.dayOfMonth" -> param.toString
      case _ => queryParams
    }
    patternMonth match {
      case Some(param) => queryParams += "pattern.month" -> param.toString
      case _ => queryParams
    }
    patternYear match {
      case Some(param) => queryParams += "pattern.year" -> param.toString
      case _ => queryParams
    }
    patternDate match {
      case Some(param) => queryParams += "pattern.date" -> param.toString
      case _ => queryParams
    }
    patternDateTime match {
      case Some(param) => queryParams += "pattern.dateTime" -> param.toString
      case _ => queryParams
    }
    patternEmail match {
      case Some(param) => queryParams += "pattern.email" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImp(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    emailName: Option[String] = None,
    emailCreatePostFromReply: Option[Boolean] = None,
    emailAddCommentIdTo: Option[String] = None,
    emailSubjectMaximumLength: Option[Integer] = None,
    emailReplyToAddress: Option[String] = None,
    emailReplyToDelimiter: Option[String] = None,
    emailTrackerIdPrefixInSubject: Option[String] = None,
    emailTrackerIdPrefixInBody: Option[String] = None,
    emailAsHTML: Option[Boolean] = None,
    emailDefaultUserName: Option[String] = None,
    emailTemplatesRootPath: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyConfigurationImpInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailReplyConfigurationImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    emailName match {
      case Some(param) => queryParams += "email.name" -> param.toString
      case _ => queryParams
    }
    emailCreatePostFromReply match {
      case Some(param) => queryParams += "email.createPostFromReply" -> param.toString
      case _ => queryParams
    }
    emailAddCommentIdTo match {
      case Some(param) => queryParams += "email.addCommentIdTo" -> param.toString
      case _ => queryParams
    }
    emailSubjectMaximumLength match {
      case Some(param) => queryParams += "email.subjectMaximumLength" -> param.toString
      case _ => queryParams
    }
    emailReplyToAddress match {
      case Some(param) => queryParams += "email.replyToAddress" -> param.toString
      case _ => queryParams
    }
    emailReplyToDelimiter match {
      case Some(param) => queryParams += "email.replyToDelimiter" -> param.toString
      case _ => queryParams
    }
    emailTrackerIdPrefixInSubject match {
      case Some(param) => queryParams += "email.trackerIdPrefixInSubject" -> param.toString
      case _ => queryParams
    }
    emailTrackerIdPrefixInBody match {
      case Some(param) => queryParams += "email.trackerIdPrefixInBody" -> param.toString
      case _ => queryParams
    }
    emailAsHTML match {
      case Some(param) => queryParams += "email.asHTML" -> param.toString
      case _ => queryParams
    }
    emailDefaultUserName match {
      case Some(param) => queryParams += "email.defaultUserName" -> param.toString
      case _ => queryParams
    }
    emailTemplatesRootPath match {
      case Some(param) => queryParams += "email.templates.rootPath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplEmailReplyImporter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    connectProtocol: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplEmailReplyImporterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.EmailReplyImporter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    connectProtocol match {
      case Some(param) => queryParams += "connectProtocol" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priorityOrder: Option[Integer] = None,
    replyEmailPatterns: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplGmailEmailClientProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.GmailEmailClientProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priorityOrder match {
      case Some(param) => queryParams += "priorityOrder" -> param.toString
      case _ => queryParams
    }
    replyEmailPatterns match {
      case Some(param) => queryParams += "replyEmailPatterns" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priorityOrder: Option[Integer] = None,
    replyEmailPatterns: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplIOSEmailClientProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.IOSEmailClientProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priorityOrder match {
      case Some(param) => queryParams += "priorityOrder" -> param.toString
      case _ => queryParams
    }
    replyEmailPatterns match {
      case Some(param) => queryParams += "replyEmailPatterns" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priorityOrder: Option[Integer] = None,
    replyEmailPatterns: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplMacmailEmailClientProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.MacmailEmailClientProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priorityOrder match {
      case Some(param) => queryParams += "priorityOrder" -> param.toString
      case _ => queryParams
    }
    replyEmailPatterns match {
      case Some(param) => queryParams += "replyEmailPatterns" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priorityOrder: Option[Integer] = None,
    replyEmailPatterns: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplOutLookEmailClientProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.OutLookEmailClientProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priorityOrder match {
      case Some(param) => queryParams += "priorityOrder" -> param.toString
      case _ => queryParams
    }
    replyEmailPatterns match {
      case Some(param) => queryParams += "replyEmailPatterns" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    replyEmailPatterns: Option[List[String]] = None,
    priorityOrder: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplUnknownEmailClientProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.UnknownEmailClientProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    replyEmailPatterns match {
      case Some(param) => queryParams += "replyEmailPatterns" -> param.toString
      case _ => queryParams
    }
    priorityOrder match {
      case Some(param) => queryParams += "priorityOrder" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priorityOrder: Option[Integer] = None,
    replyEmailPatterns: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo]): Future[ComAdobeCqSocialCommonsEmailreplyImplYahooEmailClientProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.emailreply.impl.YahooEmailClientProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priorityOrder match {
      case Some(param) => queryParams += "priorityOrder" -> param.toString
      case _ => queryParams
    }
    replyEmailPatterns match {
      case Some(param) => queryParams += "replyEmailPatterns" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUpload(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    numberOfDays: Option[Integer] = None,
    ageOfFile: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo]): Future[ComAdobeCqSocialCommonsMaintainanceImplDeleteTempUGCImageUploadInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.maintainance.impl.DeleteTempUGCImageUploads"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    numberOfDays match {
      case Some(param) => queryParams += "numberOfDays" -> param.toString
      case _ => queryParams
    }
    ageOfFile match {
      case Some(param) => queryParams += "ageOfFile" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventTopics: Option[String] = None,
    eventFilter: Option[String] = None,
    verbs: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo]): Future[ComAdobeCqSocialCommonsUgclimiterImplUGCLimiterServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.ugclimiter.impl.UGCLimiterServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventTopics match {
      case Some(param) => queryParams += "event.topics" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }
    verbs match {
      case Some(param) => queryParams += "verbs" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimit(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enable: Option[Boolean] = None,
    uGCLimit: Option[Integer] = None,
    ugcLimitDuration: Option[Integer] = None,
    domains: Option[List[String]] = None,
    toList: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo]): Future[ComAdobeCqSocialCommonsUgclimitsconfigImplCommunityUserUGCLimitInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.commons.ugclimitsconfig.impl.CommunityUserUGCLimitsConfigImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enable match {
      case Some(param) => queryParams += "enable" -> param.toString
      case _ => queryParams
    }
    uGCLimit match {
      case Some(param) => queryParams += "UGCLimit" -> param.toString
      case _ => queryParams
    }
    ugcLimitDuration match {
      case Some(param) => queryParams += "ugcLimitDuration" -> param.toString
      case _ => queryParams
    }
    domains match {
      case Some(param) => queryParams += "domains" -> param.toString
      case _ => queryParams
    }
    toList match {
      case Some(param) => queryParams += "toList" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialConnectOauthImplFacebookProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthProviderId: Option[String] = None,
    oauthCloudConfigRoot: Option[String] = None,
    providerConfigRoot: Option[String] = None,
    providerConfigCreateTagsEnabled: Option[Boolean] = None,
    providerConfigUserFolder: Option[String] = None,
    providerConfigFacebookFetchFields: Option[Boolean] = None,
    providerConfigFacebookFields: Option[List[String]] = None,
    providerConfigRefreshUserdataEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo]): Future[ComAdobeCqSocialConnectOauthImplFacebookProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.FacebookProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthProviderId match {
      case Some(param) => queryParams += "oauth.provider.id" -> param.toString
      case _ => queryParams
    }
    oauthCloudConfigRoot match {
      case Some(param) => queryParams += "oauth.cloud.config.root" -> param.toString
      case _ => queryParams
    }
    providerConfigRoot match {
      case Some(param) => queryParams += "provider.config.root" -> param.toString
      case _ => queryParams
    }
    providerConfigCreateTagsEnabled match {
      case Some(param) => queryParams += "provider.config.create.tags.enabled" -> param.toString
      case _ => queryParams
    }
    providerConfigUserFolder match {
      case Some(param) => queryParams += "provider.config.user.folder" -> param.toString
      case _ => queryParams
    }
    providerConfigFacebookFetchFields match {
      case Some(param) => queryParams += "provider.config.facebook.fetch.fields" -> param.toString
      case _ => queryParams
    }
    providerConfigFacebookFields match {
      case Some(param) => queryParams += "provider.config.facebook.fields" -> param.toString
      case _ => queryParams
    }
    providerConfigRefreshUserdataEnabled match {
      case Some(param) => queryParams += "provider.config.refresh.userdata.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandle(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo]): Future[ComAdobeCqSocialConnectOauthImplSocialOAuthAuthenticationHandleInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.SocialOAuthAuthenticationHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapper(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    facebook: Option[List[String]] = None,
    twitter: Option[List[String]] = None,
    providerConfigUserFolder: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo]): Future[ComAdobeCqSocialConnectOauthImplSocialOAuthUserProfileMapperInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.SocialOAuthUserProfileMapper"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    facebook match {
      case Some(param) => queryParams += "facebook" -> param.toString
      case _ => queryParams
    }
    twitter match {
      case Some(param) => queryParams += "twitter" -> param.toString
      case _ => queryParams
    }
    providerConfigUserFolder match {
      case Some(param) => queryParams += "provider.config.user.folder" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialConnectOauthImplTwitterProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthProviderId: Option[String] = None,
    oauthCloudConfigRoot: Option[String] = None,
    providerConfigRoot: Option[String] = None,
    providerConfigUserFolder: Option[String] = None,
    providerConfigTwitterEnableParams: Option[Boolean] = None,
    providerConfigTwitterParams: Option[List[String]] = None,
    providerConfigRefreshUserdataEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo]): Future[ComAdobeCqSocialConnectOauthImplTwitterProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.connect.oauth.impl.TwitterProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthProviderId match {
      case Some(param) => queryParams += "oauth.provider.id" -> param.toString
      case _ => queryParams
    }
    oauthCloudConfigRoot match {
      case Some(param) => queryParams += "oauth.cloud.config.root" -> param.toString
      case _ => queryParams
    }
    providerConfigRoot match {
      case Some(param) => queryParams += "provider.config.root" -> param.toString
      case _ => queryParams
    }
    providerConfigUserFolder match {
      case Some(param) => queryParams += "provider.config.user.folder" -> param.toString
      case _ => queryParams
    }
    providerConfigTwitterEnableParams match {
      case Some(param) => queryParams += "provider.config.twitter.enable.params" -> param.toString
      case _ => queryParams
    }
    providerConfigTwitterParams match {
      case Some(param) => queryParams += "provider.config.twitter.params" -> param.toString
      case _ => queryParams
    }
    providerConfigRefreshUserdataEnabled match {
      case Some(param) => queryParams += "provider.config.refresh.userdata.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmen(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqSocialContentFragmentsServicesEnabled: Option[Boolean] = None,
    cqSocialContentFragmentsServicesWaitTimeSeconds: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo]): Future[ComAdobeCqSocialContentFragmentsServicesImplCommunitiesFragmenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.content.fragments.services.impl.CommunitiesFragmentCreationServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqSocialContentFragmentsServicesEnabled match {
      case Some(param) => queryParams += "cq.social.content.fragments.services.enabled" -> param.toString
      case _ => queryParams
    }
    cqSocialContentFragmentsServicesWaitTimeSeconds match {
      case Some(param) => queryParams += "cq.social.content.fragments.services.waitTimeSeconds" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialDatastoreAsImplASResourceProviderFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    versionId: Option[String] = None,
    cacheOn: Option[Boolean] = None,
    concurrencyLevel: Option[Integer] = None,
    cacheStartSize: Option[Integer] = None,
    cacheTtl: Option[Integer] = None,
    cacheSize: Option[Integer] = None,
    timeLimit: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo]): Future[ComAdobeCqSocialDatastoreAsImplASResourceProviderFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.datastore.as.impl.ASResourceProviderFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    versionId match {
      case Some(param) => queryParams += "version.id" -> param.toString
      case _ => queryParams
    }
    cacheOn match {
      case Some(param) => queryParams += "cache.on" -> param.toString
      case _ => queryParams
    }
    concurrencyLevel match {
      case Some(param) => queryParams += "concurrency.level" -> param.toString
      case _ => queryParams
    }
    cacheStartSize match {
      case Some(param) => queryParams += "cache.start.size" -> param.toString
      case _ => queryParams
    }
    cacheTtl match {
      case Some(param) => queryParams += "cache.ttl" -> param.toString
      case _ => queryParams
    }
    cacheSize match {
      case Some(param) => queryParams += "cache.size" -> param.toString
      case _ => queryParams
    }
    timeLimit match {
      case Some(param) => queryParams += "time.limit" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    solrZkTimeout: Option[String] = None,
    solrCommit: Option[String] = None,
    cacheOn: Option[Boolean] = None,
    concurrencyLevel: Option[Integer] = None,
    cacheStartSize: Option[Integer] = None,
    cacheTtl: Option[Integer] = None,
    cacheSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo]): Future[ComAdobeCqSocialDatastoreOpImplSocialMSResourceProviderFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.datastore.op.impl.SocialMSResourceProviderFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    solrZkTimeout match {
      case Some(param) => queryParams += "solr.zk.timeout" -> param.toString
      case _ => queryParams
    }
    solrCommit match {
      case Some(param) => queryParams += "solr.commit" -> param.toString
      case _ => queryParams
    }
    cacheOn match {
      case Some(param) => queryParams += "cache.on" -> param.toString
      case _ => queryParams
    }
    concurrencyLevel match {
      case Some(param) => queryParams += "concurrency.level" -> param.toString
      case _ => queryParams
    }
    cacheStartSize match {
      case Some(param) => queryParams += "cache.start.size" -> param.toString
      case _ => queryParams
    }
    cacheTtl match {
      case Some(param) => queryParams += "cache.ttl" -> param.toString
      case _ => queryParams
    }
    cacheSize match {
      case Some(param) => queryParams += "cache.size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    solrZkTimeout: Option[String] = None,
    solrCommit: Option[String] = None,
    cacheOn: Option[Boolean] = None,
    concurrencyLevel: Option[Integer] = None,
    cacheStartSize: Option[Integer] = None,
    cacheTtl: Option[Integer] = None,
    cacheSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo]): Future[ComAdobeCqSocialDatastoreRdbImplSocialRDBResourceProviderFactorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.datastore.rdb.impl.SocialRDBResourceProviderFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    solrZkTimeout match {
      case Some(param) => queryParams += "solr.zk.timeout" -> param.toString
      case _ => queryParams
    }
    solrCommit match {
      case Some(param) => queryParams += "solr.commit" -> param.toString
      case _ => queryParams
    }
    cacheOn match {
      case Some(param) => queryParams += "cache.on" -> param.toString
      case _ => queryParams
    }
    concurrencyLevel match {
      case Some(param) => queryParams += "concurrency.level" -> param.toString
      case _ => queryParams
    }
    cacheStartSize match {
      case Some(param) => queryParams += "cache.start.size" -> param.toString
      case _ => queryParams
    }
    cacheTtl match {
      case Some(param) => queryParams += "cache.ttl" -> param.toString
      case _ => queryParams
    }
    cacheSize match {
      case Some(param) => queryParams += "cache.size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorF(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    isMemberCheck: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo]): Future[ComAdobeCqSocialEnablementAdaptorsEnablementLearningPathAdaptorFInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.enablement.adaptors.EnablementLearningPathAdaptorFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    isMemberCheck match {
      case Some(param) => queryParams += "isMemberCheck" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFacto(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    isMemberCheck: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo]): Future[ComAdobeCqSocialEnablementAdaptorsEnablementResourceAdaptorFactoInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.enablement.adaptors.EnablementResourceAdaptorFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    isMemberCheck match {
      case Some(param) => queryParams += "isMemberCheck" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialEnablementLearningpathEndpointsImplEnablementL(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo]): Future[ComAdobeCqSocialEnablementLearningpathEndpointsImplEnablementLInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.enablement.learningpath.endpoints.impl.EnablementLearningPathModelOperationService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialEnablementResourceEndpointsImplEnablementResou(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo]): Future[ComAdobeCqSocialEnablementResourceEndpointsImplEnablementResouInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.enablement.resource.endpoints.impl.EnablementResourceModelOperationService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialEnablementServicesImplAuthorMarkerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo]): Future[ComAdobeCqSocialEnablementServicesImplAuthorMarkerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.enablement.services.impl.AuthorMarkerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGe(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletSelectors: Option[String] = None,
    slingServletExtensions: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo]): Future[ComAdobeCqSocialFilelibraryClientEndpointsFilelibraryDownloadGeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.filelibrary.client.endpoints.FilelibraryDownloadGetServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletSelectors match {
      case Some(param) => queryParams += "sling.servlet.selectors" -> param.toString
      case _ => queryParams
    }
    slingServletExtensions match {
      case Some(param) => queryParams += "sling.servlet.extensions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOpera(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None,
    attachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo]): Future[ComAdobeCqSocialFilelibraryClientEndpointsImplFileLibraryOperaInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.filelibrary.client.endpoints.impl.FileLibraryOperationsService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialForumClientEndpointsImplForumOperationsService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None,
    attachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo]): Future[ComAdobeCqSocialForumClientEndpointsImplForumOperationsServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.forum.client.endpoints.impl.ForumOperationsService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialForumDispatcherImplFlushOperations(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    extensionOrder: Option[Integer] = None,
    flushForumontopic: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo]): Future[ComAdobeCqSocialForumDispatcherImplFlushOperationsInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.forum.dispatcher.impl.FlushOperations"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    extensionOrder match {
      case Some(param) => queryParams += "extension.order" -> param.toString
      case _ => queryParams
    }
    flushForumontopic match {
      case Some(param) => queryParams += "flush.forumontopic" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialGroupClientImplCommunityGroupCollectionComponen(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    groupListingPaginationEnable: Option[Boolean] = None,
    groupListingLazyloadingEnable: Option[Boolean] = None,
    pageSize: Option[Integer] = None,
    priority: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo]): Future[ComAdobeCqSocialGroupClientImplCommunityGroupCollectionComponenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.group.client.impl.CommunityGroupCollectionComponentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    groupListingPaginationEnable match {
      case Some(param) => queryParams += "group.listing.pagination.enable" -> param.toString
      case _ => queryParams
    }
    groupListingLazyloadingEnable match {
      case Some(param) => queryParams += "group.listing.lazyloading.enable" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "page.size" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialGroupImplGroupServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxWaitTime: Option[Integer] = None,
    minWaitBetweenRetries: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialGroupImplGroupServiceImplInfo]): Future[ComAdobeCqSocialGroupImplGroupServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.group.impl.GroupServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxWaitTime match {
      case Some(param) => queryParams += "maxWaitTime" -> param.toString
      case _ => queryParams
    }
    minWaitBetweenRetries match {
      case Some(param) => queryParams += "minWaitBetweenRetries" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialHandlebarsGuavaTemplateCacheImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    parameterGuavaCacheEnabled: Option[Boolean] = None,
    parameterGuavaCacheParams: Option[String] = None,
    parameterGuavaCacheReload: Option[Boolean] = None,
    serviceRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo]): Future[ComAdobeCqSocialHandlebarsGuavaTemplateCacheImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.handlebars.GuavaTemplateCacheImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    parameterGuavaCacheEnabled match {
      case Some(param) => queryParams += "parameter.guava.cache.enabled" -> param.toString
      case _ => queryParams
    }
    parameterGuavaCacheParams match {
      case Some(param) => queryParams += "parameter.guava.cache.params" -> param.toString
      case _ => queryParams
    }
    parameterGuavaCacheReload match {
      case Some(param) => queryParams += "parameter.guava.cache.reload" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsS(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None,
    attachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo]): Future[ComAdobeCqSocialIdeationClientEndpointsImplIdeationOperationsSInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.ideation.client.endpoints.impl.IdeationOperationsService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialJournalClientEndpointsImplJournalOperationsSer(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None,
    attachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo]): Future[ComAdobeCqSocialJournalClientEndpointsImplJournalOperationsSerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.journal.client.endpoints.impl.JournalOperationsService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfile(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo]): Future[ComAdobeCqSocialMembersEndpointsImplCommunityMemberGroupProfileInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.members.endpoints.impl.CommunityMemberGroupProfileOperationService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileO(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo]): Future[ComAdobeCqSocialMembersEndpointsImplCommunityMemberUserProfileOInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.members.endpoints.impl.CommunityMemberUserProfileOperationService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentF(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    everyoneLimit: Option[Integer] = None,
    priority: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo]): Future[ComAdobeCqSocialMembersImplCommunityMemberGroupProfileComponentFInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.members.impl.CommunityMemberGroupProfileComponentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    everyoneLimit match {
      case Some(param) => queryParams += "everyoneLimit" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialMessagingClientEndpointsImplMessagingOperation(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    messageProperties: Option[List[String]] = None,
    messageBoxSizeLimit: Option[Integer] = None,
    messageCountLimit: Option[Integer] = None,
    notifyFailure: Option[Boolean] = None,
    failureMessageFrom: Option[String] = None,
    failureTemplatePath: Option[String] = None,
    maxRetries: Option[Integer] = None,
    minWaitBetweenRetries: Option[Integer] = None,
    countUpdatePoolSize: Option[Integer] = None,
    inboxPath: Option[String] = None,
    sentitemsPath: Option[String] = None,
    supportAttachments: Option[Boolean] = None,
    supportGroupMessaging: Option[Boolean] = None,
    maxTotalRecipients: Option[Integer] = None,
    batchSize: Option[Integer] = None,
    maxTotalAttachmentSize: Option[Integer] = None,
    attachmentTypeBlacklist: Option[List[String]] = None,
    allowedAttachmentTypes: Option[List[String]] = None,
    serviceSelector: Option[String] = None,
    fieldWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo]): Future[ComAdobeCqSocialMessagingClientEndpointsImplMessagingOperationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.messaging.client.endpoints.impl.MessagingOperationsServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    messageProperties match {
      case Some(param) => queryParams += "message.properties" -> param.toString
      case _ => queryParams
    }
    messageBoxSizeLimit match {
      case Some(param) => queryParams += "messageBoxSizeLimit" -> param.toString
      case _ => queryParams
    }
    messageCountLimit match {
      case Some(param) => queryParams += "messageCountLimit" -> param.toString
      case _ => queryParams
    }
    notifyFailure match {
      case Some(param) => queryParams += "notifyFailure" -> param.toString
      case _ => queryParams
    }
    failureMessageFrom match {
      case Some(param) => queryParams += "failureMessageFrom" -> param.toString
      case _ => queryParams
    }
    failureTemplatePath match {
      case Some(param) => queryParams += "failureTemplatePath" -> param.toString
      case _ => queryParams
    }
    maxRetries match {
      case Some(param) => queryParams += "maxRetries" -> param.toString
      case _ => queryParams
    }
    minWaitBetweenRetries match {
      case Some(param) => queryParams += "minWaitBetweenRetries" -> param.toString
      case _ => queryParams
    }
    countUpdatePoolSize match {
      case Some(param) => queryParams += "countUpdatePoolSize" -> param.toString
      case _ => queryParams
    }
    inboxPath match {
      case Some(param) => queryParams += "inbox.path" -> param.toString
      case _ => queryParams
    }
    sentitemsPath match {
      case Some(param) => queryParams += "sentitems.path" -> param.toString
      case _ => queryParams
    }
    supportAttachments match {
      case Some(param) => queryParams += "supportAttachments" -> param.toString
      case _ => queryParams
    }
    supportGroupMessaging match {
      case Some(param) => queryParams += "supportGroupMessaging" -> param.toString
      case _ => queryParams
    }
    maxTotalRecipients match {
      case Some(param) => queryParams += "maxTotalRecipients" -> param.toString
      case _ => queryParams
    }
    batchSize match {
      case Some(param) => queryParams += "batchSize" -> param.toString
      case _ => queryParams
    }
    maxTotalAttachmentSize match {
      case Some(param) => queryParams += "maxTotalAttachmentSize" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }
    allowedAttachmentTypes match {
      case Some(param) => queryParams += "allowedAttachmentTypes" -> param.toString
      case _ => queryParams
    }
    serviceSelector match {
      case Some(param) => queryParams += "serviceSelector" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialModerationDashboardApiFilterGroupSocialComponen(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    resourceTypeFilters: Option[List[String]] = None,
    priority: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo]): Future[ComAdobeCqSocialModerationDashboardApiFilterGroupSocialComponenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.FilterGroupSocialComponentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    resourceTypeFilters match {
      case Some(param) => queryParams += "resourceType.filters" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialModerationDashboardApiModerationDashboardSocial(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priority: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo]): Future[ComAdobeCqSocialModerationDashboardApiModerationDashboardSocialInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.ModerationDashboardSocialComponentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialModerationDashboardApiUserDetailsSocialComponen(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priority: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo]): Future[ComAdobeCqSocialModerationDashboardApiUserDetailsSocialComponenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.api.UserDetailsSocialComponentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialModerationDashboardInternalImplFilterGroupSoci(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    resourceTypeFilters: Option[List[String]] = None,
    priority: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo]): Future[ComAdobeCqSocialModerationDashboardInternalImplFilterGroupSociInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.moderation.dashboard.internal.impl.FilterGroupSocialComponentFactoryV2"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    resourceTypeFilters match {
      case Some(param) => queryParams += "resourceType.filters" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialNotificationsImplMentionsRouter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventTopics: Option[String] = None,
    eventFilter: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialNotificationsImplMentionsRouterInfo]): Future[ComAdobeCqSocialNotificationsImplMentionsRouterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.notifications.impl.MentionsRouter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventTopics match {
      case Some(param) => queryParams += "event.topics" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialNotificationsImplNotificationManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxUnreadNotificationCount: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo]): Future[ComAdobeCqSocialNotificationsImplNotificationManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.notifications.impl.NotificationManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxUnreadNotificationCount match {
      case Some(param) => queryParams += "max.unread.notification.count" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialNotificationsImplNotificationsRouter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventTopics: Option[String] = None,
    eventFilter: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo]): Future[ComAdobeCqSocialNotificationsImplNotificationsRouterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.notifications.impl.NotificationsRouter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventTopics match {
      case Some(param) => queryParams += "event.topics" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServic(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None,
    attachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo]): Future[ComAdobeCqSocialQnaClientEndpointsImplQnaForumOperationsServicInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.qna.client.endpoints.impl.QnaForumOperationsService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportI(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqSocialReportingAnalyticsPollingImporterInterval: Option[Integer] = None,
    cqSocialReportingAnalyticsPollingImporterPageSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo]): Future[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportIInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.AnalyticsReportImporterServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqSocialReportingAnalyticsPollingImporterInterval match {
      case Some(param) => queryParams += "cq.social.reporting.analytics.polling.importer.interval" -> param.toString
      case _ => queryParams
    }
    cqSocialReportingAnalyticsPollingImporterPageSize match {
      case Some(param) => queryParams += "cq.social.reporting.analytics.polling.importer.pageSize" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportM(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    reportFetchDelay: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo]): Future[ComAdobeCqSocialReportingAnalyticsServicesImplAnalyticsReportMInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.AnalyticsReportManagementServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    reportFetchDelay match {
      case Some(param) => queryParams += "report.fetch.delay" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportS(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqSocialConsoleAnalyticsSitesMapping: Option[List[String]] = None,
    priority: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo]): Future[ComAdobeCqSocialReportingAnalyticsServicesImplSiteTrendReportSInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.reporting.analytics.services.impl.SiteTrendReportSocialComponentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqSocialConsoleAnalyticsSitesMapping match {
      case Some(param) => queryParams += "cq.social.console.analytics.sites.mapping" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialReviewClientEndpointsImplReviewOperationsServi(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None,
    attachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo]): Future[ComAdobeCqSocialReviewClientEndpointsImplReviewOperationsServiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.review.client.endpoints.impl.ReviewOperationsService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }
    attachmentTypeBlacklist match {
      case Some(param) => queryParams += "attachmentTypeBlacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialScfCoreOperationsImplSocialOperationsServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletSelectors: Option[String] = None,
    slingServletExtensions: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo]): Future[ComAdobeCqSocialScfCoreOperationsImplSocialOperationsServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.scf.core.operations.impl.SocialOperationsServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletSelectors match {
      case Some(param) => queryParams += "sling.servlet.selectors" -> param.toString
      case _ => queryParams
    }
    slingServletExtensions match {
      case Some(param) => queryParams += "sling.servlet.extensions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialScfEndpointsImplDefaultSocialGetServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletSelectors: Option[List[String]] = None,
    slingServletExtensions: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo]): Future[ComAdobeCqSocialScfEndpointsImplDefaultSocialGetServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.scf.endpoints.impl.DefaultSocialGetServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletSelectors match {
      case Some(param) => queryParams += "sling.servlet.selectors" -> param.toString
      case _ => queryParams
    }
    slingServletExtensions match {
      case Some(param) => queryParams += "sling.servlet.extensions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialScoringImplScoringEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventTopics: Option[String] = None,
    eventFilter: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialScoringImplScoringEventListenerInfo]): Future[ComAdobeCqSocialScoringImplScoringEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.scoring.impl.ScoringEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventTopics match {
      case Some(param) => queryParams += "event.topics" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialServiceusersInternalImplServiceUserWrapperImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enableFallback: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo]): Future[ComAdobeCqSocialServiceusersInternalImplServiceUserWrapperImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.serviceusers.internal.impl.ServiceUserWrapperImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enableFallback match {
      case Some(param) => queryParams += "enableFallback" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialSiteEndpointsImplSiteOperationService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fieldWhitelist: Option[List[String]] = None,
    sitePathFilters: Option[List[String]] = None,
    sitePackageGroup: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo]): Future[ComAdobeCqSocialSiteEndpointsImplSiteOperationServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.site.endpoints.impl.SiteOperationService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fieldWhitelist match {
      case Some(param) => queryParams += "fieldWhitelist" -> param.toString
      case _ => queryParams
    }
    sitePathFilters match {
      case Some(param) => queryParams += "sitePathFilters" -> param.toString
      case _ => queryParams
    }
    sitePackageGroup match {
      case Some(param) => queryParams += "sitePackageGroup" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceIm(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqSocialConsoleAnalyticsComponents: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo]): Future[ComAdobeCqSocialSiteImplAnalyticsComponentConfigurationServiceImInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.site.impl.AnalyticsComponentConfigurationServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqSocialConsoleAnalyticsComponents match {
      case Some(param) => queryParams += "cq.social.console.analytics.components" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialSiteImplSiteConfiguratorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    componentsUsingTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo]): Future[ComAdobeCqSocialSiteImplSiteConfiguratorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.site.impl.SiteConfiguratorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    componentsUsingTags match {
      case Some(param) => queryParams += "componentsUsingTags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialSrpImplSocialSolrConnector(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    srpType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo]): Future[ComAdobeCqSocialSrpImplSocialSolrConnectorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.srp.impl.SocialSolrConnector"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    srpType match {
      case Some(param) => queryParams += "srp.type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialSyncImplDiffChangesObserver(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    agentName: Option[String] = None,
    diffPath: Option[String] = None,
    propertyNames: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialSyncImplDiffChangesObserverInfo]): Future[ComAdobeCqSocialSyncImplDiffChangesObserverInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.sync.impl.DiffChangesObserver"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    agentName match {
      case Some(param) => queryParams += "agentName" -> param.toString
      case _ => queryParams
    }
    diffPath match {
      case Some(param) => queryParams += "diffPath" -> param.toString
      case _ => queryParams
    }
    propertyNames match {
      case Some(param) => queryParams += "propertyNames" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialSyncImplGroupSyncListenerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    nodetypes: Option[List[String]] = None,
    ignorableprops: Option[List[String]] = None,
    ignorablenodes: Option[String] = None,
    enabled: Option[Boolean] = None,
    distfolders: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo]): Future[ComAdobeCqSocialSyncImplGroupSyncListenerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.sync.impl.GroupSyncListenerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    nodetypes match {
      case Some(param) => queryParams += "nodetypes" -> param.toString
      case _ => queryParams
    }
    ignorableprops match {
      case Some(param) => queryParams += "ignorableprops" -> param.toString
      case _ => queryParams
    }
    ignorablenodes match {
      case Some(param) => queryParams += "ignorablenodes" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    distfolders match {
      case Some(param) => queryParams += "distfolders" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialSyncImplPublisherSyncServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    activeRunModes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo]): Future[ComAdobeCqSocialSyncImplPublisherSyncServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.sync.impl.PublisherSyncServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    activeRunModes match {
      case Some(param) => queryParams += "activeRunModes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialSyncImplUserSyncListenerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    nodetypes: Option[List[String]] = None,
    ignorableprops: Option[List[String]] = None,
    ignorablenodes: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    distfolders: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo]): Future[ComAdobeCqSocialSyncImplUserSyncListenerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.sync.impl.UserSyncListenerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    nodetypes match {
      case Some(param) => queryParams += "nodetypes" -> param.toString
      case _ => queryParams
    }
    ignorableprops match {
      case Some(param) => queryParams += "ignorableprops" -> param.toString
      case _ => queryParams
    }
    ignorablenodes match {
      case Some(param) => queryParams += "ignorablenodes" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    distfolders match {
      case Some(param) => queryParams += "distfolders" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialTranslationImplTranslationServiceConfigManager(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    translateLanguage: Option[String] = None,
    translateDisplay: Option[String] = None,
    translateAttribution: Option[Boolean] = None,
    translateCaching: Option[String] = None,
    translateSmartRendering: Option[String] = None,
    translateCachingDuration: Option[String] = None,
    translateSessionSaveInterval: Option[String] = None,
    translateSessionSaveBatchLimit: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo]): Future[ComAdobeCqSocialTranslationImplTranslationServiceConfigManagerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.translation.impl.TranslationServiceConfigManager"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    translateLanguage match {
      case Some(param) => queryParams += "translate.language" -> param.toString
      case _ => queryParams
    }
    translateDisplay match {
      case Some(param) => queryParams += "translate.display" -> param.toString
      case _ => queryParams
    }
    translateAttribution match {
      case Some(param) => queryParams += "translate.attribution" -> param.toString
      case _ => queryParams
    }
    translateCaching match {
      case Some(param) => queryParams += "translate.caching" -> param.toString
      case _ => queryParams
    }
    translateSmartRendering match {
      case Some(param) => queryParams += "translate.smart.rendering" -> param.toString
      case _ => queryParams
    }
    translateCachingDuration match {
      case Some(param) => queryParams += "translate.caching.duration" -> param.toString
      case _ => queryParams
    }
    translateSessionSaveInterval match {
      case Some(param) => queryParams += "translate.session.save.interval" -> param.toString
      case _ => queryParams
    }
    translateSessionSaveBatchLimit match {
      case Some(param) => queryParams += "translate.session.save.batchLimit" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialTranslationImplUGCLanguageDetector(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventTopics: Option[String] = None,
    eventFilter: Option[String] = None,
    translateListenerType: Option[List[String]] = None,
    translatePropertyList: Option[List[String]] = None,
    poolSize: Option[Integer] = None,
    maxPoolSize: Option[Integer] = None,
    queueSize: Option[Integer] = None,
    keepAliveTime: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo]): Future[ComAdobeCqSocialTranslationImplUGCLanguageDetectorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.translation.impl.UGCLanguageDetector"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventTopics match {
      case Some(param) => queryParams += "event.topics" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }
    translateListenerType match {
      case Some(param) => queryParams += "translate.listener.type" -> param.toString
      case _ => queryParams
    }
    translatePropertyList match {
      case Some(param) => queryParams += "translate.property.list" -> param.toString
      case _ => queryParams
    }
    poolSize match {
      case Some(param) => queryParams += "poolSize" -> param.toString
      case _ => queryParams
    }
    maxPoolSize match {
      case Some(param) => queryParams += "maxPoolSize" -> param.toString
      case _ => queryParams
    }
    queueSize match {
      case Some(param) => queryParams += "queueSize" -> param.toString
      case _ => queryParams
    }
    keepAliveTime match {
      case Some(param) => queryParams += "keepAliveTime" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialUgcbaseDispatcherImplFlushServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    threadPoolSize: Option[Integer] = None,
    delayTime: Option[Integer] = None,
    workerSleepTime: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo]): Future[ComAdobeCqSocialUgcbaseDispatcherImplFlushServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.ugcbase.dispatcher.impl.FlushServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    threadPoolSize match {
      case Some(param) => queryParams += "threadPoolSize" -> param.toString
      case _ => queryParams
    }
    delayTime match {
      case Some(param) => queryParams += "delayTime" -> param.toString
      case _ => queryParams
    }
    workerSleepTime match {
      case Some(param) => queryParams += "workerSleepTime" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialUgcbaseImplAysncReverseReplicatorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    poolSize: Option[Integer] = None,
    maxPoolSize: Option[Integer] = None,
    queueSize: Option[Integer] = None,
    keepAliveTime: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo]): Future[ComAdobeCqSocialUgcbaseImplAysncReverseReplicatorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.AysncReverseReplicatorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    poolSize match {
      case Some(param) => queryParams += "poolSize" -> param.toString
      case _ => queryParams
    }
    maxPoolSize match {
      case Some(param) => queryParams += "maxPoolSize" -> param.toString
      case _ => queryParams
    }
    queueSize match {
      case Some(param) => queryParams += "queueSize" -> param.toString
      case _ => queryParams
    }
    keepAliveTime match {
      case Some(param) => queryParams += "keepAliveTime" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialUgcbaseImplPublisherConfigurationImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    isPrimaryPublisher: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo]): Future[ComAdobeCqSocialUgcbaseImplPublisherConfigurationImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.PublisherConfigurationImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    isPrimaryPublisher match {
      case Some(param) => queryParams += "isPrimaryPublisher" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialUgcbaseImplSocialUtilsImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    legacyCloudUGCPathMapping: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo]): Future[ComAdobeCqSocialUgcbaseImplSocialUtilsImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.ugcbase.impl.SocialUtilsImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    legacyCloudUGCPathMapping match {
      case Some(param) => queryParams += "legacyCloudUGCPathMapping" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialUgcbaseModerationImplAutoModerationImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    automoderationSequence: Option[List[String]] = None,
    automoderationOnfailurestop: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo]): Future[ComAdobeCqSocialUgcbaseModerationImplAutoModerationImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.ugcbase.moderation.impl.AutoModerationImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    automoderationSequence match {
      case Some(param) => queryParams += "automoderation.sequence" -> param.toString
      case _ => queryParams
    }
    automoderationOnfailurestop match {
      case Some(param) => queryParams += "automoderation.onfailurestop" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialUgcbaseModerationImplSentimentProcess(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    watchwordsPositive: Option[List[String]] = None,
    watchwordsNegative: Option[List[String]] = None,
    watchwordsPath: Option[String] = None,
    sentimentPath: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo]): Future[ComAdobeCqSocialUgcbaseModerationImplSentimentProcessInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.ugcbase.moderation.impl.SentimentProcess"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    watchwordsPositive match {
      case Some(param) => queryParams += "watchwords.positive" -> param.toString
      case _ => queryParams
    }
    watchwordsNegative match {
      case Some(param) => queryParams += "watchwords.negative" -> param.toString
      case _ => queryParams
    }
    watchwordsPath match {
      case Some(param) => queryParams += "watchwords.path" -> param.toString
      case _ => queryParams
    }
    sentimentPath match {
      case Some(param) => queryParams += "sentiment.path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackli(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    defaultAttachmentTypeBlacklist: Option[List[String]] = None,
    baselineAttachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo]): Future[ComAdobeCqSocialUgcbaseSecurityImplDefaultAttachmentTypeBlackliInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.ugcbase.security.impl.DefaultAttachmentTypeBlacklistService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    defaultAttachmentTypeBlacklist match {
      case Some(param) => queryParams += "default.attachment.type.blacklist" -> param.toString
      case _ => queryParams
    }
    baselineAttachmentTypeBlacklist match {
      case Some(param) => queryParams += "baseline.attachment.type.blacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    parameterWhitelist: Option[List[String]] = None,
    parameterWhitelistPrefixes: Option[List[String]] = None,
    binaryParameterWhitelist: Option[List[String]] = None,
    modifierWhitelist: Option[List[String]] = None,
    operationWhitelist: Option[List[String]] = None,
    operationWhitelistPrefixes: Option[List[String]] = None,
    typehintWhitelist: Option[List[String]] = None,
    resourcetypeWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo]): Future[ComAdobeCqSocialUgcbaseSecurityImplSaferSlingPostValidatorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.ugcbase.security.impl.SaferSlingPostValidatorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    parameterWhitelist match {
      case Some(param) => queryParams += "parameter.whitelist" -> param.toString
      case _ => queryParams
    }
    parameterWhitelistPrefixes match {
      case Some(param) => queryParams += "parameter.whitelist.prefixes" -> param.toString
      case _ => queryParams
    }
    binaryParameterWhitelist match {
      case Some(param) => queryParams += "binary.parameter.whitelist" -> param.toString
      case _ => queryParams
    }
    modifierWhitelist match {
      case Some(param) => queryParams += "modifier.whitelist" -> param.toString
      case _ => queryParams
    }
    operationWhitelist match {
      case Some(param) => queryParams += "operation.whitelist" -> param.toString
      case _ => queryParams
    }
    operationWhitelistPrefixes match {
      case Some(param) => queryParams += "operation.whitelist.prefixes" -> param.toString
      case _ => queryParams
    }
    typehintWhitelist match {
      case Some(param) => queryParams += "typehint.whitelist" -> param.toString
      case _ => queryParams
    }
    resourcetypeWhitelist match {
      case Some(param) => queryParams += "resourcetype.whitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletExtensions: Option[String] = None,
    slingServletPaths: Option[String] = None,
    slingServletMethods: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo]): Future[ComAdobeCqSocialUserEndpointsImplUsersGroupFromPublishServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.user.endpoints.impl.UsersGroupFromPublishServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletExtensions match {
      case Some(param) => queryParams += "sling.servlet.extensions" -> param.toString
      case _ => queryParams
    }
    slingServletPaths match {
      case Some(param) => queryParams += "sling.servlet.paths" -> param.toString
      case _ => queryParams
    }
    slingServletMethods match {
      case Some(param) => queryParams += "sling.servlet.methods" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqSocialUserImplTransportHttpToPublisher(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enable: Option[Boolean] = None,
    agentConfiguration: Option[List[String]] = None,
    contextPath: Option[String] = None,
    disabledCipherSuites: Option[List[String]] = None,
    enabledCipherSuites: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo]): Future[ComAdobeCqSocialUserImplTransportHttpToPublisherInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.social.user.impl.transport.HttpToPublisher"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enable match {
      case Some(param) => queryParams += "enable" -> param.toString
      case _ => queryParams
    }
    agentConfiguration match {
      case Some(param) => queryParams += "agent.configuration" -> param.toString
      case _ => queryParams
    }
    contextPath match {
      case Some(param) => queryParams += "context.path" -> param.toString
      case _ => queryParams
    }
    disabledCipherSuites match {
      case Some(param) => queryParams += "disabled.cipher.suites" -> param.toString
      case _ => queryParams
    }
    enabledCipherSuites match {
      case Some(param) => queryParams += "enabled.cipher.suites" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFact(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    resourceTypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo]): Future[ComAdobeCqUiWcmCommonsInternalServletsRteRTEFilterServletFactInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.ui.wcm.commons.internal.servlets.rte.RTEFilterServletFactory.amended"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    resourceTypes match {
      case Some(param) => queryParams += "resource.types" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqUpgradesCleanupImplUpgradeContentCleanup(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    deletePathRegexps: Option[List[String]] = None,
    deleteSql2Query: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo]): Future[ComAdobeCqUpgradesCleanupImplUpgradeContentCleanupInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.upgrades.cleanup.impl.UpgradeContentCleanup"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    deletePathRegexps match {
      case Some(param) => queryParams += "delete.path.regexps" -> param.toString
      case _ => queryParams
    }
    deleteSql2Query match {
      case Some(param) => queryParams += "delete.sql2.query" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanup(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    deleteNameRegexps: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo]): Future[ComAdobeCqUpgradesCleanupImplUpgradeInstallFolderCleanupInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.upgrades.cleanup.impl.UpgradeInstallFolderCleanup"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    deleteNameRegexps match {
      case Some(param) => queryParams += "delete.name.regexps" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    threshold: Option[Integer] = None,
    jobTopicName: Option[String] = None,
    emailEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo]): Future[ComAdobeCqWcmJobsAsyncImplAsyncDeleteConfigProviderServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncDeleteConfigProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    threshold match {
      case Some(param) => queryParams += "threshold" -> param.toString
      case _ => queryParams
    }
    jobTopicName match {
      case Some(param) => queryParams += "jobTopicName" -> param.toString
      case _ => queryParams
    }
    emailEnabled match {
      case Some(param) => queryParams += "emailEnabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None,
    jobPurgeThreshold: Option[Integer] = None,
    jobPurgeMaxJobs: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo]): Future[ComAdobeCqWcmJobsAsyncImplAsyncJobCleanUpTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncJobCleanUpTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }
    jobPurgeThreshold match {
      case Some(param) => queryParams += "job.purge.threshold" -> param.toString
      case _ => queryParams
    }
    jobPurgeMaxJobs match {
      case Some(param) => queryParams += "job.purge.max.jobs" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    threshold: Option[Integer] = None,
    jobTopicName: Option[String] = None,
    emailEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo]): Future[ComAdobeCqWcmJobsAsyncImplAsyncMoveConfigProviderServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncMoveConfigProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    threshold match {
      case Some(param) => queryParams += "threshold" -> param.toString
      case _ => queryParams
    }
    jobTopicName match {
      case Some(param) => queryParams += "jobTopicName" -> param.toString
      case _ => queryParams
    }
    emailEnabled match {
      case Some(param) => queryParams += "emailEnabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    threshold: Option[Integer] = None,
    jobTopicName: Option[String] = None,
    emailEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo]): Future[ComAdobeCqWcmJobsAsyncImplAsyncPageMoveConfigProviderServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.wcm.jobs.async.impl.AsyncPageMoveConfigProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    threshold match {
      case Some(param) => queryParams += "threshold" -> param.toString
      case _ => queryParams
    }
    jobTopicName match {
      case Some(param) => queryParams += "jobTopicName" -> param.toString
      case _ => queryParams
    }
    emailEnabled match {
      case Some(param) => queryParams += "emailEnabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqWcmLaunchesImplLaunchesEventHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventFilter: Option[String] = None,
    launchesEventhandlerThreadpoolMaxsize: Option[Integer] = None,
    launchesEventhandlerThreadpoolPriority: Option[String] = None,
    launchesEventhandlerUpdatelastmodification: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo]): Future[ComAdobeCqWcmLaunchesImplLaunchesEventHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.wcm.launches.impl.LaunchesEventHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }
    launchesEventhandlerThreadpoolMaxsize match {
      case Some(param) => queryParams += "launches.eventhandler.threadpool.maxsize" -> param.toString
      case _ => queryParams
    }
    launchesEventhandlerThreadpoolPriority match {
      case Some(param) => queryParams += "launches.eventhandler.threadpool.priority" -> param.toString
      case _ => queryParams
    }
    launchesEventhandlerUpdatelastmodification match {
      case Some(param) => queryParams += "launches.eventhandler.updatelastmodification" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqWcmMobileQrcodeServletQRCodeImageGenerator(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqWcmQrcodeServletWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo]): Future[ComAdobeCqWcmMobileQrcodeServletQRCodeImageGeneratorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.wcm.mobile.qrcode.servlet.QRCodeImageGenerator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqWcmQrcodeServletWhitelist match {
      case Some(param) => queryParams += "cq.wcm.qrcode.servlet.whitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqWcmStyleInternalComponentStyleInfoCacheImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    size: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo]): Future[ComAdobeCqWcmStyleInternalComponentStyleInfoCacheImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.wcm.style.internal.ComponentStyleInfoCacheImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeCqWcmTranslationImplTranslationPlatformConfigurationImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    syncTranslationStateSchedulingFormat: Option[String] = None,
    schedulingRepeatTranslationSchedulingFormat: Option[String] = None,
    syncTranslationStateLockTimeoutInMinutes: Option[String] = None,
    exportFormat: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo]): Future[ComAdobeCqWcmTranslationImplTranslationPlatformConfigurationImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.cq.wcm.translation.impl.TranslationPlatformConfigurationImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    syncTranslationStateSchedulingFormat match {
      case Some(param) => queryParams += "syncTranslationState.schedulingFormat" -> param.toString
      case _ => queryParams
    }
    schedulingRepeatTranslationSchedulingFormat match {
      case Some(param) => queryParams += "schedulingRepeatTranslation.schedulingFormat" -> param.toString
      case _ => queryParams
    }
    syncTranslationStateLockTimeoutInMinutes match {
      case Some(param) => queryParams += "syncTranslationState.lockTimeoutInMinutes" -> param.toString
      case _ => queryParams
    }
    exportFormat match {
      case Some(param) => queryParams += "export.format" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    portalOutboxes: Option[List[String]] = None,
    draftDataService: Option[String] = None,
    draftMetadataService: Option[String] = None,
    submitDataService: Option[String] = None,
    submitMetadataService: Option[String] = None,
    pendingSignDataService: Option[String] = None,
    pendingSignMetadataService: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo]): Future[ComAdobeFdFpConfigFormsPortalDraftsandSubmissionConfigServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.fd.fp.config.FormsPortalDraftsandSubmissionConfigService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    portalOutboxes match {
      case Some(param) => queryParams += "portal.outboxes" -> param.toString
      case _ => queryParams
    }
    draftDataService match {
      case Some(param) => queryParams += "draft.data.service" -> param.toString
      case _ => queryParams
    }
    draftMetadataService match {
      case Some(param) => queryParams += "draft.metadata.service" -> param.toString
      case _ => queryParams
    }
    submitDataService match {
      case Some(param) => queryParams += "submit.data.service" -> param.toString
      case _ => queryParams
    }
    submitMetadataService match {
      case Some(param) => queryParams += "submit.metadata.service" -> param.toString
      case _ => queryParams
    }
    pendingSignDataService match {
      case Some(param) => queryParams += "pendingSign.data.service" -> param.toString
      case _ => queryParams
    }
    pendingSignMetadataService match {
      case Some(param) => queryParams += "pendingSign.metadata.service" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeFdFpConfigFormsPortalSchedulerService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    formportalInterval: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo]): Future[ComAdobeFdFpConfigFormsPortalSchedulerServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.fd.fp.config.FormsPortalSchedulerService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    formportalInterval match {
      case Some(param) => queryParams += "formportal.interval" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeFormsCommonServiceImplDefaultDataProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    alloweddataFileLocations: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo]): Future[ComAdobeFormsCommonServiceImplDefaultDataProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.forms.common.service.impl.DefaultDataProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    alloweddataFileLocations match {
      case Some(param) => queryParams += "alloweddataFileLocations" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImp(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    tempStorageConfig: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo]): Future[ComAdobeFormsCommonServiceImplFormsCommonConfigurationServiceImpInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.forms.common.service.impl.FormsCommonConfigurationServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    tempStorageConfig match {
      case Some(param) => queryParams += "tempStorageConfig" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeFormsCommonServletTempCleanUpTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None,
    durationForTemporaryStorage: Option[String] = None,
    durationForAnonymousStorage: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeFormsCommonServletTempCleanUpTaskInfo]): Future[ComAdobeFormsCommonServletTempCleanUpTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.forms.common.servlet.TempCleanUpTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }
    durationForTemporaryStorage match {
      case Some(param) => queryParams += "Duration for Temporary Storage" -> param.toString
      case _ => queryParams
    }
    durationForAnonymousStorage match {
      case Some(param) => queryParams += "Duration for Anonymous Storage" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAcpPlatformPlatformServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    queryLimit: Option[Integer] = None,
    fileTypeExtensionMap: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAcpPlatformPlatformServletInfo]): Future[ComAdobeGraniteAcpPlatformPlatformServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.acp.platform.PlatformServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    queryLimit match {
      case Some(param) => queryParams += "query.limit" -> param.toString
      case _ => queryParams
    }
    fileTypeExtensionMap match {
      case Some(param) => queryParams += "file.type.extension.map" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteActivitystreamsImplActivityManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    aggregateRelationships: Option[List[String]] = None,
    aggregateDescendVirtual: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo]): Future[ComAdobeGraniteActivitystreamsImplActivityManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.activitystreams.impl.ActivityManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    aggregateRelationships match {
      case Some(param) => queryParams += "aggregate.relationships" -> param.toString
      case _ => queryParams
    }
    aggregateDescendVirtual match {
      case Some(param) => queryParams += "aggregate.descend.virtual" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAnalyzerBaseSystemStatusServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    disabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo]): Future[ComAdobeGraniteAnalyzerBaseSystemStatusServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.analyzer.base.SystemStatusServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    disabled match {
      case Some(param) => queryParams += "disabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    disabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo]): Future[ComAdobeGraniteAnalyzerScriptsCompileAllScriptsCompilerServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.analyzer.scripts.compile.AllScriptsCompilerServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    disabled match {
      case Some(param) => queryParams += "disabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteApicontrollerFilterResolverHookFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeCqCdnCdnRewriter: Option[String] = None,
    comAdobeCqCloudConfigComponents: Option[String] = None,
    comAdobeCqCloudConfigCore: Option[String] = None,
    comAdobeCqCloudConfigUi: Option[String] = None,
    comAdobeCqComAdobeCqEditor: Option[String] = None,
    comAdobeCqComAdobeCqProjectsCore: Option[String] = None,
    comAdobeCqComAdobeCqProjectsWcmCore: Option[String] = None,
    comAdobeCqComAdobeCqUiCommons: Option[String] = None,
    comAdobeCqComAdobeCqWcmStyle: Option[String] = None,
    comAdobeCqCqActivitymapIntegration: Option[String] = None,
    comAdobeCqCqContexthubCommons: Option[String] = None,
    comAdobeCqCqDtm: Option[String] = None,
    comAdobeCqCqHealthcheck: Option[String] = None,
    comAdobeCqCqMultisiteTargeting: Option[String] = None,
    comAdobeCqCqPreUpgradeCleanup: Option[String] = None,
    comAdobeCqCqProductInfoProvider: Option[String] = None,
    comAdobeCqCqRestSites: Option[String] = None,
    comAdobeCqCqSecurityHc: Option[String] = None,
    comAdobeCqDamCqDamSvgHandler: Option[String] = None,
    comAdobeCqDamCqScene7Imaging: Option[String] = None,
    comAdobeCqDtmReactorCore: Option[String] = None,
    comAdobeCqDtmReactorUi: Option[String] = None,
    comAdobeCqExpJspelResolver: Option[String] = None,
    comAdobeCqInboxCqInbox: Option[String] = None,
    comAdobeCqJsonSchemaParser: Option[String] = None,
    comAdobeCqMediaCqMediaPublishingDpsFpCore: Option[String] = None,
    comAdobeCqMobileCqMobileCaas: Option[String] = None,
    comAdobeCqMobileCqMobileIndexBuilder: Option[String] = None,
    comAdobeCqMobileCqMobilePhonegapBuild: Option[String] = None,
    comAdobeCqMyspell: Option[String] = None,
    comAdobeCqSampleWeRetailCore: Option[String] = None,
    comAdobeCqScreensComAdobeCqScreensDcc: Option[String] = None,
    comAdobeCqScreensComAdobeCqScreensMqCore: Option[String] = None,
    comAdobeCqSocialCqSocialAsProvider: Option[String] = None,
    comAdobeCqSocialCqSocialBadgingBasicImpl: Option[String] = None,
    comAdobeCqSocialCqSocialBadgingImpl: Option[String] = None,
    comAdobeCqSocialCqSocialCalendarImpl: Option[String] = None,
    comAdobeCqSocialCqSocialContentFragmentsImpl: Option[String] = None,
    comAdobeCqSocialCqSocialEnablementImpl: Option[String] = None,
    comAdobeCqSocialCqSocialGraphImpl: Option[String] = None,
    comAdobeCqSocialCqSocialIdeationImpl: Option[String] = None,
    comAdobeCqSocialCqSocialJcrProvider: Option[String] = None,
    comAdobeCqSocialCqSocialMembersImpl: Option[String] = None,
    comAdobeCqSocialCqSocialMsProvider: Option[String] = None,
    comAdobeCqSocialCqSocialNotificationsChannelsWeb: Option[String] = None,
    comAdobeCqSocialCqSocialNotificationsImpl: Option[String] = None,
    comAdobeCqSocialCqSocialRdbProvider: Option[String] = None,
    comAdobeCqSocialCqSocialScfImpl: Option[String] = None,
    comAdobeCqSocialCqSocialScoringBasicImpl: Option[String] = None,
    comAdobeCqSocialCqSocialScoringImpl: Option[String] = None,
    comAdobeCqSocialCqSocialServiceusersImpl: Option[String] = None,
    comAdobeCqSocialCqSocialSrpImpl: Option[String] = None,
    comAdobeCqSocialCqSocialUgcbaseImpl: Option[String] = None,
    comAdobeDamCqDamCfmImpl: Option[String] = None,
    comAdobeFormsFoundationFormsFoundationBase: Option[String] = None,
    comAdobeGraniteApicontroller: Option[String] = None,
    comAdobeGraniteAssetCore: Option[String] = None,
    comAdobeGraniteAuthSso: Option[String] = None,
    comAdobeGraniteBundlesHcImpl: Option[String] = None,
    comAdobeGraniteCompatRouter: Option[String] = None,
    comAdobeGraniteConf: Option[String] = None,
    comAdobeGraniteConfUiCore: Option[String] = None,
    comAdobeGraniteCors: Option[String] = None,
    comAdobeGraniteCrxExplorer: Option[String] = None,
    comAdobeGraniteCrxdeLite: Option[String] = None,
    comAdobeGraniteCryptoConfig: Option[String] = None,
    comAdobeGraniteCryptoExtension: Option[String] = None,
    comAdobeGraniteCryptoFile: Option[String] = None,
    comAdobeGraniteCryptoJcr: Option[String] = None,
    comAdobeGraniteCsrf: Option[String] = None,
    comAdobeGraniteDistributionCore: Option[String] = None,
    comAdobeGraniteDropwizardMetrics: Option[String] = None,
    comAdobeGraniteFragsImpl: Option[String] = None,
    comAdobeGraniteGibson: Option[String] = None,
    comAdobeGraniteInfocollector: Option[String] = None,
    comAdobeGraniteInstallerFactoryPackages: Option[String] = None,
    comAdobeGraniteJettySsl: Option[String] = None,
    comAdobeGraniteJobsAsync: Option[String] = None,
    comAdobeGraniteMaintenanceOak: Option[String] = None,
    comAdobeGraniteMonitoringCore: Option[String] = None,
    comAdobeGraniteQueries: Option[String] = None,
    comAdobeGraniteReplicationHcImpl: Option[String] = None,
    comAdobeGraniteRepositoryChecker: Option[String] = None,
    comAdobeGraniteRepositoryHcImpl: Option[String] = None,
    comAdobeGraniteRestAssets: Option[String] = None,
    comAdobeGraniteSecurityUi: Option[String] = None,
    comAdobeGraniteStartup: Option[String] = None,
    comAdobeGraniteTagsoup: Option[String] = None,
    comAdobeGraniteTaskmanagementCore: Option[String] = None,
    comAdobeGraniteTaskmanagementWorkflow: Option[String] = None,
    comAdobeGraniteUiClientlibsCompilerLess: Option[String] = None,
    comAdobeGraniteUiClientlibsProcessorGcc: Option[String] = None,
    comAdobeGraniteWebconsolePlugins: Option[String] = None,
    comAdobeGraniteWorkflowConsole: Option[String] = None,
    comAdobeXmpWorkerFilesNativeFragmentLinux: Option[String] = None,
    comAdobeXmpWorkerFilesNativeFragmentMacosx: Option[String] = None,
    comAdobeXmpWorkerFilesNativeFragmentWin: Option[String] = None,
    comDayCommonsOsgiWrapperSimpleJndi: Option[String] = None,
    comDayCqCqAuthhandler: Option[String] = None,
    comDayCqCqCompatConfigupdate: Option[String] = None,
    comDayCqCqLicensebranding: Option[String] = None,
    comDayCqCqNotifcationImpl: Option[String] = None,
    comDayCqCqReplicationAudit: Option[String] = None,
    comDayCqCqSearchExt: Option[String] = None,
    comDayCqDamCqDamAnnotationPrint: Option[String] = None,
    comDayCqDamCqDamAssetUsage: Option[String] = None,
    comDayCqDamCqDamS7dam: Option[String] = None,
    comDayCqDamCqDamSimilaritysearch: Option[String] = None,
    comDayCqDamDamWebdavSupport: Option[String] = None,
    comDayCqPreUpgradeTasks: Option[String] = None,
    comDayCqReplicationExtensions: Option[String] = None,
    comDayCqWcmCqMsmCore: Option[String] = None,
    comDayCqWcmCqWcmTranslation: Option[String] = None,
    dayCommonsJrawio: Option[String] = None,
    orgApacheAriesJmxWhiteboard: Option[String] = None,
    orgApacheFelixHttpSslfilter: Option[String] = None,
    orgApacheFelixOrgApacheFelixThreaddump: Option[String] = None,
    orgApacheFelixWebconsolePluginsDs: Option[String] = None,
    orgApacheFelixWebconsolePluginsEvent: Option[String] = None,
    orgApacheFelixWebconsolePluginsMemoryusage: Option[String] = None,
    orgApacheFelixWebconsolePluginsPackageadmin: Option[String] = None,
    orgApacheJackrabbitOakAuthLdap: Option[String] = None,
    orgApacheJackrabbitOakSegmentTar: Option[String] = None,
    orgApacheJackrabbitOakSolrOsgi: Option[String] = None,
    orgApacheSlingBundleresourceImpl: Option[String] = None,
    orgApacheSlingCommonsFsclassloader: Option[String] = None,
    orgApacheSlingCommonsLogWebconsole: Option[String] = None,
    orgApacheSlingDatasource: Option[String] = None,
    orgApacheSlingDiscoveryBase: Option[String] = None,
    orgApacheSlingDiscoveryOak: Option[String] = None,
    orgApacheSlingDiscoverySupport: Option[String] = None,
    orgApacheSlingDistributionApi: Option[String] = None,
    orgApacheSlingDistributionCore: Option[String] = None,
    orgApacheSlingExtensionsWebconsolesecurityprovider: Option[String] = None,
    orgApacheSlingHcWebconsole: Option[String] = None,
    orgApacheSlingInstallerConsole: Option[String] = None,
    orgApacheSlingInstallerProviderFile: Option[String] = None,
    orgApacheSlingInstallerProviderJcr: Option[String] = None,
    orgApacheSlingJcrDavex: Option[String] = None,
    orgApacheSlingJcrResourcesecurity: Option[String] = None,
    orgApacheSlingJmxProvider: Option[String] = None,
    orgApacheSlingLaunchpadInstaller: Option[String] = None,
    orgApacheSlingModelsImpl: Option[String] = None,
    orgApacheSlingRepoinitParser: Option[String] = None,
    orgApacheSlingResourceInventory: Option[String] = None,
    orgApacheSlingResourceresolver: Option[String] = None,
    orgApacheSlingScriptingJavascript: Option[String] = None,
    orgApacheSlingScriptingJst: Option[String] = None,
    orgApacheSlingScriptingSightlyJsProvider: Option[String] = None,
    orgApacheSlingScriptingSightlyModelsProvider: Option[String] = None,
    orgApacheSlingSecurity: Option[String] = None,
    orgApacheSlingServletsCompat: Option[String] = None,
    orgApacheSlingServletsGet: Option[String] = None,
    orgApacheSlingStartupfilterDisabler: Option[String] = None,
    orgApacheSlingTracer: Option[String] = None,
    weRetailClientAppCore: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo]): Future[ComAdobeGraniteApicontrollerFilterResolverHookFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.apicontroller.FilterResolverHookFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCdnCdnRewriter match {
      case Some(param) => queryParams += "com.adobe.cq.cdn.cdn-rewriter" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCloudConfigComponents match {
      case Some(param) => queryParams += "com.adobe.cq.cloud-config.components" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCloudConfigCore match {
      case Some(param) => queryParams += "com.adobe.cq.cloud-config.core" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCloudConfigUi match {
      case Some(param) => queryParams += "com.adobe.cq.cloud-config.ui" -> param.toString
      case _ => queryParams
    }
    comAdobeCqComAdobeCqEditor match {
      case Some(param) => queryParams += "com.adobe.cq.com.adobe.cq.editor" -> param.toString
      case _ => queryParams
    }
    comAdobeCqComAdobeCqProjectsCore match {
      case Some(param) => queryParams += "com.adobe.cq.com.adobe.cq.projects.core" -> param.toString
      case _ => queryParams
    }
    comAdobeCqComAdobeCqProjectsWcmCore match {
      case Some(param) => queryParams += "com.adobe.cq.com.adobe.cq.projects.wcm.core" -> param.toString
      case _ => queryParams
    }
    comAdobeCqComAdobeCqUiCommons match {
      case Some(param) => queryParams += "com.adobe.cq.com.adobe.cq.ui.commons" -> param.toString
      case _ => queryParams
    }
    comAdobeCqComAdobeCqWcmStyle match {
      case Some(param) => queryParams += "com.adobe.cq.com.adobe.cq.wcm.style" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCqActivitymapIntegration match {
      case Some(param) => queryParams += "com.adobe.cq.cq-activitymap-integration" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCqContexthubCommons match {
      case Some(param) => queryParams += "com.adobe.cq.cq-contexthub-commons" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCqDtm match {
      case Some(param) => queryParams += "com.adobe.cq.cq-dtm" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCqHealthcheck match {
      case Some(param) => queryParams += "com.adobe.cq.cq-healthcheck" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCqMultisiteTargeting match {
      case Some(param) => queryParams += "com.adobe.cq.cq-multisite-targeting" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCqPreUpgradeCleanup match {
      case Some(param) => queryParams += "com.adobe.cq.cq-pre-upgrade-cleanup" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCqProductInfoProvider match {
      case Some(param) => queryParams += "com.adobe.cq.cq-product-info-provider" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCqRestSites match {
      case Some(param) => queryParams += "com.adobe.cq.cq-rest-sites" -> param.toString
      case _ => queryParams
    }
    comAdobeCqCqSecurityHc match {
      case Some(param) => queryParams += "com.adobe.cq.cq-security-hc" -> param.toString
      case _ => queryParams
    }
    comAdobeCqDamCqDamSvgHandler match {
      case Some(param) => queryParams += "com.adobe.cq.dam.cq-dam-svg-handler" -> param.toString
      case _ => queryParams
    }
    comAdobeCqDamCqScene7Imaging match {
      case Some(param) => queryParams += "com.adobe.cq.dam.cq-scene7-imaging" -> param.toString
      case _ => queryParams
    }
    comAdobeCqDtmReactorCore match {
      case Some(param) => queryParams += "com.adobe.cq.dtm-reactor.core" -> param.toString
      case _ => queryParams
    }
    comAdobeCqDtmReactorUi match {
      case Some(param) => queryParams += "com.adobe.cq.dtm-reactor.ui" -> param.toString
      case _ => queryParams
    }
    comAdobeCqExpJspelResolver match {
      case Some(param) => queryParams += "com.adobe.cq.exp-jspel-resolver" -> param.toString
      case _ => queryParams
    }
    comAdobeCqInboxCqInbox match {
      case Some(param) => queryParams += "com.adobe.cq.inbox.cq-inbox" -> param.toString
      case _ => queryParams
    }
    comAdobeCqJsonSchemaParser match {
      case Some(param) => queryParams += "com.adobe.cq.json-schema-parser" -> param.toString
      case _ => queryParams
    }
    comAdobeCqMediaCqMediaPublishingDpsFpCore match {
      case Some(param) => queryParams += "com.adobe.cq.media.cq-media-publishing-dps-fp-core" -> param.toString
      case _ => queryParams
    }
    comAdobeCqMobileCqMobileCaas match {
      case Some(param) => queryParams += "com.adobe.cq.mobile.cq-mobile-caas" -> param.toString
      case _ => queryParams
    }
    comAdobeCqMobileCqMobileIndexBuilder match {
      case Some(param) => queryParams += "com.adobe.cq.mobile.cq-mobile-index-builder" -> param.toString
      case _ => queryParams
    }
    comAdobeCqMobileCqMobilePhonegapBuild match {
      case Some(param) => queryParams += "com.adobe.cq.mobile.cq-mobile-phonegap-build" -> param.toString
      case _ => queryParams
    }
    comAdobeCqMyspell match {
      case Some(param) => queryParams += "com.adobe.cq.myspell" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSampleWeRetailCore match {
      case Some(param) => queryParams += "com.adobe.cq.sample.we.retail.core" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensComAdobeCqScreensDcc match {
      case Some(param) => queryParams += "com.adobe.cq.screens.com.adobe.cq.screens.dcc" -> param.toString
      case _ => queryParams
    }
    comAdobeCqScreensComAdobeCqScreensMqCore match {
      case Some(param) => queryParams += "com.adobe.cq.screens.com.adobe.cq.screens.mq.core" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialAsProvider match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-as-provider" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialBadgingBasicImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-badging-basic-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialBadgingImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-badging-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialCalendarImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-calendar-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialContentFragmentsImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-content-fragments-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialEnablementImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-enablement-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialGraphImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-graph-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialIdeationImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-ideation-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialJcrProvider match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-jcr-provider" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialMembersImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-members-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialMsProvider match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-ms-provider" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialNotificationsChannelsWeb match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-notifications-channels-web" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialNotificationsImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-notifications-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialRdbProvider match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-rdb-provider" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialScfImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-scf-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialScoringBasicImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-scoring-basic-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialScoringImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-scoring-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialServiceusersImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-serviceusers-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialSrpImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-srp-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeCqSocialCqSocialUgcbaseImpl match {
      case Some(param) => queryParams += "com.adobe.cq.social.cq-social-ugcbase-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeDamCqDamCfmImpl match {
      case Some(param) => queryParams += "com.adobe.dam.cq-dam-cfm-impl" -> param.toString
      case _ => queryParams
    }
    comAdobeFormsFoundationFormsFoundationBase match {
      case Some(param) => queryParams += "com.adobe.forms.foundation-forms-foundation-base" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteApicontroller match {
      case Some(param) => queryParams += "com.adobe.granite.apicontroller" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteAssetCore match {
      case Some(param) => queryParams += "com.adobe.granite.asset.core" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteAuthSso match {
      case Some(param) => queryParams += "com.adobe.granite.auth.sso" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteBundlesHcImpl match {
      case Some(param) => queryParams += "com.adobe.granite.bundles.hc.impl" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteCompatRouter match {
      case Some(param) => queryParams += "com.adobe.granite.compat-router" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteConf match {
      case Some(param) => queryParams += "com.adobe.granite.conf" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteConfUiCore match {
      case Some(param) => queryParams += "com.adobe.granite.conf.ui.core" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteCors match {
      case Some(param) => queryParams += "com.adobe.granite.cors" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteCrxExplorer match {
      case Some(param) => queryParams += "com.adobe.granite.crx-explorer" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteCrxdeLite match {
      case Some(param) => queryParams += "com.adobe.granite.crxde-lite" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteCryptoConfig match {
      case Some(param) => queryParams += "com.adobe.granite.crypto.config" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteCryptoExtension match {
      case Some(param) => queryParams += "com.adobe.granite.crypto.extension" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteCryptoFile match {
      case Some(param) => queryParams += "com.adobe.granite.crypto.file" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteCryptoJcr match {
      case Some(param) => queryParams += "com.adobe.granite.crypto.jcr" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteCsrf match {
      case Some(param) => queryParams += "com.adobe.granite.csrf" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteDistributionCore match {
      case Some(param) => queryParams += "com.adobe.granite.distribution.core" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteDropwizardMetrics match {
      case Some(param) => queryParams += "com.adobe.granite.dropwizard.metrics" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteFragsImpl match {
      case Some(param) => queryParams += "com.adobe.granite.frags.impl" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteGibson match {
      case Some(param) => queryParams += "com.adobe.granite.gibson" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteInfocollector match {
      case Some(param) => queryParams += "com.adobe.granite.infocollector" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteInstallerFactoryPackages match {
      case Some(param) => queryParams += "com.adobe.granite.installer.factory.packages" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteJettySsl match {
      case Some(param) => queryParams += "com.adobe.granite.jetty.ssl" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteJobsAsync match {
      case Some(param) => queryParams += "com.adobe.granite.jobs.async" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteMaintenanceOak match {
      case Some(param) => queryParams += "com.adobe.granite.maintenance.oak" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteMonitoringCore match {
      case Some(param) => queryParams += "com.adobe.granite.monitoring.core" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteQueries match {
      case Some(param) => queryParams += "com.adobe.granite.queries" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteReplicationHcImpl match {
      case Some(param) => queryParams += "com.adobe.granite.replication.hc.impl" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteRepositoryChecker match {
      case Some(param) => queryParams += "com.adobe.granite.repository.checker" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteRepositoryHcImpl match {
      case Some(param) => queryParams += "com.adobe.granite.repository.hc.impl" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteRestAssets match {
      case Some(param) => queryParams += "com.adobe.granite.rest.assets" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteSecurityUi match {
      case Some(param) => queryParams += "com.adobe.granite.security.ui" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteStartup match {
      case Some(param) => queryParams += "com.adobe.granite.startup" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteTagsoup match {
      case Some(param) => queryParams += "com.adobe.granite.tagsoup" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteTaskmanagementCore match {
      case Some(param) => queryParams += "com.adobe.granite.taskmanagement.core" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteTaskmanagementWorkflow match {
      case Some(param) => queryParams += "com.adobe.granite.taskmanagement.workflow" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteUiClientlibsCompilerLess match {
      case Some(param) => queryParams += "com.adobe.granite.ui.clientlibs.compiler.less" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteUiClientlibsProcessorGcc match {
      case Some(param) => queryParams += "com.adobe.granite.ui.clientlibs.processor.gcc" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteWebconsolePlugins match {
      case Some(param) => queryParams += "com.adobe.granite.webconsole.plugins" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteWorkflowConsole match {
      case Some(param) => queryParams += "com.adobe.granite.workflow.console" -> param.toString
      case _ => queryParams
    }
    comAdobeXmpWorkerFilesNativeFragmentLinux match {
      case Some(param) => queryParams += "com.adobe.xmp.worker.files.native.fragment.linux" -> param.toString
      case _ => queryParams
    }
    comAdobeXmpWorkerFilesNativeFragmentMacosx match {
      case Some(param) => queryParams += "com.adobe.xmp.worker.files.native.fragment.macosx" -> param.toString
      case _ => queryParams
    }
    comAdobeXmpWorkerFilesNativeFragmentWin match {
      case Some(param) => queryParams += "com.adobe.xmp.worker.files.native.fragment.win" -> param.toString
      case _ => queryParams
    }
    comDayCommonsOsgiWrapperSimpleJndi match {
      case Some(param) => queryParams += "com.day.commons.osgi.wrapper.simple-jndi" -> param.toString
      case _ => queryParams
    }
    comDayCqCqAuthhandler match {
      case Some(param) => queryParams += "com.day.cq.cq-authhandler" -> param.toString
      case _ => queryParams
    }
    comDayCqCqCompatConfigupdate match {
      case Some(param) => queryParams += "com.day.cq.cq-compat-configupdate" -> param.toString
      case _ => queryParams
    }
    comDayCqCqLicensebranding match {
      case Some(param) => queryParams += "com.day.cq.cq-licensebranding" -> param.toString
      case _ => queryParams
    }
    comDayCqCqNotifcationImpl match {
      case Some(param) => queryParams += "com.day.cq.cq-notifcation-impl" -> param.toString
      case _ => queryParams
    }
    comDayCqCqReplicationAudit match {
      case Some(param) => queryParams += "com.day.cq.cq-replication-audit" -> param.toString
      case _ => queryParams
    }
    comDayCqCqSearchExt match {
      case Some(param) => queryParams += "com.day.cq.cq-search-ext" -> param.toString
      case _ => queryParams
    }
    comDayCqDamCqDamAnnotationPrint match {
      case Some(param) => queryParams += "com.day.cq.dam.cq-dam-annotation-print" -> param.toString
      case _ => queryParams
    }
    comDayCqDamCqDamAssetUsage match {
      case Some(param) => queryParams += "com.day.cq.dam.cq-dam-asset-usage" -> param.toString
      case _ => queryParams
    }
    comDayCqDamCqDamS7dam match {
      case Some(param) => queryParams += "com.day.cq.dam.cq-dam-s7dam" -> param.toString
      case _ => queryParams
    }
    comDayCqDamCqDamSimilaritysearch match {
      case Some(param) => queryParams += "com.day.cq.dam.cq-dam-similaritysearch" -> param.toString
      case _ => queryParams
    }
    comDayCqDamDamWebdavSupport match {
      case Some(param) => queryParams += "com.day.cq.dam.dam-webdav-support" -> param.toString
      case _ => queryParams
    }
    comDayCqPreUpgradeTasks match {
      case Some(param) => queryParams += "com.day.cq.pre-upgrade-tasks" -> param.toString
      case _ => queryParams
    }
    comDayCqReplicationExtensions match {
      case Some(param) => queryParams += "com.day.cq.replication.extensions" -> param.toString
      case _ => queryParams
    }
    comDayCqWcmCqMsmCore match {
      case Some(param) => queryParams += "com.day.cq.wcm.cq-msm-core" -> param.toString
      case _ => queryParams
    }
    comDayCqWcmCqWcmTranslation match {
      case Some(param) => queryParams += "com.day.cq.wcm.cq-wcm-translation" -> param.toString
      case _ => queryParams
    }
    dayCommonsJrawio match {
      case Some(param) => queryParams += "day-commons-jrawio" -> param.toString
      case _ => queryParams
    }
    orgApacheAriesJmxWhiteboard match {
      case Some(param) => queryParams += "org.apache.aries.jmx.whiteboard" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpSslfilter match {
      case Some(param) => queryParams += "org.apache.felix.http.sslfilter" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixOrgApacheFelixThreaddump match {
      case Some(param) => queryParams += "org.apache.felix.org.apache.felix.threaddump" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixWebconsolePluginsDs match {
      case Some(param) => queryParams += "org.apache.felix.webconsole.plugins.ds" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixWebconsolePluginsEvent match {
      case Some(param) => queryParams += "org.apache.felix.webconsole.plugins.event" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixWebconsolePluginsMemoryusage match {
      case Some(param) => queryParams += "org.apache.felix.webconsole.plugins.memoryusage" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixWebconsolePluginsPackageadmin match {
      case Some(param) => queryParams += "org.apache.felix.webconsole.plugins.packageadmin" -> param.toString
      case _ => queryParams
    }
    orgApacheJackrabbitOakAuthLdap match {
      case Some(param) => queryParams += "org.apache.jackrabbit.oak-auth-ldap" -> param.toString
      case _ => queryParams
    }
    orgApacheJackrabbitOakSegmentTar match {
      case Some(param) => queryParams += "org.apache.jackrabbit.oak-segment-tar" -> param.toString
      case _ => queryParams
    }
    orgApacheJackrabbitOakSolrOsgi match {
      case Some(param) => queryParams += "org.apache.jackrabbit.oak-solr-osgi" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingBundleresourceImpl match {
      case Some(param) => queryParams += "org.apache.sling.bundleresource.impl" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsFsclassloader match {
      case Some(param) => queryParams += "org.apache.sling.commons.fsclassloader" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogWebconsole match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.webconsole" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingDatasource match {
      case Some(param) => queryParams += "org.apache.sling.datasource" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingDiscoveryBase match {
      case Some(param) => queryParams += "org.apache.sling.discovery.base" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingDiscoveryOak match {
      case Some(param) => queryParams += "org.apache.sling.discovery.oak" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingDiscoverySupport match {
      case Some(param) => queryParams += "org.apache.sling.discovery.support" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingDistributionApi match {
      case Some(param) => queryParams += "org.apache.sling.distribution.api" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingDistributionCore match {
      case Some(param) => queryParams += "org.apache.sling.distribution.core" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingExtensionsWebconsolesecurityprovider match {
      case Some(param) => queryParams += "org.apache.sling.extensions.webconsolesecurityprovider" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingHcWebconsole match {
      case Some(param) => queryParams += "org.apache.sling.hc.webconsole" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingInstallerConsole match {
      case Some(param) => queryParams += "org.apache.sling.installer.console" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingInstallerProviderFile match {
      case Some(param) => queryParams += "org.apache.sling.installer.provider.file" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingInstallerProviderJcr match {
      case Some(param) => queryParams += "org.apache.sling.installer.provider.jcr" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingJcrDavex match {
      case Some(param) => queryParams += "org.apache.sling.jcr.davex" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingJcrResourcesecurity match {
      case Some(param) => queryParams += "org.apache.sling.jcr.resourcesecurity" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingJmxProvider match {
      case Some(param) => queryParams += "org.apache.sling.jmx.provider" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingLaunchpadInstaller match {
      case Some(param) => queryParams += "org.apache.sling.launchpad.installer" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingModelsImpl match {
      case Some(param) => queryParams += "org.apache.sling.models.impl" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingRepoinitParser match {
      case Some(param) => queryParams += "org.apache.sling.repoinit.parser" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingResourceInventory match {
      case Some(param) => queryParams += "org.apache.sling.resource.inventory" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingResourceresolver match {
      case Some(param) => queryParams += "org.apache.sling.resourceresolver" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingScriptingJavascript match {
      case Some(param) => queryParams += "org.apache.sling.scripting.javascript" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingScriptingJst match {
      case Some(param) => queryParams += "org.apache.sling.scripting.jst" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingScriptingSightlyJsProvider match {
      case Some(param) => queryParams += "org.apache.sling.scripting.sightly.js.provider" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingScriptingSightlyModelsProvider match {
      case Some(param) => queryParams += "org.apache.sling.scripting.sightly.models.provider" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingSecurity match {
      case Some(param) => queryParams += "org.apache.sling.security" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingServletsCompat match {
      case Some(param) => queryParams += "org.apache.sling.servlets.compat" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingServletsGet match {
      case Some(param) => queryParams += "org.apache.sling.servlets.get" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingStartupfilterDisabler match {
      case Some(param) => queryParams += "org.apache.sling.startupfilter.disabler" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingTracer match {
      case Some(param) => queryParams += "org.apache.sling.tracer" -> param.toString
      case _ => queryParams
    }
    weRetailClientAppCore match {
      case Some(param) => queryParams += "we.retail.client.app.core" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthCertImplClientCertAuthHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[String] = None,
    serviceRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo]): Future[ComAdobeGraniteAuthCertImplClientCertAuthHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.cert.impl.ClientCertAuthHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthIms(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    configid: Option[String] = None,
    scope: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthImsInfo]): Future[ComAdobeGraniteAuthImsInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.ims"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    configid match {
      case Some(param) => queryParams += "configid" -> param.toString
      case _ => queryParams
    }
    scope match {
      case Some(param) => queryParams += "scope" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtension(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthProviderId: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo]): Future[ComAdobeGraniteAuthImsImplExternalUserIdMappingProviderExtensionInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.ims.impl.ExternalUserIdMappingProviderExtension"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthProviderId match {
      case Some(param) => queryParams += "oauth.provider.id" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    authImsClientSecret: Option[String] = None,
    customizerType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo]): Future[ComAdobeGraniteAuthImsImplIMSAccessTokenRequestCustomizerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSAccessTokenRequestCustomizerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    authImsClientSecret match {
      case Some(param) => queryParams += "auth.ims.client.secret" -> param.toString
      case _ => queryParams
    }
    customizerType match {
      case Some(param) => queryParams += "customizer.type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthImsImplIMSInstanceCredentialsValidator(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthProviderId: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo]): Future[ComAdobeGraniteAuthImsImplIMSInstanceCredentialsValidatorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSInstanceCredentialsValidator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthProviderId match {
      case Some(param) => queryParams += "oauth.provider.id" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthImsImplIMSProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthProviderId: Option[String] = None,
    oauthProviderImsAuthorizationUrl: Option[String] = None,
    oauthProviderImsTokenUrl: Option[String] = None,
    oauthProviderImsProfileUrl: Option[String] = None,
    oauthProviderImsExtendedDetailsUrls: Option[List[String]] = None,
    oauthProviderImsValidateTokenUrl: Option[String] = None,
    oauthProviderImsSessionProperty: Option[String] = None,
    oauthProviderImsServiceTokenClientId: Option[String] = None,
    oauthProviderImsServiceTokenClientSecret: Option[String] = None,
    oauthProviderImsServiceToken: Option[String] = None,
    imsOrgRef: Option[String] = None,
    imsGroupMapping: Option[List[String]] = None,
    oauthProviderImsOnlyLicenseGroup: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthImsImplIMSProviderImplInfo]): Future[ComAdobeGraniteAuthImsImplIMSProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.ims.impl.IMSProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthProviderId match {
      case Some(param) => queryParams += "oauth.provider.id" -> param.toString
      case _ => queryParams
    }
    oauthProviderImsAuthorizationUrl match {
      case Some(param) => queryParams += "oauth.provider.ims.authorization.url" -> param.toString
      case _ => queryParams
    }
    oauthProviderImsTokenUrl match {
      case Some(param) => queryParams += "oauth.provider.ims.token.url" -> param.toString
      case _ => queryParams
    }
    oauthProviderImsProfileUrl match {
      case Some(param) => queryParams += "oauth.provider.ims.profile.url" -> param.toString
      case _ => queryParams
    }
    oauthProviderImsExtendedDetailsUrls match {
      case Some(param) => queryParams += "oauth.provider.ims.extended.details.urls" -> param.toString
      case _ => queryParams
    }
    oauthProviderImsValidateTokenUrl match {
      case Some(param) => queryParams += "oauth.provider.ims.validate.token.url" -> param.toString
      case _ => queryParams
    }
    oauthProviderImsSessionProperty match {
      case Some(param) => queryParams += "oauth.provider.ims.session.property" -> param.toString
      case _ => queryParams
    }
    oauthProviderImsServiceTokenClientId match {
      case Some(param) => queryParams += "oauth.provider.ims.service.token.client.id" -> param.toString
      case _ => queryParams
    }
    oauthProviderImsServiceTokenClientSecret match {
      case Some(param) => queryParams += "oauth.provider.ims.service.token.client.secret" -> param.toString
      case _ => queryParams
    }
    oauthProviderImsServiceToken match {
      case Some(param) => queryParams += "oauth.provider.ims.service.token" -> param.toString
      case _ => queryParams
    }
    imsOrgRef match {
      case Some(param) => queryParams += "ims.org.ref" -> param.toString
      case _ => queryParams
    }
    imsGroupMapping match {
      case Some(param) => queryParams += "ims.group.mapping" -> param.toString
      case _ => queryParams
    }
    oauthProviderImsOnlyLicenseGroup match {
      case Some(param) => queryParams += "oauth.provider.ims.only.license.group" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthImsImplImsConfigProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthConfigmanagerImsConfigid: Option[String] = None,
    imsOwningEntity: Option[String] = None,
    aemInstanceId: Option[String] = None,
    imsServiceCode: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo]): Future[ComAdobeGraniteAuthImsImplImsConfigProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.ims.impl.ImsConfigProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthConfigmanagerImsConfigid match {
      case Some(param) => queryParams += "oauth.configmanager.ims.configid" -> param.toString
      case _ => queryParams
    }
    imsOwningEntity match {
      case Some(param) => queryParams += "ims.owningEntity" -> param.toString
      case _ => queryParams
    }
    aemInstanceId match {
      case Some(param) => queryParams += "aem.instanceId" -> param.toString
      case _ => queryParams
    }
    imsServiceCode match {
      case Some(param) => queryParams += "ims.serviceCode" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthAccesstokenProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    authTokenProviderTitle: Option[String] = None,
    authTokenProviderDefaultClaims: Option[List[String]] = None,
    authTokenProviderEndpoint: Option[String] = None,
    authAccessTokenRequest: Option[String] = None,
    authTokenProviderKeypairAlias: Option[String] = None,
    authTokenProviderConnTimeout: Option[Integer] = None,
    authTokenProviderSoTimeout: Option[Integer] = None,
    authTokenProviderClientId: Option[String] = None,
    authTokenProviderScope: Option[String] = None,
    authTokenProviderReuseAccessToken: Option[Boolean] = None,
    authTokenProviderRelaxedSsl: Option[Boolean] = None,
    tokenRequestCustomizerType: Option[String] = None,
    authTokenValidatorType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthAccesstokenProviderInfo]): Future[ComAdobeGraniteAuthOauthAccesstokenProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.accesstoken.provider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    authTokenProviderTitle match {
      case Some(param) => queryParams += "auth.token.provider.title" -> param.toString
      case _ => queryParams
    }
    authTokenProviderDefaultClaims match {
      case Some(param) => queryParams += "auth.token.provider.default.claims" -> param.toString
      case _ => queryParams
    }
    authTokenProviderEndpoint match {
      case Some(param) => queryParams += "auth.token.provider.endpoint" -> param.toString
      case _ => queryParams
    }
    authAccessTokenRequest match {
      case Some(param) => queryParams += "auth.access.token.request" -> param.toString
      case _ => queryParams
    }
    authTokenProviderKeypairAlias match {
      case Some(param) => queryParams += "auth.token.provider.keypair.alias" -> param.toString
      case _ => queryParams
    }
    authTokenProviderConnTimeout match {
      case Some(param) => queryParams += "auth.token.provider.conn.timeout" -> param.toString
      case _ => queryParams
    }
    authTokenProviderSoTimeout match {
      case Some(param) => queryParams += "auth.token.provider.so.timeout" -> param.toString
      case _ => queryParams
    }
    authTokenProviderClientId match {
      case Some(param) => queryParams += "auth.token.provider.client.id" -> param.toString
      case _ => queryParams
    }
    authTokenProviderScope match {
      case Some(param) => queryParams += "auth.token.provider.scope" -> param.toString
      case _ => queryParams
    }
    authTokenProviderReuseAccessToken match {
      case Some(param) => queryParams += "auth.token.provider.reuse.access.token" -> param.toString
      case _ => queryParams
    }
    authTokenProviderRelaxedSsl match {
      case Some(param) => queryParams += "auth.token.provider.relaxed.ssl" -> param.toString
      case _ => queryParams
    }
    tokenRequestCustomizerType match {
      case Some(param) => queryParams += "token.request.customizer.type" -> param.toString
      case _ => queryParams
    }
    authTokenValidatorType match {
      case Some(param) => queryParams += "auth.token.validator.type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthImplBearerAuthenticationHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[String] = None,
    oauthClientIdsAllowed: Option[List[String]] = None,
    authBearerSyncIms: Option[Boolean] = None,
    authTokenRequestParameter: Option[String] = None,
    oauthBearerConfigid: Option[String] = None,
    oauthJwtSupport: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo]): Future[ComAdobeGraniteAuthOauthImplBearerAuthenticationHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.impl.BearerAuthenticationHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    oauthClientIdsAllowed match {
      case Some(param) => queryParams += "oauth.clientIds.allowed" -> param.toString
      case _ => queryParams
    }
    authBearerSyncIms match {
      case Some(param) => queryParams += "auth.bearer.sync.ims" -> param.toString
      case _ => queryParams
    }
    authTokenRequestParameter match {
      case Some(param) => queryParams += "auth.tokenRequestParameter" -> param.toString
      case _ => queryParams
    }
    oauthBearerConfigid match {
      case Some(param) => queryParams += "oauth.bearer.configid" -> param.toString
      case _ => queryParams
    }
    oauthJwtSupport match {
      case Some(param) => queryParams += "oauth.jwt.support" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthImplDefaultTokenValidatorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    authTokenValidatorType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo]): Future[ComAdobeGraniteAuthOauthImplDefaultTokenValidatorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.impl.DefaultTokenValidatorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    authTokenValidatorType match {
      case Some(param) => queryParams += "auth.token.validator.type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthImplFacebookProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthProviderId: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo]): Future[ComAdobeGraniteAuthOauthImplFacebookProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.impl.FacebookProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthProviderId match {
      case Some(param) => queryParams += "oauth.provider.id" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthImplGithubProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthProviderId: Option[String] = None,
    oauthProviderGithubAuthorizationUrl: Option[String] = None,
    oauthProviderGithubTokenUrl: Option[String] = None,
    oauthProviderGithubProfileUrl: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo]): Future[ComAdobeGraniteAuthOauthImplGithubProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.impl.GithubProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthProviderId match {
      case Some(param) => queryParams += "oauth.provider.id" -> param.toString
      case _ => queryParams
    }
    oauthProviderGithubAuthorizationUrl match {
      case Some(param) => queryParams += "oauth.provider.github.authorization.url" -> param.toString
      case _ => queryParams
    }
    oauthProviderGithubTokenUrl match {
      case Some(param) => queryParams += "oauth.provider.github.token.url" -> param.toString
      case _ => queryParams
    }
    oauthProviderGithubProfileUrl match {
      case Some(param) => queryParams += "oauth.provider.github.profile.url" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthImplGraniteProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthProviderId: Option[String] = None,
    oauthProviderGraniteAuthorizationUrl: Option[String] = None,
    oauthProviderGraniteTokenUrl: Option[String] = None,
    oauthProviderGraniteProfileUrl: Option[String] = None,
    oauthProviderGraniteExtendedDetailsUrls: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthImplGraniteProviderInfo]): Future[ComAdobeGraniteAuthOauthImplGraniteProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.impl.GraniteProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthProviderId match {
      case Some(param) => queryParams += "oauth.provider.id" -> param.toString
      case _ => queryParams
    }
    oauthProviderGraniteAuthorizationUrl match {
      case Some(param) => queryParams += "oauth.provider.granite.authorization.url" -> param.toString
      case _ => queryParams
    }
    oauthProviderGraniteTokenUrl match {
      case Some(param) => queryParams += "oauth.provider.granite.token.url" -> param.toString
      case _ => queryParams
    }
    oauthProviderGraniteProfileUrl match {
      case Some(param) => queryParams += "oauth.provider.granite.profile.url" -> param.toString
      case _ => queryParams
    }
    oauthProviderGraniteExtendedDetailsUrls match {
      case Some(param) => queryParams += "oauth.provider.granite.extended.details.urls" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthImplHelperProviderConfigManager(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthCookieLoginTimeout: Option[String] = None,
    oauthCookieMaxAge: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo]): Future[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.impl.helper.ProviderConfigManager"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthCookieLoginTimeout match {
      case Some(param) => queryParams += "oauth.cookie.login.timeout" -> param.toString
      case _ => queryParams
    }
    oauthCookieMaxAge match {
      case Some(param) => queryParams += "oauth.cookie.max.age" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternal(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthCookieLoginTimeout: Option[String] = None,
    oauthCookieMaxAge: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo]): Future[ComAdobeGraniteAuthOauthImplHelperProviderConfigManagerInternalInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.impl.helper.ProviderConfigManagerInternal"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthCookieLoginTimeout match {
      case Some(param) => queryParams += "oauth.cookie.login.timeout" -> param.toString
      case _ => queryParams
    }
    oauthCookieMaxAge match {
      case Some(param) => queryParams += "oauth.cookie.max.age" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthImplOAuthAuthenticationHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo]): Future[ComAdobeGraniteAuthOauthImplOAuthAuthenticationHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.impl.OAuthAuthenticationHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthImplTwitterProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthProviderId: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo]): Future[ComAdobeGraniteAuthOauthImplTwitterProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.impl.TwitterProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthProviderId match {
      case Some(param) => queryParams += "oauth.provider.id" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthOauthProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthConfigId: Option[String] = None,
    oauthClientId: Option[String] = None,
    oauthClientSecret: Option[String] = None,
    oauthScope: Option[List[String]] = None,
    oauthConfigProviderId: Option[String] = None,
    oauthCreateUsers: Option[Boolean] = None,
    oauthUseridProperty: Option[String] = None,
    forceStrictUsernameMatching: Option[Boolean] = None,
    oauthEncodeUserids: Option[Boolean] = None,
    oauthHashUserids: Option[Boolean] = None,
    oauthCallBackUrl: Option[String] = None,
    oauthAccessTokenPersist: Option[Boolean] = None,
    oauthAccessTokenPersistCookie: Option[Boolean] = None,
    oauthCsrfStateProtection: Option[Boolean] = None,
    oauthRedirectRequestParams: Option[Boolean] = None,
    oauthConfigSiblingsAllow: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthOauthProviderInfo]): Future[ComAdobeGraniteAuthOauthProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.oauth.provider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthConfigId match {
      case Some(param) => queryParams += "oauth.config.id" -> param.toString
      case _ => queryParams
    }
    oauthClientId match {
      case Some(param) => queryParams += "oauth.client.id" -> param.toString
      case _ => queryParams
    }
    oauthClientSecret match {
      case Some(param) => queryParams += "oauth.client.secret" -> param.toString
      case _ => queryParams
    }
    oauthScope match {
      case Some(param) => queryParams += "oauth.scope" -> param.toString
      case _ => queryParams
    }
    oauthConfigProviderId match {
      case Some(param) => queryParams += "oauth.config.provider.id" -> param.toString
      case _ => queryParams
    }
    oauthCreateUsers match {
      case Some(param) => queryParams += "oauth.create.users" -> param.toString
      case _ => queryParams
    }
    oauthUseridProperty match {
      case Some(param) => queryParams += "oauth.userid.property" -> param.toString
      case _ => queryParams
    }
    forceStrictUsernameMatching match {
      case Some(param) => queryParams += "force.strict.username.matching" -> param.toString
      case _ => queryParams
    }
    oauthEncodeUserids match {
      case Some(param) => queryParams += "oauth.encode.userids" -> param.toString
      case _ => queryParams
    }
    oauthHashUserids match {
      case Some(param) => queryParams += "oauth.hash.userids" -> param.toString
      case _ => queryParams
    }
    oauthCallBackUrl match {
      case Some(param) => queryParams += "oauth.callBackUrl" -> param.toString
      case _ => queryParams
    }
    oauthAccessTokenPersist match {
      case Some(param) => queryParams += "oauth.access.token.persist" -> param.toString
      case _ => queryParams
    }
    oauthAccessTokenPersistCookie match {
      case Some(param) => queryParams += "oauth.access.token.persist.cookie" -> param.toString
      case _ => queryParams
    }
    oauthCsrfStateProtection match {
      case Some(param) => queryParams += "oauth.csrf.state.protection" -> param.toString
      case _ => queryParams
    }
    oauthRedirectRequestParams match {
      case Some(param) => queryParams += "oauth.redirect.request.params" -> param.toString
      case _ => queryParams
    }
    oauthConfigSiblingsAllow match {
      case Some(param) => queryParams += "oauth.config.siblings.allow" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthRequirementImplDefaultRequirementHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    supportedPaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo]): Future[ComAdobeGraniteAuthRequirementImplDefaultRequirementHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.requirement.impl.DefaultRequirementHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    supportedPaths match {
      case Some(param) => queryParams += "supportedPaths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthSamlSamlAuthenticationHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    idpUrl: Option[String] = None,
    idpCertAlias: Option[String] = None,
    idpHttpRedirect: Option[Boolean] = None,
    serviceProviderEntityId: Option[String] = None,
    assertionConsumerServiceURL: Option[String] = None,
    spPrivateKeyAlias: Option[String] = None,
    keyStorePassword: Option[String] = None,
    defaultRedirectUrl: Option[String] = None,
    userIDAttribute: Option[String] = None,
    useEncryption: Option[Boolean] = None,
    createUser: Option[Boolean] = None,
    userIntermediatePath: Option[String] = None,
    addGroupMemberships: Option[Boolean] = None,
    groupMembershipAttribute: Option[String] = None,
    defaultGroups: Option[List[String]] = None,
    nameIdFormat: Option[String] = None,
    synchronizeAttributes: Option[List[String]] = None,
    handleLogout: Option[Boolean] = None,
    logoutUrl: Option[String] = None,
    clockTolerance: Option[Integer] = None,
    digestMethod: Option[String] = None,
    signatureMethod: Option[String] = None,
    identitySyncType: Option[String] = None,
    idpIdentifier: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo]): Future[ComAdobeGraniteAuthSamlSamlAuthenticationHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    idpUrl match {
      case Some(param) => queryParams += "idpUrl" -> param.toString
      case _ => queryParams
    }
    idpCertAlias match {
      case Some(param) => queryParams += "idpCertAlias" -> param.toString
      case _ => queryParams
    }
    idpHttpRedirect match {
      case Some(param) => queryParams += "idpHttpRedirect" -> param.toString
      case _ => queryParams
    }
    serviceProviderEntityId match {
      case Some(param) => queryParams += "serviceProviderEntityId" -> param.toString
      case _ => queryParams
    }
    assertionConsumerServiceURL match {
      case Some(param) => queryParams += "assertionConsumerServiceURL" -> param.toString
      case _ => queryParams
    }
    spPrivateKeyAlias match {
      case Some(param) => queryParams += "spPrivateKeyAlias" -> param.toString
      case _ => queryParams
    }
    keyStorePassword match {
      case Some(param) => queryParams += "keyStorePassword" -> param.toString
      case _ => queryParams
    }
    defaultRedirectUrl match {
      case Some(param) => queryParams += "defaultRedirectUrl" -> param.toString
      case _ => queryParams
    }
    userIDAttribute match {
      case Some(param) => queryParams += "userIDAttribute" -> param.toString
      case _ => queryParams
    }
    useEncryption match {
      case Some(param) => queryParams += "useEncryption" -> param.toString
      case _ => queryParams
    }
    createUser match {
      case Some(param) => queryParams += "createUser" -> param.toString
      case _ => queryParams
    }
    userIntermediatePath match {
      case Some(param) => queryParams += "userIntermediatePath" -> param.toString
      case _ => queryParams
    }
    addGroupMemberships match {
      case Some(param) => queryParams += "addGroupMemberships" -> param.toString
      case _ => queryParams
    }
    groupMembershipAttribute match {
      case Some(param) => queryParams += "groupMembershipAttribute" -> param.toString
      case _ => queryParams
    }
    defaultGroups match {
      case Some(param) => queryParams += "defaultGroups" -> param.toString
      case _ => queryParams
    }
    nameIdFormat match {
      case Some(param) => queryParams += "nameIdFormat" -> param.toString
      case _ => queryParams
    }
    synchronizeAttributes match {
      case Some(param) => queryParams += "synchronizeAttributes" -> param.toString
      case _ => queryParams
    }
    handleLogout match {
      case Some(param) => queryParams += "handleLogout" -> param.toString
      case _ => queryParams
    }
    logoutUrl match {
      case Some(param) => queryParams += "logoutUrl" -> param.toString
      case _ => queryParams
    }
    clockTolerance match {
      case Some(param) => queryParams += "clockTolerance" -> param.toString
      case _ => queryParams
    }
    digestMethod match {
      case Some(param) => queryParams += "digestMethod" -> param.toString
      case _ => queryParams
    }
    signatureMethod match {
      case Some(param) => queryParams += "signatureMethod" -> param.toString
      case _ => queryParams
    }
    identitySyncType match {
      case Some(param) => queryParams += "identitySyncType" -> param.toString
      case _ => queryParams
    }
    idpIdentifier match {
      case Some(param) => queryParams += "idpIdentifier" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteAuthSsoImplSsoAuthenticationHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[String] = None,
    serviceRanking: Option[Integer] = None,
    jaasControlFlag: Option[String] = None,
    jaasRealmName: Option[String] = None,
    jaasRanking: Option[Integer] = None,
    headers: Option[List[String]] = None,
    cookies: Option[List[String]] = None,
    parameters: Option[List[String]] = None,
    usermap: Option[List[String]] = None,
    format: Option[String] = None,
    trustedCredentialsAttribute: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo]): Future[ComAdobeGraniteAuthSsoImplSsoAuthenticationHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.auth.sso.impl.SsoAuthenticationHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    jaasControlFlag match {
      case Some(param) => queryParams += "jaas.controlFlag" -> param.toString
      case _ => queryParams
    }
    jaasRealmName match {
      case Some(param) => queryParams += "jaas.realmName" -> param.toString
      case _ => queryParams
    }
    jaasRanking match {
      case Some(param) => queryParams += "jaas.ranking" -> param.toString
      case _ => queryParams
    }
    headers match {
      case Some(param) => queryParams += "headers" -> param.toString
      case _ => queryParams
    }
    cookies match {
      case Some(param) => queryParams += "cookies" -> param.toString
      case _ => queryParams
    }
    parameters match {
      case Some(param) => queryParams += "parameters" -> param.toString
      case _ => queryParams
    }
    usermap match {
      case Some(param) => queryParams += "usermap" -> param.toString
      case _ => queryParams
    }
    format match {
      case Some(param) => queryParams += "format" -> param.toString
      case _ => queryParams
    }
    trustedCredentialsAttribute match {
      case Some(param) => queryParams += "trustedCredentialsAttribute" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteBundlesHcImplCodeCacheHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None,
    minimumCodeCacheSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo]): Future[ComAdobeGraniteBundlesHcImplCodeCacheHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.bundles.hc.impl.CodeCacheHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    minimumCodeCacheSize match {
      case Some(param) => queryParams += "minimum.code.cache.size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo]): Future[ComAdobeGraniteBundlesHcImplCrxdeSupportBundleHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.bundles.hc.impl.CrxdeSupportBundleHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteBundlesHcImplDavExBundleHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo]): Future[ComAdobeGraniteBundlesHcImplDavExBundleHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.bundles.hc.impl.DavExBundleHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteBundlesHcImplInactiveBundlesHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None,
    ignoredBundles: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo]): Future[ComAdobeGraniteBundlesHcImplInactiveBundlesHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.bundles.hc.impl.InactiveBundlesHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    ignoredBundles match {
      case Some(param) => queryParams += "ignored.bundles" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteBundlesHcImplJobsHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None,
    maxQueuedJobs: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo]): Future[ComAdobeGraniteBundlesHcImplJobsHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.bundles.hc.impl.JobsHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    maxQueuedJobs match {
      case Some(param) => queryParams += "max.queued.jobs" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteBundlesHcImplSlingGetServletHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo]): Future[ComAdobeGraniteBundlesHcImplSlingGetServletHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingGetServletHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo]): Future[ComAdobeGraniteBundlesHcImplSlingJavaScriptHandlerHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingJavaScriptHandlerHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo]): Future[ComAdobeGraniteBundlesHcImplSlingJspScriptHandlerHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingJspScriptHandlerHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo]): Future[ComAdobeGraniteBundlesHcImplSlingReferrerFilterHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.bundles.hc.impl.SlingReferrerFilterHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteBundlesHcImplWebDavBundleHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo]): Future[ComAdobeGraniteBundlesHcImplWebDavBundleHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.bundles.hc.impl.WebDavBundleHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteCommentsInternalCommentReplicationContentFilterFac(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    replicateCommentResourceTypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo]): Future[ComAdobeGraniteCommentsInternalCommentReplicationContentFilterFacInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.comments.internal.CommentReplicationContentFilterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    replicateCommentResourceTypes match {
      case Some(param) => queryParams += "replicate.comment.resourceTypes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteCompatrouterImplCompatSwitchingServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    compatgroups: Option[List[String]] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo]): Future[ComAdobeGraniteCompatrouterImplCompatSwitchingServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.compatrouter.impl.CompatSwitchingServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    compatgroups match {
      case Some(param) => queryParams += "compatgroups" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteCompatrouterImplRoutingConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    id: Option[String] = None,
    compatPath: Option[String] = None,
    newPath: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteCompatrouterImplRoutingConfigInfo]): Future[ComAdobeGraniteCompatrouterImplRoutingConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.compatrouter.impl.RoutingConfig"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    id match {
      case Some(param) => queryParams += "id" -> param.toString
      case _ => queryParams
    }
    compatPath match {
      case Some(param) => queryParams += "compatPath" -> param.toString
      case _ => queryParams
    }
    newPath match {
      case Some(param) => queryParams += "newPath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteCompatrouterImplSwitchMappingConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    group: Option[String] = None,
    ids: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo]): Future[ComAdobeGraniteCompatrouterImplSwitchMappingConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.compatrouter.impl.SwitchMappingConfig"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    group match {
      case Some(param) => queryParams += "group" -> param.toString
      case _ => queryParams
    }
    ids match {
      case Some(param) => queryParams += "ids" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolving(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    fallbackPaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo]): Future[ComAdobeGraniteConfImplRuntimeAwareConfigurationResourceResolvingInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.conf.impl.RuntimeAwareConfigurationResourceResolvingStrategy"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    fallbackPaths match {
      case Some(param) => queryParams += "fallbackPaths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteContexthubImplContextHubImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeGraniteContexthubSilentMode: Option[Boolean] = None,
    comAdobeGraniteContexthubShowUi: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteContexthubImplContextHubImplInfo]): Future[ComAdobeGraniteContexthubImplContextHubImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.contexthub.impl.ContextHubImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteContexthubSilentMode match {
      case Some(param) => queryParams += "com.adobe.granite.contexthub.silent_mode" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteContexthubShowUi match {
      case Some(param) => queryParams += "com.adobe.granite.contexthub.show_ui" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteCorsImplCORSPolicyImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    alloworigin: Option[List[String]] = None,
    alloworiginregexp: Option[List[String]] = None,
    allowedpaths: Option[List[String]] = None,
    exposedheaders: Option[List[String]] = None,
    maxage: Option[Integer] = None,
    supportedheaders: Option[List[String]] = None,
    supportedmethods: Option[List[String]] = None,
    supportscredentials: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteCorsImplCORSPolicyImplInfo]): Future[ComAdobeGraniteCorsImplCORSPolicyImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.cors.impl.CORSPolicyImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    alloworigin match {
      case Some(param) => queryParams += "alloworigin" -> param.toString
      case _ => queryParams
    }
    alloworiginregexp match {
      case Some(param) => queryParams += "alloworiginregexp" -> param.toString
      case _ => queryParams
    }
    allowedpaths match {
      case Some(param) => queryParams += "allowedpaths" -> param.toString
      case _ => queryParams
    }
    exposedheaders match {
      case Some(param) => queryParams += "exposedheaders" -> param.toString
      case _ => queryParams
    }
    maxage match {
      case Some(param) => queryParams += "maxage" -> param.toString
      case _ => queryParams
    }
    supportedheaders match {
      case Some(param) => queryParams += "supportedheaders" -> param.toString
      case _ => queryParams
    }
    supportedmethods match {
      case Some(param) => queryParams += "supportedmethods" -> param.toString
      case _ => queryParams
    }
    supportscredentials match {
      case Some(param) => queryParams += "supportscredentials" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteCsrfImplCSRFFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    filterMethods: Option[List[String]] = None,
    filterEnableSafeUserAgents: Option[Boolean] = None,
    filterSafeUserAgents: Option[List[String]] = None,
    filterExcludedPaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteCsrfImplCSRFFilterInfo]): Future[ComAdobeGraniteCsrfImplCSRFFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.csrf.impl.CSRFFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    filterMethods match {
      case Some(param) => queryParams += "filter.methods" -> param.toString
      case _ => queryParams
    }
    filterEnableSafeUserAgents match {
      case Some(param) => queryParams += "filter.enable.safe.user.agents" -> param.toString
      case _ => queryParams
    }
    filterSafeUserAgents match {
      case Some(param) => queryParams += "filter.safe.user.agents" -> param.toString
      case _ => queryParams
    }
    filterExcludedPaths match {
      case Some(param) => queryParams += "filter.excluded.paths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteCsrfImplCSRFServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    csrfTokenExpiresIn: Option[Integer] = None,
    slingAuthRequirements: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteCsrfImplCSRFServletInfo]): Future[ComAdobeGraniteCsrfImplCSRFServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.csrf.impl.CSRFServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    csrfTokenExpiresIn match {
      case Some(param) => queryParams += "csrf.token.expires.in" -> param.toString
      case _ => queryParams
    }
    slingAuthRequirements match {
      case Some(param) => queryParams += "sling.auth.requirements" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteDistributionCoreImplCryptoDistributionTransportSe(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    username: Option[String] = None,
    encryptedPassword: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo]): Future[ComAdobeGraniteDistributionCoreImplCryptoDistributionTransportSeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.distribution.core.impl.CryptoDistributionTransportSecretProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    username match {
      case Some(param) => queryParams += "username" -> param.toString
      case _ => queryParams
    }
    encryptedPassword match {
      case Some(param) => queryParams += "encryptedPassword" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteDistributionCoreImplDiffDiffChangesObserver(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    agentName: Option[String] = None,
    diffPath: Option[String] = None,
    observedPath: Option[String] = None,
    serviceName: Option[String] = None,
    propertyNames: Option[String] = None,
    distributionDelay: Option[Integer] = None,
    serviceUserTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo]): Future[ComAdobeGraniteDistributionCoreImplDiffDiffChangesObserverInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.distribution.core.impl.diff.DiffChangesObserver"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    agentName match {
      case Some(param) => queryParams += "agentName" -> param.toString
      case _ => queryParams
    }
    diffPath match {
      case Some(param) => queryParams += "diffPath" -> param.toString
      case _ => queryParams
    }
    observedPath match {
      case Some(param) => queryParams += "observedPath" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }
    propertyNames match {
      case Some(param) => queryParams += "propertyNames" -> param.toString
      case _ => queryParams
    }
    distributionDelay match {
      case Some(param) => queryParams += "distributionDelay" -> param.toString
      case _ => queryParams
    }
    serviceUserTarget match {
      case Some(param) => queryParams += "serviceUser.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteDistributionCoreImplDiffDiffEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    diffPath: Option[String] = None,
    serviceName: Option[String] = None,
    serviceUserTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo]): Future[ComAdobeGraniteDistributionCoreImplDiffDiffEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.distribution.core.impl.diff.DiffEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    diffPath match {
      case Some(param) => queryParams += "diffPath" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }
    serviceUserTarget match {
      case Some(param) => queryParams += "serviceUser.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteDistributionCoreImplDistributionToReplicationEven(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    importerName: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo]): Future[ComAdobeGraniteDistributionCoreImplDistributionToReplicationEvenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.distribution.core.impl.DistributionToReplicationEventTransformer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    importerName match {
      case Some(param) => queryParams += "importer.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteDistributionCoreImplReplicationAdaptersReplicat(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    providerName: Option[String] = None,
    forwardRequests: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo]): Future[ComAdobeGraniteDistributionCoreImplReplicationAdaptersReplicatInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.distribution.core.impl.replication.adapters.ReplicationAgentProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    providerName match {
      case Some(param) => queryParams += "providerName" -> param.toString
      case _ => queryParams
    }
    forwardRequests match {
      case Some(param) => queryParams += "forward.requests" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteDistributionCoreImplReplicationDistributionTrans(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    forwardRequests: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo]): Future[ComAdobeGraniteDistributionCoreImplReplicationDistributionTransInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.distribution.core.impl.replication.DistributionTransportHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    forwardRequests match {
      case Some(param) => queryParams += "forward.requests" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteDistributionCoreImplTransportAccessTokenDistribu(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    serviceName: Option[String] = None,
    userId: Option[String] = None,
    accessTokenProviderTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo]): Future[ComAdobeGraniteDistributionCoreImplTransportAccessTokenDistribuInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.distribution.core.impl.transport.AccessTokenDistributionTransportSecretProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }
    userId match {
      case Some(param) => queryParams += "userId" -> param.toString
      case _ => queryParams
    }
    accessTokenProviderTarget match {
      case Some(param) => queryParams += "accessTokenProvider.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteFragsImplCheckHttpHeaderFlag(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    featureName: Option[String] = None,
    featureDescription: Option[String] = None,
    httpHeaderName: Option[String] = None,
    httpHeaderValuepattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo]): Future[ComAdobeGraniteFragsImplCheckHttpHeaderFlagInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.frags.impl.CheckHttpHeaderFlag"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    featureName match {
      case Some(param) => queryParams += "feature.name" -> param.toString
      case _ => queryParams
    }
    featureDescription match {
      case Some(param) => queryParams += "feature.description" -> param.toString
      case _ => queryParams
    }
    httpHeaderName match {
      case Some(param) => queryParams += "http.header.name" -> param.toString
      case _ => queryParams
    }
    httpHeaderValuepattern match {
      case Some(param) => queryParams += "http.header.valuepattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteFragsImplRandomFeature(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    featureName: Option[String] = None,
    featureDescription: Option[String] = None,
    activePercentage: Option[String] = None,
    cookieName: Option[String] = None,
    cookieMaxAge: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteFragsImplRandomFeatureInfo]): Future[ComAdobeGraniteFragsImplRandomFeatureInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.frags.impl.RandomFeature"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    featureName match {
      case Some(param) => queryParams += "feature.name" -> param.toString
      case _ => queryParams
    }
    featureDescription match {
      case Some(param) => queryParams += "feature.description" -> param.toString
      case _ => queryParams
    }
    activePercentage match {
      case Some(param) => queryParams += "active.percentage" -> param.toString
      case _ => queryParams
    }
    cookieName match {
      case Some(param) => queryParams += "cookie.name" -> param.toString
      case _ => queryParams
    }
    cookieMaxAge match {
      case Some(param) => queryParams += "cookie.maxAge" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteHttpcacheFileFileCacheStore(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeGraniteHttpcacheFileDocumentRoot: Option[String] = None,
    comAdobeGraniteHttpcacheFileIncludeHost: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo]): Future[ComAdobeGraniteHttpcacheFileFileCacheStoreInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.httpcache.file.FileCacheStore"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteHttpcacheFileDocumentRoot match {
      case Some(param) => queryParams += "com.adobe.granite.httpcache.file.documentRoot" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteHttpcacheFileIncludeHost match {
      case Some(param) => queryParams += "com.adobe.granite.httpcache.file.includeHost" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteHttpcacheImplOuterCacheFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeGraniteHttpcacheUrlPaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo]): Future[ComAdobeGraniteHttpcacheImplOuterCacheFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.httpcache.impl.OuterCacheFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteHttpcacheUrlPaths match {
      case Some(param) => queryParams += "com.adobe.granite.httpcache.url.paths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteI18nImplBundlePseudoTranslations(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    pseudoPatterns: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo]): Future[ComAdobeGraniteI18nImplBundlePseudoTranslationsInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.i18n.impl.bundle.PseudoTranslations"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    pseudoPatterns match {
      case Some(param) => queryParams += "pseudo.patterns" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteI18nImplPreferencesLocaleResolverService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    securityPreferencesName: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo]): Future[ComAdobeGraniteI18nImplPreferencesLocaleResolverServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.i18n.impl.PreferencesLocaleResolverService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    securityPreferencesName match {
      case Some(param) => queryParams += "security.preferences.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteInfocollectorInfoCollector(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    graniteInfocollectorIncludeThreadDumps: Option[Boolean] = None,
    graniteInfocollectorIncludeHeapDump: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteInfocollectorInfoCollectorInfo]): Future[ComAdobeGraniteInfocollectorInfoCollectorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.infocollector.InfoCollector"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    graniteInfocollectorIncludeThreadDumps match {
      case Some(param) => queryParams += "granite.infocollector.includeThreadDumps" -> param.toString
      case _ => queryParams
    }
    graniteInfocollectorIncludeHeapDump match {
      case Some(param) => queryParams += "granite.infocollector.includeHeapDump" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteJettySslInternalGraniteSslConnectorFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comAdobeGraniteJettySslPort: Option[Integer] = None,
    comAdobeGraniteJettySslKeystoreUser: Option[String] = None,
    comAdobeGraniteJettySslKeystorePassword: Option[String] = None,
    comAdobeGraniteJettySslCiphersuitesExcluded: Option[List[String]] = None,
    comAdobeGraniteJettySslCiphersuitesIncluded: Option[List[String]] = None,
    comAdobeGraniteJettySslClientCertificate: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo]): Future[ComAdobeGraniteJettySslInternalGraniteSslConnectorFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.jetty.ssl.internal.GraniteSslConnectorFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteJettySslPort match {
      case Some(param) => queryParams += "com.adobe.granite.jetty.ssl.port" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteJettySslKeystoreUser match {
      case Some(param) => queryParams += "com.adobe.granite.jetty.ssl.keystore.user" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteJettySslKeystorePassword match {
      case Some(param) => queryParams += "com.adobe.granite.jetty.ssl.keystore.password" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteJettySslCiphersuitesExcluded match {
      case Some(param) => queryParams += "com.adobe.granite.jetty.ssl.ciphersuites.excluded" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteJettySslCiphersuitesIncluded match {
      case Some(param) => queryParams += "com.adobe.granite.jetty.ssl.ciphersuites.included" -> param.toString
      case _ => queryParams
    }
    comAdobeGraniteJettySslClientCertificate match {
      case Some(param) => queryParams += "com.adobe.granite.jetty.ssl.client.certificate" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteLicenseImplLicenseCheckFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    checkInternval: Option[Integer] = None,
    excludeIds: Option[List[String]] = None,
    encryptPing: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo]): Future[ComAdobeGraniteLicenseImplLicenseCheckFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.license.impl.LicenseCheckFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    checkInternval match {
      case Some(param) => queryParams += "checkInternval" -> param.toString
      case _ => queryParams
    }
    excludeIds match {
      case Some(param) => queryParams += "excludeIds" -> param.toString
      case _ => queryParams
    }
    encryptPing match {
      case Some(param) => queryParams += "encryptPing" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteLoggingImplLogAnalyserImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    messagesQueueSize: Option[Integer] = None,
    loggerConfig: Option[List[String]] = None,
    messagesSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteLoggingImplLogAnalyserImplInfo]): Future[ComAdobeGraniteLoggingImplLogAnalyserImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.logging.impl.LogAnalyserImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    messagesQueueSize match {
      case Some(param) => queryParams += "messages.queue.size" -> param.toString
      case _ => queryParams
    }
    loggerConfig match {
      case Some(param) => queryParams += "logger.config" -> param.toString
      case _ => queryParams
    }
    messagesSize match {
      case Some(param) => queryParams += "messages.size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteLoggingImplLogErrorHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo]): Future[ComAdobeGraniteLoggingImplLogErrorHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.logging.impl.LogErrorHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    graniteMaintenanceMandatory: Option[Boolean] = None,
    jobTopics: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo]): Future[ComAdobeGraniteMaintenanceCrxImplDataStoreGarbageCollectionTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.DataStoreGarbageCollectionTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    graniteMaintenanceMandatory match {
      case Some(param) => queryParams += "granite.maintenance.mandatory" -> param.toString
      case _ => queryParams
    }
    jobTopics match {
      case Some(param) => queryParams += "job.topics" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jobTopics: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo]): Future[ComAdobeGraniteMaintenanceCrxImplLuceneBinariesCleanupTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.LuceneBinariesCleanupTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jobTopics match {
      case Some(param) => queryParams += "job.topics" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteMaintenanceCrxImplRevisionCleanupTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fullGcDays: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo]): Future[ComAdobeGraniteMaintenanceCrxImplRevisionCleanupTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.maintenance.crx.impl.RevisionCleanupTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fullGcDays match {
      case Some(param) => queryParams += "full.gc.days" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteMonitoringImplScriptConfigImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    scriptFilename: Option[String] = None,
    scriptDisplay: Option[String] = None,
    scriptPath: Option[String] = None,
    scriptPlatform: Option[List[String]] = None,
    interval: Option[Integer] = None,
    jmxdomain: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteMonitoringImplScriptConfigImplInfo]): Future[ComAdobeGraniteMonitoringImplScriptConfigImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.monitoring.impl.ScriptConfigImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    scriptFilename match {
      case Some(param) => queryParams += "script.filename" -> param.toString
      case _ => queryParams
    }
    scriptDisplay match {
      case Some(param) => queryParams += "script.display" -> param.toString
      case _ => queryParams
    }
    scriptPath match {
      case Some(param) => queryParams += "script.path" -> param.toString
      case _ => queryParams
    }
    scriptPlatform match {
      case Some(param) => queryParams += "script.platform" -> param.toString
      case _ => queryParams
    }
    interval match {
      case Some(param) => queryParams += "interval" -> param.toString
      case _ => queryParams
    }
    jmxdomain match {
      case Some(param) => queryParams += "jmxdomain" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHan(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[String] = None,
    jaasControlFlag: Option[String] = None,
    jaasRealmName: Option[String] = None,
    jaasRanking: Option[Integer] = None,
    oauthOfflineValidation: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo]): Future[ComAdobeGraniteOauthServerAuthImplOAuth2ServerAuthenticationHanInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.oauth.server.auth.impl.OAuth2ServerAuthenticationHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    jaasControlFlag match {
      case Some(param) => queryParams += "jaas.controlFlag" -> param.toString
      case _ => queryParams
    }
    jaasRealmName match {
      case Some(param) => queryParams += "jaas.realmName" -> param.toString
      case _ => queryParams
    }
    jaasRanking match {
      case Some(param) => queryParams += "jaas.ranking" -> param.toString
      case _ => queryParams
    }
    oauthOfflineValidation match {
      case Some(param) => queryParams += "oauth.offline.validation" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOauthServerImplAccessTokenCleanupTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo]): Future[ComAdobeGraniteOauthServerImplAccessTokenCleanupTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.oauth.server.impl.AccessTokenCleanupTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOauthServerImplOAuth2ClientRevocationServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthClientRevocationActive: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo]): Future[ComAdobeGraniteOauthServerImplOAuth2ClientRevocationServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2ClientRevocationServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthClientRevocationActive match {
      case Some(param) => queryParams += "oauth.client.revocation.active" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOauthServerImplOAuth2RevocationEndpointServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletPaths: Option[String] = None,
    oauthRevocationActive: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo]): Future[ComAdobeGraniteOauthServerImplOAuth2RevocationEndpointServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2RevocationEndpointServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletPaths match {
      case Some(param) => queryParams += "sling.servlet.paths" -> param.toString
      case _ => queryParams
    }
    oauthRevocationActive match {
      case Some(param) => queryParams += "oauth.revocation.active" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOauthServerImplOAuth2TokenEndpointServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthIssuer: Option[String] = None,
    oauthAccessTokenExpiresIn: Option[String] = None,
    osgiHttpWhiteboardServletPattern: Option[String] = None,
    osgiHttpWhiteboardContextSelect: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo]): Future[ComAdobeGraniteOauthServerImplOAuth2TokenEndpointServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2TokenEndpointServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthIssuer match {
      case Some(param) => queryParams += "oauth.issuer" -> param.toString
      case _ => queryParams
    }
    oauthAccessTokenExpiresIn match {
      case Some(param) => queryParams += "oauth.access.token.expires.in" -> param.toString
      case _ => queryParams
    }
    osgiHttpWhiteboardServletPattern match {
      case Some(param) => queryParams += "osgi.http.whiteboard.servlet.pattern" -> param.toString
      case _ => queryParams
    }
    osgiHttpWhiteboardContextSelect match {
      case Some(param) => queryParams += "osgi.http.whiteboard.context.select" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOauthServerImplOAuth2TokenRevocationServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    oauthTokenRevocationActive: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo]): Future[ComAdobeGraniteOauthServerImplOAuth2TokenRevocationServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.oauth.server.impl.OAuth2TokenRevocationServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    oauthTokenRevocationActive match {
      case Some(param) => queryParams += "oauth.token.revocation.active" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOffloadingImplOffloadingConfigurator(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    offloadingTransporter: Option[String] = None,
    offloadingCleanupPayload: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo]): Future[ComAdobeGraniteOffloadingImplOffloadingConfiguratorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingConfigurator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    offloadingTransporter match {
      case Some(param) => queryParams += "offloading.transporter" -> param.toString
      case _ => queryParams
    }
    offloadingCleanupPayload match {
      case Some(param) => queryParams += "offloading.cleanup.payload" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOffloadingImplOffloadingJobCloner(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    offloadingJobclonerEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo]): Future[ComAdobeGraniteOffloadingImplOffloadingJobClonerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingJobCloner"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    offloadingJobclonerEnabled match {
      case Some(param) => queryParams += "offloading.jobcloner.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOffloadingImplOffloadingJobOffloader(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    offloadingOffloaderEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo]): Future[ComAdobeGraniteOffloadingImplOffloadingJobOffloaderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.offloading.impl.OffloadingJobOffloader"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    offloadingOffloaderEnabled match {
      case Some(param) => queryParams += "offloading.offloader.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOffloadingImplTransporterOffloadingAgentManager(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    offloadingAgentmanagerEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo]): Future[ComAdobeGraniteOffloadingImplTransporterOffloadingAgentManagerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.offloading.impl.transporter.OffloadingAgentManager"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    offloadingAgentmanagerEnabled match {
      case Some(param) => queryParams += "offloading.agentmanager.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspo(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    defaultTransportAgentToWorkerPrefix: Option[String] = None,
    defaultTransportAgentToMasterPrefix: Option[String] = None,
    defaultTransportInputPackage: Option[String] = None,
    defaultTransportOutputPackage: Option[String] = None,
    defaultTransportReplicationSynchronous: Option[Boolean] = None,
    defaultTransportContentpackage: Option[Boolean] = None,
    offloadingTransporterDefaultEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo]): Future[ComAdobeGraniteOffloadingImplTransporterOffloadingDefaultTranspoInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.offloading.impl.transporter.OffloadingDefaultTransporter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    defaultTransportAgentToWorkerPrefix match {
      case Some(param) => queryParams += "default.transport.agent-to-worker.prefix" -> param.toString
      case _ => queryParams
    }
    defaultTransportAgentToMasterPrefix match {
      case Some(param) => queryParams += "default.transport.agent-to-master.prefix" -> param.toString
      case _ => queryParams
    }
    defaultTransportInputPackage match {
      case Some(param) => queryParams += "default.transport.input.package" -> param.toString
      case _ => queryParams
    }
    defaultTransportOutputPackage match {
      case Some(param) => queryParams += "default.transport.output.package" -> param.toString
      case _ => queryParams
    }
    defaultTransportReplicationSynchronous match {
      case Some(param) => queryParams += "default.transport.replication.synchronous" -> param.toString
      case _ => queryParams
    }
    defaultTransportContentpackage match {
      case Some(param) => queryParams += "default.transport.contentpackage" -> param.toString
      case _ => queryParams
    }
    offloadingTransporterDefaultEnabled match {
      case Some(param) => queryParams += "offloading.transporter.default.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOmnisearchImplCoreOmniSearchServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    omnisearchSuggestionRequiretextMin: Option[Integer] = None,
    omnisearchSuggestionSpellcheckRequire: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo]): Future[ComAdobeGraniteOmnisearchImplCoreOmniSearchServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.omnisearch.impl.core.OmniSearchServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    omnisearchSuggestionRequiretextMin match {
      case Some(param) => queryParams += "omnisearch.suggestion.requiretext.min" -> param.toString
      case _ => queryParams
    }
    omnisearchSuggestionSpellcheckRequire match {
      case Some(param) => queryParams += "omnisearch.suggestion.spellcheck.require" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteOptoutImplOptOutServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    optoutCookies: Option[List[String]] = None,
    optoutHeaders: Option[List[String]] = None,
    optoutWhitelistCookies: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteOptoutImplOptOutServiceImplInfo]): Future[ComAdobeGraniteOptoutImplOptOutServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.optout.impl.OptOutServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    optoutCookies match {
      case Some(param) => queryParams += "optout.cookies" -> param.toString
      case _ => queryParams
    }
    optoutHeaders match {
      case Some(param) => queryParams += "optout.headers" -> param.toString
      case _ => queryParams
    }
    optoutWhitelistCookies match {
      case Some(param) => queryParams += "optout.whitelist.cookies" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteQueriesImplHcAsyncIndexHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    indexingCriticalThreshold: Option[Integer] = None,
    indexingWarnThreshold: Option[Integer] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo]): Future[ComAdobeGraniteQueriesImplHcAsyncIndexHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.queries.impl.hc.AsyncIndexHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    indexingCriticalThreshold match {
      case Some(param) => queryParams += "indexing.critical.threshold" -> param.toString
      case _ => queryParams
    }
    indexingWarnThreshold match {
      case Some(param) => queryParams += "indexing.warn.threshold" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteQueriesImplHcLargeIndexHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    largeIndexCriticalThreshold: Option[Integer] = None,
    largeIndexWarnThreshold: Option[Integer] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo]): Future[ComAdobeGraniteQueriesImplHcLargeIndexHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.queries.impl.hc.LargeIndexHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    largeIndexCriticalThreshold match {
      case Some(param) => queryParams += "large.index.critical.threshold" -> param.toString
      case _ => queryParams
    }
    largeIndexWarnThreshold match {
      case Some(param) => queryParams += "large.index.warn.threshold" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteQueriesImplHcQueriesStatusHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo]): Future[ComAdobeGraniteQueriesImplHcQueriesStatusHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueriesStatusHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteQueriesImplHcQueryHealthCheckMetrics(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    getPeriod: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo]): Future[ComAdobeGraniteQueriesImplHcQueryHealthCheckMetricsInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueryHealthCheckMetrics"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    getPeriod match {
      case Some(param) => queryParams += "getPeriod" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteQueriesImplHcQueryLimitsHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo]): Future[ComAdobeGraniteQueriesImplHcQueryLimitsHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.queries.impl.hc.QueryLimitsHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteReplicationHcImplReplicationQueueHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    numberOfRetriesAllowed: Option[Integer] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo]): Future[ComAdobeGraniteReplicationHcImplReplicationQueueHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.replication.hc.impl.ReplicationQueueHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    numberOfRetriesAllowed match {
      case Some(param) => queryParams += "number.of.retries.allowed" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteReplicationHcImplReplicationTransportUsersHealthC(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo]): Future[ComAdobeGraniteReplicationHcImplReplicationTransportUsersHealthCInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.replication.hc.impl.ReplicationTransportUsersHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo]): Future[ComAdobeGraniteRepositoryHcImplAuthorizableNodeNameHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.repository.hc.impl.AuthorizableNodeNameHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthC(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None,
    excludeSearchPath: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo]): Future[ComAdobeGraniteRepositoryHcImplContentSlingSlingContentHealthCInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.repository.hc.impl.content.sling.SlingContentHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    excludeSearchPath match {
      case Some(param) => queryParams += "exclude.search.path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRepositoryHcImplContinuousRGCHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo]): Future[ComAdobeGraniteRepositoryHcImplContinuousRGCHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.repository.hc.impl.ContinuousRGCHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthChe(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo]): Future[ComAdobeGraniteRepositoryHcImplDefaultAccessUserProfileHealthCheInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.repository.hc.impl.DefaultAccessUserProfileHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None,
    accountLogins: Option[List[String]] = None,
    consoleLogins: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo]): Future[ComAdobeGraniteRepositoryHcImplDefaultLoginsHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.repository.hc.impl.DefaultLoginsHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    accountLogins match {
      case Some(param) => queryParams += "account.logins" -> param.toString
      case _ => queryParams
    }
    consoleLogins match {
      case Some(param) => queryParams += "console.logins" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRepositoryHcImplDiskSpaceHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None,
    diskSpaceWarnThreshold: Option[Integer] = None,
    diskSpaceErrorThreshold: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo]): Future[ComAdobeGraniteRepositoryHcImplDiskSpaceHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.repository.hc.impl.DiskSpaceHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    diskSpaceWarnThreshold match {
      case Some(param) => queryParams += "disk.space.warn.threshold" -> param.toString
      case _ => queryParams
    }
    diskSpaceErrorThreshold match {
      case Some(param) => queryParams += "disk.space.error.threshold" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo]): Future[ComAdobeGraniteRepositoryHcImplObservationQueueLengthHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.repository.hc.impl.ObservationQueueLengthHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRepositoryImplCommitStatsConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    intervalSeconds: Option[Integer] = None,
    commitsPerIntervalThreshold: Option[Integer] = None,
    maxLocationLength: Option[Integer] = None,
    maxDetailsShown: Option[Integer] = None,
    minDetailsPercentage: Option[Integer] = None,
    threadMatchers: Option[List[String]] = None,
    maxGreedyDepth: Option[Integer] = None,
    greedyStackMatchers: Option[String] = None,
    stackFilters: Option[List[String]] = None,
    stackMatchers: Option[List[String]] = None,
    stackCategorizers: Option[List[String]] = None,
    stackShorteners: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo]): Future[ComAdobeGraniteRepositoryImplCommitStatsConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.repository.impl.CommitStatsConfig"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    intervalSeconds match {
      case Some(param) => queryParams += "intervalSeconds" -> param.toString
      case _ => queryParams
    }
    commitsPerIntervalThreshold match {
      case Some(param) => queryParams += "commitsPerIntervalThreshold" -> param.toString
      case _ => queryParams
    }
    maxLocationLength match {
      case Some(param) => queryParams += "maxLocationLength" -> param.toString
      case _ => queryParams
    }
    maxDetailsShown match {
      case Some(param) => queryParams += "maxDetailsShown" -> param.toString
      case _ => queryParams
    }
    minDetailsPercentage match {
      case Some(param) => queryParams += "minDetailsPercentage" -> param.toString
      case _ => queryParams
    }
    threadMatchers match {
      case Some(param) => queryParams += "threadMatchers" -> param.toString
      case _ => queryParams
    }
    maxGreedyDepth match {
      case Some(param) => queryParams += "maxGreedyDepth" -> param.toString
      case _ => queryParams
    }
    greedyStackMatchers match {
      case Some(param) => queryParams += "greedyStackMatchers" -> param.toString
      case _ => queryParams
    }
    stackFilters match {
      case Some(param) => queryParams += "stackFilters" -> param.toString
      case _ => queryParams
    }
    stackMatchers match {
      case Some(param) => queryParams += "stackMatchers" -> param.toString
      case _ => queryParams
    }
    stackCategorizers match {
      case Some(param) => queryParams += "stackCategorizers" -> param.toString
      case _ => queryParams
    }
    stackShorteners match {
      case Some(param) => queryParams += "stackShorteners" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRepositoryServiceUserConfiguration(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    serviceusersSimpleSubjectPopulation: Option[Boolean] = None,
    serviceusersList: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRepositoryServiceUserConfigurationInfo]): Future[ComAdobeGraniteRepositoryServiceUserConfigurationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.repository.ServiceUserConfiguration"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    serviceusersSimpleSubjectPopulation match {
      case Some(param) => queryParams += "serviceusers.simpleSubjectPopulation" -> param.toString
      case _ => queryParams
    }
    serviceusersList match {
      case Some(param) => queryParams += "serviceusers.list" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckIm(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo]): Future[ComAdobeGraniteRequestsLoggingImplHcRequestsStatusHealthCheckImInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.requests.logging.impl.hc.RequestsStatusHealthCheckImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteResourcestatusImplCompositeStatusType(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    types: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo]): Future[ComAdobeGraniteResourcestatusImplCompositeStatusTypeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.resourcestatus.impl.CompositeStatusType"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    types match {
      case Some(param) => queryParams += "types" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteResourcestatusImplStatusResourceProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    providerRoot: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo]): Future[ComAdobeGraniteResourcestatusImplStatusResourceProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.resourcestatus.impl.StatusResourceProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    providerRoot match {
      case Some(param) => queryParams += "provider.root" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRestAssetsImplAssetContentDispositionFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mimeAllowEmpty: Option[Boolean] = None,
    mimeAllowed: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo]): Future[ComAdobeGraniteRestAssetsImplAssetContentDispositionFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.rest.assets.impl.AssetContentDispositionFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mimeAllowEmpty match {
      case Some(param) => queryParams += "mime.allowEmpty" -> param.toString
      case _ => queryParams
    }
    mimeAllowed match {
      case Some(param) => queryParams += "mime.allowed" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRestImplApiEndpointResourceProviderFactoryImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    providerRoots: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo]): Future[ComAdobeGraniteRestImplApiEndpointResourceProviderFactoryImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.rest.impl.ApiEndpointResourceProviderFactoryImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    providerRoots match {
      case Some(param) => queryParams += "provider.roots" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteRestImplServletDefaultGETServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    defaultLimit: Option[Integer] = None,
    useAbsoluteUri: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteRestImplServletDefaultGETServletInfo]): Future[ComAdobeGraniteRestImplServletDefaultGETServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.rest.impl.servlet.DefaultGETServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    defaultLimit match {
      case Some(param) => queryParams += "default.limit" -> param.toString
      case _ => queryParams
    }
    useAbsoluteUri match {
      case Some(param) => queryParams += "use.absolute.uri" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationS(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcTags: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo]): Future[ComAdobeGraniteSecurityUserUiInternalServletsSSLConfigurationSInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.security.user.ui.internal.servlets.SSLConfigurationServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteSecurityUserUserPropertiesService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    adapterCondition: Option[String] = None,
    graniteUserpropertiesNodetypes: Option[List[String]] = None,
    graniteUserpropertiesResourcetypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo]): Future[ComAdobeGraniteSecurityUserUserPropertiesServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.security.user.UserPropertiesService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    adapterCondition match {
      case Some(param) => queryParams += "adapter.condition" -> param.toString
      case _ => queryParams
    }
    graniteUserpropertiesNodetypes match {
      case Some(param) => queryParams += "granite.userproperties.nodetypes" -> param.toString
      case _ => queryParams
    }
    graniteUserpropertiesResourcetypes match {
      case Some(param) => queryParams += "granite.userproperties.resourcetypes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteSocialgraphImplSocialGraphFactoryImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    group2memberRelationshipOutgoing: Option[String] = None,
    group2memberExcludedOutgoing: Option[List[String]] = None,
    group2memberRelationshipIncoming: Option[String] = None,
    group2memberExcludedIncoming: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo]): Future[ComAdobeGraniteSocialgraphImplSocialGraphFactoryImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.socialgraph.impl.SocialGraphFactoryImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    group2memberRelationshipOutgoing match {
      case Some(param) => queryParams += "group2member.relationship.outgoing" -> param.toString
      case _ => queryParams
    }
    group2memberExcludedOutgoing match {
      case Some(param) => queryParams += "group2member.excluded.outgoing" -> param.toString
      case _ => queryParams
    }
    group2memberRelationshipIncoming match {
      case Some(param) => queryParams += "group2member.relationship.incoming" -> param.toString
      case _ => queryParams
    }
    group2memberExcludedIncoming match {
      case Some(param) => queryParams += "group2member.excluded.incoming" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteSystemMonitoringImplSystemStatsMBeanImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None,
    jmxObjectname: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo]): Future[ComAdobeGraniteSystemMonitoringImplSystemStatsMBeanImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.system.monitoring.impl.SystemStatsMBeanImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }
    jmxObjectname match {
      case Some(param) => queryParams += "jmx.objectname" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteTaskmanagementImplJcrTaskAdapterFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    adapterCondition: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo]): Future[ComAdobeGraniteTaskmanagementImplJcrTaskAdapterFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.taskmanagement.impl.jcr.TaskAdapterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    adapterCondition match {
      case Some(param) => queryParams += "adapter.condition" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteTaskmanagementImplJcrTaskArchiveService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    archivingEnabled: Option[Boolean] = None,
    schedulerExpression: Option[String] = None,
    archiveSinceDaysCompleted: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo]): Future[ComAdobeGraniteTaskmanagementImplJcrTaskArchiveServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.taskmanagement.impl.jcr.TaskArchiveService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    archivingEnabled match {
      case Some(param) => queryParams += "archiving.enabled" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }
    archiveSinceDaysCompleted match {
      case Some(param) => queryParams += "archive.since.days.completed" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    purgeCompleted: Option[Boolean] = None,
    completedAge: Option[Integer] = None,
    purgeActive: Option[Boolean] = None,
    activeAge: Option[Integer] = None,
    saveThreshold: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo]): Future[ComAdobeGraniteTaskmanagementImplPurgeTaskPurgeMaintenanceTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.taskmanagement.impl.purge.TaskPurgeMaintenanceTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    purgeCompleted match {
      case Some(param) => queryParams += "purgeCompleted" -> param.toString
      case _ => queryParams
    }
    completedAge match {
      case Some(param) => queryParams += "completedAge" -> param.toString
      case _ => queryParams
    }
    purgeActive match {
      case Some(param) => queryParams += "purgeActive" -> param.toString
      case _ => queryParams
    }
    activeAge match {
      case Some(param) => queryParams += "activeAge" -> param.toString
      case _ => queryParams
    }
    saveThreshold match {
      case Some(param) => queryParams += "saveThreshold" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    adapterCondition: Option[String] = None,
    taskmanagerAdmingroups: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo]): Future[ComAdobeGraniteTaskmanagementImplServiceTaskManagerAdapterFactorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.taskmanagement.impl.service.TaskManagerAdapterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    adapterCondition match {
      case Some(param) => queryParams += "adapter.condition" -> param.toString
      case _ => queryParams
    }
    taskmanagerAdmingroups match {
      case Some(param) => queryParams += "taskmanager.admingroups" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteThreaddumpThreadDumpCollector(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerPeriod: Option[Integer] = None,
    schedulerRunOn: Option[String] = None,
    graniteThreaddumpEnabled: Option[Boolean] = None,
    graniteThreaddumpDumpsPerFile: Option[Integer] = None,
    graniteThreaddumpEnableGzipCompression: Option[Boolean] = None,
    graniteThreaddumpEnableDirectoriesCompression: Option[Boolean] = None,
    graniteThreaddumpEnableJStack: Option[Boolean] = None,
    graniteThreaddumpMaxBackupDays: Option[Integer] = None,
    graniteThreaddumpBackupCleanTrigger: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo]): Future[ComAdobeGraniteThreaddumpThreadDumpCollectorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.threaddump.ThreadDumpCollector"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerPeriod match {
      case Some(param) => queryParams += "scheduler.period" -> param.toString
      case _ => queryParams
    }
    schedulerRunOn match {
      case Some(param) => queryParams += "scheduler.runOn" -> param.toString
      case _ => queryParams
    }
    graniteThreaddumpEnabled match {
      case Some(param) => queryParams += "granite.threaddump.enabled" -> param.toString
      case _ => queryParams
    }
    graniteThreaddumpDumpsPerFile match {
      case Some(param) => queryParams += "granite.threaddump.dumpsPerFile" -> param.toString
      case _ => queryParams
    }
    graniteThreaddumpEnableGzipCompression match {
      case Some(param) => queryParams += "granite.threaddump.enableGzipCompression" -> param.toString
      case _ => queryParams
    }
    graniteThreaddumpEnableDirectoriesCompression match {
      case Some(param) => queryParams += "granite.threaddump.enableDirectoriesCompression" -> param.toString
      case _ => queryParams
    }
    graniteThreaddumpEnableJStack match {
      case Some(param) => queryParams += "granite.threaddump.enableJStack" -> param.toString
      case _ => queryParams
    }
    graniteThreaddumpMaxBackupDays match {
      case Some(param) => queryParams += "granite.threaddump.maxBackupDays" -> param.toString
      case _ => queryParams
    }
    graniteThreaddumpBackupCleanTrigger match {
      case Some(param) => queryParams += "granite.threaddump.backupCleanTrigger" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTransl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    translationFactory: Option[String] = None,
    defaultConnectorLabel: Option[String] = None,
    defaultConnectorAttribution: Option[String] = None,
    defaultConnectorWorkspaceId: Option[String] = None,
    defaultConnectorSubscriptionKey: Option[String] = None,
    languageMapLocation: Option[String] = None,
    categoryMapLocation: Option[String] = None,
    retryAttempts: Option[Integer] = None,
    timeoutCount: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo]): Future[ComAdobeGraniteTranslationConnectorMsftCoreImplMicrosoftTranslInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.translation.connector.msft.core.impl.MicrosoftTranslationServiceFactoryImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    translationFactory match {
      case Some(param) => queryParams += "translationFactory" -> param.toString
      case _ => queryParams
    }
    defaultConnectorLabel match {
      case Some(param) => queryParams += "defaultConnectorLabel" -> param.toString
      case _ => queryParams
    }
    defaultConnectorAttribution match {
      case Some(param) => queryParams += "defaultConnectorAttribution" -> param.toString
      case _ => queryParams
    }
    defaultConnectorWorkspaceId match {
      case Some(param) => queryParams += "defaultConnectorWorkspaceId" -> param.toString
      case _ => queryParams
    }
    defaultConnectorSubscriptionKey match {
      case Some(param) => queryParams += "defaultConnectorSubscriptionKey" -> param.toString
      case _ => queryParams
    }
    languageMapLocation match {
      case Some(param) => queryParams += "languageMapLocation" -> param.toString
      case _ => queryParams
    }
    categoryMapLocation match {
      case Some(param) => queryParams += "categoryMapLocation" -> param.toString
      case _ => queryParams
    }
    retryAttempts match {
      case Some(param) => queryParams += "retryAttempts" -> param.toString
      case _ => queryParams
    }
    timeoutCount match {
      case Some(param) => queryParams += "timeoutCount" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteTranslationCoreImplTranslationManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    defaultConnectorName: Option[String] = None,
    defaultCategory: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo]): Future[ComAdobeGraniteTranslationCoreImplTranslationManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.translation.core.impl.TranslationManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    defaultConnectorName match {
      case Some(param) => queryParams += "defaultConnectorName" -> param.toString
      case _ => queryParams
    }
    defaultCategory match {
      case Some(param) => queryParams += "defaultCategory" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteUiClientlibsImplHtmlLibraryManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    htmllibmanagerTiming: Option[Boolean] = None,
    htmllibmanagerDebugInitJs: Option[String] = None,
    htmllibmanagerMinify: Option[Boolean] = None,
    htmllibmanagerDebug: Option[Boolean] = None,
    htmllibmanagerGzip: Option[Boolean] = None,
    htmllibmanagerMaxDataUriSize: Option[Integer] = None,
    htmllibmanagerMaxage: Option[Integer] = None,
    htmllibmanagerForceCQUrlInfo: Option[Boolean] = None,
    htmllibmanagerDefaultthemename: Option[String] = None,
    htmllibmanagerDefaultuserthemename: Option[String] = None,
    htmllibmanagerClientmanager: Option[String] = None,
    htmllibmanagerPathList: Option[List[String]] = None,
    htmllibmanagerExcludedPathList: Option[List[String]] = None,
    htmllibmanagerProcessorJs: Option[List[String]] = None,
    htmllibmanagerProcessorCss: Option[List[String]] = None,
    htmllibmanagerLongcachePatterns: Option[List[String]] = None,
    htmllibmanagerLongcacheFormat: Option[String] = None,
    htmllibmanagerUseFileSystemOutputCache: Option[Boolean] = None,
    htmllibmanagerFileSystemOutputCacheLocation: Option[String] = None,
    htmllibmanagerDisableReplacement: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo]): Future[ComAdobeGraniteUiClientlibsImplHtmlLibraryManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.ui.clientlibs.impl.HtmlLibraryManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerTiming match {
      case Some(param) => queryParams += "htmllibmanager.timing" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerDebugInitJs match {
      case Some(param) => queryParams += "htmllibmanager.debug.init.js" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerMinify match {
      case Some(param) => queryParams += "htmllibmanager.minify" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerDebug match {
      case Some(param) => queryParams += "htmllibmanager.debug" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerGzip match {
      case Some(param) => queryParams += "htmllibmanager.gzip" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerMaxDataUriSize match {
      case Some(param) => queryParams += "htmllibmanager.maxDataUriSize" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerMaxage match {
      case Some(param) => queryParams += "htmllibmanager.maxage" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerForceCQUrlInfo match {
      case Some(param) => queryParams += "htmllibmanager.forceCQUrlInfo" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerDefaultthemename match {
      case Some(param) => queryParams += "htmllibmanager.defaultthemename" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerDefaultuserthemename match {
      case Some(param) => queryParams += "htmllibmanager.defaultuserthemename" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerClientmanager match {
      case Some(param) => queryParams += "htmllibmanager.clientmanager" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerPathList match {
      case Some(param) => queryParams += "htmllibmanager.path.list" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerExcludedPathList match {
      case Some(param) => queryParams += "htmllibmanager.excluded.path.list" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerProcessorJs match {
      case Some(param) => queryParams += "htmllibmanager.processor.js" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerProcessorCss match {
      case Some(param) => queryParams += "htmllibmanager.processor.css" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerLongcachePatterns match {
      case Some(param) => queryParams += "htmllibmanager.longcache.patterns" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerLongcacheFormat match {
      case Some(param) => queryParams += "htmllibmanager.longcache.format" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerUseFileSystemOutputCache match {
      case Some(param) => queryParams += "htmllibmanager.useFileSystemOutputCache" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerFileSystemOutputCacheLocation match {
      case Some(param) => queryParams += "htmllibmanager.fileSystemOutputCacheLocation" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerDisableReplacement match {
      case Some(param) => queryParams += "htmllibmanager.disable.replacement" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeature(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo]): Future[ComAdobeGraniteWorkflowConsoleFragsWorkflowWithdrawFeatureInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.console.frags.WorkflowWithdrawFeature"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowConsolePublishWorkflowPublishEventService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    graniteWorkflowWorkflowPublishEventServiceEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo]): Future[ComAdobeGraniteWorkflowConsolePublishWorkflowPublishEventServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.console.publish.WorkflowPublishEventService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    graniteWorkflowWorkflowPublishEventServiceEnabled match {
      case Some(param) => queryParams += "granite.workflow.WorkflowPublishEventService.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowCoreJcrWorkflowBucketManager(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    bucketSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo]): Future[ComAdobeGraniteWorkflowCoreJcrWorkflowBucketManagerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.core.jcr.WorkflowBucketManager"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    bucketSize match {
      case Some(param) => queryParams += "bucketSize" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowCoreJobExternalProcessJobHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    defaultTimeout: Option[Integer] = None,
    maxTimeout: Option[Integer] = None,
    defaultPeriod: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo]): Future[ComAdobeGraniteWorkflowCoreJobExternalProcessJobHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.core.job.ExternalProcessJobHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    defaultTimeout match {
      case Some(param) => queryParams += "default.timeout" -> param.toString
      case _ => queryParams
    }
    maxTimeout match {
      case Some(param) => queryParams += "max.timeout" -> param.toString
      case _ => queryParams
    }
    defaultPeriod match {
      case Some(param) => queryParams += "default.period" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowCoreJobJobHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jobTopics: Option[List[String]] = None,
    allowSelfProcessTermination: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo]): Future[ComAdobeGraniteWorkflowCoreJobJobHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.core.job.JobHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jobTopics match {
      case Some(param) => queryParams += "job.topics" -> param.toString
      case _ => queryParams
    }
    allowSelfProcessTermination match {
      case Some(param) => queryParams += "allow.self.process.termination" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsum(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jobTopics: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo]): Future[ComAdobeGraniteWorkflowCoreOffloadingWorkflowOffloadingJobConsumInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.core.offloading.WorkflowOffloadingJobConsumer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jobTopics match {
      case Some(param) => queryParams += "job.topics" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowCorePayloadMapCache(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    getSystemWorkflowModels: Option[List[String]] = None,
    getPackageRootPath: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo]): Future[ComAdobeGraniteWorkflowCorePayloadMapCacheInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.core.PayloadMapCache"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    getSystemWorkflowModels match {
      case Some(param) => queryParams += "getSystemWorkflowModels" -> param.toString
      case _ => queryParams
    }
    getPackageRootPath match {
      case Some(param) => queryParams += "getPackageRootPath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowCorePayloadmapPayloadMoveListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    payloadMoveWhiteList: Option[List[String]] = None,
    payloadMoveHandleFromWorkflowProcess: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo]): Future[ComAdobeGraniteWorkflowCorePayloadmapPayloadMoveListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.core.payloadmap.PayloadMoveListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    payloadMoveWhiteList match {
      case Some(param) => queryParams += "payload.move.white.list" -> param.toString
      case _ => queryParams
    }
    payloadMoveHandleFromWorkflowProcess match {
      case Some(param) => queryParams += "payload.move.handle.from.workflow.process" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowCoreWorkflowConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqWorkflowConfigWorkflowPackagesRootPath: Option[List[String]] = None,
    cqWorkflowConfigWorkflowProcessLegacyMode: Option[Boolean] = None,
    cqWorkflowConfigAllowLocking: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo]): Future[ComAdobeGraniteWorkflowCoreWorkflowConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.core.WorkflowConfig"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqWorkflowConfigWorkflowPackagesRootPath match {
      case Some(param) => queryParams += "cq.workflow.config.workflow.packages.root.path" -> param.toString
      case _ => queryParams
    }
    cqWorkflowConfigWorkflowProcessLegacyMode match {
      case Some(param) => queryParams += "cq.workflow.config.workflow.process.legacy.mode" -> param.toString
      case _ => queryParams
    }
    cqWorkflowConfigAllowLocking match {
      case Some(param) => queryParams += "cq.workflow.config.allow.locking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowCoreWorkflowSessionFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    graniteWorkflowinboxSortPropertyName: Option[String] = None,
    graniteWorkflowinboxSortOrder: Option[String] = None,
    cqWorkflowJobRetry: Option[Integer] = None,
    cqWorkflowSuperuser: Option[List[String]] = None,
    graniteWorkflowInboxQuerySize: Option[Integer] = None,
    graniteWorkflowAdminUserGroupFilter: Option[Boolean] = None,
    graniteWorkflowEnforceWorkitemAssigneePermissions: Option[Boolean] = None,
    graniteWorkflowEnforceWorkflowInitiatorPermissions: Option[Boolean] = None,
    graniteWorkflowInjectTenantIdInJobTopics: Option[Boolean] = None,
    graniteWorkflowMaxPurgeSaveThreshold: Option[Integer] = None,
    graniteWorkflowMaxPurgeQueryCount: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo]): Future[ComAdobeGraniteWorkflowCoreWorkflowSessionFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.core.WorkflowSessionFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    graniteWorkflowinboxSortPropertyName match {
      case Some(param) => queryParams += "granite.workflowinbox.sort.propertyName" -> param.toString
      case _ => queryParams
    }
    graniteWorkflowinboxSortOrder match {
      case Some(param) => queryParams += "granite.workflowinbox.sort.order" -> param.toString
      case _ => queryParams
    }
    cqWorkflowJobRetry match {
      case Some(param) => queryParams += "cq.workflow.job.retry" -> param.toString
      case _ => queryParams
    }
    cqWorkflowSuperuser match {
      case Some(param) => queryParams += "cq.workflow.superuser" -> param.toString
      case _ => queryParams
    }
    graniteWorkflowInboxQuerySize match {
      case Some(param) => queryParams += "granite.workflow.inboxQuerySize" -> param.toString
      case _ => queryParams
    }
    graniteWorkflowAdminUserGroupFilter match {
      case Some(param) => queryParams += "granite.workflow.adminUserGroupFilter" -> param.toString
      case _ => queryParams
    }
    graniteWorkflowEnforceWorkitemAssigneePermissions match {
      case Some(param) => queryParams += "granite.workflow.enforceWorkitemAssigneePermissions" -> param.toString
      case _ => queryParams
    }
    graniteWorkflowEnforceWorkflowInitiatorPermissions match {
      case Some(param) => queryParams += "granite.workflow.enforceWorkflowInitiatorPermissions" -> param.toString
      case _ => queryParams
    }
    graniteWorkflowInjectTenantIdInJobTopics match {
      case Some(param) => queryParams += "granite.workflow.injectTenantIdInJobTopics" -> param.toString
      case _ => queryParams
    }
    graniteWorkflowMaxPurgeSaveThreshold match {
      case Some(param) => queryParams += "granite.workflow.maxPurgeSaveThreshold" -> param.toString
      case _ => queryParams
    }
    graniteWorkflowMaxPurgeQueryCount match {
      case Some(param) => queryParams += "granite.workflow.maxPurgeQueryCount" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeGraniteWorkflowPurgeScheduler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    scheduledpurgeName: Option[String] = None,
    scheduledpurgeWorkflowStatus: Option[String] = None,
    scheduledpurgeModelIds: Option[List[String]] = None,
    scheduledpurgeDaysold: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeGraniteWorkflowPurgeSchedulerInfo]): Future[ComAdobeGraniteWorkflowPurgeSchedulerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.granite.workflow.purge.Scheduler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    scheduledpurgeName match {
      case Some(param) => queryParams += "scheduledpurge.name" -> param.toString
      case _ => queryParams
    }
    scheduledpurgeWorkflowStatus match {
      case Some(param) => queryParams += "scheduledpurge.workflowStatus" -> param.toString
      case _ => queryParams
    }
    scheduledpurgeModelIds match {
      case Some(param) => queryParams += "scheduledpurge.modelIds" -> param.toString
      case _ => queryParams
    }
    scheduledpurgeDaysold match {
      case Some(param) => queryParams += "scheduledpurge.daysold" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeOctopusNcommBootstrap(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxConnections: Option[Integer] = None,
    maxRequests: Option[Integer] = None,
    requestTimeout: Option[Integer] = None,
    requestRetries: Option[Integer] = None,
    launchTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComAdobeOctopusNcommBootstrapInfo]): Future[ComAdobeOctopusNcommBootstrapInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.octopus.ncomm.bootstrap"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxConnections match {
      case Some(param) => queryParams += "maxConnections" -> param.toString
      case _ => queryParams
    }
    maxRequests match {
      case Some(param) => queryParams += "maxRequests" -> param.toString
      case _ => queryParams
    }
    requestTimeout match {
      case Some(param) => queryParams += "requestTimeout" -> param.toString
      case _ => queryParams
    }
    requestRetries match {
      case Some(param) => queryParams += "requestRetries" -> param.toString
      case _ => queryParams
    }
    launchTimeout match {
      case Some(param) => queryParams += "launchTimeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullS(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    communitiesIntegrationLivefyreSlingEventFilter: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo]): Future[ComAdobeSocialIntegrationsLivefyreUserPingforpullImplPingPullSInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.social.integrations.livefyre.user.pingforpull.impl.PingPullServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    communitiesIntegrationLivefyreSlingEventFilter match {
      case Some(param) => queryParams += "communities.integration.livefyre.sling.event.filter" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comAdobeXmpWorkerFilesNcommXMPFilesNComm(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxConnections: Option[String] = None,
    maxRequests: Option[String] = None,
    requestTimeout: Option[String] = None,
    logDir: Option[String] = None
    )(implicit reader: ClientResponseReader[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo]): Future[ComAdobeXmpWorkerFilesNcommXMPFilesNCommInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.adobe.xmp.worker.files.ncomm.XMPFilesNComm"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxConnections match {
      case Some(param) => queryParams += "maxConnections" -> param.toString
      case _ => queryParams
    }
    maxRequests match {
      case Some(param) => queryParams += "maxRequests" -> param.toString
      case _ => queryParams
    }
    requestTimeout match {
      case Some(param) => queryParams += "requestTimeout" -> param.toString
      case _ => queryParams
    }
    logDir match {
      case Some(param) => queryParams += "logDir" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCommonsDatasourceJdbcpoolJdbcPoolService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jdbcDriverClass: Option[String] = None,
    jdbcConnectionUri: Option[String] = None,
    jdbcUsername: Option[String] = None,
    jdbcPassword: Option[String] = None,
    jdbcValidationQuery: Option[String] = None,
    defaultReadonly: Option[Boolean] = None,
    defaultAutocommit: Option[Boolean] = None,
    poolSize: Option[Integer] = None,
    poolMaxWaitMsec: Option[Integer] = None,
    datasourceName: Option[String] = None,
    datasourceSvcProperties: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo]): Future[ComDayCommonsDatasourceJdbcpoolJdbcPoolServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.commons.datasource.jdbcpool.JdbcPoolService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jdbcDriverClass match {
      case Some(param) => queryParams += "jdbc.driver.class" -> param.toString
      case _ => queryParams
    }
    jdbcConnectionUri match {
      case Some(param) => queryParams += "jdbc.connection.uri" -> param.toString
      case _ => queryParams
    }
    jdbcUsername match {
      case Some(param) => queryParams += "jdbc.username" -> param.toString
      case _ => queryParams
    }
    jdbcPassword match {
      case Some(param) => queryParams += "jdbc.password" -> param.toString
      case _ => queryParams
    }
    jdbcValidationQuery match {
      case Some(param) => queryParams += "jdbc.validation.query" -> param.toString
      case _ => queryParams
    }
    defaultReadonly match {
      case Some(param) => queryParams += "default.readonly" -> param.toString
      case _ => queryParams
    }
    defaultAutocommit match {
      case Some(param) => queryParams += "default.autocommit" -> param.toString
      case _ => queryParams
    }
    poolSize match {
      case Some(param) => queryParams += "pool.size" -> param.toString
      case _ => queryParams
    }
    poolMaxWaitMsec match {
      case Some(param) => queryParams += "pool.max.wait.msec" -> param.toString
      case _ => queryParams
    }
    datasourceName match {
      case Some(param) => queryParams += "datasource.name" -> param.toString
      case _ => queryParams
    }
    datasourceSvcProperties match {
      case Some(param) => queryParams += "datasource.svc.properties" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCommonsHttpclient(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    proxyEnabled: Option[Boolean] = None,
    proxyHost: Option[String] = None,
    proxyUser: Option[String] = None,
    proxyPassword: Option[String] = None,
    proxyNtlmHost: Option[String] = None,
    proxyNtlmDomain: Option[String] = None,
    proxyExceptions: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCommonsHttpclientInfo]): Future[ComDayCommonsHttpclientInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.commons.httpclient"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    proxyEnabled match {
      case Some(param) => queryParams += "proxy.enabled" -> param.toString
      case _ => queryParams
    }
    proxyHost match {
      case Some(param) => queryParams += "proxy.host" -> param.toString
      case _ => queryParams
    }
    proxyUser match {
      case Some(param) => queryParams += "proxy.user" -> param.toString
      case _ => queryParams
    }
    proxyPassword match {
      case Some(param) => queryParams += "proxy.password" -> param.toString
      case _ => queryParams
    }
    proxyNtlmHost match {
      case Some(param) => queryParams += "proxy.ntlm.host" -> param.toString
      case _ => queryParams
    }
    proxyNtlmDomain match {
      case Some(param) => queryParams += "proxy.ntlm.domain" -> param.toString
      case _ => queryParams
    }
    proxyExceptions match {
      case Some(param) => queryParams += "proxy.exceptions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsImplStorePropertiesChangeListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqStoreListenerAdditionalStorePaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo]): Future[ComDayCqAnalyticsImplStorePropertiesChangeListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.impl.StorePropertiesChangeListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqStoreListenerAdditionalStorePaths match {
      case Some(param) => queryParams += "cq.store.listener.additionalStorePaths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsSitecatalystImplExporterClassificationsExporte(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    allowedPaths: Option[List[String]] = None,
    cqAnalyticsSaintExporterPagesize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo]): Future[ComDayCqAnalyticsSitecatalystImplExporterClassificationsExporteInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.exporter.ClassificationsExporter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    allowedPaths match {
      case Some(param) => queryParams += "allowed.paths" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsSaintExporterPagesize match {
      case Some(param) => queryParams += "cq.analytics.saint.exporter.pagesize" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsSitecatalystImplImporterReportImporter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    reportFetchAttempts: Option[Integer] = None,
    reportFetchDelay: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo]): Future[ComDayCqAnalyticsSitecatalystImplImporterReportImporterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.importer.ReportImporter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    reportFetchAttempts match {
      case Some(param) => queryParams += "report.fetch.attempts" -> param.toString
      case _ => queryParams
    }
    reportFetchDelay match {
      case Some(param) => queryParams += "report.fetch.delay" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAnalyticsAdapterfactoryContextstores: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo]): Future[ComDayCqAnalyticsSitecatalystImplSitecatalystAdapterFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.SitecatalystAdapterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsAdapterfactoryContextstores match {
      case Some(param) => queryParams += "cq.analytics.adapterfactory.contextstores" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAnalyticsSitecatalystServiceDatacenterUrl: Option[List[String]] = None,
    devhostnamepatterns: Option[List[String]] = None,
    connectionTimeout: Option[Integer] = None,
    socketTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo]): Future[ComDayCqAnalyticsSitecatalystImplSitecatalystHttpClientImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.sitecatalyst.impl.SitecatalystHttpClientImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsSitecatalystServiceDatacenterUrl match {
      case Some(param) => queryParams += "cq.analytics.sitecatalyst.service.datacenter.url" -> param.toString
      case _ => queryParams
    }
    devhostnamepatterns match {
      case Some(param) => queryParams += "devhostnamepatterns" -> param.toString
      case _ => queryParams
    }
    connectionTimeout match {
      case Some(param) => queryParams += "connection.timeout" -> param.toString
      case _ => queryParams
    }
    socketTimeout match {
      case Some(param) => queryParams += "socket.timeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsTestandtargetImplAccountOptionsUpdater(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAnalyticsTestandtargetAccountoptionsupdaterEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo]): Future[ComDayCqAnalyticsTestandtargetImplAccountOptionsUpdaterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.AccountOptionsUpdater"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsTestandtargetAccountoptionsupdaterEnabled match {
      case Some(param) => queryParams += "cq.analytics.testandtarget.accountoptionsupdater.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo]): Future[ComDayCqAnalyticsTestandtargetImplDeleteAuthorActivityListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.DeleteAuthorActivityListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsTestandtargetDeleteauthoractivitylistenerEnabled match {
      case Some(param) => queryParams += "cq.analytics.testandtarget.deleteauthoractivitylistener.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo]): Future[ComDayCqAnalyticsTestandtargetImplPushAuthorCampaignPageListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.PushAuthorCampaignPageListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsTestandtargetPushauthorcampaignpagelistenerEnabled match {
      case Some(param) => queryParams += "cq.analytics.testandtarget.pushauthorcampaignpagelistener.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsTestandtargetImplSegmentImporter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAnalyticsTestandtargetSegmentimporterEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo]): Future[ComDayCqAnalyticsTestandtargetImplSegmentImporterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.SegmentImporter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsTestandtargetSegmentimporterEnabled match {
      case Some(param) => queryParams += "cq.analytics.testandtarget.segmentimporter.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsTestandtargetImplServiceWebServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    endpointUri: Option[String] = None,
    connectionTimeout: Option[Integer] = None,
    socketTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo]): Future[ComDayCqAnalyticsTestandtargetImplServiceWebServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.service.WebServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    endpointUri match {
      case Some(param) => queryParams += "endpointUri" -> param.toString
      case _ => queryParams
    }
    connectionTimeout match {
      case Some(param) => queryParams += "connectionTimeout" -> param.toString
      case _ => queryParams
    }
    socketTimeout match {
      case Some(param) => queryParams += "socketTimeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsTestandtargetImplServletsAdminServerServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    testandtargetEndpointUrl: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo]): Future[ComDayCqAnalyticsTestandtargetImplServletsAdminServerServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.servlets.AdminServerServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    testandtargetEndpointUrl match {
      case Some(param) => queryParams += "testandtarget.endpoint.url" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAnalyticsTestandtargetApiUrl: Option[String] = None,
    cqAnalyticsTestandtargetTimeout: Option[Integer] = None,
    cqAnalyticsTestandtargetSockettimeout: Option[Integer] = None,
    cqAnalyticsTestandtargetRecommendationsUrlReplace: Option[String] = None,
    cqAnalyticsTestandtargetRecommendationsUrlReplacewith: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo]): Future[ComDayCqAnalyticsTestandtargetImplTestandtargetHttpClientImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.analytics.testandtarget.impl.TestandtargetHttpClientImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsTestandtargetApiUrl match {
      case Some(param) => queryParams += "cq.analytics.testandtarget.api.url" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsTestandtargetTimeout match {
      case Some(param) => queryParams += "cq.analytics.testandtarget.timeout" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsTestandtargetSockettimeout match {
      case Some(param) => queryParams += "cq.analytics.testandtarget.sockettimeout" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsTestandtargetRecommendationsUrlReplace match {
      case Some(param) => queryParams += "cq.analytics.testandtarget.recommendations.url.replace" -> param.toString
      case _ => queryParams
    }
    cqAnalyticsTestandtargetRecommendationsUrlReplacewith match {
      case Some(param) => queryParams += "cq.analytics.testandtarget.recommendations.url.replacewith" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAuthImplCugCugSupportImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cugExemptedPrincipals: Option[List[String]] = None,
    cugEnabled: Option[Boolean] = None,
    cugPrincipalsRegex: Option[String] = None,
    cugPrincipalsReplacement: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqAuthImplCugCugSupportImplInfo]): Future[ComDayCqAuthImplCugCugSupportImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.auth.impl.cug.CugSupportImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cugExemptedPrincipals match {
      case Some(param) => queryParams += "cug.exempted.principals" -> param.toString
      case _ => queryParams
    }
    cugEnabled match {
      case Some(param) => queryParams += "cug.enabled" -> param.toString
      case _ => queryParams
    }
    cugPrincipalsRegex match {
      case Some(param) => queryParams += "cug.principals.regex" -> param.toString
      case _ => queryParams
    }
    cugPrincipalsReplacement match {
      case Some(param) => queryParams += "cug.principals.replacement" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqAuthImplLoginSelectorHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[String] = None,
    serviceRanking: Option[Integer] = None,
    authLoginselectorMappings: Option[List[String]] = None,
    authLoginselectorChangepwMappings: Option[List[String]] = None,
    authLoginselectorDefaultloginpage: Option[String] = None,
    authLoginselectorDefaultchangepwpage: Option[String] = None,
    authLoginselectorHandle: Option[List[String]] = None,
    authLoginselectorHandleAllExtensions: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqAuthImplLoginSelectorHandlerInfo]): Future[ComDayCqAuthImplLoginSelectorHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.auth.impl.LoginSelectorHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    authLoginselectorMappings match {
      case Some(param) => queryParams += "auth.loginselector.mappings" -> param.toString
      case _ => queryParams
    }
    authLoginselectorChangepwMappings match {
      case Some(param) => queryParams += "auth.loginselector.changepw.mappings" -> param.toString
      case _ => queryParams
    }
    authLoginselectorDefaultloginpage match {
      case Some(param) => queryParams += "auth.loginselector.defaultloginpage" -> param.toString
      case _ => queryParams
    }
    authLoginselectorDefaultchangepwpage match {
      case Some(param) => queryParams += "auth.loginselector.defaultchangepwpage" -> param.toString
      case _ => queryParams
    }
    authLoginselectorHandle match {
      case Some(param) => queryParams += "auth.loginselector.handle" -> param.toString
      case _ => queryParams
    }
    authLoginselectorHandleAllExtensions match {
      case Some(param) => queryParams += "auth.loginselector.handle.all.extensions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqCommonsImplExternalizerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    externalizerDomains: Option[List[String]] = None,
    externalizerHost: Option[String] = None,
    externalizerContextpath: Option[String] = None,
    externalizerEncodedpath: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqCommonsImplExternalizerImplInfo]): Future[ComDayCqCommonsImplExternalizerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.commons.impl.ExternalizerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    externalizerDomains match {
      case Some(param) => queryParams += "externalizer.domains" -> param.toString
      case _ => queryParams
    }
    externalizerHost match {
      case Some(param) => queryParams += "externalizer.host" -> param.toString
      case _ => queryParams
    }
    externalizerContextpath match {
      case Some(param) => queryParams += "externalizer.contextpath" -> param.toString
      case _ => queryParams
    }
    externalizerEncodedpath match {
      case Some(param) => queryParams += "externalizer.encodedpath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqCommonsServletsRootMappingServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    rootmappingTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqCommonsServletsRootMappingServletInfo]): Future[ComDayCqCommonsServletsRootMappingServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.commons.servlets.RootMappingServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    rootmappingTarget match {
      case Some(param) => queryParams += "rootmapping.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionChecke(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    codeupgradetasks: Option[List[String]] = None,
    codeupgradetaskfilters: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo]): Future[ComDayCqCompatCodeupgradeImplCodeUpgradeExecutionConditionCheckeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.CodeUpgradeExecutionConditionChecker"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    codeupgradetasks match {
      case Some(param) => queryParams += "codeupgradetasks" -> param.toString
      case _ => queryParams
    }
    codeupgradetaskfilters match {
      case Some(param) => queryParams += "codeupgradetaskfilters" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqCompatCodeupgradeImplUpgradeTaskIgnoreList(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    upgradeTaskIgnoreList: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo]): Future[ComDayCqCompatCodeupgradeImplUpgradeTaskIgnoreListInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.UpgradeTaskIgnoreList"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    upgradeTaskIgnoreList match {
      case Some(param) => queryParams += "upgradeTaskIgnoreList" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelist(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    effectiveBundleListPath: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo]): Future[ComDayCqCompatCodeupgradeImplVersionRangeTaskIgnorelistInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.compat.codeupgrade.impl.VersionRangeTaskIgnorelist"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    effectiveBundleListPath match {
      case Some(param) => queryParams += "effectiveBundleListPath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqContentsyncImplContentSyncManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    contentsyncFallbackAuthorizable: Option[String] = None,
    contentsyncFallbackUpdateuser: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqContentsyncImplContentSyncManagerImplInfo]): Future[ComDayCqContentsyncImplContentSyncManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.contentsync.impl.ContentSyncManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    contentsyncFallbackAuthorizable match {
      case Some(param) => queryParams += "contentsync.fallback.authorizable" -> param.toString
      case _ => queryParams
    }
    contentsyncFallbackUpdateuser match {
      case Some(param) => queryParams += "contentsync.fallback.updateuser" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCommonsHandlerStandardImageHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    largeFileThreshold: Option[Integer] = None,
    largeCommentThreshold: Option[Integer] = None,
    cqDamEnableExtMetaExtraction: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCommonsHandlerStandardImageHandlerInfo]): Future[ComDayCqDamCommonsHandlerStandardImageHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.commons.handler.StandardImageHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    largeFileThreshold match {
      case Some(param) => queryParams += "large_file_threshold" -> param.toString
      case _ => queryParams
    }
    largeCommentThreshold match {
      case Some(param) => queryParams += "large_comment_threshold" -> param.toString
      case _ => queryParams
    }
    cqDamEnableExtMetaExtraction match {
      case Some(param) => queryParams += "cq.dam.enable.ext.meta.extraction" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCommonsMetadataXmpFilterBlackWhite(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    xmpFilterApplyWhitelist: Option[Boolean] = None,
    xmpFilterWhitelist: Option[List[String]] = None,
    xmpFilterApplyBlacklist: Option[Boolean] = None,
    xmpFilterBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo]): Future[ComDayCqDamCommonsMetadataXmpFilterBlackWhiteInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.commons.metadata.XmpFilterBlackWhite"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    xmpFilterApplyWhitelist match {
      case Some(param) => queryParams += "xmp.filter.apply_whitelist" -> param.toString
      case _ => queryParams
    }
    xmpFilterWhitelist match {
      case Some(param) => queryParams += "xmp.filter.whitelist" -> param.toString
      case _ => queryParams
    }
    xmpFilterApplyBlacklist match {
      case Some(param) => queryParams += "xmp.filter.apply_blacklist" -> param.toString
      case _ => queryParams
    }
    xmpFilterBlacklist match {
      case Some(param) => queryParams += "xmp.filter.blacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCommonsUtilImplAssetCacheImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    largeFileMin: Option[Integer] = None,
    cacheApply: Option[Boolean] = None,
    mimeTypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCommonsUtilImplAssetCacheImplInfo]): Future[ComDayCqDamCommonsUtilImplAssetCacheImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.commons.util.impl.AssetCacheImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    largeFileMin match {
      case Some(param) => queryParams += "large.file.min" -> param.toString
      case _ => queryParams
    }
    cacheApply match {
      case Some(param) => queryParams += "cache.apply" -> param.toString
      case _ => queryParams
    }
    mimeTypes match {
      case Some(param) => queryParams += "mime.types" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplAnnotationPdfAnnotationPdfConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamConfigAnnotationPdfDocumentWidth: Option[Integer] = None,
    cqDamConfigAnnotationPdfDocumentHeight: Option[Integer] = None,
    cqDamConfigAnnotationPdfDocumentPaddingHorizontal: Option[Integer] = None,
    cqDamConfigAnnotationPdfDocumentPaddingVertical: Option[Integer] = None,
    cqDamConfigAnnotationPdfFontSize: Option[Integer] = None,
    cqDamConfigAnnotationPdfFontColor: Option[String] = None,
    cqDamConfigAnnotationPdfFontFamily: Option[String] = None,
    cqDamConfigAnnotationPdfFontLight: Option[String] = None,
    cqDamConfigAnnotationPdfMarginTextImage: Option[Integer] = None,
    cqDamConfigAnnotationPdfMinImageHeight: Option[Integer] = None,
    cqDamConfigAnnotationPdfReviewStatusWidth: Option[Integer] = None,
    cqDamConfigAnnotationPdfReviewStatusColorApproved: Option[String] = None,
    cqDamConfigAnnotationPdfReviewStatusColorRejected: Option[String] = None,
    cqDamConfigAnnotationPdfReviewStatusColorChangesRequested: Option[String] = None,
    cqDamConfigAnnotationPdfAnnotationMarkerWidth: Option[Integer] = None,
    cqDamConfigAnnotationPdfAssetMinheight: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo]): Future[ComDayCqDamCoreImplAnnotationPdfAnnotationPdfConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.annotation.pdf.AnnotationPdfConfig"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfDocumentWidth match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.document.width" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfDocumentHeight match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.document.height" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfDocumentPaddingHorizontal match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.document.padding.horizontal" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfDocumentPaddingVertical match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.document.padding.vertical" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfFontSize match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.font.size" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfFontColor match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.font.color" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfFontFamily match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.font.family" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfFontLight match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.font.light" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfMarginTextImage match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.marginTextImage" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfMinImageHeight match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.minImageHeight" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfReviewStatusWidth match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.reviewStatus.width" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfReviewStatusColorApproved match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.reviewStatus.color.approved" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfReviewStatusColorRejected match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.reviewStatus.color.rejected" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfReviewStatusColorChangesRequested match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.reviewStatus.color.changesRequested" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfAnnotationMarkerWidth match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.annotationMarker.width" -> param.toString
      case _ => queryParams
    }
    cqDamConfigAnnotationPdfAssetMinheight match {
      case Some(param) => queryParams += "cq.dam.config.annotation.pdf.asset.minheight" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplAssetMoveListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplAssetMoveListenerInfo]): Future[ComDayCqDamCoreImplAssetMoveListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.AssetMoveListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplAssethomeAssetHomePageConfiguration(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    isEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo]): Future[ComDayCqDamCoreImplAssethomeAssetHomePageConfigurationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.assethome.AssetHomePageConfiguration"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    isEnabled match {
      case Some(param) => queryParams += "isEnabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamAdhocAssetSharePrezipMaxcontentsize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo]): Future[ComDayCqDamCoreImplAssetlinkshareAdhocAssetShareProxyServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.assetlinkshare.AdhocAssetShareProxyServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamAdhocAssetSharePrezipMaxcontentsize match {
      case Some(param) => queryParams += "cq.dam.adhoc.asset.share.prezip.maxcontentsize" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplCacheCQBufferedImageCache(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamImageCacheMaxMemory: Option[Integer] = None,
    cqDamImageCacheMaxAge: Option[Integer] = None,
    cqDamImageCacheMaxDimension: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo]): Future[ComDayCqDamCoreImplCacheCQBufferedImageCacheInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.cache.CQBufferedImageCache"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamImageCacheMaxMemory match {
      case Some(param) => queryParams += "cq.dam.image.cache.max.memory" -> param.toString
      case _ => queryParams
    }
    cqDamImageCacheMaxAge match {
      case Some(param) => queryParams += "cq.dam.image.cache.max.age" -> param.toString
      case _ => queryParams
    }
    cqDamImageCacheMaxDimension match {
      case Some(param) => queryParams += "cq.dam.image.cache.max.dimension" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplDamChangeEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    changeeventlistenerObservedPaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplDamChangeEventListenerInfo]): Future[ComDayCqDamCoreImplDamChangeEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.DamChangeEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    changeeventlistenerObservedPaths match {
      case Some(param) => queryParams += "changeeventlistener.observed.paths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplDamEventPurgeService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None,
    maxSavedActivities: Option[Integer] = None,
    saveInterval: Option[Integer] = None,
    enableActivityPurge: Option[Boolean] = None,
    eventTypes: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplDamEventPurgeServiceInfo]): Future[ComDayCqDamCoreImplDamEventPurgeServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.DamEventPurgeService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }
    maxSavedActivities match {
      case Some(param) => queryParams += "maxSavedActivities" -> param.toString
      case _ => queryParams
    }
    saveInterval match {
      case Some(param) => queryParams += "saveInterval" -> param.toString
      case _ => queryParams
    }
    enableActivityPurge match {
      case Some(param) => queryParams += "enableActivityPurge" -> param.toString
      case _ => queryParams
    }
    eventTypes match {
      case Some(param) => queryParams += "eventTypes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplDamEventRecorderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventFilter: Option[String] = None,
    eventQueueLength: Option[Integer] = None,
    eventrecorderEnabled: Option[Boolean] = None,
    eventrecorderBlacklist: Option[List[String]] = None,
    eventrecorderEventtypes: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplDamEventRecorderImplInfo]): Future[ComDayCqDamCoreImplDamEventRecorderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.DamEventRecorderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }
    eventQueueLength match {
      case Some(param) => queryParams += "event.queue.length" -> param.toString
      case _ => queryParams
    }
    eventrecorderEnabled match {
      case Some(param) => queryParams += "eventrecorder.enabled" -> param.toString
      case _ => queryParams
    }
    eventrecorderBlacklist match {
      case Some(param) => queryParams += "eventrecorder.blacklist" -> param.toString
      case _ => queryParams
    }
    eventrecorderEventtypes match {
      case Some(param) => queryParams += "eventrecorder.eventtypes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplEventDamEventAuditListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventFilter: Option[String] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplEventDamEventAuditListenerInfo]): Future[ComDayCqDamCoreImplEventDamEventAuditListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.event.DamEventAuditListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplExpiryNotificationJobImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamExpiryNotificationSchedulerIstimebased: Option[Boolean] = None,
    cqDamExpiryNotificationSchedulerTimebasedRule: Option[String] = None,
    cqDamExpiryNotificationSchedulerPeriodRule: Option[Integer] = None,
    sendEmail: Option[Boolean] = None,
    assetExpiredLimit: Option[Integer] = None,
    priorNotificationSeconds: Option[Integer] = None,
    cqDamExpiryNotificationUrlProtocol: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplExpiryNotificationJobImplInfo]): Future[ComDayCqDamCoreImplExpiryNotificationJobImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.ExpiryNotificationJobImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamExpiryNotificationSchedulerIstimebased match {
      case Some(param) => queryParams += "cq.dam.expiry.notification.scheduler.istimebased" -> param.toString
      case _ => queryParams
    }
    cqDamExpiryNotificationSchedulerTimebasedRule match {
      case Some(param) => queryParams += "cq.dam.expiry.notification.scheduler.timebased.rule" -> param.toString
      case _ => queryParams
    }
    cqDamExpiryNotificationSchedulerPeriodRule match {
      case Some(param) => queryParams += "cq.dam.expiry.notification.scheduler.period.rule" -> param.toString
      case _ => queryParams
    }
    sendEmail match {
      case Some(param) => queryParams += "send_email" -> param.toString
      case _ => queryParams
    }
    assetExpiredLimit match {
      case Some(param) => queryParams += "asset_expired_limit" -> param.toString
      case _ => queryParams
    }
    priorNotificationSeconds match {
      case Some(param) => queryParams += "prior_notification_seconds" -> param.toString
      case _ => queryParams
    }
    cqDamExpiryNotificationUrlProtocol match {
      case Some(param) => queryParams += "cq.dam.expiry.notification.url.protocol" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeat(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    isEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo]): Future[ComDayCqDamCoreImplFoldermetadataschemaFolderMetadataSchemaFeatInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.foldermetadataschema.FolderMetadataSchemaFeatureFlag"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    isEnabled match {
      case Some(param) => queryParams += "isEnabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplGfxCommonsGfxRenderer(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    skipBufferedcache: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo]): Future[ComDayCqDamCoreImplGfxCommonsGfxRendererInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.gfx.CommonsGfxRenderer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    skipBufferedcache match {
      case Some(param) => queryParams += "skip.bufferedcache" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplHandlerEPSFormatHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mimetype: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo]): Future[ComDayCqDamCoreImplHandlerEPSFormatHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.handler.EPSFormatHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mimetype match {
      case Some(param) => queryParams += "mimetype" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplHandlerIndesignFormatHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mimetype: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo]): Future[ComDayCqDamCoreImplHandlerIndesignFormatHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.handler.IndesignFormatHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mimetype match {
      case Some(param) => queryParams += "mimetype" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplHandlerJpegHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamEnableExtMetaExtraction: Option[Boolean] = None,
    largeFileThreshold: Option[Integer] = None,
    largeCommentThreshold: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplHandlerJpegHandlerInfo]): Future[ComDayCqDamCoreImplHandlerJpegHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.handler.JpegHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamEnableExtMetaExtraction match {
      case Some(param) => queryParams += "cq.dam.enable.ext.meta.extraction" -> param.toString
      case _ => queryParams
    }
    largeFileThreshold match {
      case Some(param) => queryParams += "large_file_threshold" -> param.toString
      case _ => queryParams
    }
    largeCommentThreshold match {
      case Some(param) => queryParams += "large_comment_threshold" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplHandlerXmpNCommXMPHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    xmphandlerCqFormats: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo]): Future[ComDayCqDamCoreImplHandlerXmpNCommXMPHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.handler.xmp.NCommXMPHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    xmphandlerCqFormats match {
      case Some(param) => queryParams += "xmphandler.cq.formats" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplJmxAssetIndexUpdateMonitor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jmxObjectname: Option[String] = None,
    propertyMeasureEnabled: Option[Boolean] = None,
    propertyName: Option[String] = None,
    propertyMaxWaitMs: Option[Integer] = None,
    propertyMaxRate: Option[Number] = None,
    fulltextMeasureEnabled: Option[Boolean] = None,
    fulltextName: Option[String] = None,
    fulltextMaxWaitMs: Option[Integer] = None,
    fulltextMaxRate: Option[Number] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo]): Future[ComDayCqDamCoreImplJmxAssetIndexUpdateMonitorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetIndexUpdateMonitor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jmxObjectname match {
      case Some(param) => queryParams += "jmx.objectname" -> param.toString
      case _ => queryParams
    }
    propertyMeasureEnabled match {
      case Some(param) => queryParams += "property.measure.enabled" -> param.toString
      case _ => queryParams
    }
    propertyName match {
      case Some(param) => queryParams += "property.name" -> param.toString
      case _ => queryParams
    }
    propertyMaxWaitMs match {
      case Some(param) => queryParams += "property.max.wait.ms" -> param.toString
      case _ => queryParams
    }
    propertyMaxRate match {
      case Some(param) => queryParams += "property.max.rate" -> param.toString
      case _ => queryParams
    }
    fulltextMeasureEnabled match {
      case Some(param) => queryParams += "fulltext.measure.enabled" -> param.toString
      case _ => queryParams
    }
    fulltextName match {
      case Some(param) => queryParams += "fulltext.name" -> param.toString
      case _ => queryParams
    }
    fulltextMaxWaitMs match {
      case Some(param) => queryParams += "fulltext.max.wait.ms" -> param.toString
      case _ => queryParams
    }
    fulltextMaxRate match {
      case Some(param) => queryParams += "fulltext.max.rate" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplJmxAssetMigrationMBeanImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jmxObjectname: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo]): Future[ComDayCqDamCoreImplJmxAssetMigrationMBeanImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetMigrationMBeanImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jmxObjectname match {
      case Some(param) => queryParams += "jmx.objectname" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplJmxAssetUpdateMonitorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jmxObjectname: Option[String] = None,
    active: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo]): Future[ComDayCqDamCoreImplJmxAssetUpdateMonitorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.jmx.AssetUpdateMonitorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jmxObjectname match {
      case Some(param) => queryParams += "jmx.objectname" -> param.toString
      case _ => queryParams
    }
    active match {
      case Some(param) => queryParams += "active" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    operation: Option[String] = None,
    emailEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo]): Future[ComDayCqDamCoreImplJobsMetadataexportAsyncMetadataExportConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.jobs.metadataexport.AsyncMetadataExportConfigProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    operation match {
      case Some(param) => queryParams += "operation" -> param.toString
      case _ => queryParams
    }
    emailEnabled match {
      case Some(param) => queryParams += "emailEnabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    operation: Option[String] = None,
    operationIcon: Option[String] = None,
    topicName: Option[String] = None,
    emailEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo]): Future[ComDayCqDamCoreImplJobsMetadataimportAsyncMetadataImportConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.jobs.metadataimport.AsyncMetadataImportConfigProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    operation match {
      case Some(param) => queryParams += "operation" -> param.toString
      case _ => queryParams
    }
    operationIcon match {
      case Some(param) => queryParams += "operationIcon" -> param.toString
      case _ => queryParams
    }
    topicName match {
      case Some(param) => queryParams += "topicName" -> param.toString
      case _ => queryParams
    }
    emailEnabled match {
      case Some(param) => queryParams += "emailEnabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplLightboxLightboxServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletPaths: Option[String] = None,
    slingServletMethods: Option[List[String]] = None,
    cqDamEnableAnonymous: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplLightboxLightboxServletInfo]): Future[ComDayCqDamCoreImplLightboxLightboxServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.lightbox.LightboxServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletPaths match {
      case Some(param) => queryParams += "sling.servlet.paths" -> param.toString
      case _ => queryParams
    }
    slingServletMethods match {
      case Some(param) => queryParams += "sling.servlet.methods" -> param.toString
      case _ => queryParams
    }
    cqDamEnableAnonymous match {
      case Some(param) => queryParams += "cq.dam.enable.anonymous" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplMetadataEditorSelectComponentHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    granitedata: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo]): Future[ComDayCqDamCoreImplMetadataEditorSelectComponentHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.metadata.editor.SelectComponentHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    granitedata match {
      case Some(param) => queryParams += "granite:data" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelper(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamAllowAllMime: Option[Boolean] = None,
    cqDamAllowedAssetMimes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo]): Future[ComDayCqDamCoreImplMimeTypeAssetUploadRestrictionHelperInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.mimeType.AssetUploadRestrictionHelper"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamAllowAllMime match {
      case Some(param) => queryParams += "cq.dam.allow.all.mime" -> param.toString
      case _ => queryParams
    }
    cqDamAllowedAssetMimes match {
      case Some(param) => queryParams += "cq.dam.allowed.asset.mimes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplMimeTypeDamMimeTypeServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamDetectAssetMimeFromContent: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo]): Future[ComDayCqDamCoreImplMimeTypeDamMimeTypeServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.mimeType.DamMimeTypeServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamDetectAssetMimeFromContent match {
      case Some(param) => queryParams += "cq.dam.detect.asset.mime.from.content" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplMissingMetadataNotificationJob(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamMissingmetadataNotificationSchedulerIstimebased: Option[Boolean] = None,
    cqDamMissingmetadataNotificationSchedulerTimebasedRule: Option[String] = None,
    cqDamMissingmetadataNotificationSchedulerPeriodRule: Option[Integer] = None,
    cqDamMissingmetadataNotificationRecipient: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo]): Future[ComDayCqDamCoreImplMissingMetadataNotificationJobInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.MissingMetadataNotificationJob"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamMissingmetadataNotificationSchedulerIstimebased match {
      case Some(param) => queryParams += "cq.dam.missingmetadata.notification.scheduler.istimebased" -> param.toString
      case _ => queryParams
    }
    cqDamMissingmetadataNotificationSchedulerTimebasedRule match {
      case Some(param) => queryParams += "cq.dam.missingmetadata.notification.scheduler.timebased.rule" -> param.toString
      case _ => queryParams
    }
    cqDamMissingmetadataNotificationSchedulerPeriodRule match {
      case Some(param) => queryParams += "cq.dam.missingmetadata.notification.scheduler.period.rule" -> param.toString
      case _ => queryParams
    }
    cqDamMissingmetadataNotificationRecipient match {
      case Some(param) => queryParams += "cq.dam.missingmetadata.notification.recipient" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPr(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    processLabel: Option[String] = None,
    notifyOnComplete: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo]): Future[ComDayCqDamCoreImplProcessSendTransientWorkflowCompletedEmailPrInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.process.SendTransientWorkflowCompletedEmailProcess"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    processLabel match {
      case Some(param) => queryParams += "process.label" -> param.toString
      case _ => queryParams
    }
    notifyOnComplete match {
      case Some(param) => queryParams += "Notify on Complete" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplProcessTextExtractionProcess(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mimeTypes: Option[List[String]] = None,
    maxExtract: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplProcessTextExtractionProcessInfo]): Future[ComDayCqDamCoreImplProcessTextExtractionProcessInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.process.TextExtractionProcess"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mimeTypes match {
      case Some(param) => queryParams += "mimeTypes" -> param.toString
      case _ => queryParams
    }
    maxExtract match {
      case Some(param) => queryParams += "maxExtract" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplRenditionMakerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    xmpPropagate: Option[Boolean] = None,
    xmpExcludes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplRenditionMakerImplInfo]): Future[ComDayCqDamCoreImplRenditionMakerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.RenditionMakerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    xmpPropagate match {
      case Some(param) => queryParams += "xmp.propagate" -> param.toString
      case _ => queryParams
    }
    xmpExcludes match {
      case Some(param) => queryParams += "xmp.excludes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplReportsReportExportService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    queryBatchSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplReportsReportExportServiceInfo]): Future[ComDayCqDamCoreImplReportsReportExportServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.reports.ReportExportService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    queryBatchSize match {
      case Some(param) => queryParams += "queryBatchSize" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplReportsReportPurgeService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None,
    maxSavedReports: Option[Integer] = None,
    timeDuration: Option[Integer] = None,
    enableReportPurge: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplReportsReportPurgeServiceInfo]): Future[ComDayCqDamCoreImplReportsReportPurgeServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.reports.ReportPurgeService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }
    maxSavedReports match {
      case Some(param) => queryParams += "maxSavedReports" -> param.toString
      case _ => queryParams
    }
    timeDuration match {
      case Some(param) => queryParams += "timeDuration" -> param.toString
      case _ => queryParams
    }
    enableReportPurge match {
      case Some(param) => queryParams += "enableReportPurge" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletAssetDownloadServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletAssetDownloadServletInfo]): Future[ComDayCqDamCoreImplServletAssetDownloadServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetDownloadServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletAssetStatusServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamBatchStatusMaxassets: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletAssetStatusServletInfo]): Future[ComDayCqDamCoreImplServletAssetStatusServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetStatusServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamBatchStatusMaxassets match {
      case Some(param) => queryParams += "cq.dam.batch.status.maxassets" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletAssetXMPSearchServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamBatchIndesignMaxassets: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo]): Future[ComDayCqDamCoreImplServletAssetXMPSearchServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.AssetXMPSearchServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamBatchIndesignMaxassets match {
      case Some(param) => queryParams += "cq.dam.batch.indesign.maxassets" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletBatchMetadataServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamBatchMetadataAssetDefault: Option[List[String]] = None,
    cqDamBatchMetadataCollectionDefault: Option[List[String]] = None,
    cqDamBatchMetadataMaxresources: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletBatchMetadataServletInfo]): Future[ComDayCqDamCoreImplServletBatchMetadataServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.BatchMetadataServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamBatchMetadataAssetDefault match {
      case Some(param) => queryParams += "cq.dam.batch.metadata.asset.default" -> param.toString
      case _ => queryParams
    }
    cqDamBatchMetadataCollectionDefault match {
      case Some(param) => queryParams += "cq.dam.batch.metadata.collection.default" -> param.toString
      case _ => queryParams
    }
    cqDamBatchMetadataMaxresources match {
      case Some(param) => queryParams += "cq.dam.batch.metadata.maxresources" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletBinaryProviderServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletResourceTypes: Option[List[String]] = None,
    slingServletMethods: Option[List[String]] = None,
    cqDamDrmEnable: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletBinaryProviderServletInfo]): Future[ComDayCqDamCoreImplServletBinaryProviderServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.BinaryProviderServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletResourceTypes match {
      case Some(param) => queryParams += "sling.servlet.resourceTypes" -> param.toString
      case _ => queryParams
    }
    slingServletMethods match {
      case Some(param) => queryParams += "sling.servlet.methods" -> param.toString
      case _ => queryParams
    }
    cqDamDrmEnable match {
      case Some(param) => queryParams += "cq.dam.drm.enable" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletCollectionServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamBatchCollectionProperties: Option[List[String]] = None,
    cqDamBatchCollectionMaxcollections: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletCollectionServletInfo]): Future[ComDayCqDamCoreImplServletCollectionServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CollectionServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamBatchCollectionProperties match {
      case Some(param) => queryParams += "cq.dam.batch.collection.properties" -> param.toString
      case _ => queryParams
    }
    cqDamBatchCollectionMaxcollections match {
      case Some(param) => queryParams += "cq.dam.batch.collection.maxcollections" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletCollectionsServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamBatchCollectionsProperties: Option[List[String]] = None,
    cqDamBatchCollectionsLimit: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletCollectionsServletInfo]): Future[ComDayCqDamCoreImplServletCollectionsServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CollectionsServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamBatchCollectionsProperties match {
      case Some(param) => queryParams += "cq.dam.batch.collections.properties" -> param.toString
      case _ => queryParams
    }
    cqDamBatchCollectionsLimit match {
      case Some(param) => queryParams += "cq.dam.batch.collections.limit" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletCompanionServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    moreInfo: Option[String] = None,
    mntoverlaydamguicontentassetsmoreinfoHtmlpath: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletCompanionServletInfo]): Future[ComDayCqDamCoreImplServletCompanionServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CompanionServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    moreInfo match {
      case Some(param) => queryParams += "More Info" -> param.toString
      case _ => queryParams
    }
    mntoverlaydamguicontentassetsmoreinfoHtmlpath match {
      case Some(param) => queryParams += "/mnt/overlay/dam/gui/content/assets/moreinfo.html/${path}" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletCreateAssetServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    detectDuplicate: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletCreateAssetServletInfo]): Future[ComDayCqDamCoreImplServletCreateAssetServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.CreateAssetServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    detectDuplicate match {
      case Some(param) => queryParams += "detect_duplicate" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletDamContentDispositionFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqMimeTypeBlacklist: Option[List[String]] = None,
    cqDamEmptyMime: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo]): Future[ComDayCqDamCoreImplServletDamContentDispositionFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.DamContentDispositionFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqMimeTypeBlacklist match {
      case Some(param) => queryParams += "cq.mime.type.blacklist" -> param.toString
      case _ => queryParams
    }
    cqDamEmptyMime match {
      case Some(param) => queryParams += "cq.dam.empty.mime" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletGuidLookupFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamCoreGuidlookupfilterEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletGuidLookupFilterInfo]): Future[ComDayCqDamCoreImplServletGuidLookupFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.GuidLookupFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamCoreGuidlookupfilterEnabled match {
      case Some(param) => queryParams += "cq.dam.core.guidlookupfilter.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletHealthCheckServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamSyncWorkflowId: Option[String] = None,
    cqDamSyncFolderTypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletHealthCheckServletInfo]): Future[ComDayCqDamCoreImplServletHealthCheckServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.HealthCheckServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamSyncWorkflowId match {
      case Some(param) => queryParams += "cq.dam.sync.workflow.id" -> param.toString
      case _ => queryParams
    }
    cqDamSyncFolderTypes match {
      case Some(param) => queryParams += "cq.dam.sync.folder.types" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletMetadataGetServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletResourceTypes: Option[String] = None,
    slingServletMethods: Option[String] = None,
    slingServletExtensions: Option[String] = None,
    slingServletSelectors: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletMetadataGetServletInfo]): Future[ComDayCqDamCoreImplServletMetadataGetServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.MetadataGetServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletResourceTypes match {
      case Some(param) => queryParams += "sling.servlet.resourceTypes" -> param.toString
      case _ => queryParams
    }
    slingServletMethods match {
      case Some(param) => queryParams += "sling.servlet.methods" -> param.toString
      case _ => queryParams
    }
    slingServletExtensions match {
      case Some(param) => queryParams += "sling.servlet.extensions" -> param.toString
      case _ => queryParams
    }
    slingServletSelectors match {
      case Some(param) => queryParams += "sling.servlet.selectors" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletMultipleLicenseAcceptServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamDrmEnable: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo]): Future[ComDayCqDamCoreImplServletMultipleLicenseAcceptServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.MultipleLicenseAcceptServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamDrmEnable match {
      case Some(param) => queryParams += "cq.dam.drm.enable" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplServletResourceCollectionServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletResourceTypes: Option[List[String]] = None,
    slingServletMethods: Option[String] = None,
    slingServletSelectors: Option[String] = None,
    downloadConfig: Option[String] = None,
    viewSelector: Option[String] = None,
    sendEmail: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplServletResourceCollectionServletInfo]): Future[ComDayCqDamCoreImplServletResourceCollectionServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.servlet.ResourceCollectionServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletResourceTypes match {
      case Some(param) => queryParams += "sling.servlet.resourceTypes" -> param.toString
      case _ => queryParams
    }
    slingServletMethods match {
      case Some(param) => queryParams += "sling.servlet.methods" -> param.toString
      case _ => queryParams
    }
    slingServletSelectors match {
      case Some(param) => queryParams += "sling.servlet.selectors" -> param.toString
      case _ => queryParams
    }
    downloadConfig match {
      case Some(param) => queryParams += "download.config" -> param.toString
      case _ => queryParams
    }
    viewSelector match {
      case Some(param) => queryParams += "view.selector" -> param.toString
      case _ => queryParams
    }
    sendEmail match {
      case Some(param) => queryParams += "send_email" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    createPreviewEnabled: Option[Boolean] = None,
    updatePreviewEnabled: Option[Boolean] = None,
    queueSize: Option[Integer] = None,
    folderPreviewRenditionRegex: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo]): Future[ComDayCqDamCoreImplUiPreviewFolderPreviewUpdaterImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.ui.preview.FolderPreviewUpdaterImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    createPreviewEnabled match {
      case Some(param) => queryParams += "createPreviewEnabled" -> param.toString
      case _ => queryParams
    }
    updatePreviewEnabled match {
      case Some(param) => queryParams += "updatePreviewEnabled" -> param.toString
      case _ => queryParams
    }
    queueSize match {
      case Some(param) => queryParams += "queueSize" -> param.toString
      case _ => queryParams
    }
    folderPreviewRenditionRegex match {
      case Some(param) => queryParams += "folderPreviewRenditionRegex" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreImplUnzipUnzipConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamConfigUnzipMaxuncompressedsize: Option[Integer] = None,
    cqDamConfigUnzipEncoding: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreImplUnzipUnzipConfigInfo]): Future[ComDayCqDamCoreImplUnzipUnzipConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.impl.unzip.UnzipConfig"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamConfigUnzipMaxuncompressedsize match {
      case Some(param) => queryParams += "cq.dam.config.unzip.maxuncompressedsize" -> param.toString
      case _ => queryParams
    }
    cqDamConfigUnzipEncoding match {
      case Some(param) => queryParams += "cq.dam.config.unzip.encoding" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreProcessExifToolExtractMetadataProcess(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    processLabel: Option[String] = None,
    cqDamEnableSha1: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo]): Future[ComDayCqDamCoreProcessExifToolExtractMetadataProcessInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.process.ExifToolExtractMetadataProcess"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    processLabel match {
      case Some(param) => queryParams += "process.label" -> param.toString
      case _ => queryParams
    }
    cqDamEnableSha1 match {
      case Some(param) => queryParams += "cq.dam.enable.sha1" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreProcessExtractMetadataProcess(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    processLabel: Option[String] = None,
    cqDamEnableSha1: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreProcessExtractMetadataProcessInfo]): Future[ComDayCqDamCoreProcessExtractMetadataProcessInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.process.ExtractMetadataProcess"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    processLabel match {
      case Some(param) => queryParams += "process.label" -> param.toString
      case _ => queryParams
    }
    cqDamEnableSha1 match {
      case Some(param) => queryParams += "cq.dam.enable.sha1" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamCoreProcessMetadataProcessorProcess(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    processLabel: Option[String] = None,
    cqDamEnableSha1: Option[Boolean] = None,
    cqDamMetadataXssprotectedProperties: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamCoreProcessMetadataProcessorProcessInfo]): Future[ComDayCqDamCoreProcessMetadataProcessorProcessInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.core.process.MetadataProcessorProcess"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    processLabel match {
      case Some(param) => queryParams += "process.label" -> param.toString
      case _ => queryParams
    }
    cqDamEnableSha1 match {
      case Some(param) => queryParams += "cq.dam.enable.sha1" -> param.toString
      case _ => queryParams
    }
    cqDamMetadataXssprotectedProperties match {
      case Some(param) => queryParams += "cq.dam.metadata.xssprotected.properties" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamHandlerFfmpegLocatorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    executableSearchpath: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamHandlerFfmpegLocatorImplInfo]): Future[ComDayCqDamHandlerFfmpegLocatorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.handler.ffmpeg.LocatorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    executableSearchpath match {
      case Some(param) => queryParams += "executable.searchpath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventFilter: Option[String] = None,
    fontmgrSystemFontDir: Option[List[String]] = None,
    fontmgrAdobeFontDir: Option[String] = None,
    fontmgrCustomerFontDir: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo]): Future[ComDayCqDamHandlerGibsonFontmanagerImplFontManagerServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.handler.gibson.fontmanager.impl.FontManagerServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }
    fontmgrSystemFontDir match {
      case Some(param) => queryParams += "fontmgr.system.font.dir" -> param.toString
      case _ => queryParams
    }
    fontmgrAdobeFontDir match {
      case Some(param) => queryParams += "fontmgr.adobe.font.dir" -> param.toString
      case _ => queryParams
    }
    fontmgrCustomerFontDir match {
      case Some(param) => queryParams += "fontmgr.customer.font.dir" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamHandlerStandardPdfPdfHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    rasterAnnotation: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamHandlerStandardPdfPdfHandlerInfo]): Future[ComDayCqDamHandlerStandardPdfPdfHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.handler.standard.pdf.PdfHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    rasterAnnotation match {
      case Some(param) => queryParams += "raster.annotation" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamHandlerStandardPsPostScriptHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    rasterAnnotation: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo]): Future[ComDayCqDamHandlerStandardPsPostScriptHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.handler.standard.ps.PostScriptHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    rasterAnnotation match {
      case Some(param) => queryParams += "raster.annotation" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamHandlerStandardPsdPsdHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    largeFileThreshold: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamHandlerStandardPsdPsdHandlerInfo]): Future[ComDayCqDamHandlerStandardPsdPsdHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.handler.standard.psd.PsdHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    largeFileThreshold match {
      case Some(param) => queryParams += "large_file_threshold" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamIdsImplIDSJobProcessor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enableMultisession: Option[Boolean] = None,
    idsCcEnable: Option[Boolean] = None,
    enableRetry: Option[Boolean] = None,
    enableRetryScripterror: Option[Boolean] = None,
    externalizerDomainCqhost: Option[String] = None,
    externalizerDomainHttp: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamIdsImplIDSJobProcessorInfo]): Future[ComDayCqDamIdsImplIDSJobProcessorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.ids.impl.IDSJobProcessor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enableMultisession match {
      case Some(param) => queryParams += "enable.multisession" -> param.toString
      case _ => queryParams
    }
    idsCcEnable match {
      case Some(param) => queryParams += "ids.cc.enable" -> param.toString
      case _ => queryParams
    }
    enableRetry match {
      case Some(param) => queryParams += "enable.retry" -> param.toString
      case _ => queryParams
    }
    enableRetryScripterror match {
      case Some(param) => queryParams += "enable.retry.scripterror" -> param.toString
      case _ => queryParams
    }
    externalizerDomainCqhost match {
      case Some(param) => queryParams += "externalizer.domain.cqhost" -> param.toString
      case _ => queryParams
    }
    externalizerDomainHttp match {
      case Some(param) => queryParams += "externalizer.domain.http" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamIdsImplIDSPoolManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxErrorsToBlacklist: Option[Integer] = None,
    retryIntervalToWhitelist: Option[Integer] = None,
    connectTimeout: Option[Integer] = None,
    socketTimeout: Option[Integer] = None,
    processLabel: Option[String] = None,
    connectionUseMax: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamIdsImplIDSPoolManagerImplInfo]): Future[ComDayCqDamIdsImplIDSPoolManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.ids.impl.IDSPoolManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxErrorsToBlacklist match {
      case Some(param) => queryParams += "max.errors.to.blacklist" -> param.toString
      case _ => queryParams
    }
    retryIntervalToWhitelist match {
      case Some(param) => queryParams += "retry.interval.to.whitelist" -> param.toString
      case _ => queryParams
    }
    connectTimeout match {
      case Some(param) => queryParams += "connect.timeout" -> param.toString
      case _ => queryParams
    }
    socketTimeout match {
      case Some(param) => queryParams += "socket.timeout" -> param.toString
      case _ => queryParams
    }
    processLabel match {
      case Some(param) => queryParams += "process.label" -> param.toString
      case _ => queryParams
    }
    connectionUseMax match {
      case Some(param) => queryParams += "connection.use.max" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamInddImplHandlerIndesignXMPHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    processLabel: Option[String] = None,
    extractPages: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo]): Future[ComDayCqDamInddImplHandlerIndesignXMPHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.indd.impl.handler.IndesignXMPHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    processLabel match {
      case Some(param) => queryParams += "process.label" -> param.toString
      case _ => queryParams
    }
    extractPages match {
      case Some(param) => queryParams += "extract.pages" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamInddImplServletSnippetCreationServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    snippetcreationMaxcollections: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamInddImplServletSnippetCreationServletInfo]): Future[ComDayCqDamInddImplServletSnippetCreationServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.indd.impl.servlet.SnippetCreationServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    snippetcreationMaxcollections match {
      case Some(param) => queryParams += "snippetcreation.maxcollections" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamInddProcessINDDMediaExtractProcess(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    processLabel: Option[String] = None,
    cqDamInddPagesRegex: Option[String] = None,
    idsJobDecoupled: Option[Boolean] = None,
    idsJobWorkflowModel: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamInddProcessINDDMediaExtractProcessInfo]): Future[ComDayCqDamInddProcessINDDMediaExtractProcessInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.indd.process.INDDMediaExtractProcess"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    processLabel match {
      case Some(param) => queryParams += "process.label" -> param.toString
      case _ => queryParams
    }
    cqDamInddPagesRegex match {
      case Some(param) => queryParams += "cq.dam.indd.pages.regex" -> param.toString
      case _ => queryParams
    }
    idsJobDecoupled match {
      case Some(param) => queryParams += "ids.job.decoupled" -> param.toString
      case _ => queryParams
    }
    idsJobWorkflowModel match {
      case Some(param) => queryParams += "ids.job.workflow.model" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamPerformanceInternalAssetPerformanceDataHandlerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    batchCommitSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo]): Future[ComDayCqDamPerformanceInternalAssetPerformanceDataHandlerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.performance.internal.AssetPerformanceDataHandlerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    batchCommitSize match {
      case Some(param) => queryParams += "batch.commit.size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamPerformanceInternalAssetPerformanceReportSyncJob(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo]): Future[ComDayCqDamPerformanceInternalAssetPerformanceReportSyncJobInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.performance.internal.AssetPerformanceReportSyncJob"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamPimImplSourcingUploadProcessProductAssetsUploadPro(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    deleteZipFile: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo]): Future[ComDayCqDamPimImplSourcingUploadProcessProductAssetsUploadProInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.pim.impl.sourcing.upload.process.ProductAssetsUploadProcess"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    deleteZipFile match {
      case Some(param) => queryParams += "delete.zip.file" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEven(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamS7damDynamicmediaconfigeventlistenerEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo]): Future[ComDayCqDamS7damCommonAnalyticsImplS7damDynamicMediaConfigEvenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.s7dam.common.analytics.impl.S7damDynamicMediaConfigEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamS7damDynamicmediaconfigeventlistenerEnabled match {
      case Some(param) => queryParams += "cq.dam.s7dam.dynamicmediaconfigeventlistener.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunner(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None,
    schedulerConcurrent: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo]): Future[ComDayCqDamS7damCommonAnalyticsImplSiteCatalystReportRunnerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.s7dam.common.analytics.impl.SiteCatalystReportRunner"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }
    schedulerConcurrent match {
      case Some(param) => queryParams += "scheduler.concurrent" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamS7damCommonPostServletsSetCreateHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingPostOperation: Option[String] = None,
    slingServletMethods: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo]): Future[ComDayCqDamS7damCommonPostServletsSetCreateHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.s7dam.common.post.servlets.SetCreateHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingPostOperation match {
      case Some(param) => queryParams += "sling.post.operation" -> param.toString
      case _ => queryParams
    }
    slingServletMethods match {
      case Some(param) => queryParams += "sling.servlet.methods" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamS7damCommonPostServletsSetModifyHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingPostOperation: Option[String] = None,
    slingServletMethods: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo]): Future[ComDayCqDamS7damCommonPostServletsSetModifyHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.s7dam.common.post.servlets.SetModifyHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingPostOperation match {
      case Some(param) => queryParams += "sling.post.operation" -> param.toString
      case _ => queryParams
    }
    slingServletMethods match {
      case Some(param) => queryParams += "sling.servlet.methods" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamS7damCommonProcessVideoThumbnailDownloadProcess(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    processLabel: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo]): Future[ComDayCqDamS7damCommonProcessVideoThumbnailDownloadProcessInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.s7dam.common.process.VideoThumbnailDownloadProcess"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    processLabel match {
      case Some(param) => queryParams += "process.label" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamS7damCommonS7damDamChangeEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamS7damDamchangeeventlistenerEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo]): Future[ComDayCqDamS7damCommonS7damDamChangeEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.s7dam.common.S7damDamChangeEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamS7damDamchangeeventlistenerEnabled match {
      case Some(param) => queryParams += "cq.dam.s7dam.damchangeeventlistener.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamS7damCommonServletsS7damProductInfoServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletPaths: Option[String] = None,
    slingServletMethods: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo]): Future[ComDayCqDamS7damCommonServletsS7damProductInfoServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.s7dam.common.servlets.S7damProductInfoServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletPaths match {
      case Some(param) => queryParams += "sling.servlet.paths" -> param.toString
      case _ => queryParams
    }
    slingServletMethods match {
      case Some(param) => queryParams += "sling.servlet.methods" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamS7damCommonVideoImplVideoProxyClientServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName: Option[Integer] = None,
    cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName: Option[Integer] = None,
    cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName: Option[Integer] = None,
    cqDamS7damVideoproxyclientserviceHttpReadtimeoutName: Option[Integer] = None,
    cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName: Option[Integer] = None,
    cqDamS7damVideoproxyclientserviceHttpMaxretrycountName: Option[Integer] = None,
    cqDamS7damVideoproxyclientserviceUploadprogressIntervalName: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo]): Future[ComDayCqDamS7damCommonVideoImplVideoProxyClientServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.s7dam.common.video.impl.VideoProxyClientServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamS7damVideoproxyclientserviceMultipartuploadMinsizeName match {
      case Some(param) => queryParams += "cq.dam.s7dam.videoproxyclientservice.multipartupload.minsize.name" -> param.toString
      case _ => queryParams
    }
    cqDamS7damVideoproxyclientserviceMultipartuploadPartsizeName match {
      case Some(param) => queryParams += "cq.dam.s7dam.videoproxyclientservice.multipartupload.partsize.name" -> param.toString
      case _ => queryParams
    }
    cqDamS7damVideoproxyclientserviceMultipartuploadNumthreadName match {
      case Some(param) => queryParams += "cq.dam.s7dam.videoproxyclientservice.multipartupload.numthread.name" -> param.toString
      case _ => queryParams
    }
    cqDamS7damVideoproxyclientserviceHttpReadtimeoutName match {
      case Some(param) => queryParams += "cq.dam.s7dam.videoproxyclientservice.http.readtimeout.name" -> param.toString
      case _ => queryParams
    }
    cqDamS7damVideoproxyclientserviceHttpConnectiontimeoutName match {
      case Some(param) => queryParams += "cq.dam.s7dam.videoproxyclientservice.http.connectiontimeout.name" -> param.toString
      case _ => queryParams
    }
    cqDamS7damVideoproxyclientserviceHttpMaxretrycountName match {
      case Some(param) => queryParams += "cq.dam.s7dam.videoproxyclientservice.http.maxretrycount.name" -> param.toString
      case _ => queryParams
    }
    cqDamS7damVideoproxyclientserviceUploadprogressIntervalName match {
      case Some(param) => queryParams += "cq.dam.s7dam.videoproxyclientservice.uploadprogress.interval.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamScene7ImplScene7APIClientImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamScene7ApiclientRecordsperpageNofilterName: Option[Integer] = None,
    cqDamScene7ApiclientRecordsperpageWithfilterName: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamScene7ImplScene7APIClientImplInfo]): Future[ComDayCqDamScene7ImplScene7APIClientImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7APIClientImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamScene7ApiclientRecordsperpageNofilterName match {
      case Some(param) => queryParams += "cq.dam.scene7.apiclient.recordsperpage.nofilter.name" -> param.toString
      case _ => queryParams
    }
    cqDamScene7ApiclientRecordsperpageWithfilterName match {
      case Some(param) => queryParams += "cq.dam.scene7.apiclient.recordsperpage.withfilter.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamScene7ImplScene7AssetMimeTypeServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamScene7AssetmimetypeserviceMapping: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo]): Future[ComDayCqDamScene7ImplScene7AssetMimeTypeServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7AssetMimeTypeServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamScene7AssetmimetypeserviceMapping match {
      case Some(param) => queryParams += "cq.dam.scene7.assetmimetypeservice.mapping" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamScene7ImplScene7ConfigurationEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamScene7ConfigurationeventlistenerEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo]): Future[ComDayCqDamScene7ImplScene7ConfigurationEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7ConfigurationEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamScene7ConfigurationeventlistenerEnabled match {
      case Some(param) => queryParams += "cq.dam.scene7.configurationeventlistener.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamScene7ImplScene7DamChangeEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamScene7DamchangeeventlistenerEnabled: Option[Boolean] = None,
    cqDamScene7DamchangeeventlistenerObservedPaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo]): Future[ComDayCqDamScene7ImplScene7DamChangeEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7DamChangeEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamScene7DamchangeeventlistenerEnabled match {
      case Some(param) => queryParams += "cq.dam.scene7.damchangeeventlistener.enabled" -> param.toString
      case _ => queryParams
    }
    cqDamScene7DamchangeeventlistenerObservedPaths match {
      case Some(param) => queryParams += "cq.dam.scene7.damchangeeventlistener.observed.paths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamScene7ImplScene7FlashTemplatesServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    scene7FlashTemplatesRti: Option[String] = None,
    scene7FlashTemplatesRsi: Option[String] = None,
    scene7FlashTemplatesRb: Option[String] = None,
    scene7FlashTemplatesRurl: Option[String] = None,
    scene7FlashTemplateUrlFormatParameter: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo]): Future[ComDayCqDamScene7ImplScene7FlashTemplatesServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7FlashTemplatesServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    scene7FlashTemplatesRti match {
      case Some(param) => queryParams += "scene7FlashTemplates.rti" -> param.toString
      case _ => queryParams
    }
    scene7FlashTemplatesRsi match {
      case Some(param) => queryParams += "scene7FlashTemplates.rsi" -> param.toString
      case _ => queryParams
    }
    scene7FlashTemplatesRb match {
      case Some(param) => queryParams += "scene7FlashTemplates.rb" -> param.toString
      case _ => queryParams
    }
    scene7FlashTemplatesRurl match {
      case Some(param) => queryParams += "scene7FlashTemplates.rurl" -> param.toString
      case _ => queryParams
    }
    scene7FlashTemplateUrlFormatParameter match {
      case Some(param) => queryParams += "scene7FlashTemplate.urlFormatParameter" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamScene7ImplScene7UploadServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqDamScene7UploadserviceActivejobtimeoutLabel: Option[Integer] = None,
    cqDamScene7UploadserviceConnectionmaxperrouteLabel: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamScene7ImplScene7UploadServiceImplInfo]): Future[ComDayCqDamScene7ImplScene7UploadServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.scene7.impl.Scene7UploadServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqDamScene7UploadserviceActivejobtimeoutLabel match {
      case Some(param) => queryParams += "cq.dam.scene7.uploadservice.activejobtimeout.label" -> param.toString
      case _ => queryParams
    }
    cqDamScene7UploadserviceConnectionmaxperrouteLabel match {
      case Some(param) => queryParams += "cq.dam.scene7.uploadservice.connectionmaxperroute.label" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamStockIntegrationImplCacheStockCacheConfigurationSer(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    getCacheExpirationUnit: Option[String] = None,
    getCacheExpirationValue: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo]): Future[ComDayCqDamStockIntegrationImplCacheStockCacheConfigurationSerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.stock.integration.impl.cache.StockCacheConfigurationServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    getCacheExpirationUnit match {
      case Some(param) => queryParams += "getCacheExpirationUnit" -> param.toString
      case _ => queryParams
    }
    getCacheExpirationValue match {
      case Some(param) => queryParams += "getCacheExpirationValue" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamStockIntegrationImplConfigurationStockConfiguration(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    locale: Option[String] = None,
    imsConfig: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo]): Future[ComDayCqDamStockIntegrationImplConfigurationStockConfigurationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.stock.integration.impl.configuration.StockConfigurationImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    locale match {
      case Some(param) => queryParams += "locale" -> param.toString
      case _ => queryParams
    }
    imsConfig match {
      case Some(param) => queryParams += "imsConfig" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqDamVideoImplServletVideoTestServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqDamVideoImplServletVideoTestServletInfo]): Future[ComDayCqDamVideoImplServletVideoTestServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.dam.video.impl.servlet.VideoTestServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqExtwidgetServletsImageSpriteServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxWidth: Option[Integer] = None,
    maxHeight: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqExtwidgetServletsImageSpriteServletInfo]): Future[ComDayCqExtwidgetServletsImageSpriteServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.extwidget.servlets.ImageSpriteServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxWidth match {
      case Some(param) => queryParams += "maxWidth" -> param.toString
      case _ => queryParams
    }
    maxHeight match {
      case Some(param) => queryParams += "maxHeight" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqImageInternalFontFontHelper(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fontpath: Option[List[String]] = None,
    oversamplingFactor: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqImageInternalFontFontHelperInfo]): Future[ComDayCqImageInternalFontFontHelperInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.image.internal.font.FontHelper"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fontpath match {
      case Some(param) => queryParams += "fontpath" -> param.toString
      case _ => queryParams
    }
    oversamplingFactor match {
      case Some(param) => queryParams += "oversamplingFactor" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqJcrclustersupportClusterStartLevelController(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    clusterLevelEnable: Option[Boolean] = None,
    clusterMasterLevel: Option[Integer] = None,
    clusterSlaveLevel: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqJcrclustersupportClusterStartLevelControllerInfo]): Future[ComDayCqJcrclustersupportClusterStartLevelControllerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.jcrclustersupport.ClusterStartLevelController"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    clusterLevelEnable match {
      case Some(param) => queryParams += "cluster.level.enable" -> param.toString
      case _ => queryParams
    }
    clusterMasterLevel match {
      case Some(param) => queryParams += "cluster.master.level" -> param.toString
      case _ => queryParams
    }
    clusterSlaveLevel match {
      case Some(param) => queryParams += "cluster.slave.level" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMailerDefaultMailService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    smtpHost: Option[String] = None,
    smtpPort: Option[Integer] = None,
    smtpUser: Option[String] = None,
    smtpPassword: Option[String] = None,
    fromAddress: Option[String] = None,
    smtpSsl: Option[Boolean] = None,
    smtpStarttls: Option[Boolean] = None,
    debugEmail: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqMailerDefaultMailServiceInfo]): Future[ComDayCqMailerDefaultMailServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mailer.DefaultMailService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    smtpHost match {
      case Some(param) => queryParams += "smtp.host" -> param.toString
      case _ => queryParams
    }
    smtpPort match {
      case Some(param) => queryParams += "smtp.port" -> param.toString
      case _ => queryParams
    }
    smtpUser match {
      case Some(param) => queryParams += "smtp.user" -> param.toString
      case _ => queryParams
    }
    smtpPassword match {
      case Some(param) => queryParams += "smtp.password" -> param.toString
      case _ => queryParams
    }
    fromAddress match {
      case Some(param) => queryParams += "from.address" -> param.toString
      case _ => queryParams
    }
    smtpSsl match {
      case Some(param) => queryParams += "smtp.ssl" -> param.toString
      case _ => queryParams
    }
    smtpStarttls match {
      case Some(param) => queryParams += "smtp.starttls" -> param.toString
      case _ => queryParams
    }
    debugEmail match {
      case Some(param) => queryParams += "debug.email" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMailerImplCqMailingService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxRecipientCount: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqMailerImplCqMailingServiceInfo]): Future[ComDayCqMailerImplCqMailingServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mailer.impl.CqMailingService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxRecipientCount match {
      case Some(param) => queryParams += "max.recipient.count" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMailerImplEmailCqEmailTemplateFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mailerEmailCharset: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo]): Future[ComDayCqMailerImplEmailCqEmailTemplateFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mailer.impl.email.CqEmailTemplateFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mailerEmailCharset match {
      case Some(param) => queryParams += "mailer.email.charset" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMailerImplEmailCqRetrieverTemplateFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mailerEmailEmbed: Option[Boolean] = None,
    mailerEmailCharset: Option[String] = None,
    mailerEmailRetrieverUserID: Option[String] = None,
    mailerEmailRetrieverUserPWD: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo]): Future[ComDayCqMailerImplEmailCqRetrieverTemplateFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mailer.impl.email.CqRetrieverTemplateFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mailerEmailEmbed match {
      case Some(param) => queryParams += "mailer.email.embed" -> param.toString
      case _ => queryParams
    }
    mailerEmailCharset match {
      case Some(param) => queryParams += "mailer.email.charset" -> param.toString
      case _ => queryParams
    }
    mailerEmailRetrieverUserID match {
      case Some(param) => queryParams += "mailer.email.retrieverUserID" -> param.toString
      case _ => queryParams
    }
    mailerEmailRetrieverUserPWD match {
      case Some(param) => queryParams += "mailer.email.retrieverUserPWD" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMcmCampaignImplIntegrationConfigImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    aemMcmCampaignFormConstraints: Option[List[String]] = None,
    aemMcmCampaignPublicUrl: Option[String] = None,
    aemMcmCampaignRelaxedSSL: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqMcmCampaignImplIntegrationConfigImplInfo]): Future[ComDayCqMcmCampaignImplIntegrationConfigImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mcm.campaign.impl.IntegrationConfigImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    aemMcmCampaignFormConstraints match {
      case Some(param) => queryParams += "aem.mcm.campaign.formConstraints" -> param.toString
      case _ => queryParams
    }
    aemMcmCampaignPublicUrl match {
      case Some(param) => queryParams += "aem.mcm.campaign.publicUrl" -> param.toString
      case _ => queryParams
    }
    aemMcmCampaignRelaxedSSL match {
      case Some(param) => queryParams += "aem.mcm.campaign.relaxedSSL" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMcmCampaignImporterPersonalizedTextHandlerFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo]): Future[ComDayCqMcmCampaignImporterPersonalizedTextHandlerFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mcm.campaign.importer.PersonalizedTextHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMcmCoreNewsletterNewsletterEmailServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fromAddress: Option[String] = None,
    senderHost: Option[String] = None,
    maxBounceCount: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo]): Future[ComDayCqMcmCoreNewsletterNewsletterEmailServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mcm.core.newsletter.NewsletterEmailServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fromAddress match {
      case Some(param) => queryParams += "from.address" -> param.toString
      case _ => queryParams
    }
    senderHost match {
      case Some(param) => queryParams += "sender.host" -> param.toString
      case _ => queryParams
    }
    maxBounceCount match {
      case Some(param) => queryParams += "max.bounce.count" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMcmImplMCMConfiguration(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    experienceIndirection: Option[List[String]] = None,
    touchpointIndirection: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqMcmImplMCMConfigurationInfo]): Future[ComDayCqMcmImplMCMConfigurationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mcm.impl.MCMConfiguration"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    experienceIndirection match {
      case Some(param) => queryParams += "experience.indirection" -> param.toString
      case _ => queryParams
    }
    touchpointIndirection match {
      case Some(param) => queryParams += "touchpoint.indirection" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponen(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None,
    componentResourceType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo]): Future[ComDayCqMcmLandingpageParserTaghandlersCtaClickThroughComponenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.ClickThroughComponentTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }
    componentResourceType match {
      case Some(param) => queryParams += "component.resourceType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThroug(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None,
    componentResourceType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo]): Future[ComDayCqMcmLandingpageParserTaghandlersCtaGraphicalClickThrougInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.GraphicalClickThroughComponentTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }
    componentResourceType match {
      case Some(param) => queryParams += "component.resourceType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponent(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo]): Future[ComDayCqMcmLandingpageParserTaghandlersCtaLeadFormCTAComponentInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.cta.LeadFormCTAComponentTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHa(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo]): Future[ComDayCqMcmLandingpageParserTaghandlersMboxMBoxExperienceTagHaInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.mbox.MBoxExperienceTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagH(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None,
    componentResourceType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo]): Future[ComDayCqMcmLandingpageParserTaghandlersMboxTargetComponentTagHInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.mcm.landingpage.parser.taghandlers.mbox.TargetComponentTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }
    componentResourceType match {
      case Some(param) => queryParams += "component.resourceType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqNotificationImplNotificationServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventFilter: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqNotificationImplNotificationServiceImplInfo]): Future[ComDayCqNotificationImplNotificationServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.notification.impl.NotificationServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqPersonalizationImplServletsTargetingConfigurationServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    forcelocation: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo]): Future[ComDayCqPersonalizationImplServletsTargetingConfigurationServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.personalization.impl.servlets.TargetingConfigurationServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    forcelocation match {
      case Some(param) => queryParams += "forcelocation" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqPollingImporterImplManagedPollConfigImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    id: Option[String] = None,
    enabled: Option[Boolean] = None,
    reference: Option[Boolean] = None,
    interval: Option[Integer] = None,
    expression: Option[String] = None,
    source: Option[String] = None,
    target: Option[String] = None,
    login: Option[String] = None,
    password: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqPollingImporterImplManagedPollConfigImplInfo]): Future[ComDayCqPollingImporterImplManagedPollConfigImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.polling.importer.impl.ManagedPollConfigImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    id match {
      case Some(param) => queryParams += "id" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    reference match {
      case Some(param) => queryParams += "reference" -> param.toString
      case _ => queryParams
    }
    interval match {
      case Some(param) => queryParams += "interval" -> param.toString
      case _ => queryParams
    }
    expression match {
      case Some(param) => queryParams += "expression" -> param.toString
      case _ => queryParams
    }
    source match {
      case Some(param) => queryParams += "source" -> param.toString
      case _ => queryParams
    }
    target match {
      case Some(param) => queryParams += "target" -> param.toString
      case _ => queryParams
    }
    login match {
      case Some(param) => queryParams += "login" -> param.toString
      case _ => queryParams
    }
    password match {
      case Some(param) => queryParams += "password" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqPollingImporterImplManagedPollingImporterImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    importerUser: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqPollingImporterImplManagedPollingImporterImplInfo]): Future[ComDayCqPollingImporterImplManagedPollingImporterImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.polling.importer.impl.ManagedPollingImporterImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    importerUser match {
      case Some(param) => queryParams += "importer.user" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqPollingImporterImplPollingImporterImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    importerMinInterval: Option[Integer] = None,
    importerUser: Option[String] = None,
    excludePaths: Option[List[String]] = None,
    includePaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqPollingImporterImplPollingImporterImplInfo]): Future[ComDayCqPollingImporterImplPollingImporterImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.polling.importer.impl.PollingImporterImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    importerMinInterval match {
      case Some(param) => queryParams += "importer.min.interval" -> param.toString
      case _ => queryParams
    }
    importerUser match {
      case Some(param) => queryParams += "importer.user" -> param.toString
      case _ => queryParams
    }
    excludePaths match {
      case Some(param) => queryParams += "exclude.paths" -> param.toString
      case _ => queryParams
    }
    includePaths match {
      case Some(param) => queryParams += "include.paths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationAuditReplicationEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationAuditReplicationEventListenerInfo]): Future[ComDayCqReplicationAuditReplicationEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.audit.ReplicationEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationContentStaticContentBuilder(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    host: Option[String] = None,
    port: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationContentStaticContentBuilderInfo]): Future[ComDayCqReplicationContentStaticContentBuilderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.content.StaticContentBuilder"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    host match {
      case Some(param) => queryParams += "host" -> param.toString
      case _ => queryParams
    }
    port match {
      case Some(param) => queryParams += "port" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationImplAgentManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jobTopics: Option[String] = None,
    serviceUserTarget: Option[String] = None,
    agentProviderTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationImplAgentManagerImplInfo]): Future[ComDayCqReplicationImplAgentManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.impl.AgentManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jobTopics match {
      case Some(param) => queryParams += "job.topics" -> param.toString
      case _ => queryParams
    }
    serviceUserTarget match {
      case Some(param) => queryParams += "serviceUser.target" -> param.toString
      case _ => queryParams
    }
    agentProviderTarget match {
      case Some(param) => queryParams += "agentProvider.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationImplContentDurboBinaryLessContentBuilder(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    binaryThreshold: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo]): Future[ComDayCqReplicationImplContentDurboBinaryLessContentBuilderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.impl.content.durbo.BinaryLessContentBuilder"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    binaryThreshold match {
      case Some(param) => queryParams += "binary.threshold" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationImplContentDurboDurboImportConfigurationProv(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    preserveHierarchyNodes: Option[Boolean] = None,
    ignoreVersioning: Option[Boolean] = None,
    importAcl: Option[Boolean] = None,
    saveThreshold: Option[Integer] = None,
    preserveUserPaths: Option[Boolean] = None,
    preserveUuid: Option[Boolean] = None,
    preserveUuidNodetypes: Option[List[String]] = None,
    preserveUuidSubtrees: Option[List[String]] = None,
    autoCommit: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo]): Future[ComDayCqReplicationImplContentDurboDurboImportConfigurationProvInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.impl.content.durbo.DurboImportConfigurationProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    preserveHierarchyNodes match {
      case Some(param) => queryParams += "preserve.hierarchy.nodes" -> param.toString
      case _ => queryParams
    }
    ignoreVersioning match {
      case Some(param) => queryParams += "ignore.versioning" -> param.toString
      case _ => queryParams
    }
    importAcl match {
      case Some(param) => queryParams += "import.acl" -> param.toString
      case _ => queryParams
    }
    saveThreshold match {
      case Some(param) => queryParams += "save.threshold" -> param.toString
      case _ => queryParams
    }
    preserveUserPaths match {
      case Some(param) => queryParams += "preserve.user.paths" -> param.toString
      case _ => queryParams
    }
    preserveUuid match {
      case Some(param) => queryParams += "preserve.uuid" -> param.toString
      case _ => queryParams
    }
    preserveUuidNodetypes match {
      case Some(param) => queryParams += "preserve.uuid.nodetypes" -> param.toString
      case _ => queryParams
    }
    preserveUuidSubtrees match {
      case Some(param) => queryParams += "preserve.uuid.subtrees" -> param.toString
      case _ => queryParams
    }
    autoCommit match {
      case Some(param) => queryParams += "auto.commit" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationImplReplicationContentFactoryProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    replicationContentUseFileStorage: Option[Boolean] = None,
    replicationContentMaxCommitAttempts: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo]): Future[ComDayCqReplicationImplReplicationContentFactoryProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.impl.ReplicationContentFactoryProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    replicationContentUseFileStorage match {
      case Some(param) => queryParams += "replication.content.useFileStorage" -> param.toString
      case _ => queryParams
    }
    replicationContentMaxCommitAttempts match {
      case Some(param) => queryParams += "replication.content.maxCommitAttempts" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationImplReplicationReceiverImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    receiverTmpfileThreshold: Option[Integer] = None,
    receiverPackagesUseInstall: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationImplReplicationReceiverImplInfo]): Future[ComDayCqReplicationImplReplicationReceiverImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.impl.ReplicationReceiverImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    receiverTmpfileThreshold match {
      case Some(param) => queryParams += "receiver.tmpfile.threshold" -> param.toString
      case _ => queryParams
    }
    receiverPackagesUseInstall match {
      case Some(param) => queryParams += "receiver.packages.use.install" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationImplReplicatorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    distributeEvents: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationImplReplicatorImplInfo]): Future[ComDayCqReplicationImplReplicatorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.impl.ReplicatorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    distributeEvents match {
      case Some(param) => queryParams += "distribute_events" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationImplReverseReplicator(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerPeriod: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationImplReverseReplicatorInfo]): Future[ComDayCqReplicationImplReverseReplicatorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.impl.ReverseReplicator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerPeriod match {
      case Some(param) => queryParams += "scheduler.period" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationImplTransportBinaryLessTransportHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    disabledCipherSuites: Option[List[String]] = None,
    enabledCipherSuites: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo]): Future[ComDayCqReplicationImplTransportBinaryLessTransportHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.impl.transport.BinaryLessTransportHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    disabledCipherSuites match {
      case Some(param) => queryParams += "disabled.cipher.suites" -> param.toString
      case _ => queryParams
    }
    enabledCipherSuites match {
      case Some(param) => queryParams += "enabled.cipher.suites" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReplicationImplTransportHttp(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    disabledCipherSuites: Option[List[String]] = None,
    enabledCipherSuites: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqReplicationImplTransportHttpInfo]): Future[ComDayCqReplicationImplTransportHttpInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.replication.impl.transport.Http"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    disabledCipherSuites match {
      case Some(param) => queryParams += "disabled.cipher.suites" -> param.toString
      case _ => queryParams
    }
    enabledCipherSuites match {
      case Some(param) => queryParams += "enabled.cipher.suites" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReportingImplCacheCacheImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    repcacheEnable: Option[Boolean] = None,
    repcacheTtl: Option[Integer] = None,
    repcacheMax: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqReportingImplCacheCacheImplInfo]): Future[ComDayCqReportingImplCacheCacheImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.reporting.impl.cache.CacheImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    repcacheEnable match {
      case Some(param) => queryParams += "repcache.enable" -> param.toString
      case _ => queryParams
    }
    repcacheTtl match {
      case Some(param) => queryParams += "repcache.ttl" -> param.toString
      case _ => queryParams
    }
    repcacheMax match {
      case Some(param) => queryParams += "repcache.max" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReportingImplConfigServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    repconfTimezone: Option[String] = None,
    repconfLocale: Option[String] = None,
    repconfSnapshots: Option[String] = None,
    repconfRepdir: Option[String] = None,
    repconfHourofday: Option[Integer] = None,
    repconfMinofhour: Option[Integer] = None,
    repconfMaxrows: Option[Integer] = None,
    repconfFakedata: Option[Boolean] = None,
    repconfSnapshotuser: Option[String] = None,
    repconfEnforcesnapshotuser: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqReportingImplConfigServiceImplInfo]): Future[ComDayCqReportingImplConfigServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.reporting.impl.ConfigServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    repconfTimezone match {
      case Some(param) => queryParams += "repconf.timezone" -> param.toString
      case _ => queryParams
    }
    repconfLocale match {
      case Some(param) => queryParams += "repconf.locale" -> param.toString
      case _ => queryParams
    }
    repconfSnapshots match {
      case Some(param) => queryParams += "repconf.snapshots" -> param.toString
      case _ => queryParams
    }
    repconfRepdir match {
      case Some(param) => queryParams += "repconf.repdir" -> param.toString
      case _ => queryParams
    }
    repconfHourofday match {
      case Some(param) => queryParams += "repconf.hourofday" -> param.toString
      case _ => queryParams
    }
    repconfMinofhour match {
      case Some(param) => queryParams += "repconf.minofhour" -> param.toString
      case _ => queryParams
    }
    repconfMaxrows match {
      case Some(param) => queryParams += "repconf.maxrows" -> param.toString
      case _ => queryParams
    }
    repconfFakedata match {
      case Some(param) => queryParams += "repconf.fakedata" -> param.toString
      case _ => queryParams
    }
    repconfSnapshotuser match {
      case Some(param) => queryParams += "repconf.snapshotuser" -> param.toString
      case _ => queryParams
    }
    repconfEnforcesnapshotuser match {
      case Some(param) => queryParams += "repconf.enforcesnapshotuser" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqReportingImplRLogAnalyzer(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    requestLogOutput: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqReportingImplRLogAnalyzerInfo]): Future[ComDayCqReportingImplRLogAnalyzerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.reporting.impl.RLogAnalyzer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    requestLogOutput match {
      case Some(param) => queryParams += "request.log.output" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqRewriterLinkcheckerImplLinkCheckerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerPeriod: Option[Integer] = None,
    schedulerConcurrent: Option[Boolean] = None,
    serviceBadLinkToleranceInterval: Option[Integer] = None,
    serviceCheckOverridePatterns: Option[List[String]] = None,
    serviceCacheBrokenInternalLinks: Option[Boolean] = None,
    serviceSpecialLinkPrefix: Option[List[String]] = None,
    serviceSpecialLinkPatterns: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo]): Future[ComDayCqRewriterLinkcheckerImplLinkCheckerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerPeriod match {
      case Some(param) => queryParams += "scheduler.period" -> param.toString
      case _ => queryParams
    }
    schedulerConcurrent match {
      case Some(param) => queryParams += "scheduler.concurrent" -> param.toString
      case _ => queryParams
    }
    serviceBadLinkToleranceInterval match {
      case Some(param) => queryParams += "service.bad_link_tolerance_interval" -> param.toString
      case _ => queryParams
    }
    serviceCheckOverridePatterns match {
      case Some(param) => queryParams += "service.check_override_patterns" -> param.toString
      case _ => queryParams
    }
    serviceCacheBrokenInternalLinks match {
      case Some(param) => queryParams += "service.cache_broken_internal_links" -> param.toString
      case _ => queryParams
    }
    serviceSpecialLinkPrefix match {
      case Some(param) => queryParams += "service.special_link_prefix" -> param.toString
      case _ => queryParams
    }
    serviceSpecialLinkPatterns match {
      case Some(param) => queryParams += "service.special_link_patterns" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqRewriterLinkcheckerImplLinkCheckerTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerPeriod: Option[Integer] = None,
    schedulerConcurrent: Option[Boolean] = None,
    goodLinkTestInterval: Option[Integer] = None,
    badLinkTestInterval: Option[Integer] = None,
    linkUnusedInterval: Option[Integer] = None,
    connectionTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo]): Future[ComDayCqRewriterLinkcheckerImplLinkCheckerTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerPeriod match {
      case Some(param) => queryParams += "scheduler.period" -> param.toString
      case _ => queryParams
    }
    schedulerConcurrent match {
      case Some(param) => queryParams += "scheduler.concurrent" -> param.toString
      case _ => queryParams
    }
    goodLinkTestInterval match {
      case Some(param) => queryParams += "good_link_test_interval" -> param.toString
      case _ => queryParams
    }
    badLinkTestInterval match {
      case Some(param) => queryParams += "bad_link_test_interval" -> param.toString
      case _ => queryParams
    }
    linkUnusedInterval match {
      case Some(param) => queryParams += "link_unused_interval" -> param.toString
      case _ => queryParams
    }
    connectionTimeout match {
      case Some(param) => queryParams += "connection.timeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    linkcheckertransformerDisableRewriting: Option[Boolean] = None,
    linkcheckertransformerDisableChecking: Option[Boolean] = None,
    linkcheckertransformerMapCacheSize: Option[Integer] = None,
    linkcheckertransformerStrictExtensionCheck: Option[Boolean] = None,
    linkcheckertransformerStripHtmltExtension: Option[Boolean] = None,
    linkcheckertransformerRewriteElements: Option[List[String]] = None,
    linkcheckertransformerStripExtensionPathBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo]): Future[ComDayCqRewriterLinkcheckerImplLinkCheckerTransformerFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkCheckerTransformerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    linkcheckertransformerDisableRewriting match {
      case Some(param) => queryParams += "linkcheckertransformer.disableRewriting" -> param.toString
      case _ => queryParams
    }
    linkcheckertransformerDisableChecking match {
      case Some(param) => queryParams += "linkcheckertransformer.disableChecking" -> param.toString
      case _ => queryParams
    }
    linkcheckertransformerMapCacheSize match {
      case Some(param) => queryParams += "linkcheckertransformer.mapCacheSize" -> param.toString
      case _ => queryParams
    }
    linkcheckertransformerStrictExtensionCheck match {
      case Some(param) => queryParams += "linkcheckertransformer.strictExtensionCheck" -> param.toString
      case _ => queryParams
    }
    linkcheckertransformerStripHtmltExtension match {
      case Some(param) => queryParams += "linkcheckertransformer.stripHtmltExtension" -> param.toString
      case _ => queryParams
    }
    linkcheckertransformerRewriteElements match {
      case Some(param) => queryParams += "linkcheckertransformer.rewriteElements" -> param.toString
      case _ => queryParams
    }
    linkcheckertransformerStripExtensionPathBlacklist match {
      case Some(param) => queryParams += "linkcheckertransformer.stripExtensionPathBlacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqRewriterLinkcheckerImplLinkInfoStorageImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceMaxLinksPerHost: Option[Integer] = None,
    serviceSaveExternalLinkReferences: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo]): Future[ComDayCqRewriterLinkcheckerImplLinkInfoStorageImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.rewriter.linkchecker.impl.LinkInfoStorageImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceMaxLinksPerHost match {
      case Some(param) => queryParams += "service.max_links_per_host" -> param.toString
      case _ => queryParams
    }
    serviceSaveExternalLinkReferences match {
      case Some(param) => queryParams += "service.save_external_link_references" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqRewriterProcessorImplHtmlParserFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    htmlparserProcessTags: Option[List[String]] = None,
    htmlparserPreserveCamelCase: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo]): Future[ComDayCqRewriterProcessorImplHtmlParserFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.rewriter.processor.impl.HtmlParserFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    htmlparserProcessTags match {
      case Some(param) => queryParams += "htmlparser.processTags" -> param.toString
      case _ => queryParams
    }
    htmlparserPreserveCamelCase match {
      case Some(param) => queryParams += "htmlparser.preserveCamelCase" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqSearchImplBuilderQueryBuilderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    excerptProperties: Option[List[String]] = None,
    cacheMaxEntries: Option[Integer] = None,
    cacheEntryLifetime: Option[Integer] = None,
    xpathUnion: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqSearchImplBuilderQueryBuilderImplInfo]): Future[ComDayCqSearchImplBuilderQueryBuilderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.search.impl.builder.QueryBuilderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    excerptProperties match {
      case Some(param) => queryParams += "excerpt.properties" -> param.toString
      case _ => queryParams
    }
    cacheMaxEntries match {
      case Some(param) => queryParams += "cache.max.entries" -> param.toString
      case _ => queryParams
    }
    cacheEntryLifetime match {
      case Some(param) => queryParams += "cache.entry.lifetime" -> param.toString
      case _ => queryParams
    }
    xpathUnion match {
      case Some(param) => queryParams += "xpath.union" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqSearchSuggestImplSuggestionIndexManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    pathBuilderTarget: Option[String] = None,
    suggestBasepath: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo]): Future[ComDayCqSearchSuggestImplSuggestionIndexManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.search.suggest.impl.SuggestionIndexManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    pathBuilderTarget match {
      case Some(param) => queryParams += "pathBuilder.target" -> param.toString
      case _ => queryParams
    }
    suggestBasepath match {
      case Some(param) => queryParams += "suggest.basepath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqSearchpromoteImplPublishSearchPromoteConfigHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqSearchpromoteConfighandlerEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo]): Future[ComDayCqSearchpromoteImplPublishSearchPromoteConfigHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.searchpromote.impl.PublishSearchPromoteConfigHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqSearchpromoteConfighandlerEnabled match {
      case Some(param) => queryParams += "cq.searchpromote.confighandler.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqSearchpromoteImplSearchPromoteServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqSearchpromoteConfigurationServerUri: Option[String] = None,
    cqSearchpromoteConfigurationEnvironment: Option[String] = None,
    connectionTimeout: Option[Integer] = None,
    socketTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo]): Future[ComDayCqSearchpromoteImplSearchPromoteServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.searchpromote.impl.SearchPromoteServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqSearchpromoteConfigurationServerUri match {
      case Some(param) => queryParams += "cq.searchpromote.configuration.server.uri" -> param.toString
      case _ => queryParams
    }
    cqSearchpromoteConfigurationEnvironment match {
      case Some(param) => queryParams += "cq.searchpromote.configuration.environment" -> param.toString
      case _ => queryParams
    }
    connectionTimeout match {
      case Some(param) => queryParams += "connection.timeout" -> param.toString
      case _ => queryParams
    }
    socketTimeout match {
      case Some(param) => queryParams += "socket.timeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqSecurityACLSetup(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqAclsetupRules: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqSecurityACLSetupInfo]): Future[ComDayCqSecurityACLSetupInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.security.ACLSetup"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqAclsetupRules match {
      case Some(param) => queryParams += "cq.aclsetup.rules" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqStatisticsImplStatisticsServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerPeriod: Option[Integer] = None,
    schedulerConcurrent: Option[Boolean] = None,
    `path`: Option[String] = None,
    workspace: Option[String] = None,
    keywordsPath: Option[String] = None,
    asyncEntries: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqStatisticsImplStatisticsServiceImplInfo]): Future[ComDayCqStatisticsImplStatisticsServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.statistics.impl.StatisticsServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerPeriod match {
      case Some(param) => queryParams += "scheduler.period" -> param.toString
      case _ => queryParams
    }
    schedulerConcurrent match {
      case Some(param) => queryParams += "scheduler.concurrent" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    workspace match {
      case Some(param) => queryParams += "workspace" -> param.toString
      case _ => queryParams
    }
    keywordsPath match {
      case Some(param) => queryParams += "keywordsPath" -> param.toString
      case _ => queryParams
    }
    asyncEntries match {
      case Some(param) => queryParams += "asyncEntries" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqTaggingImplJcrTagManagerFactoryImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    validationEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo]): Future[ComDayCqTaggingImplJcrTagManagerFactoryImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.tagging.impl.JcrTagManagerFactoryImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    validationEnabled match {
      case Some(param) => queryParams += "validation.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqTaggingImplSearchTagPredicateEvaluator(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    ignorePath: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo]): Future[ComDayCqTaggingImplSearchTagPredicateEvaluatorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.tagging.impl.search.TagPredicateEvaluator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    ignorePath match {
      case Some(param) => queryParams += "ignore_path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqTaggingImplTagGarbageCollector(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqTaggingImplTagGarbageCollectorInfo]): Future[ComDayCqTaggingImplTagGarbageCollectorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.tagging.impl.TagGarbageCollector"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmContentsyncImplHandlerPagesUpdateHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqPagesupdatehandlerImageresourcetypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo]): Future[ComDayCqWcmContentsyncImplHandlerPagesUpdateHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.contentsync.impl.handler.PagesUpdateHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqPagesupdatehandlerImageresourcetypes match {
      case Some(param) => queryParams += "cq.pagesupdatehandler.imageresourcetypes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqContentsyncPathrewritertransformerMappingLinks: Option[List[String]] = None,
    cqContentsyncPathrewritertransformerMappingClientlibs: Option[List[String]] = None,
    cqContentsyncPathrewritertransformerMappingImages: Option[List[String]] = None,
    cqContentsyncPathrewritertransformerAttributePattern: Option[String] = None,
    cqContentsyncPathrewritertransformerClientlibraryPattern: Option[String] = None,
    cqContentsyncPathrewritertransformerClientlibraryReplace: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo]): Future[ComDayCqWcmContentsyncImplRewriterPathRewriterTransformerFactorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.contentsync.impl.rewriter.PathRewriterTransformerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqContentsyncPathrewritertransformerMappingLinks match {
      case Some(param) => queryParams += "cq.contentsync.pathrewritertransformer.mapping.links" -> param.toString
      case _ => queryParams
    }
    cqContentsyncPathrewritertransformerMappingClientlibs match {
      case Some(param) => queryParams += "cq.contentsync.pathrewritertransformer.mapping.clientlibs" -> param.toString
      case _ => queryParams
    }
    cqContentsyncPathrewritertransformerMappingImages match {
      case Some(param) => queryParams += "cq.contentsync.pathrewritertransformer.mapping.images" -> param.toString
      case _ => queryParams
    }
    cqContentsyncPathrewritertransformerAttributePattern match {
      case Some(param) => queryParams += "cq.contentsync.pathrewritertransformer.attribute.pattern" -> param.toString
      case _ => queryParams
    }
    cqContentsyncPathrewritertransformerClientlibraryPattern match {
      case Some(param) => queryParams += "cq.contentsync.pathrewritertransformer.clientlibrary.pattern" -> param.toString
      case _ => queryParams
    }
    cqContentsyncPathrewritertransformerClientlibraryReplace match {
      case Some(param) => queryParams += "cq.contentsync.pathrewritertransformer.clientlibrary.replace" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplAuthoringUIModeServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    authoringUIModeServiceDefault: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo]): Future[ComDayCqWcmCoreImplAuthoringUIModeServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.AuthoringUIModeServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    authoringUIModeServiceDefault match {
      case Some(param) => queryParams += "authoringUIModeService.default" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplCommandsWCMCommandServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    wcmcommandservletDeleteWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo]): Future[ComDayCqWcmCoreImplCommandsWCMCommandServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.commands.WCMCommandServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    wcmcommandservletDeleteWhitelist match {
      case Some(param) => queryParams += "wcmcommandservlet.delete_whitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    dimDefaultMode: Option[String] = None,
    dimAppcacheEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo]): Future[ComDayCqWcmCoreImplDevicedetectionDeviceIdentificationModeImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.devicedetection.DeviceIdentificationModeImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    dimDefaultMode match {
      case Some(param) => queryParams += "dim.default.mode" -> param.toString
      case _ => queryParams
    }
    dimAppcacheEnabled match {
      case Some(param) => queryParams += "dim.appcache.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplEventPageEventAuditListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    configured: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo]): Future[ComDayCqWcmCoreImplEventPageEventAuditListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.event.PageEventAuditListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    configured match {
      case Some(param) => queryParams += "configured" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplEventPagePostProcessor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    paths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplEventPagePostProcessorInfo]): Future[ComDayCqWcmCoreImplEventPagePostProcessorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.event.PagePostProcessor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    paths match {
      case Some(param) => queryParams += "paths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplEventRepositoryChangeEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    paths: Option[List[String]] = None,
    excludedPaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo]): Future[ComDayCqWcmCoreImplEventRepositoryChangeEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.event.RepositoryChangeEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    paths match {
      case Some(param) => queryParams += "paths" -> param.toString
      case _ => queryParams
    }
    excludedPaths match {
      case Some(param) => queryParams += "excludedPaths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplEventTemplatePostProcessor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    paths: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo]): Future[ComDayCqWcmCoreImplEventTemplatePostProcessorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.event.TemplatePostProcessor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    paths match {
      case Some(param) => queryParams += "paths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplLanguageManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    langmgrListPath: Option[String] = None,
    langmgrCountryDefault: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplLanguageManagerImplInfo]): Future[ComDayCqWcmCoreImplLanguageManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.LanguageManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    langmgrListPath match {
      case Some(param) => queryParams += "langmgr.list.path" -> param.toString
      case _ => queryParams
    }
    langmgrCountryDefault match {
      case Some(param) => queryParams += "langmgr.country.default" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplLinkCheckerConfigurationFactoryImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    linkExpiredPrefix: Option[String] = None,
    linkExpiredRemove: Option[Boolean] = None,
    linkExpiredSuffix: Option[String] = None,
    linkInvalidPrefix: Option[String] = None,
    linkInvalidRemove: Option[Boolean] = None,
    linkInvalidSuffix: Option[String] = None,
    linkPredatedPrefix: Option[String] = None,
    linkPredatedRemove: Option[Boolean] = None,
    linkPredatedSuffix: Option[String] = None,
    linkWcmmodes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo]): Future[ComDayCqWcmCoreImplLinkCheckerConfigurationFactoryImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.LinkCheckerConfigurationFactoryImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    linkExpiredPrefix match {
      case Some(param) => queryParams += "link.expired.prefix" -> param.toString
      case _ => queryParams
    }
    linkExpiredRemove match {
      case Some(param) => queryParams += "link.expired.remove" -> param.toString
      case _ => queryParams
    }
    linkExpiredSuffix match {
      case Some(param) => queryParams += "link.expired.suffix" -> param.toString
      case _ => queryParams
    }
    linkInvalidPrefix match {
      case Some(param) => queryParams += "link.invalid.prefix" -> param.toString
      case _ => queryParams
    }
    linkInvalidRemove match {
      case Some(param) => queryParams += "link.invalid.remove" -> param.toString
      case _ => queryParams
    }
    linkInvalidSuffix match {
      case Some(param) => queryParams += "link.invalid.suffix" -> param.toString
      case _ => queryParams
    }
    linkPredatedPrefix match {
      case Some(param) => queryParams += "link.predated.prefix" -> param.toString
      case _ => queryParams
    }
    linkPredatedRemove match {
      case Some(param) => queryParams += "link.predated.remove" -> param.toString
      case _ => queryParams
    }
    linkPredatedSuffix match {
      case Some(param) => queryParams += "link.predated.suffix" -> param.toString
      case _ => queryParams
    }
    linkWcmmodes match {
      case Some(param) => queryParams += "link.wcmmodes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplPagePageInfoAggregatorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    pageInfoProviderPropertyRegexDefault: Option[String] = None,
    pageInfoProviderPropertyName: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo]): Future[ComDayCqWcmCoreImplPagePageInfoAggregatorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.page.PageInfoAggregatorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    pageInfoProviderPropertyRegexDefault match {
      case Some(param) => queryParams += "page.info.provider.property.regex.default" -> param.toString
      case _ => queryParams
    }
    pageInfoProviderPropertyName match {
      case Some(param) => queryParams += "page.info.provider.property.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplPagePageManagerFactoryImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    illegalCharMapping: Option[String] = None,
    pageSubTreeActivationCheck: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo]): Future[ComDayCqWcmCoreImplPagePageManagerFactoryImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.page.PageManagerFactoryImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    illegalCharMapping match {
      case Some(param) => queryParams += "illegalCharMapping" -> param.toString
      case _ => queryParams
    }
    pageSubTreeActivationCheck match {
      case Some(param) => queryParams += "pageSubTreeActivationCheck" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplReferencesContentContentReferenceConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    contentReferenceConfigResourceTypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo]): Future[ComDayCqWcmCoreImplReferencesContentContentReferenceConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.references.content.ContentReferenceConfig"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    contentReferenceConfigResourceTypes match {
      case Some(param) => queryParams += "contentReferenceConfig.resourceTypes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplServletsContentfinderAssetViewHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    damShowexpired: Option[Boolean] = None,
    damShowhidden: Option[Boolean] = None,
    tagTitleSearch: Option[Boolean] = None,
    guessTotal: Option[String] = None,
    damExpiryProperty: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo]): Future[ComDayCqWcmCoreImplServletsContentfinderAssetViewHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.AssetViewHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    damShowexpired match {
      case Some(param) => queryParams += "dam.showexpired" -> param.toString
      case _ => queryParams
    }
    damShowhidden match {
      case Some(param) => queryParams += "dam.showhidden" -> param.toString
      case _ => queryParams
    }
    tagTitleSearch match {
      case Some(param) => queryParams += "tagTitleSearch" -> param.toString
      case _ => queryParams
    }
    guessTotal match {
      case Some(param) => queryParams += "guessTotal" -> param.toString
      case _ => queryParams
    }
    damExpiryProperty match {
      case Some(param) => queryParams += "dam.expiryProperty" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplServletsContentfinderConnectorConnectorVie(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    itemResourceTypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo]): Future[ComDayCqWcmCoreImplServletsContentfinderConnectorConnectorVieInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.connector.ConnectorViewHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    itemResourceTypes match {
      case Some(param) => queryParams += "item.resource.types" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplServletsContentfinderPageViewHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    guessTotal: Option[String] = None,
    tagTitleSearch: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo]): Future[ComDayCqWcmCoreImplServletsContentfinderPageViewHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.contentfinder.PageViewHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    guessTotal match {
      case Some(param) => queryParams += "guessTotal" -> param.toString
      case _ => queryParams
    }
    tagTitleSearch match {
      case Some(param) => queryParams += "tagTitleSearch" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplServletsFindReplaceServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    scope: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplServletsFindReplaceServletInfo]): Future[ComDayCqWcmCoreImplServletsFindReplaceServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.FindReplaceServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    scope match {
      case Some(param) => queryParams += "scope" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplServletsReferenceSearchServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    referencesearchservletMaxReferencesPerPage: Option[Integer] = None,
    referencesearchservletMaxPages: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo]): Future[ComDayCqWcmCoreImplServletsReferenceSearchServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.ReferenceSearchServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    referencesearchservletMaxReferencesPerPage match {
      case Some(param) => queryParams += "referencesearchservlet.maxReferencesPerPage" -> param.toString
      case _ => queryParams
    }
    referencesearchservletMaxPages match {
      case Some(param) => queryParams += "referencesearchservlet.maxPages" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplServletsThumbnailServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    workspace: Option[String] = None,
    dimensions: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplServletsThumbnailServletInfo]): Future[ComDayCqWcmCoreImplServletsThumbnailServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.servlets.ThumbnailServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    workspace match {
      case Some(param) => queryParams += "workspace" -> param.toString
      case _ => queryParams
    }
    dimensions match {
      case Some(param) => queryParams += "dimensions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplUtilsDefaultPageNameValidator(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    nonValidChars: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo]): Future[ComDayCqWcmCoreImplUtilsDefaultPageNameValidatorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.utils.DefaultPageNameValidator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    nonValidChars match {
      case Some(param) => queryParams += "nonValidChars" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplVariantsPageVariantsProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    defaultExternalizerDomain: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo]): Future[ComDayCqWcmCoreImplVariantsPageVariantsProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.variants.PageVariantsProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    defaultExternalizerDomain match {
      case Some(param) => queryParams += "default.externalizer.domain" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplVersionManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    versionmanagerCreateVersionOnActivation: Option[Boolean] = None,
    versionmanagerPurgingEnabled: Option[Boolean] = None,
    versionmanagerPurgePaths: Option[List[String]] = None,
    versionmanagerIvPaths: Option[List[String]] = None,
    versionmanagerMaxAgeDays: Option[Integer] = None,
    versionmanagerMaxNumberVersions: Option[Integer] = None,
    versionmanagerMinNumberVersions: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplVersionManagerImplInfo]): Future[ComDayCqWcmCoreImplVersionManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.VersionManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    versionmanagerCreateVersionOnActivation match {
      case Some(param) => queryParams += "versionmanager.createVersionOnActivation" -> param.toString
      case _ => queryParams
    }
    versionmanagerPurgingEnabled match {
      case Some(param) => queryParams += "versionmanager.purgingEnabled" -> param.toString
      case _ => queryParams
    }
    versionmanagerPurgePaths match {
      case Some(param) => queryParams += "versionmanager.purgePaths" -> param.toString
      case _ => queryParams
    }
    versionmanagerIvPaths match {
      case Some(param) => queryParams += "versionmanager.ivPaths" -> param.toString
      case _ => queryParams
    }
    versionmanagerMaxAgeDays match {
      case Some(param) => queryParams += "versionmanager.maxAgeDays" -> param.toString
      case _ => queryParams
    }
    versionmanagerMaxNumberVersions match {
      case Some(param) => queryParams += "versionmanager.maxNumberVersions" -> param.toString
      case _ => queryParams
    }
    versionmanagerMinNumberVersions match {
      case Some(param) => queryParams += "versionmanager.minNumberVersions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplVersionPurgeTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    versionpurgePaths: Option[List[String]] = None,
    versionpurgeRecursive: Option[Boolean] = None,
    versionpurgeMaxVersions: Option[Integer] = None,
    versionpurgeMinVersions: Option[Integer] = None,
    versionpurgeMaxAgeDays: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplVersionPurgeTaskInfo]): Future[ComDayCqWcmCoreImplVersionPurgeTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.VersionPurgeTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    versionpurgePaths match {
      case Some(param) => queryParams += "versionpurge.paths" -> param.toString
      case _ => queryParams
    }
    versionpurgeRecursive match {
      case Some(param) => queryParams += "versionpurge.recursive" -> param.toString
      case _ => queryParams
    }
    versionpurgeMaxVersions match {
      case Some(param) => queryParams += "versionpurge.maxVersions" -> param.toString
      case _ => queryParams
    }
    versionpurgeMinVersions match {
      case Some(param) => queryParams += "versionpurge.minVersions" -> param.toString
      case _ => queryParams
    }
    versionpurgeMaxAgeDays match {
      case Some(param) => queryParams += "versionpurge.maxAgeDays" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplWCMDebugFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    wcmdbgfilterEnabled: Option[Boolean] = None,
    wcmdbgfilterJspDebug: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplWCMDebugFilterInfo]): Future[ComDayCqWcmCoreImplWCMDebugFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.WCMDebugFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    wcmdbgfilterEnabled match {
      case Some(param) => queryParams += "wcmdbgfilter.enabled" -> param.toString
      case _ => queryParams
    }
    wcmdbgfilterJspDebug match {
      case Some(param) => queryParams += "wcmdbgfilter.jspDebug" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplWCMDeveloperModeFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    wcmdevmodefilterEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo]): Future[ComDayCqWcmCoreImplWCMDeveloperModeFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.WCMDeveloperModeFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    wcmdevmodefilterEnabled match {
      case Some(param) => queryParams += "wcmdevmodefilter.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreImplWarpTimeWarpFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    filterOrder: Option[String] = None,
    filterScope: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo]): Future[ComDayCqWcmCoreImplWarpTimeWarpFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.impl.warp.TimeWarpFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    filterOrder match {
      case Some(param) => queryParams += "filter.order" -> param.toString
      case _ => queryParams
    }
    filterScope match {
      case Some(param) => queryParams += "filter.scope" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreMvtMVTStatisticsImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mvtstatisticsTrackingurl: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreMvtMVTStatisticsImplInfo]): Future[ComDayCqWcmCoreMvtMVTStatisticsImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.mvt.MVTStatisticsImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mvtstatisticsTrackingurl match {
      case Some(param) => queryParams += "mvtstatistics.trackingurl" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreStatsPageViewStatisticsImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    pageviewstatisticsTrackingurl: Option[String] = None,
    pageviewstatisticsTrackingscriptEnabled: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo]): Future[ComDayCqWcmCoreStatsPageViewStatisticsImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.stats.PageViewStatisticsImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    pageviewstatisticsTrackingurl match {
      case Some(param) => queryParams += "pageviewstatistics.trackingurl" -> param.toString
      case _ => queryParams
    }
    pageviewstatisticsTrackingscriptEnabled match {
      case Some(param) => queryParams += "pageviewstatistics.trackingscript.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmCoreWCMRequestFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    wcmfilterMode: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmCoreWCMRequestFilterInfo]): Future[ComDayCqWcmCoreWCMRequestFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.core.WCMRequestFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    wcmfilterMode match {
      case Some(param) => queryParams += "wcmfilter.mode" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterDesignPackageImporter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    extractFilter: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterDesignPackageImporterInfo]): Future[ComDayCqWcmDesignimporterDesignPackageImporterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.DesignPackageImporter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    extractFilter match {
      case Some(param) => queryParams += "extract.filter" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterImplCanvasBuilderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    filepattern: Option[String] = None,
    buildPageNodes: Option[Boolean] = None,
    buildClientLibs: Option[Boolean] = None,
    buildCanvasComponent: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo]): Future[ComDayCqWcmDesignimporterImplCanvasBuilderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.impl.CanvasBuilderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    filepattern match {
      case Some(param) => queryParams += "filepattern" -> param.toString
      case _ => queryParams
    }
    buildPageNodes match {
      case Some(param) => queryParams += "build.page.nodes" -> param.toString
      case _ => queryParams
    }
    buildClientLibs match {
      case Some(param) => queryParams += "build.client.libs" -> param.toString
      case _ => queryParams
    }
    buildCanvasComponent match {
      case Some(param) => queryParams += "build.canvas.component" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterImplCanvasPageDeleteHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    minThreadPoolSize: Option[Integer] = None,
    maxThreadPoolSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo]): Future[ComDayCqWcmDesignimporterImplCanvasPageDeleteHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.impl.CanvasPageDeleteHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    minThreadPoolSize match {
      case Some(param) => queryParams += "minThreadPoolSize" -> param.toString
      case _ => queryParams
    }
    maxThreadPoolSize match {
      case Some(param) => queryParams += "maxThreadPoolSize" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterImplEntryPreprocessorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    searchPattern: Option[String] = None,
    replacePattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo]): Future[ComDayCqWcmDesignimporterImplEntryPreprocessorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.impl.EntryPreprocessorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    searchPattern match {
      case Some(param) => queryParams += "search.pattern" -> param.toString
      case _ => queryParams
    }
    replacePattern match {
      case Some(param) => queryParams += "replace.pattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterImplMobileCanvasBuilderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    filepattern: Option[String] = None,
    deviceGroups: Option[List[String]] = None,
    buildPageNodes: Option[Boolean] = None,
    buildClientLibs: Option[Boolean] = None,
    buildCanvasComponent: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo]): Future[ComDayCqWcmDesignimporterImplMobileCanvasBuilderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.impl.MobileCanvasBuilderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    filepattern match {
      case Some(param) => queryParams += "filepattern" -> param.toString
      case _ => queryParams
    }
    deviceGroups match {
      case Some(param) => queryParams += "device.groups" -> param.toString
      case _ => queryParams
    }
    buildPageNodes match {
      case Some(param) => queryParams += "build.page.nodes" -> param.toString
      case _ => queryParams
    }
    buildClientLibs match {
      case Some(param) => queryParams += "build.client.libs" -> param.toString
      case _ => queryParams
    }
    buildCanvasComponent match {
      case Some(param) => queryParams += "build.canvas.component" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryCanvasCompone(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryCanvasComponeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.CanvasComponentTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultCompon(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultComponInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.DefaultComponentTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHan(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryDefaultTagHanInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.DefaultTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandle(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryHeadTagHandleInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.HeadTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHand(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryIFrameTagHandInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.IFrameTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryImageComponen(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None,
    componentResourceType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryImageComponenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ImageComponentTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }
    componentResourceType match {
      case Some(param) => queryParams += "component.resourceType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryImgTagHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ImgTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptT(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryInlineScriptTInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.InlineScriptTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandle(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryLinkTagHandleInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.LinkTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandle(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryMetaTagHandleInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.MetaTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagH(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryNonScriptTagHInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.NonScriptTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryParsysCompone(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None,
    componentResourceType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryParsysComponeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ParsysComponentTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }
    componentResourceType match {
      case Some(param) => queryParams += "component.resourceType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHand(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryScriptTagHandInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.ScriptTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryStyleTagHandlInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.StyleTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryTextComponent(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None,
    componentResourceType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryTextComponentInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TextComponentTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }
    componentResourceType match {
      case Some(param) => queryParams += "component.resourceType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponen(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None,
    componentResourceType: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleComponenInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TitleComponentTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }
    componentResourceType match {
      case Some(param) => queryParams += "component.resourceType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    tagpattern: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo]): Future[ComDayCqWcmDesignimporterParserTaghandlersFactoryTitleTagHandlInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.designimporter.parser.taghandlers.factory.TitleTagHandlerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    tagpattern match {
      case Some(param) => queryParams += "tagpattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmFoundationFormsImplFormChooserServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceName: Option[String] = None,
    slingServletResourceTypes: Option[String] = None,
    slingServletSelectors: Option[String] = None,
    slingServletMethods: Option[List[String]] = None,
    formsFormchooserservletAdvansesearchRequire: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmFoundationFormsImplFormChooserServletInfo]): Future[ComDayCqWcmFoundationFormsImplFormChooserServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormChooserServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "service.name" -> param.toString
      case _ => queryParams
    }
    slingServletResourceTypes match {
      case Some(param) => queryParams += "sling.servlet.resourceTypes" -> param.toString
      case _ => queryParams
    }
    slingServletSelectors match {
      case Some(param) => queryParams += "sling.servlet.selectors" -> param.toString
      case _ => queryParams
    }
    slingServletMethods match {
      case Some(param) => queryParams += "sling.servlet.methods" -> param.toString
      case _ => queryParams
    }
    formsFormchooserservletAdvansesearchRequire match {
      case Some(param) => queryParams += "forms.formchooserservlet.advansesearch.require" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmFoundationFormsImplFormParagraphPostProcessor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    formsFormparagraphpostprocessorEnabled: Option[Boolean] = None,
    formsFormparagraphpostprocessorFormresourcetypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo]): Future[ComDayCqWcmFoundationFormsImplFormParagraphPostProcessorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormParagraphPostProcessor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    formsFormparagraphpostprocessorEnabled match {
      case Some(param) => queryParams += "forms.formparagraphpostprocessor.enabled" -> param.toString
      case _ => queryParams
    }
    formsFormparagraphpostprocessorFormresourcetypes match {
      case Some(param) => queryParams += "forms.formparagraphpostprocessor.formresourcetypes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmFoundationFormsImplFormsHandlingServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    nameWhitelist: Option[String] = None,
    allowExpressions: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo]): Future[ComDayCqWcmFoundationFormsImplFormsHandlingServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.FormsHandlingServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    nameWhitelist match {
      case Some(param) => queryParams += "name.whitelist" -> param.toString
      case _ => queryParams
    }
    allowExpressions match {
      case Some(param) => queryParams += "allow.expressions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmFoundationFormsImplMailServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletResourceTypes: Option[String] = None,
    slingServletSelectors: Option[String] = None,
    resourceWhitelist: Option[List[String]] = None,
    resourceBlacklist: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmFoundationFormsImplMailServletInfo]): Future[ComDayCqWcmFoundationFormsImplMailServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.foundation.forms.impl.MailServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletResourceTypes match {
      case Some(param) => queryParams += "sling.servlet.resourceTypes" -> param.toString
      case _ => queryParams
    }
    slingServletSelectors match {
      case Some(param) => queryParams += "sling.servlet.selectors" -> param.toString
      case _ => queryParams
    }
    resourceWhitelist match {
      case Some(param) => queryParams += "resource.whitelist" -> param.toString
      case _ => queryParams
    }
    resourceBlacklist match {
      case Some(param) => queryParams += "resource.blacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmFoundationImplAdaptiveImageComponentServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    adaptSupportedWidths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo]): Future[ComDayCqWcmFoundationImplAdaptiveImageComponentServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.foundation.impl.AdaptiveImageComponentServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    adaptSupportedWidths match {
      case Some(param) => queryParams += "adapt.supported.widths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmFoundationImplHTTPAuthHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[String] = None,
    authHttpNologin: Option[Boolean] = None,
    authHttpRealm: Option[String] = None,
    authDefaultLoginpage: Option[String] = None,
    authCredForm: Option[List[String]] = None,
    authCredUtf8: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo]): Future[ComDayCqWcmFoundationImplHTTPAuthHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.foundation.impl.HTTPAuthHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    authHttpNologin match {
      case Some(param) => queryParams += "auth.http.nologin" -> param.toString
      case _ => queryParams
    }
    authHttpRealm match {
      case Some(param) => queryParams += "auth.http.realm" -> param.toString
      case _ => queryParams
    }
    authDefaultLoginpage match {
      case Some(param) => queryParams += "auth.default.loginpage" -> param.toString
      case _ => queryParams
    }
    authCredForm match {
      case Some(param) => queryParams += "auth.cred.form" -> param.toString
      case _ => queryParams
    }
    authCredUtf8 match {
      case Some(param) => queryParams += "auth.cred.utf8" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmFoundationImplPageImpressionsTracker(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingAuthRequirements: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo]): Future[ComDayCqWcmFoundationImplPageImpressionsTrackerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.foundation.impl.PageImpressionsTracker"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingAuthRequirements match {
      case Some(param) => queryParams += "sling.auth.requirements" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmFoundationImplPageRedirectServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    excludedResourceTypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmFoundationImplPageRedirectServletInfo]): Future[ComDayCqWcmFoundationImplPageRedirectServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.foundation.impl.PageRedirectServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    excludedResourceTypes match {
      case Some(param) => queryParams += "excluded.resource.types" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklist(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    defaultAttachmentTypeBlacklist: Option[List[String]] = None,
    baselineAttachmentTypeBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo]): Future[ComDayCqWcmFoundationSecurityImplDefaultAttachmentTypeBlacklistInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.foundation.security.impl.DefaultAttachmentTypeBlacklistService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    defaultAttachmentTypeBlacklist match {
      case Some(param) => queryParams += "default.attachment.type.blacklist" -> param.toString
      case _ => queryParams
    }
    baselineAttachmentTypeBlacklist match {
      case Some(param) => queryParams += "baseline.attachment.type.blacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    parameterWhitelist: Option[List[String]] = None,
    parameterWhitelistPrefixes: Option[List[String]] = None,
    binaryParameterWhitelist: Option[List[String]] = None,
    modifierWhitelist: Option[List[String]] = None,
    operationWhitelist: Option[List[String]] = None,
    operationWhitelistPrefixes: Option[List[String]] = None,
    typehintWhitelist: Option[List[String]] = None,
    resourcetypeWhitelist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo]): Future[ComDayCqWcmFoundationSecurityImplSaferSlingPostValidatorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.foundation.security.impl.SaferSlingPostValidatorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    parameterWhitelist match {
      case Some(param) => queryParams += "parameter.whitelist" -> param.toString
      case _ => queryParams
    }
    parameterWhitelistPrefixes match {
      case Some(param) => queryParams += "parameter.whitelist.prefixes" -> param.toString
      case _ => queryParams
    }
    binaryParameterWhitelist match {
      case Some(param) => queryParams += "binary.parameter.whitelist" -> param.toString
      case _ => queryParams
    }
    modifierWhitelist match {
      case Some(param) => queryParams += "modifier.whitelist" -> param.toString
      case _ => queryParams
    }
    operationWhitelist match {
      case Some(param) => queryParams += "operation.whitelist" -> param.toString
      case _ => queryParams
    }
    operationWhitelistPrefixes match {
      case Some(param) => queryParams += "operation.whitelist.prefixes" -> param.toString
      case _ => queryParams
    }
    typehintWhitelist match {
      case Some(param) => queryParams += "typehint.whitelist" -> param.toString
      case _ => queryParams
    }
    resourcetypeWhitelist match {
      case Some(param) => queryParams += "resourcetype.whitelist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    deviceInfoTransformerEnabled: Option[Boolean] = None,
    deviceInfoTransformerCssStyle: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo]): Future[ComDayCqWcmMobileCoreImplDeviceDeviceInfoTransformerFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.mobile.core.impl.device.DeviceInfoTransformerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    deviceInfoTransformerEnabled match {
      case Some(param) => queryParams += "device.info.transformer.enabled" -> param.toString
      case _ => queryParams
    }
    deviceInfoTransformerCssStyle match {
      case Some(param) => queryParams += "device.info.transformer.css.style" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMobileCoreImplRedirectRedirectFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    redirectEnabled: Option[Boolean] = None,
    redirectStatsEnabled: Option[Boolean] = None,
    redirectExtensions: Option[List[String]] = None,
    redirectPaths: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo]): Future[ComDayCqWcmMobileCoreImplRedirectRedirectFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.mobile.core.impl.redirect.RedirectFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    redirectEnabled match {
      case Some(param) => queryParams += "redirect.enabled" -> param.toString
      case _ => queryParams
    }
    redirectStatsEnabled match {
      case Some(param) => queryParams += "redirect.stats.enabled" -> param.toString
      case _ => queryParams
    }
    redirectExtensions match {
      case Some(param) => queryParams += "redirect.extensions" -> param.toString
      case _ => queryParams
    }
    redirectPaths match {
      case Some(param) => queryParams += "redirect.paths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMsmImplActionsContentCopyActionFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqWcmMsmActionExcludednodetypes: Option[List[String]] = None,
    cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None,
    cqWcmMsmActionExcludedprops: Option[List[String]] = None,
    contentcopyactionOrderStyle: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo]): Future[ComDayCqWcmMsmImplActionsContentCopyActionFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentCopyActionFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludednodetypes match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludednodetypes" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedparagraphitems match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedparagraphitems" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedprops match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedprops" -> param.toString
      case _ => queryParams
    }
    contentcopyactionOrderStyle match {
      case Some(param) => queryParams += "contentcopyaction.order.style" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMsmImplActionsContentDeleteActionFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqWcmMsmActionExcludednodetypes: Option[List[String]] = None,
    cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None,
    cqWcmMsmActionExcludedprops: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo]): Future[ComDayCqWcmMsmImplActionsContentDeleteActionFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentDeleteActionFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludednodetypes match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludednodetypes" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedparagraphitems match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedparagraphitems" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedprops match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedprops" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMsmImplActionsContentUpdateActionFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqWcmMsmActionExcludednodetypes: Option[List[String]] = None,
    cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None,
    cqWcmMsmActionExcludedprops: Option[List[String]] = None,
    cqWcmMsmActionIgnoredMixin: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo]): Future[ComDayCqWcmMsmImplActionsContentUpdateActionFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ContentUpdateActionFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludednodetypes match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludednodetypes" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedparagraphitems match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedparagraphitems" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedprops match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedprops" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionIgnoredMixin match {
      case Some(param) => queryParams += "cq.wcm.msm.action.ignoredMixin" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMsmImplActionsOrderChildrenActionFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqWcmMsmActionExcludednodetypes: Option[List[String]] = None,
    cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None,
    cqWcmMsmActionExcludedprops: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo]): Future[ComDayCqWcmMsmImplActionsOrderChildrenActionFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.OrderChildrenActionFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludednodetypes match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludednodetypes" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedparagraphitems match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedparagraphitems" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedprops match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedprops" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMsmImplActionsPageMoveActionFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqWcmMsmActionExcludednodetypes: Option[List[String]] = None,
    cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None,
    cqWcmMsmActionExcludedprops: Option[List[String]] = None,
    cqWcmMsmImplActionsPagemovePropReferenceUpdate: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo]): Future[ComDayCqWcmMsmImplActionsPageMoveActionFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.PageMoveActionFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludednodetypes match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludednodetypes" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedparagraphitems match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedparagraphitems" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedprops match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedprops" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmImplActionsPagemovePropReferenceUpdate match {
      case Some(param) => queryParams += "cq.wcm.msm.impl.actions.pagemove.prop_referenceUpdate" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMsmImplActionsReferencesUpdateActionFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqWcmMsmActionExcludednodetypes: Option[List[String]] = None,
    cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None,
    cqWcmMsmActionExcludedprops: Option[List[String]] = None,
    cqWcmMsmImplActionReferencesupdatePropUpdateNested: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo]): Future[ComDayCqWcmMsmImplActionsReferencesUpdateActionFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.ReferencesUpdateActionFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludednodetypes match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludednodetypes" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedparagraphitems match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedparagraphitems" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedprops match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedprops" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmImplActionReferencesupdatePropUpdateNested match {
      case Some(param) => queryParams += "cq.wcm.msm.impl.action.referencesupdate.prop_updateNested" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMsmImplActionsVersionCopyActionFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqWcmMsmActionExcludednodetypes: Option[List[String]] = None,
    cqWcmMsmActionExcludedparagraphitems: Option[List[String]] = None,
    cqWcmMsmActionExcludedprops: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo]): Future[ComDayCqWcmMsmImplActionsVersionCopyActionFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.msm.impl.actions.VersionCopyActionFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludednodetypes match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludednodetypes" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedparagraphitems match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedparagraphitems" -> param.toString
      case _ => queryParams
    }
    cqWcmMsmActionExcludedprops match {
      case Some(param) => queryParams += "cq.wcm.msm.action.excludedprops" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMsmImplLiveRelationshipManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    liverelationshipmgrRelationsconfigDefault: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo]): Future[ComDayCqWcmMsmImplLiveRelationshipManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.msm.impl.LiveRelationshipManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    liverelationshipmgrRelationsconfigDefault match {
      case Some(param) => queryParams += "liverelationshipmgr.relationsconfig.default" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMsmImplRolloutManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventFilter: Option[String] = None,
    rolloutmgrExcludedpropsDefault: Option[List[String]] = None,
    rolloutmgrExcludedparagraphpropsDefault: Option[List[String]] = None,
    rolloutmgrExcludednodetypesDefault: Option[List[String]] = None,
    rolloutmgrThreadpoolMaxsize: Option[Integer] = None,
    rolloutmgrThreadpoolMaxshutdowntime: Option[Integer] = None,
    rolloutmgrThreadpoolPriority: Option[String] = None,
    rolloutmgrCommitSize: Option[Integer] = None,
    rolloutmgrConflicthandlingEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMsmImplRolloutManagerImplInfo]): Future[ComDayCqWcmMsmImplRolloutManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.msm.impl.RolloutManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }
    rolloutmgrExcludedpropsDefault match {
      case Some(param) => queryParams += "rolloutmgr.excludedprops.default" -> param.toString
      case _ => queryParams
    }
    rolloutmgrExcludedparagraphpropsDefault match {
      case Some(param) => queryParams += "rolloutmgr.excludedparagraphprops.default" -> param.toString
      case _ => queryParams
    }
    rolloutmgrExcludednodetypesDefault match {
      case Some(param) => queryParams += "rolloutmgr.excludednodetypes.default" -> param.toString
      case _ => queryParams
    }
    rolloutmgrThreadpoolMaxsize match {
      case Some(param) => queryParams += "rolloutmgr.threadpool.maxsize" -> param.toString
      case _ => queryParams
    }
    rolloutmgrThreadpoolMaxshutdowntime match {
      case Some(param) => queryParams += "rolloutmgr.threadpool.maxshutdowntime" -> param.toString
      case _ => queryParams
    }
    rolloutmgrThreadpoolPriority match {
      case Some(param) => queryParams += "rolloutmgr.threadpool.priority" -> param.toString
      case _ => queryParams
    }
    rolloutmgrCommitSize match {
      case Some(param) => queryParams += "rolloutmgr.commit.size" -> param.toString
      case _ => queryParams
    }
    rolloutmgrConflicthandlingEnabled match {
      case Some(param) => queryParams += "rolloutmgr.conflicthandling.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmMsmImplServletsAuditLogServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    auditlogservletDefaultEventsCount: Option[Integer] = None,
    auditlogservletDefaultPath: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmMsmImplServletsAuditLogServletInfo]): Future[ComDayCqWcmMsmImplServletsAuditLogServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.msm.impl.servlets.AuditLogServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    auditlogservletDefaultEventsCount match {
      case Some(param) => queryParams += "auditlogservlet.default.events.count" -> param.toString
      case _ => queryParams
    }
    auditlogservletDefaultPath match {
      case Some(param) => queryParams += "auditlogservlet.default.path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmNotificationEmailImplEmailChannel(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    emailFrom: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmNotificationEmailImplEmailChannelInfo]): Future[ComDayCqWcmNotificationEmailImplEmailChannelInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.notification.email.impl.EmailChannel"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    emailFrom match {
      case Some(param) => queryParams += "email.from" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmNotificationImplNotificationManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventTopics: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmNotificationImplNotificationManagerImplInfo]): Future[ComDayCqWcmNotificationImplNotificationManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.notification.impl.NotificationManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventTopics match {
      case Some(param) => queryParams += "event.topics" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmScriptingImplBVPManager(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    comDayCqWcmScriptingBvpScriptEngines: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmScriptingImplBVPManagerInfo]): Future[ComDayCqWcmScriptingImplBVPManagerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.scripting.impl.BVPManager"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    comDayCqWcmScriptingBvpScriptEngines match {
      case Some(param) => queryParams += "com.day.cq.wcm.scripting.bvp.script.engines" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmUndoUndoConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cqWcmUndoEnabled: Option[Boolean] = None,
    cqWcmUndoPath: Option[String] = None,
    cqWcmUndoValidity: Option[Integer] = None,
    cqWcmUndoSteps: Option[Integer] = None,
    cqWcmUndoPersistence: Option[String] = None,
    cqWcmUndoPersistenceMode: Option[Boolean] = None,
    cqWcmUndoMarkermode: Option[String] = None,
    cqWcmUndoWhitelist: Option[List[String]] = None,
    cqWcmUndoBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmUndoUndoConfigInfo]): Future[ComDayCqWcmUndoUndoConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.undo.UndoConfig"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cqWcmUndoEnabled match {
      case Some(param) => queryParams += "cq.wcm.undo.enabled" -> param.toString
      case _ => queryParams
    }
    cqWcmUndoPath match {
      case Some(param) => queryParams += "cq.wcm.undo.path" -> param.toString
      case _ => queryParams
    }
    cqWcmUndoValidity match {
      case Some(param) => queryParams += "cq.wcm.undo.validity" -> param.toString
      case _ => queryParams
    }
    cqWcmUndoSteps match {
      case Some(param) => queryParams += "cq.wcm.undo.steps" -> param.toString
      case _ => queryParams
    }
    cqWcmUndoPersistence match {
      case Some(param) => queryParams += "cq.wcm.undo.persistence" -> param.toString
      case _ => queryParams
    }
    cqWcmUndoPersistenceMode match {
      case Some(param) => queryParams += "cq.wcm.undo.persistence.mode" -> param.toString
      case _ => queryParams
    }
    cqWcmUndoMarkermode match {
      case Some(param) => queryParams += "cq.wcm.undo.markermode" -> param.toString
      case _ => queryParams
    }
    cqWcmUndoWhitelist match {
      case Some(param) => queryParams += "cq.wcm.undo.whitelist" -> param.toString
      case _ => queryParams
    }
    cqWcmUndoBlacklist match {
      case Some(param) => queryParams += "cq.wcm.undo.blacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmWebservicesupportImplReplicationEventListener(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    flushAgents: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo]): Future[ComDayCqWcmWebservicesupportImplReplicationEventListenerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.webservicesupport.impl.ReplicationEventListener"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    flushAgents match {
      case Some(param) => queryParams += "Flush agents" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmWorkflowImplWcmWorkflowServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    eventFilter: Option[String] = None,
    minThreadPoolSize: Option[Integer] = None,
    maxThreadPoolSize: Option[Integer] = None,
    cqWcmWorkflowTerminateOnActivate: Option[Boolean] = None,
    cqWcmWorklfowTerminateExclusionList: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo]): Future[ComDayCqWcmWorkflowImplWcmWorkflowServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.workflow.impl.WcmWorkflowServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    eventFilter match {
      case Some(param) => queryParams += "event.filter" -> param.toString
      case _ => queryParams
    }
    minThreadPoolSize match {
      case Some(param) => queryParams += "minThreadPoolSize" -> param.toString
      case _ => queryParams
    }
    maxThreadPoolSize match {
      case Some(param) => queryParams += "maxThreadPoolSize" -> param.toString
      case _ => queryParams
    }
    cqWcmWorkflowTerminateOnActivate match {
      case Some(param) => queryParams += "cq.wcm.workflow.terminate.on.activate" -> param.toString
      case _ => queryParams
    }
    cqWcmWorklfowTerminateExclusionList match {
      case Some(param) => queryParams += "cq.wcm.worklfow.terminate.exclusion.list" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWcmWorkflowImplWorkflowPackageInfoProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    workflowpackageinfoproviderFilter: Option[List[String]] = None,
    workflowpackageinfoproviderFilterRootpath: Option[String] = None
    )(implicit reader: ClientResponseReader[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo]): Future[ComDayCqWcmWorkflowImplWorkflowPackageInfoProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.wcm.workflow.impl.WorkflowPackageInfoProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    workflowpackageinfoproviderFilter match {
      case Some(param) => queryParams += "workflowpackageinfoprovider.filter" -> param.toString
      case _ => queryParams
    }
    workflowpackageinfoproviderFilterRootpath match {
      case Some(param) => queryParams += "workflowpackageinfoprovider.filter.rootpath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWidgetImplHtmlLibraryManagerImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    htmllibmanagerClientmanager: Option[String] = None,
    htmllibmanagerDebug: Option[Boolean] = None,
    htmllibmanagerDebugConsole: Option[Boolean] = None,
    htmllibmanagerDebugInitJs: Option[String] = None,
    htmllibmanagerDefaultthemename: Option[String] = None,
    htmllibmanagerDefaultuserthemename: Option[String] = None,
    htmllibmanagerFirebuglitePath: Option[String] = None,
    htmllibmanagerForceCQUrlInfo: Option[Boolean] = None,
    htmllibmanagerGzip: Option[Boolean] = None,
    htmllibmanagerMaxage: Option[Integer] = None,
    htmllibmanagerMaxDataUriSize: Option[Integer] = None,
    htmllibmanagerMinify: Option[Boolean] = None,
    htmllibmanagerPathList: Option[List[String]] = None,
    htmllibmanagerTiming: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWidgetImplHtmlLibraryManagerImplInfo]): Future[ComDayCqWidgetImplHtmlLibraryManagerImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.widget.impl.HtmlLibraryManagerImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerClientmanager match {
      case Some(param) => queryParams += "htmllibmanager.clientmanager" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerDebug match {
      case Some(param) => queryParams += "htmllibmanager.debug" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerDebugConsole match {
      case Some(param) => queryParams += "htmllibmanager.debug.console" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerDebugInitJs match {
      case Some(param) => queryParams += "htmllibmanager.debug.init.js" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerDefaultthemename match {
      case Some(param) => queryParams += "htmllibmanager.defaultthemename" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerDefaultuserthemename match {
      case Some(param) => queryParams += "htmllibmanager.defaultuserthemename" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerFirebuglitePath match {
      case Some(param) => queryParams += "htmllibmanager.firebuglite.path" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerForceCQUrlInfo match {
      case Some(param) => queryParams += "htmllibmanager.forceCQUrlInfo" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerGzip match {
      case Some(param) => queryParams += "htmllibmanager.gzip" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerMaxage match {
      case Some(param) => queryParams += "htmllibmanager.maxage" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerMaxDataUriSize match {
      case Some(param) => queryParams += "htmllibmanager.maxDataUriSize" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerMinify match {
      case Some(param) => queryParams += "htmllibmanager.minify" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerPathList match {
      case Some(param) => queryParams += "htmllibmanager.path.list" -> param.toString
      case _ => queryParams
    }
    htmllibmanagerTiming match {
      case Some(param) => queryParams += "htmllibmanager.timing" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWidgetImplWidgetExtensionProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    extendableWidgets: Option[List[String]] = None,
    widgetextensionproviderDebug: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWidgetImplWidgetExtensionProviderImplInfo]): Future[ComDayCqWidgetImplWidgetExtensionProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.widget.impl.WidgetExtensionProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    extendableWidgets match {
      case Some(param) => queryParams += "extendable.widgets" -> param.toString
      case _ => queryParams
    }
    widgetextensionproviderDebug match {
      case Some(param) => queryParams += "widgetextensionprovider.debug" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWorkflowImplEmailEMailNotificationService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    fromAddress: Option[String] = None,
    hostPrefix: Option[String] = None,
    notifyOnabort: Option[Boolean] = None,
    notifyOncomplete: Option[Boolean] = None,
    notifyOncontainercomplete: Option[Boolean] = None,
    notifyUseronly: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo]): Future[ComDayCqWorkflowImplEmailEMailNotificationServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.workflow.impl.email.EMailNotificationService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    fromAddress match {
      case Some(param) => queryParams += "from.address" -> param.toString
      case _ => queryParams
    }
    hostPrefix match {
      case Some(param) => queryParams += "host.prefix" -> param.toString
      case _ => queryParams
    }
    notifyOnabort match {
      case Some(param) => queryParams += "notify.onabort" -> param.toString
      case _ => queryParams
    }
    notifyOncomplete match {
      case Some(param) => queryParams += "notify.oncomplete" -> param.toString
      case _ => queryParams
    }
    notifyOncontainercomplete match {
      case Some(param) => queryParams += "notify.oncontainercomplete" -> param.toString
      case _ => queryParams
    }
    notifyUseronly match {
      case Some(param) => queryParams += "notify.useronly" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCqWorkflowImplEmailTaskEMailNotificationService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    notifyOnupdate: Option[Boolean] = None,
    notifyOncomplete: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo]): Future[ComDayCqWorkflowImplEmailTaskEMailNotificationServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.cq.workflow.impl.email.TaskEMailNotificationService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    notifyOnupdate match {
      case Some(param) => queryParams += "notify.onupdate" -> param.toString
      case _ => queryParams
    }
    notifyOncomplete match {
      case Some(param) => queryParams += "notify.oncomplete" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCrxSecurityTokenImplImplTokenAuthenticationHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[String] = None,
    tokenRequiredAttr: Option[String] = None,
    tokenAlternateUrl: Option[String] = None,
    tokenEncapsulated: Option[Boolean] = None,
    skipTokenRefresh: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo]): Future[ComDayCrxSecurityTokenImplImplTokenAuthenticationHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.crx.security.token.impl.impl.TokenAuthenticationHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    tokenRequiredAttr match {
      case Some(param) => queryParams += "token.required.attr" -> param.toString
      case _ => queryParams
    }
    tokenAlternateUrl match {
      case Some(param) => queryParams += "token.alternate.url" -> param.toString
      case _ => queryParams
    }
    tokenEncapsulated match {
      case Some(param) => queryParams += "token.encapsulated" -> param.toString
      case _ => queryParams
    }
    skipTokenRefresh match {
      case Some(param) => queryParams += "skip.token.refresh" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def comDayCrxSecurityTokenImplTokenCleanupTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enableTokenCleanupTask: Option[Boolean] = None,
    schedulerExpression: Option[String] = None,
    batchSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo]): Future[ComDayCrxSecurityTokenImplTokenCleanupTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/com.day.crx.security.token.impl.TokenCleanupTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enableTokenCleanupTask match {
      case Some(param) => queryParams += "enable.token.cleanup.task" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }
    batchSize match {
      case Some(param) => queryParams += "batch.size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def guideLocalizationService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    supportedLocales: Option[List[String]] = None,
    localizableProperties: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[GuideLocalizationServiceInfo]): Future[GuideLocalizationServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/Guide Localization Service"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    supportedLocales match {
      case Some(param) => queryParams += "supportedLocales" -> param.toString
      case _ => queryParams
    }
    localizableProperties match {
      case Some(param) => queryParams += "Localizable Properties" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def messagingUserComponentFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    priority: Option[Integer] = None
    )(implicit reader: ClientResponseReader[MessagingUserComponentFactoryInfo]): Future[MessagingUserComponentFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/MessagingUserComponentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheAriesJmxFrameworkStateConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    attributeChangeNotificationEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheAriesJmxFrameworkStateConfigInfo]): Future[OrgApacheAriesJmxFrameworkStateConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.aries.jmx.framework.StateConfig"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    attributeChangeNotificationEnabled match {
      case Some(param) => queryParams += "attributeChangeNotificationEnabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixEventadminImplEventAdmin(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheFelixEventadminThreadPoolSize: Option[Integer] = None,
    orgApacheFelixEventadminAsyncToSyncThreadRatio: Option[Number] = None,
    orgApacheFelixEventadminTimeout: Option[Integer] = None,
    orgApacheFelixEventadminRequireTopic: Option[Boolean] = None,
    orgApacheFelixEventadminIgnoreTimeout: Option[List[String]] = None,
    orgApacheFelixEventadminIgnoreTopic: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixEventadminImplEventAdminInfo]): Future[OrgApacheFelixEventadminImplEventAdminInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.eventadmin.impl.EventAdmin"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixEventadminThreadPoolSize match {
      case Some(param) => queryParams += "org.apache.felix.eventadmin.ThreadPoolSize" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixEventadminAsyncToSyncThreadRatio match {
      case Some(param) => queryParams += "org.apache.felix.eventadmin.AsyncToSyncThreadRatio" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixEventadminTimeout match {
      case Some(param) => queryParams += "org.apache.felix.eventadmin.Timeout" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixEventadminRequireTopic match {
      case Some(param) => queryParams += "org.apache.felix.eventadmin.RequireTopic" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixEventadminIgnoreTimeout match {
      case Some(param) => queryParams += "org.apache.felix.eventadmin.IgnoreTimeout" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixEventadminIgnoreTopic match {
      case Some(param) => queryParams += "org.apache.felix.eventadmin.IgnoreTopic" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixHttp(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheFelixHttpHost: Option[String] = None,
    orgApacheFelixHttpEnable: Option[Boolean] = None,
    orgOsgiServiceHttpPort: Option[Integer] = None,
    orgApacheFelixHttpTimeout: Option[Integer] = None,
    orgApacheFelixHttpsEnable: Option[Boolean] = None,
    orgOsgiServiceHttpPortSecure: Option[Integer] = None,
    orgApacheFelixHttpsKeystore: Option[String] = None,
    orgApacheFelixHttpsKeystorePassword: Option[String] = None,
    orgApacheFelixHttpsKeystoreKeyPassword: Option[String] = None,
    orgApacheFelixHttpsTruststore: Option[String] = None,
    orgApacheFelixHttpsTruststorePassword: Option[String] = None,
    orgApacheFelixHttpsClientcertificate: Option[String] = None,
    orgApacheFelixHttpContextPath: Option[String] = None,
    orgApacheFelixHttpMbeans: Option[Boolean] = None,
    orgApacheFelixHttpSessionTimeout: Option[Integer] = None,
    orgApacheFelixHttpJettyThreadpoolMax: Option[Integer] = None,
    orgApacheFelixHttpJettyAcceptors: Option[Integer] = None,
    orgApacheFelixHttpJettySelectors: Option[Integer] = None,
    orgApacheFelixHttpJettyHeaderBufferSize: Option[Integer] = None,
    orgApacheFelixHttpJettyRequestBufferSize: Option[Integer] = None,
    orgApacheFelixHttpJettyResponseBufferSize: Option[Integer] = None,
    orgApacheFelixHttpJettyMaxFormSize: Option[Integer] = None,
    orgApacheFelixHttpPathExclusions: Option[List[String]] = None,
    orgApacheFelixHttpsJettyCiphersuitesExcluded: Option[List[String]] = None,
    orgApacheFelixHttpsJettyCiphersuitesIncluded: Option[List[String]] = None,
    orgApacheFelixHttpJettySendServerHeader: Option[Boolean] = None,
    orgApacheFelixHttpsJettyProtocolsIncluded: Option[List[String]] = None,
    orgApacheFelixHttpsJettyProtocolsExcluded: Option[List[String]] = None,
    orgApacheFelixProxyLoadBalancerConnectionEnable: Option[Boolean] = None,
    orgApacheFelixHttpsJettyRenegotiateAllowed: Option[Boolean] = None,
    orgApacheFelixHttpsJettySessionCookieHttpOnly: Option[Boolean] = None,
    orgApacheFelixHttpsJettySessionCookieSecure: Option[Boolean] = None,
    orgEclipseJettyServletSessionIdPathParameterName: Option[String] = None,
    orgEclipseJettyServletCheckingRemoteSessionIdEncoding: Option[Boolean] = None,
    orgEclipseJettyServletSessionCookie: Option[String] = None,
    orgEclipseJettyServletSessionDomain: Option[String] = None,
    orgEclipseJettyServletSessionPath: Option[String] = None,
    orgEclipseJettyServletMaxAge: Option[Integer] = None,
    orgApacheFelixHttpName: Option[String] = None,
    orgApacheFelixJettyGziphandlerEnable: Option[Boolean] = None,
    orgApacheFelixJettyGzipMinGzipSize: Option[Integer] = None,
    orgApacheFelixJettyGzipCompressionLevel: Option[Integer] = None,
    orgApacheFelixJettyGzipInflateBufferSize: Option[Integer] = None,
    orgApacheFelixJettyGzipSyncFlush: Option[Boolean] = None,
    orgApacheFelixJettyGzipExcludedUserAgents: Option[List[String]] = None,
    orgApacheFelixJettyGzipIncludedMethods: Option[List[String]] = None,
    orgApacheFelixJettyGzipExcludedMethods: Option[List[String]] = None,
    orgApacheFelixJettyGzipIncludedPaths: Option[List[String]] = None,
    orgApacheFelixJettyGzipExcludedPaths: Option[List[String]] = None,
    orgApacheFelixJettyGzipIncludedMimeTypes: Option[List[String]] = None,
    orgApacheFelixJettyGzipExcludedMimeTypes: Option[List[String]] = None,
    orgApacheFelixHttpSessionInvalidate: Option[Boolean] = None,
    orgApacheFelixHttpSessionUniqueid: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixHttpInfo]): Future[OrgApacheFelixHttpInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.http"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpHost match {
      case Some(param) => queryParams += "org.apache.felix.http.host" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpEnable match {
      case Some(param) => queryParams += "org.apache.felix.http.enable" -> param.toString
      case _ => queryParams
    }
    orgOsgiServiceHttpPort match {
      case Some(param) => queryParams += "org.osgi.service.http.port" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpTimeout match {
      case Some(param) => queryParams += "org.apache.felix.http.timeout" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsEnable match {
      case Some(param) => queryParams += "org.apache.felix.https.enable" -> param.toString
      case _ => queryParams
    }
    orgOsgiServiceHttpPortSecure match {
      case Some(param) => queryParams += "org.osgi.service.http.port.secure" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystore match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystorePassword match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore.password" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystoreKeyPassword match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore.key.password" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsTruststore match {
      case Some(param) => queryParams += "org.apache.felix.https.truststore" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsTruststorePassword match {
      case Some(param) => queryParams += "org.apache.felix.https.truststore.password" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsClientcertificate match {
      case Some(param) => queryParams += "org.apache.felix.https.clientcertificate" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpContextPath match {
      case Some(param) => queryParams += "org.apache.felix.http.context_path" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpMbeans match {
      case Some(param) => queryParams += "org.apache.felix.http.mbeans" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpSessionTimeout match {
      case Some(param) => queryParams += "org.apache.felix.http.session.timeout" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpJettyThreadpoolMax match {
      case Some(param) => queryParams += "org.apache.felix.http.jetty.threadpool.max" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpJettyAcceptors match {
      case Some(param) => queryParams += "org.apache.felix.http.jetty.acceptors" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpJettySelectors match {
      case Some(param) => queryParams += "org.apache.felix.http.jetty.selectors" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpJettyHeaderBufferSize match {
      case Some(param) => queryParams += "org.apache.felix.http.jetty.headerBufferSize" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpJettyRequestBufferSize match {
      case Some(param) => queryParams += "org.apache.felix.http.jetty.requestBufferSize" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpJettyResponseBufferSize match {
      case Some(param) => queryParams += "org.apache.felix.http.jetty.responseBufferSize" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpJettyMaxFormSize match {
      case Some(param) => queryParams += "org.apache.felix.http.jetty.maxFormSize" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpPathExclusions match {
      case Some(param) => queryParams += "org.apache.felix.http.path_exclusions" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsJettyCiphersuitesExcluded match {
      case Some(param) => queryParams += "org.apache.felix.https.jetty.ciphersuites.excluded" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsJettyCiphersuitesIncluded match {
      case Some(param) => queryParams += "org.apache.felix.https.jetty.ciphersuites.included" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpJettySendServerHeader match {
      case Some(param) => queryParams += "org.apache.felix.http.jetty.sendServerHeader" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsJettyProtocolsIncluded match {
      case Some(param) => queryParams += "org.apache.felix.https.jetty.protocols.included" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsJettyProtocolsExcluded match {
      case Some(param) => queryParams += "org.apache.felix.https.jetty.protocols.excluded" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixProxyLoadBalancerConnectionEnable match {
      case Some(param) => queryParams += "org.apache.felix.proxy.load.balancer.connection.enable" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsJettyRenegotiateAllowed match {
      case Some(param) => queryParams += "org.apache.felix.https.jetty.renegotiateAllowed" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsJettySessionCookieHttpOnly match {
      case Some(param) => queryParams += "org.apache.felix.https.jetty.session.cookie.httpOnly" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsJettySessionCookieSecure match {
      case Some(param) => queryParams += "org.apache.felix.https.jetty.session.cookie.secure" -> param.toString
      case _ => queryParams
    }
    orgEclipseJettyServletSessionIdPathParameterName match {
      case Some(param) => queryParams += "org.eclipse.jetty.servlet.SessionIdPathParameterName" -> param.toString
      case _ => queryParams
    }
    orgEclipseJettyServletCheckingRemoteSessionIdEncoding match {
      case Some(param) => queryParams += "org.eclipse.jetty.servlet.CheckingRemoteSessionIdEncoding" -> param.toString
      case _ => queryParams
    }
    orgEclipseJettyServletSessionCookie match {
      case Some(param) => queryParams += "org.eclipse.jetty.servlet.SessionCookie" -> param.toString
      case _ => queryParams
    }
    orgEclipseJettyServletSessionDomain match {
      case Some(param) => queryParams += "org.eclipse.jetty.servlet.SessionDomain" -> param.toString
      case _ => queryParams
    }
    orgEclipseJettyServletSessionPath match {
      case Some(param) => queryParams += "org.eclipse.jetty.servlet.SessionPath" -> param.toString
      case _ => queryParams
    }
    orgEclipseJettyServletMaxAge match {
      case Some(param) => queryParams += "org.eclipse.jetty.servlet.MaxAge" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpName match {
      case Some(param) => queryParams += "org.apache.felix.http.name" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGziphandlerEnable match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gziphandler.enable" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipMinGzipSize match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.minGzipSize" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipCompressionLevel match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.compressionLevel" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipInflateBufferSize match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.inflateBufferSize" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipSyncFlush match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.syncFlush" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipExcludedUserAgents match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.excludedUserAgents" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipIncludedMethods match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.includedMethods" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipExcludedMethods match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.excludedMethods" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipIncludedPaths match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.includedPaths" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipExcludedPaths match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.excludedPaths" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipIncludedMimeTypes match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.includedMimeTypes" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixJettyGzipExcludedMimeTypes match {
      case Some(param) => queryParams += "org.apache.felix.jetty.gzip.excludedMimeTypes" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpSessionInvalidate match {
      case Some(param) => queryParams += "org.apache.felix.http.session.invalidate" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpSessionUniqueid match {
      case Some(param) => queryParams += "org.apache.felix.http.session.uniqueid" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixHttpSslfilterSslFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    sslForwardHeader: Option[String] = None,
    sslForwardValue: Option[String] = None,
    sslForwardCertHeader: Option[String] = None,
    rewriteAbsoluteUrls: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixHttpSslfilterSslFilterInfo]): Future[OrgApacheFelixHttpSslfilterSslFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.http.sslfilter.SslFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    sslForwardHeader match {
      case Some(param) => queryParams += "ssl-forward.header" -> param.toString
      case _ => queryParams
    }
    sslForwardValue match {
      case Some(param) => queryParams += "ssl-forward.value" -> param.toString
      case _ => queryParams
    }
    sslForwardCertHeader match {
      case Some(param) => queryParams += "ssl-forward-cert.header" -> param.toString
      case _ => queryParams
    }
    rewriteAbsoluteUrls match {
      case Some(param) => queryParams += "rewrite.absolute.urls" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixJaasConfigurationFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jaasControlFlag: Option[String] = None,
    jaasRanking: Option[Integer] = None,
    jaasRealmName: Option[String] = None,
    jaasClassname: Option[String] = None,
    jaasOptions: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixJaasConfigurationFactoryInfo]): Future[OrgApacheFelixJaasConfigurationFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.jaas.Configuration.factory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jaasControlFlag match {
      case Some(param) => queryParams += "jaas.controlFlag" -> param.toString
      case _ => queryParams
    }
    jaasRanking match {
      case Some(param) => queryParams += "jaas.ranking" -> param.toString
      case _ => queryParams
    }
    jaasRealmName match {
      case Some(param) => queryParams += "jaas.realmName" -> param.toString
      case _ => queryParams
    }
    jaasClassname match {
      case Some(param) => queryParams += "jaas.classname" -> param.toString
      case _ => queryParams
    }
    jaasOptions match {
      case Some(param) => queryParams += "jaas.options" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixJaasConfigurationSpi(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jaasDefaultRealmName: Option[String] = None,
    jaasConfigProviderName: Option[String] = None,
    jaasGlobalConfigPolicy: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixJaasConfigurationSpiInfo]): Future[OrgApacheFelixJaasConfigurationSpiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.jaas.ConfigurationSpi"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jaasDefaultRealmName match {
      case Some(param) => queryParams += "jaas.defaultRealmName" -> param.toString
      case _ => queryParams
    }
    jaasConfigProviderName match {
      case Some(param) => queryParams += "jaas.configProviderName" -> param.toString
      case _ => queryParams
    }
    jaasGlobalConfigPolicy match {
      case Some(param) => queryParams += "jaas.globalConfigPolicy" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixScrScrService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    dsLoglevel: Option[Integer] = None,
    dsFactoryEnabled: Option[Boolean] = None,
    dsDelayedKeepInstances: Option[Boolean] = None,
    dsLockTimeoutMilliseconds: Option[Integer] = None,
    dsStopTimeoutMilliseconds: Option[Integer] = None,
    dsGlobalExtender: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixScrScrServiceInfo]): Future[OrgApacheFelixScrScrServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.scr.ScrService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    dsLoglevel match {
      case Some(param) => queryParams += "ds.loglevel" -> param.toString
      case _ => queryParams
    }
    dsFactoryEnabled match {
      case Some(param) => queryParams += "ds.factory.enabled" -> param.toString
      case _ => queryParams
    }
    dsDelayedKeepInstances match {
      case Some(param) => queryParams += "ds.delayed.keepInstances" -> param.toString
      case _ => queryParams
    }
    dsLockTimeoutMilliseconds match {
      case Some(param) => queryParams += "ds.lock.timeout.milliseconds" -> param.toString
      case _ => queryParams
    }
    dsStopTimeoutMilliseconds match {
      case Some(param) => queryParams += "ds.stop.timeout.milliseconds" -> param.toString
      case _ => queryParams
    }
    dsGlobalExtender match {
      case Some(param) => queryParams += "ds.global.extender" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixSystemreadyImplComponentsCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    componentsList: Option[List[String]] = None,
    `type`: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixSystemreadyImplComponentsCheckInfo]): Future[OrgApacheFelixSystemreadyImplComponentsCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.systemready.impl.ComponentsCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    componentsList match {
      case Some(param) => queryParams += "components.list" -> param.toString
      case _ => queryParams
    }
    `type` match {
      case Some(param) => queryParams += "type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixSystemreadyImplFrameworkStartCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    timeout: Option[Integer] = None,
    targetStartLevel: Option[Integer] = None,
    targetStartLevelPropName: Option[String] = None,
    `type`: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo]): Future[OrgApacheFelixSystemreadyImplFrameworkStartCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.systemready.impl.FrameworkStartCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    timeout match {
      case Some(param) => queryParams += "timeout" -> param.toString
      case _ => queryParams
    }
    targetStartLevel match {
      case Some(param) => queryParams += "target.start.level" -> param.toString
      case _ => queryParams
    }
    targetStartLevelPropName match {
      case Some(param) => queryParams += "target.start.level.prop.name" -> param.toString
      case _ => queryParams
    }
    `type` match {
      case Some(param) => queryParams += "type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixSystemreadyImplServicesCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    servicesList: Option[List[String]] = None,
    `type`: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixSystemreadyImplServicesCheckInfo]): Future[OrgApacheFelixSystemreadyImplServicesCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.systemready.impl.ServicesCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    servicesList match {
      case Some(param) => queryParams += "services.list" -> param.toString
      case _ => queryParams
    }
    `type` match {
      case Some(param) => queryParams += "type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixSystemreadyImplServletSystemAliveServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    osgiHttpWhiteboardServletPattern: Option[String] = None,
    osgiHttpWhiteboardContextSelect: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo]): Future[OrgApacheFelixSystemreadyImplServletSystemAliveServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.systemready.impl.servlet.SystemAliveServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    osgiHttpWhiteboardServletPattern match {
      case Some(param) => queryParams += "osgi.http.whiteboard.servlet.pattern" -> param.toString
      case _ => queryParams
    }
    osgiHttpWhiteboardContextSelect match {
      case Some(param) => queryParams += "osgi.http.whiteboard.context.select" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixSystemreadyImplServletSystemReadyServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    osgiHttpWhiteboardServletPattern: Option[String] = None,
    osgiHttpWhiteboardContextSelect: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo]): Future[OrgApacheFelixSystemreadyImplServletSystemReadyServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.systemready.impl.servlet.SystemReadyServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    osgiHttpWhiteboardServletPattern match {
      case Some(param) => queryParams += "osgi.http.whiteboard.servlet.pattern" -> param.toString
      case _ => queryParams
    }
    osgiHttpWhiteboardContextSelect match {
      case Some(param) => queryParams += "osgi.http.whiteboard.context.select" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixSystemreadySystemReadyMonitor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    pollInterval: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixSystemreadySystemReadyMonitorInfo]): Future[OrgApacheFelixSystemreadySystemReadyMonitorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.systemready.SystemReadyMonitor"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    pollInterval match {
      case Some(param) => queryParams += "poll.interval" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixWebconsoleInternalServletOsgiManager(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    managerRoot: Option[String] = None,
    httpServiceFilter: Option[String] = None,
    defaultRender: Option[String] = None,
    realm: Option[String] = None,
    username: Option[String] = None,
    password: Option[String] = None,
    category: Option[String] = None,
    locale: Option[String] = None,
    loglevel: Option[Integer] = None,
    plugins: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo]): Future[OrgApacheFelixWebconsoleInternalServletOsgiManagerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.webconsole.internal.servlet.OsgiManager"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    managerRoot match {
      case Some(param) => queryParams += "manager.root" -> param.toString
      case _ => queryParams
    }
    httpServiceFilter match {
      case Some(param) => queryParams += "http.service.filter" -> param.toString
      case _ => queryParams
    }
    defaultRender match {
      case Some(param) => queryParams += "default.render" -> param.toString
      case _ => queryParams
    }
    realm match {
      case Some(param) => queryParams += "realm" -> param.toString
      case _ => queryParams
    }
    username match {
      case Some(param) => queryParams += "username" -> param.toString
      case _ => queryParams
    }
    password match {
      case Some(param) => queryParams += "password" -> param.toString
      case _ => queryParams
    }
    category match {
      case Some(param) => queryParams += "category" -> param.toString
      case _ => queryParams
    }
    locale match {
      case Some(param) => queryParams += "locale" -> param.toString
      case _ => queryParams
    }
    loglevel match {
      case Some(param) => queryParams += "loglevel" -> param.toString
      case _ => queryParams
    }
    plugins match {
      case Some(param) => queryParams += "plugins" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixWebconsolePluginsEventInternalPluginServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo]): Future[OrgApacheFelixWebconsolePluginsEventInternalPluginServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.webconsole.plugins.event.internal.PluginServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxSize match {
      case Some(param) => queryParams += "max.size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCo(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    felixMemoryusageDumpThreshold: Option[Integer] = None,
    felixMemoryusageDumpInterval: Option[Integer] = None,
    felixMemoryusageDumpLocation: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo]): Future[OrgApacheFelixWebconsolePluginsMemoryusageInternalMemoryUsageCoInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.felix.webconsole.plugins.memoryusage.internal.MemoryUsageConfigurator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    felixMemoryusageDumpThreshold match {
      case Some(param) => queryParams += "felix.memoryusage.dump.threshold" -> param.toString
      case _ => queryParams
    }
    felixMemoryusageDumpInterval match {
      case Some(param) => queryParams += "felix.memoryusage.dump.interval" -> param.toString
      case _ => queryParams
    }
    felixMemoryusageDumpLocation match {
      case Some(param) => queryParams += "felix.memoryusage.dump.location" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheHttpProxyconfigurator(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    proxyEnabled: Option[Boolean] = None,
    proxyHost: Option[String] = None,
    proxyPort: Option[Integer] = None,
    proxyUser: Option[String] = None,
    proxyPassword: Option[String] = None,
    proxyExceptions: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheHttpProxyconfiguratorInfo]): Future[OrgApacheHttpProxyconfiguratorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.http.proxyconfigurator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    proxyEnabled match {
      case Some(param) => queryParams += "proxy.enabled" -> param.toString
      case _ => queryParams
    }
    proxyHost match {
      case Some(param) => queryParams += "proxy.host" -> param.toString
      case _ => queryParams
    }
    proxyPort match {
      case Some(param) => queryParams += "proxy.port" -> param.toString
      case _ => queryParams
    }
    proxyUser match {
      case Some(param) => queryParams += "proxy.user" -> param.toString
      case _ => queryParams
    }
    proxyPassword match {
      case Some(param) => queryParams += "proxy.password" -> param.toString
      case _ => queryParams
    }
    proxyExceptions match {
      case Some(param) => queryParams += "proxy.exceptions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    dir: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo]): Future[OrgApacheJackrabbitOakPluginsBlobDatastoreDataStoreTextProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.blob.datastore.DataStoreTextProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    dir match {
      case Some(param) => queryParams += "dir" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsBlobDatastoreFileDataStore(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo]): Future[OrgApacheJackrabbitOakPluginsBlobDatastoreFileDataStoreInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.blob.datastore.FileDataStore"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mongouri: Option[String] = None,
    db: Option[String] = None,
    socketKeepAlive: Option[Boolean] = None,
    cache: Option[Integer] = None,
    nodeCachePercentage: Option[Integer] = None,
    prevDocCachePercentage: Option[Integer] = None,
    childrenCachePercentage: Option[Integer] = None,
    diffCachePercentage: Option[Integer] = None,
    cacheSegmentCount: Option[Integer] = None,
    cacheStackMoveDistance: Option[Integer] = None,
    blobCacheSize: Option[Integer] = None,
    persistentCache: Option[String] = None,
    journalCache: Option[String] = None,
    customBlobStore: Option[Boolean] = None,
    journalGCInterval: Option[Integer] = None,
    journalGCMaxAge: Option[Integer] = None,
    prefetchExternalChanges: Option[Boolean] = None,
    role: Option[String] = None,
    versionGcMaxAgeInSecs: Option[Integer] = None,
    versionGCExpression: Option[String] = None,
    versionGCTimeLimitInSecs: Option[Integer] = None,
    blobGcMaxAgeInSecs: Option[Integer] = None,
    blobTrackSnapshotIntervalInSecs: Option[Integer] = None,
    repositoryHome: Option[String] = None,
    maxReplicationLagInSecs: Option[Integer] = None,
    documentStoreType: Option[String] = None,
    bundlingDisabled: Option[Boolean] = None,
    updateLimit: Option[Integer] = None,
    persistentCacheIncludes: Option[List[String]] = None,
    leaseCheckMode: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo]): Future[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mongouri match {
      case Some(param) => queryParams += "mongouri" -> param.toString
      case _ => queryParams
    }
    db match {
      case Some(param) => queryParams += "db" -> param.toString
      case _ => queryParams
    }
    socketKeepAlive match {
      case Some(param) => queryParams += "socketKeepAlive" -> param.toString
      case _ => queryParams
    }
    cache match {
      case Some(param) => queryParams += "cache" -> param.toString
      case _ => queryParams
    }
    nodeCachePercentage match {
      case Some(param) => queryParams += "nodeCachePercentage" -> param.toString
      case _ => queryParams
    }
    prevDocCachePercentage match {
      case Some(param) => queryParams += "prevDocCachePercentage" -> param.toString
      case _ => queryParams
    }
    childrenCachePercentage match {
      case Some(param) => queryParams += "childrenCachePercentage" -> param.toString
      case _ => queryParams
    }
    diffCachePercentage match {
      case Some(param) => queryParams += "diffCachePercentage" -> param.toString
      case _ => queryParams
    }
    cacheSegmentCount match {
      case Some(param) => queryParams += "cacheSegmentCount" -> param.toString
      case _ => queryParams
    }
    cacheStackMoveDistance match {
      case Some(param) => queryParams += "cacheStackMoveDistance" -> param.toString
      case _ => queryParams
    }
    blobCacheSize match {
      case Some(param) => queryParams += "blobCacheSize" -> param.toString
      case _ => queryParams
    }
    persistentCache match {
      case Some(param) => queryParams += "persistentCache" -> param.toString
      case _ => queryParams
    }
    journalCache match {
      case Some(param) => queryParams += "journalCache" -> param.toString
      case _ => queryParams
    }
    customBlobStore match {
      case Some(param) => queryParams += "customBlobStore" -> param.toString
      case _ => queryParams
    }
    journalGCInterval match {
      case Some(param) => queryParams += "journalGCInterval" -> param.toString
      case _ => queryParams
    }
    journalGCMaxAge match {
      case Some(param) => queryParams += "journalGCMaxAge" -> param.toString
      case _ => queryParams
    }
    prefetchExternalChanges match {
      case Some(param) => queryParams += "prefetchExternalChanges" -> param.toString
      case _ => queryParams
    }
    role match {
      case Some(param) => queryParams += "role" -> param.toString
      case _ => queryParams
    }
    versionGcMaxAgeInSecs match {
      case Some(param) => queryParams += "versionGcMaxAgeInSecs" -> param.toString
      case _ => queryParams
    }
    versionGCExpression match {
      case Some(param) => queryParams += "versionGCExpression" -> param.toString
      case _ => queryParams
    }
    versionGCTimeLimitInSecs match {
      case Some(param) => queryParams += "versionGCTimeLimitInSecs" -> param.toString
      case _ => queryParams
    }
    blobGcMaxAgeInSecs match {
      case Some(param) => queryParams += "blobGcMaxAgeInSecs" -> param.toString
      case _ => queryParams
    }
    blobTrackSnapshotIntervalInSecs match {
      case Some(param) => queryParams += "blobTrackSnapshotIntervalInSecs" -> param.toString
      case _ => queryParams
    }
    repositoryHome match {
      case Some(param) => queryParams += "repository.home" -> param.toString
      case _ => queryParams
    }
    maxReplicationLagInSecs match {
      case Some(param) => queryParams += "maxReplicationLagInSecs" -> param.toString
      case _ => queryParams
    }
    documentStoreType match {
      case Some(param) => queryParams += "documentStoreType" -> param.toString
      case _ => queryParams
    }
    bundlingDisabled match {
      case Some(param) => queryParams += "bundlingDisabled" -> param.toString
      case _ => queryParams
    }
    updateLimit match {
      case Some(param) => queryParams += "updateLimit" -> param.toString
      case _ => queryParams
    }
    persistentCacheIncludes match {
      case Some(param) => queryParams += "persistentCacheIncludes" -> param.toString
      case _ => queryParams
    }
    leaseCheckMode match {
      case Some(param) => queryParams += "leaseCheckMode" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePre(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    persistentCacheIncludes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo]): Future[OrgApacheJackrabbitOakPluginsDocumentDocumentNodeStoreServicePreInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreServicePreset"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    persistentCacheIncludes match {
      case Some(param) => queryParams += "persistentCacheIncludes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCac(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    includedPaths: Option[List[String]] = None,
    enableAsyncObserver: Option[Boolean] = None,
    observerQueueSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo]): Future[OrgApacheJackrabbitOakPluginsDocumentSecondarySecondaryStoreCacInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.document.secondary.SecondaryStoreCacheService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    includedPaths match {
      case Some(param) => queryParams += "includedPaths" -> param.toString
      case _ => queryParams
    }
    enableAsyncObserver match {
      case Some(param) => queryParams += "enableAsyncObserver" -> param.toString
      case _ => queryParams
    }
    observerQueueSize match {
      case Some(param) => queryParams += "observerQueueSize" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsIndexAsyncIndexerService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    asyncConfigs: Option[List[String]] = None,
    leaseTimeOutMinutes: Option[Integer] = None,
    failingIndexTimeoutSeconds: Option[Integer] = None,
    errorWarnIntervalSeconds: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo]): Future[OrgApacheJackrabbitOakPluginsIndexAsyncIndexerServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.AsyncIndexerService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    asyncConfigs match {
      case Some(param) => queryParams += "asyncConfigs" -> param.toString
      case _ => queryParams
    }
    leaseTimeOutMinutes match {
      case Some(param) => queryParams += "leaseTimeOutMinutes" -> param.toString
      case _ => queryParams
    }
    failingIndexTimeoutSeconds match {
      case Some(param) => queryParams += "failingIndexTimeoutSeconds" -> param.toString
      case _ => queryParams
    }
    errorWarnIntervalSeconds match {
      case Some(param) => queryParams += "errorWarnIntervalSeconds" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServ(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    disabled: Option[Boolean] = None,
    debug: Option[Boolean] = None,
    localIndexDir: Option[String] = None,
    enableOpenIndexAsync: Option[Boolean] = None,
    threadPoolSize: Option[Integer] = None,
    prefetchIndexFiles: Option[Boolean] = None,
    extractedTextCacheSizeInMB: Option[Integer] = None,
    extractedTextCacheExpiryInSecs: Option[Integer] = None,
    alwaysUsePreExtractedCache: Option[Boolean] = None,
    booleanClauseLimit: Option[Integer] = None,
    enableHybridIndexing: Option[Boolean] = None,
    hybridQueueSize: Option[Integer] = None,
    disableStoredIndexDefinition: Option[Boolean] = None,
    deletedBlobsCollectionEnabled: Option[Boolean] = None,
    propIndexCleanerIntervalInSecs: Option[Integer] = None,
    enableSingleBlobIndexFiles: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo]): Future[OrgApacheJackrabbitOakPluginsIndexLuceneLuceneIndexProviderServInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    disabled match {
      case Some(param) => queryParams += "disabled" -> param.toString
      case _ => queryParams
    }
    debug match {
      case Some(param) => queryParams += "debug" -> param.toString
      case _ => queryParams
    }
    localIndexDir match {
      case Some(param) => queryParams += "localIndexDir" -> param.toString
      case _ => queryParams
    }
    enableOpenIndexAsync match {
      case Some(param) => queryParams += "enableOpenIndexAsync" -> param.toString
      case _ => queryParams
    }
    threadPoolSize match {
      case Some(param) => queryParams += "threadPoolSize" -> param.toString
      case _ => queryParams
    }
    prefetchIndexFiles match {
      case Some(param) => queryParams += "prefetchIndexFiles" -> param.toString
      case _ => queryParams
    }
    extractedTextCacheSizeInMB match {
      case Some(param) => queryParams += "extractedTextCacheSizeInMB" -> param.toString
      case _ => queryParams
    }
    extractedTextCacheExpiryInSecs match {
      case Some(param) => queryParams += "extractedTextCacheExpiryInSecs" -> param.toString
      case _ => queryParams
    }
    alwaysUsePreExtractedCache match {
      case Some(param) => queryParams += "alwaysUsePreExtractedCache" -> param.toString
      case _ => queryParams
    }
    booleanClauseLimit match {
      case Some(param) => queryParams += "booleanClauseLimit" -> param.toString
      case _ => queryParams
    }
    enableHybridIndexing match {
      case Some(param) => queryParams += "enableHybridIndexing" -> param.toString
      case _ => queryParams
    }
    hybridQueueSize match {
      case Some(param) => queryParams += "hybridQueueSize" -> param.toString
      case _ => queryParams
    }
    disableStoredIndexDefinition match {
      case Some(param) => queryParams += "disableStoredIndexDefinition" -> param.toString
      case _ => queryParams
    }
    deletedBlobsCollectionEnabled match {
      case Some(param) => queryParams += "deletedBlobsCollectionEnabled" -> param.toString
      case _ => queryParams
    }
    propIndexCleanerIntervalInSecs match {
      case Some(param) => queryParams += "propIndexCleanerIntervalInSecs" -> param.toString
      case _ => queryParams
    }
    enableSingleBlobIndexFiles match {
      case Some(param) => queryParams += "enableSingleBlobIndexFiles" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCo(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    solrHomePath: Option[String] = None,
    solrCoreName: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo]): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiEmbeddedSolrServerCoInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.EmbeddedSolrServerConfigurationProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    solrHomePath match {
      case Some(param) => queryParams += "solr.home.path" -> param.toString
      case _ => queryParams
    }
    solrCoreName match {
      case Some(param) => queryParams += "solr.core.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServers(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo]): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiNodeStateSolrServersInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.NodeStateSolrServersObserverService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfiguration(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    pathDescField: Option[String] = None,
    pathChildField: Option[String] = None,
    pathParentField: Option[String] = None,
    pathExactField: Option[String] = None,
    catchAllField: Option[String] = None,
    collapsedPathField: Option[String] = None,
    pathDepthField: Option[String] = None,
    commitPolicy: Option[String] = None,
    rows: Option[Integer] = None,
    pathRestrictions: Option[Boolean] = None,
    propertyRestrictions: Option[Boolean] = None,
    primarytypesRestrictions: Option[Boolean] = None,
    ignoredProperties: Option[List[String]] = None,
    usedProperties: Option[List[String]] = None,
    typeMappings: Option[List[String]] = None,
    propertyMappings: Option[List[String]] = None,
    collapseJcrcontentNodes: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo]): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiOakSolrConfigurationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.OakSolrConfigurationProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    pathDescField match {
      case Some(param) => queryParams += "path.desc.field" -> param.toString
      case _ => queryParams
    }
    pathChildField match {
      case Some(param) => queryParams += "path.child.field" -> param.toString
      case _ => queryParams
    }
    pathParentField match {
      case Some(param) => queryParams += "path.parent.field" -> param.toString
      case _ => queryParams
    }
    pathExactField match {
      case Some(param) => queryParams += "path.exact.field" -> param.toString
      case _ => queryParams
    }
    catchAllField match {
      case Some(param) => queryParams += "catch.all.field" -> param.toString
      case _ => queryParams
    }
    collapsedPathField match {
      case Some(param) => queryParams += "collapsed.path.field" -> param.toString
      case _ => queryParams
    }
    pathDepthField match {
      case Some(param) => queryParams += "path.depth.field" -> param.toString
      case _ => queryParams
    }
    commitPolicy match {
      case Some(param) => queryParams += "commit.policy" -> param.toString
      case _ => queryParams
    }
    rows match {
      case Some(param) => queryParams += "rows" -> param.toString
      case _ => queryParams
    }
    pathRestrictions match {
      case Some(param) => queryParams += "path.restrictions" -> param.toString
      case _ => queryParams
    }
    propertyRestrictions match {
      case Some(param) => queryParams += "property.restrictions" -> param.toString
      case _ => queryParams
    }
    primarytypesRestrictions match {
      case Some(param) => queryParams += "primarytypes.restrictions" -> param.toString
      case _ => queryParams
    }
    ignoredProperties match {
      case Some(param) => queryParams += "ignored.properties" -> param.toString
      case _ => queryParams
    }
    usedProperties match {
      case Some(param) => queryParams += "used.properties" -> param.toString
      case _ => queryParams
    }
    typeMappings match {
      case Some(param) => queryParams += "type.mappings" -> param.toString
      case _ => queryParams
    }
    propertyMappings match {
      case Some(param) => queryParams += "property.mappings" -> param.toString
      case _ => queryParams
    }
    collapseJcrcontentNodes match {
      case Some(param) => queryParams += "collapse.jcrcontent.nodes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConf(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    solrHttpUrl: Option[String] = None,
    solrZkHost: Option[String] = None,
    solrCollection: Option[String] = None,
    solrSocketTimeout: Option[Integer] = None,
    solrConnectionTimeout: Option[Integer] = None,
    solrShardsNo: Option[Integer] = None,
    solrReplicationFactor: Option[Integer] = None,
    solrConfDir: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo]): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiRemoteSolrServerConfInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.RemoteSolrServerConfigurationProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    solrHttpUrl match {
      case Some(param) => queryParams += "solr.http.url" -> param.toString
      case _ => queryParams
    }
    solrZkHost match {
      case Some(param) => queryParams += "solr.zk.host" -> param.toString
      case _ => queryParams
    }
    solrCollection match {
      case Some(param) => queryParams += "solr.collection" -> param.toString
      case _ => queryParams
    }
    solrSocketTimeout match {
      case Some(param) => queryParams += "solr.socket.timeout" -> param.toString
      case _ => queryParams
    }
    solrConnectionTimeout match {
      case Some(param) => queryParams += "solr.connection.timeout" -> param.toString
      case _ => queryParams
    }
    solrShardsNo match {
      case Some(param) => queryParams += "solr.shards.no" -> param.toString
      case _ => queryParams
    }
    solrReplicationFactor match {
      case Some(param) => queryParams += "solr.replication.factor" -> param.toString
      case _ => queryParams
    }
    solrConfDir match {
      case Some(param) => queryParams += "solr.conf.dir" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvid(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    queryAggregation: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo]): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrQueryIndexProvidInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.SolrQueryIndexProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    queryAggregation match {
      case Some(param) => queryParams += "query.aggregation" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSe(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serverType: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo]): Future[OrgApacheJackrabbitOakPluginsIndexSolrOsgiSolrServerProviderSeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.index.solr.osgi.SolrServerProviderService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serverType match {
      case Some(param) => queryParams += "server.type" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsMetricStatisticsProviderFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    providerType: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo]): Future[OrgApacheJackrabbitOakPluginsMetricStatisticsProviderFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.metric.StatisticsProviderFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    providerType match {
      case Some(param) => queryParams += "providerType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakPluginsObservationChangeCollectorProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxItems: Option[Integer] = None,
    maxPathDepth: Option[Integer] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo]): Future[OrgApacheJackrabbitOakPluginsObservationChangeCollectorProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.plugins.observation.ChangeCollectorProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxItems match {
      case Some(param) => queryParams += "maxItems" -> param.toString
      case _ => queryParams
    }
    maxPathDepth match {
      case Some(param) => queryParams += "maxPathDepth" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakQueryQueryEngineSettingsService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    queryLimitInMemory: Option[Integer] = None,
    queryLimitReads: Option[Integer] = None,
    queryFailTraversal: Option[Boolean] = None,
    fastQuerySize: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo]): Future[OrgApacheJackrabbitOakQueryQueryEngineSettingsServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.query.QueryEngineSettingsService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    queryLimitInMemory match {
      case Some(param) => queryParams += "queryLimitInMemory" -> param.toString
      case _ => queryParams
    }
    queryLimitReads match {
      case Some(param) => queryParams += "queryLimitReads" -> param.toString
      case _ => queryParams
    }
    queryFailTraversal match {
      case Some(param) => queryParams += "queryFailTraversal" -> param.toString
      case _ => queryParams
    }
    fastQuerySize match {
      case Some(param) => queryParams += "fastQuerySize" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheJackrabbitOakAuthenticationAppName: Option[String] = None,
    orgApacheJackrabbitOakAuthenticationConfigSpiName: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo]): Future[OrgApacheJackrabbitOakSecurityAuthenticationAuthenticationConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.AuthenticationConfigurationImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheJackrabbitOakAuthenticationAppName match {
      case Some(param) => queryParams += "org.apache.jackrabbit.oak.authentication.appName" -> param.toString
      case _ => queryParams
    }
    orgApacheJackrabbitOakAuthenticationConfigSpiName match {
      case Some(param) => queryParams += "org.apache.jackrabbit.oak.authentication.configSpiName" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdenti(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    providerName: Option[String] = None,
    hostName: Option[String] = None,
    hostPort: Option[Integer] = None,
    hostSsl: Option[Boolean] = None,
    hostTls: Option[Boolean] = None,
    hostNoCertCheck: Option[Boolean] = None,
    bindDn: Option[String] = None,
    bindPassword: Option[String] = None,
    searchTimeout: Option[String] = None,
    adminPoolMaxActive: Option[Integer] = None,
    adminPoolLookupOnValidate: Option[Boolean] = None,
    userPoolMaxActive: Option[Integer] = None,
    userPoolLookupOnValidate: Option[Boolean] = None,
    userBaseDN: Option[String] = None,
    userObjectclass: Option[List[String]] = None,
    userIdAttribute: Option[String] = None,
    userExtraFilter: Option[String] = None,
    userMakeDnPath: Option[Boolean] = None,
    groupBaseDN: Option[String] = None,
    groupObjectclass: Option[List[String]] = None,
    groupNameAttribute: Option[String] = None,
    groupExtraFilter: Option[String] = None,
    groupMakeDnPath: Option[Boolean] = None,
    groupMemberAttribute: Option[String] = None,
    useUidForExtId: Option[Boolean] = None,
    customattributes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo]): Future[OrgApacheJackrabbitOakSecurityAuthenticationLdapImplLdapIdentiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    providerName match {
      case Some(param) => queryParams += "provider.name" -> param.toString
      case _ => queryParams
    }
    hostName match {
      case Some(param) => queryParams += "host.name" -> param.toString
      case _ => queryParams
    }
    hostPort match {
      case Some(param) => queryParams += "host.port" -> param.toString
      case _ => queryParams
    }
    hostSsl match {
      case Some(param) => queryParams += "host.ssl" -> param.toString
      case _ => queryParams
    }
    hostTls match {
      case Some(param) => queryParams += "host.tls" -> param.toString
      case _ => queryParams
    }
    hostNoCertCheck match {
      case Some(param) => queryParams += "host.noCertCheck" -> param.toString
      case _ => queryParams
    }
    bindDn match {
      case Some(param) => queryParams += "bind.dn" -> param.toString
      case _ => queryParams
    }
    bindPassword match {
      case Some(param) => queryParams += "bind.password" -> param.toString
      case _ => queryParams
    }
    searchTimeout match {
      case Some(param) => queryParams += "searchTimeout" -> param.toString
      case _ => queryParams
    }
    adminPoolMaxActive match {
      case Some(param) => queryParams += "adminPool.maxActive" -> param.toString
      case _ => queryParams
    }
    adminPoolLookupOnValidate match {
      case Some(param) => queryParams += "adminPool.lookupOnValidate" -> param.toString
      case _ => queryParams
    }
    userPoolMaxActive match {
      case Some(param) => queryParams += "userPool.maxActive" -> param.toString
      case _ => queryParams
    }
    userPoolLookupOnValidate match {
      case Some(param) => queryParams += "userPool.lookupOnValidate" -> param.toString
      case _ => queryParams
    }
    userBaseDN match {
      case Some(param) => queryParams += "user.baseDN" -> param.toString
      case _ => queryParams
    }
    userObjectclass match {
      case Some(param) => queryParams += "user.objectclass" -> param.toString
      case _ => queryParams
    }
    userIdAttribute match {
      case Some(param) => queryParams += "user.idAttribute" -> param.toString
      case _ => queryParams
    }
    userExtraFilter match {
      case Some(param) => queryParams += "user.extraFilter" -> param.toString
      case _ => queryParams
    }
    userMakeDnPath match {
      case Some(param) => queryParams += "user.makeDnPath" -> param.toString
      case _ => queryParams
    }
    groupBaseDN match {
      case Some(param) => queryParams += "group.baseDN" -> param.toString
      case _ => queryParams
    }
    groupObjectclass match {
      case Some(param) => queryParams += "group.objectclass" -> param.toString
      case _ => queryParams
    }
    groupNameAttribute match {
      case Some(param) => queryParams += "group.nameAttribute" -> param.toString
      case _ => queryParams
    }
    groupExtraFilter match {
      case Some(param) => queryParams += "group.extraFilter" -> param.toString
      case _ => queryParams
    }
    groupMakeDnPath match {
      case Some(param) => queryParams += "group.makeDnPath" -> param.toString
      case _ => queryParams
    }
    groupMemberAttribute match {
      case Some(param) => queryParams += "group.memberAttribute" -> param.toString
      case _ => queryParams
    }
    useUidForExtId match {
      case Some(param) => queryParams += "useUidForExtId" -> param.toString
      case _ => queryParams
    }
    customattributes match {
      case Some(param) => queryParams += "customattributes" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfigura(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    tokenExpiration: Option[String] = None,
    tokenLength: Option[String] = None,
    tokenRefresh: Option[Boolean] = None,
    tokenCleanupThreshold: Option[Integer] = None,
    passwordHashAlgorithm: Option[String] = None,
    passwordHashIterations: Option[Integer] = None,
    passwordSaltSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo]): Future[OrgApacheJackrabbitOakSecurityAuthenticationTokenTokenConfiguraInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.security.authentication.token.TokenConfigurationImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    tokenExpiration match {
      case Some(param) => queryParams += "tokenExpiration" -> param.toString
      case _ => queryParams
    }
    tokenLength match {
      case Some(param) => queryParams += "tokenLength" -> param.toString
      case _ => queryParams
    }
    tokenRefresh match {
      case Some(param) => queryParams += "tokenRefresh" -> param.toString
      case _ => queryParams
    }
    tokenCleanupThreshold match {
      case Some(param) => queryParams += "tokenCleanupThreshold" -> param.toString
      case _ => queryParams
    }
    passwordHashAlgorithm match {
      case Some(param) => queryParams += "passwordHashAlgorithm" -> param.toString
      case _ => queryParams
    }
    passwordHashIterations match {
      case Some(param) => queryParams += "passwordHashIterations" -> param.toString
      case _ => queryParams
    }
    passwordSaltSize match {
      case Some(param) => queryParams += "passwordSaltSize" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigur(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    permissionsJr2: Option[String] = None,
    importBehavior: Option[String] = None,
    readPaths: Option[List[String]] = None,
    administrativePrincipals: Option[List[String]] = None,
    configurationRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo]): Future[OrgApacheJackrabbitOakSecurityAuthorizationAuthorizationConfigurInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.security.authorization.AuthorizationConfigurationImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    permissionsJr2 match {
      case Some(param) => queryParams += "permissionsJr2" -> param.toString
      case _ => queryParams
    }
    importBehavior match {
      case Some(param) => queryParams += "importBehavior" -> param.toString
      case _ => queryParams
    }
    readPaths match {
      case Some(param) => queryParams += "readPaths" -> param.toString
      case _ => queryParams
    }
    administrativePrincipals match {
      case Some(param) => queryParams += "administrativePrincipals" -> param.toString
      case _ => queryParams
    }
    configurationRanking match {
      case Some(param) => queryParams += "configurationRanking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSecurityInternalSecurityProviderRegistrati(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    requiredServicePids: Option[List[String]] = None,
    authorizationCompositionType: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo]): Future[OrgApacheJackrabbitOakSecurityInternalSecurityProviderRegistratiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.security.internal.SecurityProviderRegistration"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    requiredServicePids match {
      case Some(param) => queryParams += "requiredServicePids" -> param.toString
      case _ => queryParams
    }
    authorizationCompositionType match {
      case Some(param) => queryParams += "authorizationCompositionType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeName(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    length: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo]): Future[OrgApacheJackrabbitOakSecurityUserRandomAuthorizableNodeNameInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.security.user.RandomAuthorizableNodeName"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    length match {
      case Some(param) => queryParams += "length" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSecurityUserUserConfigurationImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    usersPath: Option[String] = None,
    groupsPath: Option[String] = None,
    systemRelativePath: Option[String] = None,
    defaultDepth: Option[Integer] = None,
    importBehavior: Option[String] = None,
    passwordHashAlgorithm: Option[String] = None,
    passwordHashIterations: Option[Integer] = None,
    passwordSaltSize: Option[Integer] = None,
    omitAdminPw: Option[Boolean] = None,
    supportAutoSave: Option[Boolean] = None,
    passwordMaxAge: Option[Integer] = None,
    initialPasswordChange: Option[Boolean] = None,
    passwordHistorySize: Option[Integer] = None,
    passwordExpiryForAdmin: Option[Boolean] = None,
    cacheExpiration: Option[Integer] = None,
    enableRFC7613UsercaseMappedProfile: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo]): Future[OrgApacheJackrabbitOakSecurityUserUserConfigurationImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.security.user.UserConfigurationImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    usersPath match {
      case Some(param) => queryParams += "usersPath" -> param.toString
      case _ => queryParams
    }
    groupsPath match {
      case Some(param) => queryParams += "groupsPath" -> param.toString
      case _ => queryParams
    }
    systemRelativePath match {
      case Some(param) => queryParams += "systemRelativePath" -> param.toString
      case _ => queryParams
    }
    defaultDepth match {
      case Some(param) => queryParams += "defaultDepth" -> param.toString
      case _ => queryParams
    }
    importBehavior match {
      case Some(param) => queryParams += "importBehavior" -> param.toString
      case _ => queryParams
    }
    passwordHashAlgorithm match {
      case Some(param) => queryParams += "passwordHashAlgorithm" -> param.toString
      case _ => queryParams
    }
    passwordHashIterations match {
      case Some(param) => queryParams += "passwordHashIterations" -> param.toString
      case _ => queryParams
    }
    passwordSaltSize match {
      case Some(param) => queryParams += "passwordSaltSize" -> param.toString
      case _ => queryParams
    }
    omitAdminPw match {
      case Some(param) => queryParams += "omitAdminPw" -> param.toString
      case _ => queryParams
    }
    supportAutoSave match {
      case Some(param) => queryParams += "supportAutoSave" -> param.toString
      case _ => queryParams
    }
    passwordMaxAge match {
      case Some(param) => queryParams += "passwordMaxAge" -> param.toString
      case _ => queryParams
    }
    initialPasswordChange match {
      case Some(param) => queryParams += "initialPasswordChange" -> param.toString
      case _ => queryParams
    }
    passwordHistorySize match {
      case Some(param) => queryParams += "passwordHistorySize" -> param.toString
      case _ => queryParams
    }
    passwordExpiryForAdmin match {
      case Some(param) => queryParams += "passwordExpiryForAdmin" -> param.toString
      case _ => queryParams
    }
    cacheExpiration match {
      case Some(param) => queryParams += "cacheExpiration" -> param.toString
      case _ => queryParams
    }
    enableRFC7613UsercaseMappedProfile match {
      case Some(param) => queryParams += "enableRFC7613UsercaseMappedProfile" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSegmentAzureAzureSegmentStoreService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    accountName: Option[String] = None,
    containerName: Option[String] = None,
    accessKey: Option[String] = None,
    rootPath: Option[String] = None,
    connectionURL: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo]): Future[OrgApacheJackrabbitOakSegmentAzureAzureSegmentStoreServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.segment.azure.AzureSegmentStoreService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    accountName match {
      case Some(param) => queryParams += "accountName" -> param.toString
      case _ => queryParams
    }
    containerName match {
      case Some(param) => queryParams += "containerName" -> param.toString
      case _ => queryParams
    }
    accessKey match {
      case Some(param) => queryParams += "accessKey" -> param.toString
      case _ => queryParams
    }
    rootPath match {
      case Some(param) => queryParams += "rootPath" -> param.toString
      case _ => queryParams
    }
    connectionURL match {
      case Some(param) => queryParams += "connectionURL" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSegmentSegmentNodeStoreFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    repositoryHome: Option[String] = None,
    tarmkMode: Option[String] = None,
    tarmkSize: Option[Integer] = None,
    segmentCacheSize: Option[Integer] = None,
    stringCacheSize: Option[Integer] = None,
    templateCacheSize: Option[Integer] = None,
    stringDeduplicationCacheSize: Option[Integer] = None,
    templateDeduplicationCacheSize: Option[Integer] = None,
    nodeDeduplicationCacheSize: Option[Integer] = None,
    pauseCompaction: Option[Boolean] = None,
    compactionRetryCount: Option[Integer] = None,
    compactionForceTimeout: Option[Integer] = None,
    compactionSizeDeltaEstimation: Option[Integer] = None,
    compactionDisableEstimation: Option[Boolean] = None,
    compactionRetainedGenerations: Option[Integer] = None,
    compactionMemoryThreshold: Option[Integer] = None,
    compactionProgressLog: Option[Integer] = None,
    standby: Option[Boolean] = None,
    customBlobStore: Option[Boolean] = None,
    customSegmentStore: Option[Boolean] = None,
    splitPersistence: Option[Boolean] = None,
    repositoryBackupDir: Option[String] = None,
    blobGcMaxAgeInSecs: Option[Integer] = None,
    blobTrackSnapshotIntervalInSecs: Option[Integer] = None,
    role: Option[String] = None,
    registerDescriptors: Option[Boolean] = None,
    dispatchChanges: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo]): Future[OrgApacheJackrabbitOakSegmentSegmentNodeStoreFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    repositoryHome match {
      case Some(param) => queryParams += "repository.home" -> param.toString
      case _ => queryParams
    }
    tarmkMode match {
      case Some(param) => queryParams += "tarmk.mode" -> param.toString
      case _ => queryParams
    }
    tarmkSize match {
      case Some(param) => queryParams += "tarmk.size" -> param.toString
      case _ => queryParams
    }
    segmentCacheSize match {
      case Some(param) => queryParams += "segmentCache.size" -> param.toString
      case _ => queryParams
    }
    stringCacheSize match {
      case Some(param) => queryParams += "stringCache.size" -> param.toString
      case _ => queryParams
    }
    templateCacheSize match {
      case Some(param) => queryParams += "templateCache.size" -> param.toString
      case _ => queryParams
    }
    stringDeduplicationCacheSize match {
      case Some(param) => queryParams += "stringDeduplicationCache.size" -> param.toString
      case _ => queryParams
    }
    templateDeduplicationCacheSize match {
      case Some(param) => queryParams += "templateDeduplicationCache.size" -> param.toString
      case _ => queryParams
    }
    nodeDeduplicationCacheSize match {
      case Some(param) => queryParams += "nodeDeduplicationCache.size" -> param.toString
      case _ => queryParams
    }
    pauseCompaction match {
      case Some(param) => queryParams += "pauseCompaction" -> param.toString
      case _ => queryParams
    }
    compactionRetryCount match {
      case Some(param) => queryParams += "compaction.retryCount" -> param.toString
      case _ => queryParams
    }
    compactionForceTimeout match {
      case Some(param) => queryParams += "compaction.force.timeout" -> param.toString
      case _ => queryParams
    }
    compactionSizeDeltaEstimation match {
      case Some(param) => queryParams += "compaction.sizeDeltaEstimation" -> param.toString
      case _ => queryParams
    }
    compactionDisableEstimation match {
      case Some(param) => queryParams += "compaction.disableEstimation" -> param.toString
      case _ => queryParams
    }
    compactionRetainedGenerations match {
      case Some(param) => queryParams += "compaction.retainedGenerations" -> param.toString
      case _ => queryParams
    }
    compactionMemoryThreshold match {
      case Some(param) => queryParams += "compaction.memoryThreshold" -> param.toString
      case _ => queryParams
    }
    compactionProgressLog match {
      case Some(param) => queryParams += "compaction.progressLog" -> param.toString
      case _ => queryParams
    }
    standby match {
      case Some(param) => queryParams += "standby" -> param.toString
      case _ => queryParams
    }
    customBlobStore match {
      case Some(param) => queryParams += "customBlobStore" -> param.toString
      case _ => queryParams
    }
    customSegmentStore match {
      case Some(param) => queryParams += "customSegmentStore" -> param.toString
      case _ => queryParams
    }
    splitPersistence match {
      case Some(param) => queryParams += "splitPersistence" -> param.toString
      case _ => queryParams
    }
    repositoryBackupDir match {
      case Some(param) => queryParams += "repository.backup.dir" -> param.toString
      case _ => queryParams
    }
    blobGcMaxAgeInSecs match {
      case Some(param) => queryParams += "blobGcMaxAgeInSecs" -> param.toString
      case _ => queryParams
    }
    blobTrackSnapshotIntervalInSecs match {
      case Some(param) => queryParams += "blobTrackSnapshotIntervalInSecs" -> param.toString
      case _ => queryParams
    }
    role match {
      case Some(param) => queryParams += "role" -> param.toString
      case _ => queryParams
    }
    registerDescriptors match {
      case Some(param) => queryParams += "registerDescriptors" -> param.toString
      case _ => queryParams
    }
    dispatchChanges match {
      case Some(param) => queryParams += "dispatchChanges" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    commitsTrackerWriterGroups: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo]): Future[OrgApacheJackrabbitOakSegmentSegmentNodeStoreMonitorServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreMonitorService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    commitsTrackerWriterGroups match {
      case Some(param) => queryParams += "commitsTrackerWriterGroups" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSegmentSegmentNodeStoreService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    repositoryHome: Option[String] = None,
    tarmkMode: Option[String] = None,
    tarmkSize: Option[Integer] = None,
    segmentCacheSize: Option[Integer] = None,
    stringCacheSize: Option[Integer] = None,
    templateCacheSize: Option[Integer] = None,
    stringDeduplicationCacheSize: Option[Integer] = None,
    templateDeduplicationCacheSize: Option[Integer] = None,
    nodeDeduplicationCacheSize: Option[Integer] = None,
    pauseCompaction: Option[Boolean] = None,
    compactionRetryCount: Option[Integer] = None,
    compactionForceTimeout: Option[Integer] = None,
    compactionSizeDeltaEstimation: Option[Integer] = None,
    compactionDisableEstimation: Option[Boolean] = None,
    compactionRetainedGenerations: Option[Integer] = None,
    compactionMemoryThreshold: Option[Integer] = None,
    compactionProgressLog: Option[Integer] = None,
    standby: Option[Boolean] = None,
    customBlobStore: Option[Boolean] = None,
    customSegmentStore: Option[Boolean] = None,
    splitPersistence: Option[Boolean] = None,
    repositoryBackupDir: Option[String] = None,
    blobGcMaxAgeInSecs: Option[Integer] = None,
    blobTrackSnapshotIntervalInSecs: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo]): Future[OrgApacheJackrabbitOakSegmentSegmentNodeStoreServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.segment.SegmentNodeStoreService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    repositoryHome match {
      case Some(param) => queryParams += "repository.home" -> param.toString
      case _ => queryParams
    }
    tarmkMode match {
      case Some(param) => queryParams += "tarmk.mode" -> param.toString
      case _ => queryParams
    }
    tarmkSize match {
      case Some(param) => queryParams += "tarmk.size" -> param.toString
      case _ => queryParams
    }
    segmentCacheSize match {
      case Some(param) => queryParams += "segmentCache.size" -> param.toString
      case _ => queryParams
    }
    stringCacheSize match {
      case Some(param) => queryParams += "stringCache.size" -> param.toString
      case _ => queryParams
    }
    templateCacheSize match {
      case Some(param) => queryParams += "templateCache.size" -> param.toString
      case _ => queryParams
    }
    stringDeduplicationCacheSize match {
      case Some(param) => queryParams += "stringDeduplicationCache.size" -> param.toString
      case _ => queryParams
    }
    templateDeduplicationCacheSize match {
      case Some(param) => queryParams += "templateDeduplicationCache.size" -> param.toString
      case _ => queryParams
    }
    nodeDeduplicationCacheSize match {
      case Some(param) => queryParams += "nodeDeduplicationCache.size" -> param.toString
      case _ => queryParams
    }
    pauseCompaction match {
      case Some(param) => queryParams += "pauseCompaction" -> param.toString
      case _ => queryParams
    }
    compactionRetryCount match {
      case Some(param) => queryParams += "compaction.retryCount" -> param.toString
      case _ => queryParams
    }
    compactionForceTimeout match {
      case Some(param) => queryParams += "compaction.force.timeout" -> param.toString
      case _ => queryParams
    }
    compactionSizeDeltaEstimation match {
      case Some(param) => queryParams += "compaction.sizeDeltaEstimation" -> param.toString
      case _ => queryParams
    }
    compactionDisableEstimation match {
      case Some(param) => queryParams += "compaction.disableEstimation" -> param.toString
      case _ => queryParams
    }
    compactionRetainedGenerations match {
      case Some(param) => queryParams += "compaction.retainedGenerations" -> param.toString
      case _ => queryParams
    }
    compactionMemoryThreshold match {
      case Some(param) => queryParams += "compaction.memoryThreshold" -> param.toString
      case _ => queryParams
    }
    compactionProgressLog match {
      case Some(param) => queryParams += "compaction.progressLog" -> param.toString
      case _ => queryParams
    }
    standby match {
      case Some(param) => queryParams += "standby" -> param.toString
      case _ => queryParams
    }
    customBlobStore match {
      case Some(param) => queryParams += "customBlobStore" -> param.toString
      case _ => queryParams
    }
    customSegmentStore match {
      case Some(param) => queryParams += "customSegmentStore" -> param.toString
      case _ => queryParams
    }
    splitPersistence match {
      case Some(param) => queryParams += "splitPersistence" -> param.toString
      case _ => queryParams
    }
    repositoryBackupDir match {
      case Some(param) => queryParams += "repository.backup.dir" -> param.toString
      case _ => queryParams
    }
    blobGcMaxAgeInSecs match {
      case Some(param) => queryParams += "blobGcMaxAgeInSecs" -> param.toString
      case _ => queryParams
    }
    blobTrackSnapshotIntervalInSecs match {
      case Some(param) => queryParams += "blobTrackSnapshotIntervalInSecs" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheSlingInstallerConfigurationPersist: Option[Boolean] = None,
    mode: Option[String] = None,
    port: Option[Integer] = None,
    primaryHost: Option[String] = None,
    interval: Option[Integer] = None,
    primaryAllowedClientIpRanges: Option[List[String]] = None,
    secure: Option[Boolean] = None,
    standbyReadtimeout: Option[Integer] = None,
    standbyAutoclean: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo]): Future[OrgApacheJackrabbitOakSegmentStandbyStoreStandbyStoreServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.segment.standby.store.StandbyStoreService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingInstallerConfigurationPersist match {
      case Some(param) => queryParams += "org.apache.sling.installer.configuration.persist" -> param.toString
      case _ => queryParams
    }
    mode match {
      case Some(param) => queryParams += "mode" -> param.toString
      case _ => queryParams
    }
    port match {
      case Some(param) => queryParams += "port" -> param.toString
      case _ => queryParams
    }
    primaryHost match {
      case Some(param) => queryParams += "primary.host" -> param.toString
      case _ => queryParams
    }
    interval match {
      case Some(param) => queryParams += "interval" -> param.toString
      case _ => queryParams
    }
    primaryAllowedClientIpRanges match {
      case Some(param) => queryParams += "primary.allowed-client-ip-ranges" -> param.toString
      case _ => queryParams
    }
    secure match {
      case Some(param) => queryParams += "secure" -> param.toString
      case _ => queryParams
    }
    standbyReadtimeout match {
      case Some(param) => queryParams += "standby.readtimeout" -> param.toString
      case _ => queryParams
    }
    standbyAutoclean match {
      case Some(param) => queryParams += "standby.autoclean" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDe(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    handlerName: Option[String] = None,
    userExpirationTime: Option[String] = None,
    userAutoMembership: Option[List[String]] = None,
    userPropertyMapping: Option[List[String]] = None,
    userPathPrefix: Option[String] = None,
    userMembershipExpTime: Option[String] = None,
    userMembershipNestingDepth: Option[Integer] = None,
    userDynamicMembership: Option[Boolean] = None,
    userDisableMissing: Option[Boolean] = None,
    groupExpirationTime: Option[String] = None,
    groupAutoMembership: Option[List[String]] = None,
    groupPropertyMapping: Option[List[String]] = None,
    groupPathPrefix: Option[String] = None,
    enableRFC7613UsercaseMappedProfile: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo]): Future[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplDeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    handlerName match {
      case Some(param) => queryParams += "handler.name" -> param.toString
      case _ => queryParams
    }
    userExpirationTime match {
      case Some(param) => queryParams += "user.expirationTime" -> param.toString
      case _ => queryParams
    }
    userAutoMembership match {
      case Some(param) => queryParams += "user.autoMembership" -> param.toString
      case _ => queryParams
    }
    userPropertyMapping match {
      case Some(param) => queryParams += "user.propertyMapping" -> param.toString
      case _ => queryParams
    }
    userPathPrefix match {
      case Some(param) => queryParams += "user.pathPrefix" -> param.toString
      case _ => queryParams
    }
    userMembershipExpTime match {
      case Some(param) => queryParams += "user.membershipExpTime" -> param.toString
      case _ => queryParams
    }
    userMembershipNestingDepth match {
      case Some(param) => queryParams += "user.membershipNestingDepth" -> param.toString
      case _ => queryParams
    }
    userDynamicMembership match {
      case Some(param) => queryParams += "user.dynamicMembership" -> param.toString
      case _ => queryParams
    }
    userDisableMissing match {
      case Some(param) => queryParams += "user.disableMissing" -> param.toString
      case _ => queryParams
    }
    groupExpirationTime match {
      case Some(param) => queryParams += "group.expirationTime" -> param.toString
      case _ => queryParams
    }
    groupAutoMembership match {
      case Some(param) => queryParams += "group.autoMembership" -> param.toString
      case _ => queryParams
    }
    groupPropertyMapping match {
      case Some(param) => queryParams += "group.propertyMapping" -> param.toString
      case _ => queryParams
    }
    groupPathPrefix match {
      case Some(param) => queryParams += "group.pathPrefix" -> param.toString
      case _ => queryParams
    }
    enableRFC7613UsercaseMappedProfile match {
      case Some(param) => queryParams += "enableRFC7613UsercaseMappedProfile" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplEx(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jaasRanking: Option[Integer] = None,
    jaasControlFlag: Option[String] = None,
    jaasRealmName: Option[String] = None,
    idpName: Option[String] = None,
    syncHandlerName: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo]): Future[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplExInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.ExternalLoginModuleFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jaasRanking match {
      case Some(param) => queryParams += "jaas.ranking" -> param.toString
      case _ => queryParams
    }
    jaasControlFlag match {
      case Some(param) => queryParams += "jaas.controlFlag" -> param.toString
      case _ => queryParams
    }
    jaasRealmName match {
      case Some(param) => queryParams += "jaas.realmName" -> param.toString
      case _ => queryParams
    }
    idpName match {
      case Some(param) => queryParams += "idp.name" -> param.toString
      case _ => queryParams
    }
    syncHandlerName match {
      case Some(param) => queryParams += "sync.handlerName" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPr(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    protectExternalId: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo]): Future[OrgApacheJackrabbitOakSpiSecurityAuthenticationExternalImplPrInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authentication.external.impl.principal.ExternalPrincipalConfiguration"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    protectExternalId match {
      case Some(param) => queryParams += "protectExternalId" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfi(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    cugSupportedPaths: Option[List[String]] = None,
    cugEnabled: Option[Boolean] = None,
    configurationRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo]): Future[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugConfiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authorization.cug.impl.CugConfiguration"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    cugSupportedPaths match {
      case Some(param) => queryParams += "cugSupportedPaths" -> param.toString
      case _ => queryParams
    }
    cugEnabled match {
      case Some(param) => queryParams += "cugEnabled" -> param.toString
      case _ => queryParams
    }
    configurationRanking match {
      case Some(param) => queryParams += "configurationRanking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExclu(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    principalNames: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo]): Future[OrgApacheJackrabbitOakSpiSecurityAuthorizationCugImplCugExcluInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.authorization.cug.impl.CugExcludeImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    principalNames match {
      case Some(param) => queryParams += "principalNames" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizable(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabledActions: Option[String] = None,
    userPrivilegeNames: Option[List[String]] = None,
    groupPrivilegeNames: Option[List[String]] = None,
    constraint: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo]): Future[OrgApacheJackrabbitOakSpiSecurityUserActionDefaultAuthorizableInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.oak.spi.security.user.action.DefaultAuthorizableActionProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabledActions match {
      case Some(param) => queryParams += "enabledActions" -> param.toString
      case _ => queryParams
    }
    userPrivilegeNames match {
      case Some(param) => queryParams += "userPrivilegeNames" -> param.toString
      case _ => queryParams
    }
    groupPrivilegeNames match {
      case Some(param) => queryParams += "groupPrivilegeNames" -> param.toString
      case _ => queryParams
    }
    constraint match {
      case Some(param) => queryParams += "constraint" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitVaultPackagingImplPackagingImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    packageRoots: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo]): Future[OrgApacheJackrabbitVaultPackagingImplPackagingImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.vault.packaging.impl.PackagingImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    packageRoots match {
      case Some(param) => queryParams += "packageRoots" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistry(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    homePath: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo]): Future[OrgApacheJackrabbitVaultPackagingRegistryImplFSPackageRegistryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.jackrabbit.vault.packaging.registry.impl.FSPackageRegistry"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    homePath match {
      case Some(param) => queryParams += "homePath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingAuthCoreImplLogoutServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletMethods: Option[List[String]] = None,
    slingServletPaths: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingAuthCoreImplLogoutServletInfo]): Future[OrgApacheSlingAuthCoreImplLogoutServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.auth.core.impl.LogoutServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletMethods match {
      case Some(param) => queryParams += "sling.servlet.methods" -> param.toString
      case _ => queryParams
    }
    slingServletPaths match {
      case Some(param) => queryParams += "sling.servlet.paths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCaconfigImplConfigurationBindingsValueProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo]): Future[OrgApacheSlingCaconfigImplConfigurationBindingsValueProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.caconfig.impl.ConfigurationBindingsValueProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCaconfigImplConfigurationResolverImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    configBucketNames: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo]): Future[OrgApacheSlingCaconfigImplConfigurationResolverImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.caconfig.impl.ConfigurationResolverImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    configBucketNames match {
      case Some(param) => queryParams += "configBucketNames" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStra(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    configPropertyInheritancePropertyNames: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo]): Future[OrgApacheSlingCaconfigImplDefDefaultConfigurationInheritanceStraInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.caconfig.impl.def.DefaultConfigurationInheritanceStrategy"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    configPropertyInheritancePropertyNames match {
      case Some(param) => queryParams += "configPropertyInheritancePropertyNames" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStra(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo]): Future[OrgApacheSlingCaconfigImplDefDefaultConfigurationPersistenceStraInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.caconfig.impl.def.DefaultConfigurationPersistenceStrategy"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProvi(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    description: Option[String] = None,
    overrides: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    serviceRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo]): Future[OrgApacheSlingCaconfigImplOverrideOsgiConfigurationOverrideProviInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.caconfig.impl.override.OsgiConfigurationOverrideProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    description match {
      case Some(param) => queryParams += "description" -> param.toString
      case _ => queryParams
    }
    overrides match {
      case Some(param) => queryParams += "overrides" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOve(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    serviceRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo]): Future[OrgApacheSlingCaconfigImplOverrideSystemPropertyConfigurationOveInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.caconfig.impl.override.SystemPropertyConfigurationOverrideProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCaconfigManagementImplConfigurationManagementSetti(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    ignorePropertyNameRegex: Option[List[String]] = None,
    configCollectionPropertiesResourceNames: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo]): Future[OrgApacheSlingCaconfigManagementImplConfigurationManagementSettiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.caconfig.management.impl.ConfigurationManagementSettingsImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    ignorePropertyNameRegex match {
      case Some(param) => queryParams += "ignorePropertyNameRegex" -> param.toString
      case _ => queryParams
    }
    configCollectionPropertiesResourceNames match {
      case Some(param) => queryParams += "configCollectionPropertiesResourceNames" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCaconfigResourceImplDefDefaultConfigurationResour(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    configPath: Option[String] = None,
    fallbackPaths: Option[List[String]] = None,
    configCollectionInheritancePropertyNames: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo]): Future[OrgApacheSlingCaconfigResourceImplDefDefaultConfigurationResourInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.caconfig.resource.impl.def.DefaultConfigurationResourceResolvingStrategy"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    configPath match {
      case Some(param) => queryParams += "configPath" -> param.toString
      case _ => queryParams
    }
    fallbackPaths match {
      case Some(param) => queryParams += "fallbackPaths" -> param.toString
      case _ => queryParams
    }
    configCollectionInheritancePropertyNames match {
      case Some(param) => queryParams += "configCollectionInheritancePropertyNames" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategy(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    configRefResourceNames: Option[List[String]] = None,
    configRefPropertyNames: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo]): Future[OrgApacheSlingCaconfigResourceImplDefDefaultContextPathStrategyInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.caconfig.resource.impl.def.DefaultContextPathStrategy"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    configRefResourceNames match {
      case Some(param) => queryParams += "configRefResourceNames" -> param.toString
      case _ => queryParams
    }
    configRefPropertyNames match {
      case Some(param) => queryParams += "configRefPropertyNames" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCommonsHtmlInternalTagsoupHtmlParser(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    parserFeatures: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo]): Future[OrgApacheSlingCommonsHtmlInternalTagsoupHtmlParserInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.commons.html.internal.TagsoupHtmlParser"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    parserFeatures match {
      case Some(param) => queryParams += "parser.features" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCommonsLogLogManager(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheSlingCommonsLogLevel: Option[String] = None,
    orgApacheSlingCommonsLogFile: Option[String] = None,
    orgApacheSlingCommonsLogFileNumber: Option[Integer] = None,
    orgApacheSlingCommonsLogFileSize: Option[String] = None,
    orgApacheSlingCommonsLogPattern: Option[String] = None,
    orgApacheSlingCommonsLogConfigurationFile: Option[String] = None,
    orgApacheSlingCommonsLogPackagingDataEnabled: Option[Boolean] = None,
    orgApacheSlingCommonsLogMaxCallerDataDepth: Option[Integer] = None,
    orgApacheSlingCommonsLogMaxOldFileCountInDump: Option[Integer] = None,
    orgApacheSlingCommonsLogNumOfLines: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCommonsLogLogManagerInfo]): Future[OrgApacheSlingCommonsLogLogManagerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.commons.log.LogManager"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogLevel match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.level" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogFile match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.file" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogFileNumber match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.file.number" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogFileSize match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.file.size" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogPattern match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.pattern" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogConfigurationFile match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.configurationFile" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogPackagingDataEnabled match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.packagingDataEnabled" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogMaxCallerDataDepth match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.maxCallerDataDepth" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogMaxOldFileCountInDump match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.maxOldFileCountInDump" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogNumOfLines match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.numOfLines" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCommonsLogLogManagerFactoryConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheSlingCommonsLogLevel: Option[String] = None,
    orgApacheSlingCommonsLogFile: Option[String] = None,
    orgApacheSlingCommonsLogPattern: Option[String] = None,
    orgApacheSlingCommonsLogNames: Option[List[String]] = None,
    orgApacheSlingCommonsLogAdditiv: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo]): Future[OrgApacheSlingCommonsLogLogManagerFactoryConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.commons.log.LogManager.factory.config"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogLevel match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.level" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogFile match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.file" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogPattern match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.pattern" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogNames match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.names" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogAdditiv match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.additiv" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCommonsLogLogManagerFactoryWriter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheSlingCommonsLogFile: Option[String] = None,
    orgApacheSlingCommonsLogFileNumber: Option[Integer] = None,
    orgApacheSlingCommonsLogFileSize: Option[String] = None,
    orgApacheSlingCommonsLogFileBuffered: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo]): Future[OrgApacheSlingCommonsLogLogManagerFactoryWriterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.commons.log.LogManager.factory.writer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogFile match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.file" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogFileNumber match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.file.number" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogFileSize match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.file.size" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingCommonsLogFileBuffered match {
      case Some(param) => queryParams += "org.apache.sling.commons.log.file.buffered" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCommonsMetricsInternalLogReporter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    period: Option[Integer] = None,
    timeUnit: Option[String] = None,
    level: Option[String] = None,
    loggerName: Option[String] = None,
    prefix: Option[String] = None,
    pattern: Option[String] = None,
    registryName: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCommonsMetricsInternalLogReporterInfo]): Future[OrgApacheSlingCommonsMetricsInternalLogReporterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.commons.metrics.internal.LogReporter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    period match {
      case Some(param) => queryParams += "period" -> param.toString
      case _ => queryParams
    }
    timeUnit match {
      case Some(param) => queryParams += "timeUnit" -> param.toString
      case _ => queryParams
    }
    level match {
      case Some(param) => queryParams += "level" -> param.toString
      case _ => queryParams
    }
    loggerName match {
      case Some(param) => queryParams += "loggerName" -> param.toString
      case _ => queryParams
    }
    prefix match {
      case Some(param) => queryParams += "prefix" -> param.toString
      case _ => queryParams
    }
    pattern match {
      case Some(param) => queryParams += "pattern" -> param.toString
      case _ => queryParams
    }
    registryName match {
      case Some(param) => queryParams += "registryName" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    datasources: Option[List[String]] = None,
    step: Option[Integer] = None,
    archives: Option[List[String]] = None,
    `path`: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo]): Future[OrgApacheSlingCommonsMetricsRrd4jImplCodahaleMetricsReporterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.commons.metrics.rrd4j.impl.CodahaleMetricsReporter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    datasources match {
      case Some(param) => queryParams += "datasources" -> param.toString
      case _ => queryParams
    }
    step match {
      case Some(param) => queryParams += "step" -> param.toString
      case _ => queryParams
    }
    archives match {
      case Some(param) => queryParams += "archives" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCommonsMimeInternalMimeTypeServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mimeTypes: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo]): Future[OrgApacheSlingCommonsMimeInternalMimeTypeServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.commons.mime.internal.MimeTypeServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mimeTypes match {
      case Some(param) => queryParams += "mime.types" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCommonsSchedulerImplQuartzScheduler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    poolName: Option[String] = None,
    allowedPoolNames: Option[List[String]] = None,
    schedulerUseleaderforsingle: Option[Boolean] = None,
    metricsFilters: Option[List[String]] = None,
    slowThresholdMillis: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo]): Future[OrgApacheSlingCommonsSchedulerImplQuartzSchedulerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.commons.scheduler.impl.QuartzScheduler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    poolName match {
      case Some(param) => queryParams += "poolName" -> param.toString
      case _ => queryParams
    }
    allowedPoolNames match {
      case Some(param) => queryParams += "allowedPoolNames" -> param.toString
      case _ => queryParams
    }
    schedulerUseleaderforsingle match {
      case Some(param) => queryParams += "scheduler.useleaderforsingle" -> param.toString
      case _ => queryParams
    }
    metricsFilters match {
      case Some(param) => queryParams += "metrics.filters" -> param.toString
      case _ => queryParams
    }
    slowThresholdMillis match {
      case Some(param) => queryParams += "slowThresholdMillis" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCommonsSchedulerImplSchedulerHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxQuartzJobDurationAcceptable: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo]): Future[OrgApacheSlingCommonsSchedulerImplSchedulerHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.commons.scheduler.impl.SchedulerHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxQuartzJobDurationAcceptable match {
      case Some(param) => queryParams += "max.quartzJob.duration.acceptable" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingCommonsThreadsImplDefaultThreadPoolFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    minPoolSize: Option[Integer] = None,
    maxPoolSize: Option[Integer] = None,
    queueSize: Option[Integer] = None,
    maxThreadAge: Option[Integer] = None,
    keepAliveTime: Option[Integer] = None,
    blockPolicy: Option[String] = None,
    shutdownGraceful: Option[Boolean] = None,
    daemon: Option[Boolean] = None,
    shutdownWaitTime: Option[Integer] = None,
    priority: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo]): Future[OrgApacheSlingCommonsThreadsImplDefaultThreadPoolFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.commons.threads.impl.DefaultThreadPool.factory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    minPoolSize match {
      case Some(param) => queryParams += "minPoolSize" -> param.toString
      case _ => queryParams
    }
    maxPoolSize match {
      case Some(param) => queryParams += "maxPoolSize" -> param.toString
      case _ => queryParams
    }
    queueSize match {
      case Some(param) => queryParams += "queueSize" -> param.toString
      case _ => queryParams
    }
    maxThreadAge match {
      case Some(param) => queryParams += "maxThreadAge" -> param.toString
      case _ => queryParams
    }
    keepAliveTime match {
      case Some(param) => queryParams += "keepAliveTime" -> param.toString
      case _ => queryParams
    }
    blockPolicy match {
      case Some(param) => queryParams += "blockPolicy" -> param.toString
      case _ => queryParams
    }
    shutdownGraceful match {
      case Some(param) => queryParams += "shutdownGraceful" -> param.toString
      case _ => queryParams
    }
    daemon match {
      case Some(param) => queryParams += "daemon" -> param.toString
      case _ => queryParams
    }
    shutdownWaitTime match {
      case Some(param) => queryParams += "shutdownWaitTime" -> param.toString
      case _ => queryParams
    }
    priority match {
      case Some(param) => queryParams += "priority" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDatasourceDataSourceFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    datasourceName: Option[String] = None,
    datasourceSvcPropName: Option[String] = None,
    driverClassName: Option[String] = None,
    url: Option[String] = None,
    username: Option[String] = None,
    password: Option[String] = None,
    defaultAutoCommit: Option[String] = None,
    defaultReadOnly: Option[String] = None,
    defaultTransactionIsolation: Option[String] = None,
    defaultCatalog: Option[String] = None,
    maxActive: Option[Integer] = None,
    maxIdle: Option[Integer] = None,
    minIdle: Option[Integer] = None,
    initialSize: Option[Integer] = None,
    maxWait: Option[Integer] = None,
    maxAge: Option[Integer] = None,
    testOnBorrow: Option[Boolean] = None,
    testOnReturn: Option[Boolean] = None,
    testWhileIdle: Option[Boolean] = None,
    validationQuery: Option[String] = None,
    validationQueryTimeout: Option[Integer] = None,
    timeBetweenEvictionRunsMillis: Option[Integer] = None,
    minEvictableIdleTimeMillis: Option[Integer] = None,
    connectionProperties: Option[String] = None,
    initSQL: Option[String] = None,
    jdbcInterceptors: Option[String] = None,
    validationInterval: Option[Integer] = None,
    logValidationErrors: Option[Boolean] = None,
    datasourceSvcProperties: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDatasourceDataSourceFactoryInfo]): Future[OrgApacheSlingDatasourceDataSourceFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.datasource.DataSourceFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    datasourceName match {
      case Some(param) => queryParams += "datasource.name" -> param.toString
      case _ => queryParams
    }
    datasourceSvcPropName match {
      case Some(param) => queryParams += "datasource.svc.prop.name" -> param.toString
      case _ => queryParams
    }
    driverClassName match {
      case Some(param) => queryParams += "driverClassName" -> param.toString
      case _ => queryParams
    }
    url match {
      case Some(param) => queryParams += "url" -> param.toString
      case _ => queryParams
    }
    username match {
      case Some(param) => queryParams += "username" -> param.toString
      case _ => queryParams
    }
    password match {
      case Some(param) => queryParams += "password" -> param.toString
      case _ => queryParams
    }
    defaultAutoCommit match {
      case Some(param) => queryParams += "defaultAutoCommit" -> param.toString
      case _ => queryParams
    }
    defaultReadOnly match {
      case Some(param) => queryParams += "defaultReadOnly" -> param.toString
      case _ => queryParams
    }
    defaultTransactionIsolation match {
      case Some(param) => queryParams += "defaultTransactionIsolation" -> param.toString
      case _ => queryParams
    }
    defaultCatalog match {
      case Some(param) => queryParams += "defaultCatalog" -> param.toString
      case _ => queryParams
    }
    maxActive match {
      case Some(param) => queryParams += "maxActive" -> param.toString
      case _ => queryParams
    }
    maxIdle match {
      case Some(param) => queryParams += "maxIdle" -> param.toString
      case _ => queryParams
    }
    minIdle match {
      case Some(param) => queryParams += "minIdle" -> param.toString
      case _ => queryParams
    }
    initialSize match {
      case Some(param) => queryParams += "initialSize" -> param.toString
      case _ => queryParams
    }
    maxWait match {
      case Some(param) => queryParams += "maxWait" -> param.toString
      case _ => queryParams
    }
    maxAge match {
      case Some(param) => queryParams += "maxAge" -> param.toString
      case _ => queryParams
    }
    testOnBorrow match {
      case Some(param) => queryParams += "testOnBorrow" -> param.toString
      case _ => queryParams
    }
    testOnReturn match {
      case Some(param) => queryParams += "testOnReturn" -> param.toString
      case _ => queryParams
    }
    testWhileIdle match {
      case Some(param) => queryParams += "testWhileIdle" -> param.toString
      case _ => queryParams
    }
    validationQuery match {
      case Some(param) => queryParams += "validationQuery" -> param.toString
      case _ => queryParams
    }
    validationQueryTimeout match {
      case Some(param) => queryParams += "validationQueryTimeout" -> param.toString
      case _ => queryParams
    }
    timeBetweenEvictionRunsMillis match {
      case Some(param) => queryParams += "timeBetweenEvictionRunsMillis" -> param.toString
      case _ => queryParams
    }
    minEvictableIdleTimeMillis match {
      case Some(param) => queryParams += "minEvictableIdleTimeMillis" -> param.toString
      case _ => queryParams
    }
    connectionProperties match {
      case Some(param) => queryParams += "connectionProperties" -> param.toString
      case _ => queryParams
    }
    initSQL match {
      case Some(param) => queryParams += "initSQL" -> param.toString
      case _ => queryParams
    }
    jdbcInterceptors match {
      case Some(param) => queryParams += "jdbcInterceptors" -> param.toString
      case _ => queryParams
    }
    validationInterval match {
      case Some(param) => queryParams += "validationInterval" -> param.toString
      case _ => queryParams
    }
    logValidationErrors match {
      case Some(param) => queryParams += "logValidationErrors" -> param.toString
      case _ => queryParams
    }
    datasourceSvcProperties match {
      case Some(param) => queryParams += "datasource.svc.properties" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDatasourceJNDIDataSourceFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    datasourceName: Option[String] = None,
    datasourceSvcPropName: Option[String] = None,
    datasourceJndiName: Option[String] = None,
    jndiProperties: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo]): Future[OrgApacheSlingDatasourceJNDIDataSourceFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.datasource.JNDIDataSourceFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    datasourceName match {
      case Some(param) => queryParams += "datasource.name" -> param.toString
      case _ => queryParams
    }
    datasourceSvcPropName match {
      case Some(param) => queryParams += "datasource.svc.prop.name" -> param.toString
      case _ => queryParams
    }
    datasourceJndiName match {
      case Some(param) => queryParams += "datasource.jndi.name" -> param.toString
      case _ => queryParams
    }
    jndiProperties match {
      case Some(param) => queryParams += "jndi.properties" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDiscoveryOakConfig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    connectorPingTimeout: Option[Integer] = None,
    connectorPingInterval: Option[Integer] = None,
    discoveryLiteCheckInterval: Option[Integer] = None,
    clusterSyncServiceTimeout: Option[Integer] = None,
    clusterSyncServiceInterval: Option[Integer] = None,
    enableSyncToken: Option[Boolean] = None,
    minEventDelay: Option[Integer] = None,
    socketConnectTimeout: Option[Integer] = None,
    soTimeout: Option[Integer] = None,
    topologyConnectorUrls: Option[List[String]] = None,
    topologyConnectorWhitelist: Option[List[String]] = None,
    autoStopLocalLoopEnabled: Option[Boolean] = None,
    gzipConnectorRequestsEnabled: Option[Boolean] = None,
    hmacEnabled: Option[Boolean] = None,
    enableEncryption: Option[Boolean] = None,
    sharedKey: Option[String] = None,
    hmacSharedKeyTTL: Option[Integer] = None,
    backoffStandbyFactor: Option[String] = None,
    backoffStableFactor: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDiscoveryOakConfigInfo]): Future[OrgApacheSlingDiscoveryOakConfigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.discovery.oak.Config"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    connectorPingTimeout match {
      case Some(param) => queryParams += "connectorPingTimeout" -> param.toString
      case _ => queryParams
    }
    connectorPingInterval match {
      case Some(param) => queryParams += "connectorPingInterval" -> param.toString
      case _ => queryParams
    }
    discoveryLiteCheckInterval match {
      case Some(param) => queryParams += "discoveryLiteCheckInterval" -> param.toString
      case _ => queryParams
    }
    clusterSyncServiceTimeout match {
      case Some(param) => queryParams += "clusterSyncServiceTimeout" -> param.toString
      case _ => queryParams
    }
    clusterSyncServiceInterval match {
      case Some(param) => queryParams += "clusterSyncServiceInterval" -> param.toString
      case _ => queryParams
    }
    enableSyncToken match {
      case Some(param) => queryParams += "enableSyncToken" -> param.toString
      case _ => queryParams
    }
    minEventDelay match {
      case Some(param) => queryParams += "minEventDelay" -> param.toString
      case _ => queryParams
    }
    socketConnectTimeout match {
      case Some(param) => queryParams += "socketConnectTimeout" -> param.toString
      case _ => queryParams
    }
    soTimeout match {
      case Some(param) => queryParams += "soTimeout" -> param.toString
      case _ => queryParams
    }
    topologyConnectorUrls match {
      case Some(param) => queryParams += "topologyConnectorUrls" -> param.toString
      case _ => queryParams
    }
    topologyConnectorWhitelist match {
      case Some(param) => queryParams += "topologyConnectorWhitelist" -> param.toString
      case _ => queryParams
    }
    autoStopLocalLoopEnabled match {
      case Some(param) => queryParams += "autoStopLocalLoopEnabled" -> param.toString
      case _ => queryParams
    }
    gzipConnectorRequestsEnabled match {
      case Some(param) => queryParams += "gzipConnectorRequestsEnabled" -> param.toString
      case _ => queryParams
    }
    hmacEnabled match {
      case Some(param) => queryParams += "hmacEnabled" -> param.toString
      case _ => queryParams
    }
    enableEncryption match {
      case Some(param) => queryParams += "enableEncryption" -> param.toString
      case _ => queryParams
    }
    sharedKey match {
      case Some(param) => queryParams += "sharedKey" -> param.toString
      case _ => queryParams
    }
    hmacSharedKeyTTL match {
      case Some(param) => queryParams += "hmacSharedKeyTTL" -> param.toString
      case _ => queryParams
    }
    backoffStandbyFactor match {
      case Some(param) => queryParams += "backoffStandbyFactor" -> param.toString
      case _ => queryParams
    }
    backoffStableFactor match {
      case Some(param) => queryParams += "backoffStableFactor" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDiscoveryOakSynchronizedClocksHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcName: Option[String] = None,
    hcTags: Option[List[String]] = None,
    hcMbeanName: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo]): Future[OrgApacheSlingDiscoveryOakSynchronizedClocksHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.discovery.oak.SynchronizedClocksHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcName match {
      case Some(param) => queryParams += "hc.name" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    hcMbeanName match {
      case Some(param) => queryParams += "hc.mbean.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionAgentImplForwardDistributionAgentFacto(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    title: Option[String] = None,
    details: Option[String] = None,
    enabled: Option[Boolean] = None,
    serviceName: Option[String] = None,
    logLevel: Option[String] = None,
    allowedRoots: Option[List[String]] = None,
    queueProcessingEnabled: Option[Boolean] = None,
    packageImporterEndpoints: Option[List[String]] = None,
    passiveQueues: Option[List[String]] = None,
    priorityQueues: Option[List[String]] = None,
    retryStrategy: Option[String] = None,
    retryAttempts: Option[Integer] = None,
    requestAuthorizationStrategyTarget: Option[String] = None,
    transportSecretProviderTarget: Option[String] = None,
    packageBuilderTarget: Option[String] = None,
    triggersTarget: Option[String] = None,
    queueProvider: Option[String] = None,
    asyncDelivery: Option[Boolean] = None,
    httpConnTimeout: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo]): Future[OrgApacheSlingDistributionAgentImplForwardDistributionAgentFactoInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.agent.impl.ForwardDistributionAgentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    title match {
      case Some(param) => queryParams += "title" -> param.toString
      case _ => queryParams
    }
    details match {
      case Some(param) => queryParams += "details" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }
    logLevel match {
      case Some(param) => queryParams += "log.level" -> param.toString
      case _ => queryParams
    }
    allowedRoots match {
      case Some(param) => queryParams += "allowed.roots" -> param.toString
      case _ => queryParams
    }
    queueProcessingEnabled match {
      case Some(param) => queryParams += "queue.processing.enabled" -> param.toString
      case _ => queryParams
    }
    packageImporterEndpoints match {
      case Some(param) => queryParams += "packageImporter.endpoints" -> param.toString
      case _ => queryParams
    }
    passiveQueues match {
      case Some(param) => queryParams += "passiveQueues" -> param.toString
      case _ => queryParams
    }
    priorityQueues match {
      case Some(param) => queryParams += "priorityQueues" -> param.toString
      case _ => queryParams
    }
    retryStrategy match {
      case Some(param) => queryParams += "retry.strategy" -> param.toString
      case _ => queryParams
    }
    retryAttempts match {
      case Some(param) => queryParams += "retry.attempts" -> param.toString
      case _ => queryParams
    }
    requestAuthorizationStrategyTarget match {
      case Some(param) => queryParams += "requestAuthorizationStrategy.target" -> param.toString
      case _ => queryParams
    }
    transportSecretProviderTarget match {
      case Some(param) => queryParams += "transportSecretProvider.target" -> param.toString
      case _ => queryParams
    }
    packageBuilderTarget match {
      case Some(param) => queryParams += "packageBuilder.target" -> param.toString
      case _ => queryParams
    }
    triggersTarget match {
      case Some(param) => queryParams += "triggers.target" -> param.toString
      case _ => queryParams
    }
    queueProvider match {
      case Some(param) => queryParams += "queue.provider" -> param.toString
      case _ => queryParams
    }
    asyncDelivery match {
      case Some(param) => queryParams += "async.delivery" -> param.toString
      case _ => queryParams
    }
    httpConnTimeout match {
      case Some(param) => queryParams += "http.conn.timeout" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionAgentImplPrivilegeDistributionRequestA(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    jcrPrivilege: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo]): Future[OrgApacheSlingDistributionAgentImplPrivilegeDistributionRequestAInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.agent.impl.PrivilegeDistributionRequestAuthorizationStrategyFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    jcrPrivilege match {
      case Some(param) => queryParams += "jcrPrivilege" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionAgentImplQueueDistributionAgentFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    title: Option[String] = None,
    details: Option[String] = None,
    enabled: Option[Boolean] = None,
    serviceName: Option[String] = None,
    logLevel: Option[String] = None,
    allowedRoots: Option[List[String]] = None,
    requestAuthorizationStrategyTarget: Option[String] = None,
    queueProviderFactoryTarget: Option[String] = None,
    packageBuilderTarget: Option[String] = None,
    triggersTarget: Option[String] = None,
    priorityQueues: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo]): Future[OrgApacheSlingDistributionAgentImplQueueDistributionAgentFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.agent.impl.QueueDistributionAgentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    title match {
      case Some(param) => queryParams += "title" -> param.toString
      case _ => queryParams
    }
    details match {
      case Some(param) => queryParams += "details" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }
    logLevel match {
      case Some(param) => queryParams += "log.level" -> param.toString
      case _ => queryParams
    }
    allowedRoots match {
      case Some(param) => queryParams += "allowed.roots" -> param.toString
      case _ => queryParams
    }
    requestAuthorizationStrategyTarget match {
      case Some(param) => queryParams += "requestAuthorizationStrategy.target" -> param.toString
      case _ => queryParams
    }
    queueProviderFactoryTarget match {
      case Some(param) => queryParams += "queueProviderFactory.target" -> param.toString
      case _ => queryParams
    }
    packageBuilderTarget match {
      case Some(param) => queryParams += "packageBuilder.target" -> param.toString
      case _ => queryParams
    }
    triggersTarget match {
      case Some(param) => queryParams += "triggers.target" -> param.toString
      case _ => queryParams
    }
    priorityQueues match {
      case Some(param) => queryParams += "priorityQueues" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionAgentImplReverseDistributionAgentFacto(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    title: Option[String] = None,
    details: Option[String] = None,
    enabled: Option[Boolean] = None,
    serviceName: Option[String] = None,
    logLevel: Option[String] = None,
    queueProcessingEnabled: Option[Boolean] = None,
    packageExporterEndpoints: Option[List[String]] = None,
    pullItems: Option[Integer] = None,
    httpConnTimeout: Option[Integer] = None,
    requestAuthorizationStrategyTarget: Option[String] = None,
    transportSecretProviderTarget: Option[String] = None,
    packageBuilderTarget: Option[String] = None,
    triggersTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo]): Future[OrgApacheSlingDistributionAgentImplReverseDistributionAgentFactoInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.agent.impl.ReverseDistributionAgentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    title match {
      case Some(param) => queryParams += "title" -> param.toString
      case _ => queryParams
    }
    details match {
      case Some(param) => queryParams += "details" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }
    logLevel match {
      case Some(param) => queryParams += "log.level" -> param.toString
      case _ => queryParams
    }
    queueProcessingEnabled match {
      case Some(param) => queryParams += "queue.processing.enabled" -> param.toString
      case _ => queryParams
    }
    packageExporterEndpoints match {
      case Some(param) => queryParams += "packageExporter.endpoints" -> param.toString
      case _ => queryParams
    }
    pullItems match {
      case Some(param) => queryParams += "pull.items" -> param.toString
      case _ => queryParams
    }
    httpConnTimeout match {
      case Some(param) => queryParams += "http.conn.timeout" -> param.toString
      case _ => queryParams
    }
    requestAuthorizationStrategyTarget match {
      case Some(param) => queryParams += "requestAuthorizationStrategy.target" -> param.toString
      case _ => queryParams
    }
    transportSecretProviderTarget match {
      case Some(param) => queryParams += "transportSecretProvider.target" -> param.toString
      case _ => queryParams
    }
    packageBuilderTarget match {
      case Some(param) => queryParams += "packageBuilder.target" -> param.toString
      case _ => queryParams
    }
    triggersTarget match {
      case Some(param) => queryParams += "triggers.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionAgentImplSimpleDistributionAgentFactor(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    title: Option[String] = None,
    details: Option[String] = None,
    enabled: Option[Boolean] = None,
    serviceName: Option[String] = None,
    logLevel: Option[String] = None,
    queueProcessingEnabled: Option[Boolean] = None,
    packageExporterTarget: Option[String] = None,
    packageImporterTarget: Option[String] = None,
    requestAuthorizationStrategyTarget: Option[String] = None,
    triggersTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo]): Future[OrgApacheSlingDistributionAgentImplSimpleDistributionAgentFactorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.agent.impl.SimpleDistributionAgentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    title match {
      case Some(param) => queryParams += "title" -> param.toString
      case _ => queryParams
    }
    details match {
      case Some(param) => queryParams += "details" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }
    logLevel match {
      case Some(param) => queryParams += "log.level" -> param.toString
      case _ => queryParams
    }
    queueProcessingEnabled match {
      case Some(param) => queryParams += "queue.processing.enabled" -> param.toString
      case _ => queryParams
    }
    packageExporterTarget match {
      case Some(param) => queryParams += "packageExporter.target" -> param.toString
      case _ => queryParams
    }
    packageImporterTarget match {
      case Some(param) => queryParams += "packageImporter.target" -> param.toString
      case _ => queryParams
    }
    requestAuthorizationStrategyTarget match {
      case Some(param) => queryParams += "requestAuthorizationStrategy.target" -> param.toString
      case _ => queryParams
    }
    triggersTarget match {
      case Some(param) => queryParams += "triggers.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionAgentImplSyncDistributionAgentFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    title: Option[String] = None,
    details: Option[String] = None,
    enabled: Option[Boolean] = None,
    serviceName: Option[String] = None,
    logLevel: Option[String] = None,
    queueProcessingEnabled: Option[Boolean] = None,
    passiveQueues: Option[List[String]] = None,
    packageExporterEndpoints: Option[List[String]] = None,
    packageImporterEndpoints: Option[List[String]] = None,
    retryStrategy: Option[String] = None,
    retryAttempts: Option[Integer] = None,
    pullItems: Option[Integer] = None,
    httpConnTimeout: Option[Integer] = None,
    requestAuthorizationStrategyTarget: Option[String] = None,
    transportSecretProviderTarget: Option[String] = None,
    packageBuilderTarget: Option[String] = None,
    triggersTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo]): Future[OrgApacheSlingDistributionAgentImplSyncDistributionAgentFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.agent.impl.SyncDistributionAgentFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    title match {
      case Some(param) => queryParams += "title" -> param.toString
      case _ => queryParams
    }
    details match {
      case Some(param) => queryParams += "details" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }
    logLevel match {
      case Some(param) => queryParams += "log.level" -> param.toString
      case _ => queryParams
    }
    queueProcessingEnabled match {
      case Some(param) => queryParams += "queue.processing.enabled" -> param.toString
      case _ => queryParams
    }
    passiveQueues match {
      case Some(param) => queryParams += "passiveQueues" -> param.toString
      case _ => queryParams
    }
    packageExporterEndpoints match {
      case Some(param) => queryParams += "packageExporter.endpoints" -> param.toString
      case _ => queryParams
    }
    packageImporterEndpoints match {
      case Some(param) => queryParams += "packageImporter.endpoints" -> param.toString
      case _ => queryParams
    }
    retryStrategy match {
      case Some(param) => queryParams += "retry.strategy" -> param.toString
      case _ => queryParams
    }
    retryAttempts match {
      case Some(param) => queryParams += "retry.attempts" -> param.toString
      case _ => queryParams
    }
    pullItems match {
      case Some(param) => queryParams += "pull.items" -> param.toString
      case _ => queryParams
    }
    httpConnTimeout match {
      case Some(param) => queryParams += "http.conn.timeout" -> param.toString
      case _ => queryParams
    }
    requestAuthorizationStrategyTarget match {
      case Some(param) => queryParams += "requestAuthorizationStrategy.target" -> param.toString
      case _ => queryParams
    }
    transportSecretProviderTarget match {
      case Some(param) => queryParams += "transportSecretProvider.target" -> param.toString
      case _ => queryParams
    }
    packageBuilderTarget match {
      case Some(param) => queryParams += "packageBuilder.target" -> param.toString
      case _ => queryParams
    }
    triggersTarget match {
      case Some(param) => queryParams += "triggers.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionMonitorDistributionQueueHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcName: Option[String] = None,
    hcTags: Option[List[String]] = None,
    hcMbeanName: Option[String] = None,
    numberOfRetriesAllowed: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo]): Future[OrgApacheSlingDistributionMonitorDistributionQueueHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.monitor.DistributionQueueHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcName match {
      case Some(param) => queryParams += "hc.name" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    hcMbeanName match {
      case Some(param) => queryParams += "hc.mbean.name" -> param.toString
      case _ => queryParams
    }
    numberOfRetriesAllowed match {
      case Some(param) => queryParams += "numberOfRetriesAllowed" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionPackagingImplExporterAgentDistributio(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    queue: Option[String] = None,
    dropInvalidItems: Option[Boolean] = None,
    agentTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo]): Future[OrgApacheSlingDistributionPackagingImplExporterAgentDistributioInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.AgentDistributionPackageExporterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    queue match {
      case Some(param) => queryParams += "queue" -> param.toString
      case _ => queryParams
    }
    dropInvalidItems match {
      case Some(param) => queryParams += "drop.invalid.items" -> param.toString
      case _ => queryParams
    }
    agentTarget match {
      case Some(param) => queryParams += "agent.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionPackagingImplExporterLocalDistributio(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    packageBuilderTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo]): Future[OrgApacheSlingDistributionPackagingImplExporterLocalDistributioInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.LocalDistributionPackageExporterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    packageBuilderTarget match {
      case Some(param) => queryParams += "packageBuilder.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionPackagingImplExporterRemoteDistributi(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    endpoints: Option[List[String]] = None,
    pullItems: Option[Integer] = None,
    packageBuilderTarget: Option[String] = None,
    transportSecretProviderTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo]): Future[OrgApacheSlingDistributionPackagingImplExporterRemoteDistributiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.packaging.impl.exporter.RemoteDistributionPackageExporterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    endpoints match {
      case Some(param) => queryParams += "endpoints" -> param.toString
      case _ => queryParams
    }
    pullItems match {
      case Some(param) => queryParams += "pull.items" -> param.toString
      case _ => queryParams
    }
    packageBuilderTarget match {
      case Some(param) => queryParams += "packageBuilder.target" -> param.toString
      case _ => queryParams
    }
    transportSecretProviderTarget match {
      case Some(param) => queryParams += "transportSecretProvider.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionPackagingImplImporterLocalDistributio(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    packageBuilderTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo]): Future[OrgApacheSlingDistributionPackagingImplImporterLocalDistributioInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.LocalDistributionPackageImporterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    packageBuilderTarget match {
      case Some(param) => queryParams += "packageBuilder.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionPackagingImplImporterRemoteDistributi(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    endpoints: Option[List[String]] = None,
    transportSecretProviderTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo]): Future[OrgApacheSlingDistributionPackagingImplImporterRemoteDistributiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.RemoteDistributionPackageImporterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    endpoints match {
      case Some(param) => queryParams += "endpoints" -> param.toString
      case _ => queryParams
    }
    transportSecretProviderTarget match {
      case Some(param) => queryParams += "transportSecretProvider.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionPackagingImplImporterRepositoryDistri(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    serviceName: Option[String] = None,
    `path`: Option[String] = None,
    privilegeName: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo]): Future[OrgApacheSlingDistributionPackagingImplImporterRepositoryDistriInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.packaging.impl.importer.RepositoryDistributionPackageImporterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "service.name" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    privilegeName match {
      case Some(param) => queryParams += "privilege.name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionResourcesImplDistributionConfiguration(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    providerRoots: Option[String] = None,
    kind: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo]): Future[OrgApacheSlingDistributionResourcesImplDistributionConfigurationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.resources.impl.DistributionConfigurationResourceProviderFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    providerRoots match {
      case Some(param) => queryParams += "provider.roots" -> param.toString
      case _ => queryParams
    }
    kind match {
      case Some(param) => queryParams += "kind" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionResourcesImplDistributionServiceResour(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    providerRoots: Option[String] = None,
    kind: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo]): Future[OrgApacheSlingDistributionResourcesImplDistributionServiceResourInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.resources.impl.DistributionServiceResourceProviderFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    providerRoots match {
      case Some(param) => queryParams += "provider.roots" -> param.toString
      case _ => queryParams
    }
    kind match {
      case Some(param) => queryParams += "kind" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionSerializationImplDistributionPackageBu(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    `type`: Option[String] = None,
    formatTarget: Option[String] = None,
    tempFsFolder: Option[String] = None,
    fileThreshold: Option[Integer] = None,
    memoryUnit: Option[String] = None,
    useOffHeapMemory: Option[Boolean] = None,
    digestAlgorithm: Option[String] = None,
    monitoringQueueSize: Option[Integer] = None,
    cleanupDelay: Option[Integer] = None,
    packageFilters: Option[List[String]] = None,
    propertyFilters: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo]): Future[OrgApacheSlingDistributionSerializationImplDistributionPackageBuInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.serialization.impl.DistributionPackageBuilderFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    `type` match {
      case Some(param) => queryParams += "type" -> param.toString
      case _ => queryParams
    }
    formatTarget match {
      case Some(param) => queryParams += "format.target" -> param.toString
      case _ => queryParams
    }
    tempFsFolder match {
      case Some(param) => queryParams += "tempFsFolder" -> param.toString
      case _ => queryParams
    }
    fileThreshold match {
      case Some(param) => queryParams += "fileThreshold" -> param.toString
      case _ => queryParams
    }
    memoryUnit match {
      case Some(param) => queryParams += "memoryUnit" -> param.toString
      case _ => queryParams
    }
    useOffHeapMemory match {
      case Some(param) => queryParams += "useOffHeapMemory" -> param.toString
      case _ => queryParams
    }
    digestAlgorithm match {
      case Some(param) => queryParams += "digestAlgorithm" -> param.toString
      case _ => queryParams
    }
    monitoringQueueSize match {
      case Some(param) => queryParams += "monitoringQueueSize" -> param.toString
      case _ => queryParams
    }
    cleanupDelay match {
      case Some(param) => queryParams += "cleanupDelay" -> param.toString
      case _ => queryParams
    }
    packageFilters match {
      case Some(param) => queryParams += "package.filters" -> param.toString
      case _ => queryParams
    }
    propertyFilters match {
      case Some(param) => queryParams += "property.filters" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionSerializationImplVltVaultDistribution(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    `type`: Option[String] = None,
    importMode: Option[String] = None,
    aclHandling: Option[String] = None,
    packageRoots: Option[String] = None,
    packageFilters: Option[List[String]] = None,
    propertyFilters: Option[List[String]] = None,
    tempFsFolder: Option[String] = None,
    useBinaryReferences: Option[Boolean] = None,
    autoSaveThreshold: Option[Integer] = None,
    cleanupDelay: Option[Integer] = None,
    fileThreshold: Option[Integer] = None,
    MEGA_BYTES: Option[String] = None,
    useOffHeapMemory: Option[Boolean] = None,
    digestAlgorithm: Option[String] = None,
    monitoringQueueSize: Option[Integer] = None,
    pathsMapping: Option[List[String]] = None,
    strictImport: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo]): Future[OrgApacheSlingDistributionSerializationImplVltVaultDistributionInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.serialization.impl.vlt.VaultDistributionPackageBuilderFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    `type` match {
      case Some(param) => queryParams += "type" -> param.toString
      case _ => queryParams
    }
    importMode match {
      case Some(param) => queryParams += "importMode" -> param.toString
      case _ => queryParams
    }
    aclHandling match {
      case Some(param) => queryParams += "aclHandling" -> param.toString
      case _ => queryParams
    }
    packageRoots match {
      case Some(param) => queryParams += "package.roots" -> param.toString
      case _ => queryParams
    }
    packageFilters match {
      case Some(param) => queryParams += "package.filters" -> param.toString
      case _ => queryParams
    }
    propertyFilters match {
      case Some(param) => queryParams += "property.filters" -> param.toString
      case _ => queryParams
    }
    tempFsFolder match {
      case Some(param) => queryParams += "tempFsFolder" -> param.toString
      case _ => queryParams
    }
    useBinaryReferences match {
      case Some(param) => queryParams += "useBinaryReferences" -> param.toString
      case _ => queryParams
    }
    autoSaveThreshold match {
      case Some(param) => queryParams += "autoSaveThreshold" -> param.toString
      case _ => queryParams
    }
    cleanupDelay match {
      case Some(param) => queryParams += "cleanupDelay" -> param.toString
      case _ => queryParams
    }
    fileThreshold match {
      case Some(param) => queryParams += "fileThreshold" -> param.toString
      case _ => queryParams
    }
    MEGA_BYTES match {
      case Some(param) => queryParams += "MEGA_BYTES" -> param.toString
      case _ => queryParams
    }
    useOffHeapMemory match {
      case Some(param) => queryParams += "useOffHeapMemory" -> param.toString
      case _ => queryParams
    }
    digestAlgorithm match {
      case Some(param) => queryParams += "digestAlgorithm" -> param.toString
      case _ => queryParams
    }
    monitoringQueueSize match {
      case Some(param) => queryParams += "monitoringQueueSize" -> param.toString
      case _ => queryParams
    }
    pathsMapping match {
      case Some(param) => queryParams += "pathsMapping" -> param.toString
      case _ => queryParams
    }
    strictImport match {
      case Some(param) => queryParams += "strictImport" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionTransportImplUserCredentialsDistributi(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    username: Option[String] = None,
    password: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo]): Future[OrgApacheSlingDistributionTransportImplUserCredentialsDistributiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.transport.impl.UserCredentialsDistributionTransportSecretProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    username match {
      case Some(param) => queryParams += "username" -> param.toString
      case _ => queryParams
    }
    password match {
      case Some(param) => queryParams += "password" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionTriggerImplDistributionEventDistribute(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    `path`: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo]): Future[OrgApacheSlingDistributionTriggerImplDistributionEventDistributeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.trigger.impl.DistributionEventDistributeDistributionTriggerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionTriggerImplJcrEventDistributionTrigger(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    `path`: Option[String] = None,
    ignoredPathsPatterns: Option[List[String]] = None,
    serviceName: Option[String] = None,
    deep: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo]): Future[OrgApacheSlingDistributionTriggerImplJcrEventDistributionTriggerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.trigger.impl.JcrEventDistributionTriggerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    ignoredPathsPatterns match {
      case Some(param) => queryParams += "ignoredPathsPatterns" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }
    deep match {
      case Some(param) => queryParams += "deep" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionTriggerImplPersistedJcrEventDistributi(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    `path`: Option[String] = None,
    serviceName: Option[String] = None,
    nuggetsPath: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo]): Future[OrgApacheSlingDistributionTriggerImplPersistedJcrEventDistributiInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.trigger.impl.PersistedJcrEventDistributionTriggerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }
    nuggetsPath match {
      case Some(param) => queryParams += "nuggetsPath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionTriggerImplRemoteEventDistributionTrig(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    endpoint: Option[String] = None,
    transportSecretProviderTarget: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo]): Future[OrgApacheSlingDistributionTriggerImplRemoteEventDistributionTrigInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.trigger.impl.RemoteEventDistributionTriggerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    endpoint match {
      case Some(param) => queryParams += "endpoint" -> param.toString
      case _ => queryParams
    }
    transportSecretProviderTarget match {
      case Some(param) => queryParams += "transportSecretProvider.target" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionTriggerImplResourceEventDistributionTr(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    `path`: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo]): Future[OrgApacheSlingDistributionTriggerImplResourceEventDistributionTrInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.trigger.impl.ResourceEventDistributionTriggerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingDistributionTriggerImplScheduledDistributionTrigge(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    `path`: Option[String] = None,
    seconds: Option[String] = None,
    serviceName: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo]): Future[OrgApacheSlingDistributionTriggerImplScheduledDistributionTriggeInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.distribution.trigger.impl.ScheduledDistributionTriggerFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    seconds match {
      case Some(param) => queryParams += "seconds" -> param.toString
      case _ => queryParams
    }
    serviceName match {
      case Some(param) => queryParams += "serviceName" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEngineImplAuthSlingAuthenticator(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    osgiHttpWhiteboardContextSelect: Option[String] = None,
    osgiHttpWhiteboardListener: Option[String] = None,
    authSudoCookie: Option[String] = None,
    authSudoParameter: Option[String] = None,
    authAnnonymous: Option[Boolean] = None,
    slingAuthRequirements: Option[List[String]] = None,
    slingAuthAnonymousUser: Option[String] = None,
    slingAuthAnonymousPassword: Option[String] = None,
    authHttp: Option[String] = None,
    authHttpRealm: Option[String] = None,
    authUriSuffix: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo]): Future[OrgApacheSlingEngineImplAuthSlingAuthenticatorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.engine.impl.auth.SlingAuthenticator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    osgiHttpWhiteboardContextSelect match {
      case Some(param) => queryParams += "osgi.http.whiteboard.context.select" -> param.toString
      case _ => queryParams
    }
    osgiHttpWhiteboardListener match {
      case Some(param) => queryParams += "osgi.http.whiteboard.listener" -> param.toString
      case _ => queryParams
    }
    authSudoCookie match {
      case Some(param) => queryParams += "auth.sudo.cookie" -> param.toString
      case _ => queryParams
    }
    authSudoParameter match {
      case Some(param) => queryParams += "auth.sudo.parameter" -> param.toString
      case _ => queryParams
    }
    authAnnonymous match {
      case Some(param) => queryParams += "auth.annonymous" -> param.toString
      case _ => queryParams
    }
    slingAuthRequirements match {
      case Some(param) => queryParams += "sling.auth.requirements" -> param.toString
      case _ => queryParams
    }
    slingAuthAnonymousUser match {
      case Some(param) => queryParams += "sling.auth.anonymous.user" -> param.toString
      case _ => queryParams
    }
    slingAuthAnonymousPassword match {
      case Some(param) => queryParams += "sling.auth.anonymous.password" -> param.toString
      case _ => queryParams
    }
    authHttp match {
      case Some(param) => queryParams += "auth.http" -> param.toString
      case _ => queryParams
    }
    authHttpRealm match {
      case Some(param) => queryParams += "auth.http.realm" -> param.toString
      case _ => queryParams
    }
    authUriSuffix match {
      case Some(param) => queryParams += "auth.uri.suffix" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEngineImplDebugRequestProgressTrackerLogFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    extensions: Option[List[String]] = None,
    minDurationMs: Option[Integer] = None,
    maxDurationMs: Option[Integer] = None,
    compactLogFormat: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo]): Future[OrgApacheSlingEngineImplDebugRequestProgressTrackerLogFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.engine.impl.debug.RequestProgressTrackerLogFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    extensions match {
      case Some(param) => queryParams += "extensions" -> param.toString
      case _ => queryParams
    }
    minDurationMs match {
      case Some(param) => queryParams += "minDurationMs" -> param.toString
      case _ => queryParams
    }
    maxDurationMs match {
      case Some(param) => queryParams += "maxDurationMs" -> param.toString
      case _ => queryParams
    }
    compactLogFormat match {
      case Some(param) => queryParams += "compactLogFormat" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEngineImplLogRequestLogger(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    requestLogOutput: Option[String] = None,
    requestLogOutputtype: Option[Integer] = None,
    requestLogEnabled: Option[Boolean] = None,
    accessLogOutput: Option[String] = None,
    accessLogOutputtype: Option[Integer] = None,
    accessLogEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEngineImplLogRequestLoggerInfo]): Future[OrgApacheSlingEngineImplLogRequestLoggerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.engine.impl.log.RequestLogger"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    requestLogOutput match {
      case Some(param) => queryParams += "request.log.output" -> param.toString
      case _ => queryParams
    }
    requestLogOutputtype match {
      case Some(param) => queryParams += "request.log.outputtype" -> param.toString
      case _ => queryParams
    }
    requestLogEnabled match {
      case Some(param) => queryParams += "request.log.enabled" -> param.toString
      case _ => queryParams
    }
    accessLogOutput match {
      case Some(param) => queryParams += "access.log.output" -> param.toString
      case _ => queryParams
    }
    accessLogOutputtype match {
      case Some(param) => queryParams += "access.log.outputtype" -> param.toString
      case _ => queryParams
    }
    accessLogEnabled match {
      case Some(param) => queryParams += "access.log.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEngineImplLogRequestLoggerService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    requestLogServiceFormat: Option[String] = None,
    requestLogServiceOutput: Option[String] = None,
    requestLogServiceOutputtype: Option[Integer] = None,
    requestLogServiceOnentry: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo]): Future[OrgApacheSlingEngineImplLogRequestLoggerServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.engine.impl.log.RequestLoggerService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    requestLogServiceFormat match {
      case Some(param) => queryParams += "request.log.service.format" -> param.toString
      case _ => queryParams
    }
    requestLogServiceOutput match {
      case Some(param) => queryParams += "request.log.service.output" -> param.toString
      case _ => queryParams
    }
    requestLogServiceOutputtype match {
      case Some(param) => queryParams += "request.log.service.outputtype" -> param.toString
      case _ => queryParams
    }
    requestLogServiceOnentry match {
      case Some(param) => queryParams += "request.log.service.onentry" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEngineImplSlingMainServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingMaxCalls: Option[Integer] = None,
    slingMaxInclusions: Option[Integer] = None,
    slingTraceAllow: Option[Boolean] = None,
    slingMaxRecordRequests: Option[Integer] = None,
    slingStorePatternRequests: Option[List[String]] = None,
    slingServerinfo: Option[String] = None,
    slingAdditionalResponseHeaders: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEngineImplSlingMainServletInfo]): Future[OrgApacheSlingEngineImplSlingMainServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.engine.impl.SlingMainServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingMaxCalls match {
      case Some(param) => queryParams += "sling.max.calls" -> param.toString
      case _ => queryParams
    }
    slingMaxInclusions match {
      case Some(param) => queryParams += "sling.max.inclusions" -> param.toString
      case _ => queryParams
    }
    slingTraceAllow match {
      case Some(param) => queryParams += "sling.trace.allow" -> param.toString
      case _ => queryParams
    }
    slingMaxRecordRequests match {
      case Some(param) => queryParams += "sling.max.record.requests" -> param.toString
      case _ => queryParams
    }
    slingStorePatternRequests match {
      case Some(param) => queryParams += "sling.store.pattern.requests" -> param.toString
      case _ => queryParams
    }
    slingServerinfo match {
      case Some(param) => queryParams += "sling.serverinfo" -> param.toString
      case _ => queryParams
    }
    slingAdditionalResponseHeaders match {
      case Some(param) => queryParams += "sling.additional.response.headers" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEngineParameters(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingDefaultParameterEncoding: Option[String] = None,
    slingDefaultMaxParameters: Option[Integer] = None,
    fileLocation: Option[String] = None,
    fileThreshold: Option[Integer] = None,
    fileMax: Option[Integer] = None,
    requestMax: Option[Integer] = None,
    slingDefaultParameterCheckForAdditionalContainerParameters: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEngineParametersInfo]): Future[OrgApacheSlingEngineParametersInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.engine.parameters"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingDefaultParameterEncoding match {
      case Some(param) => queryParams += "sling.default.parameter.encoding" -> param.toString
      case _ => queryParams
    }
    slingDefaultMaxParameters match {
      case Some(param) => queryParams += "sling.default.max.parameters" -> param.toString
      case _ => queryParams
    }
    fileLocation match {
      case Some(param) => queryParams += "file.location" -> param.toString
      case _ => queryParams
    }
    fileThreshold match {
      case Some(param) => queryParams += "file.threshold" -> param.toString
      case _ => queryParams
    }
    fileMax match {
      case Some(param) => queryParams += "file.max" -> param.toString
      case _ => queryParams
    }
    requestMax match {
      case Some(param) => queryParams += "request.max" -> param.toString
      case _ => queryParams
    }
    slingDefaultParameterCheckForAdditionalContainerParameters match {
      case Some(param) => queryParams += "sling.default.parameter.checkForAdditionalContainerParameters" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEventImplEventingThreadPool(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    minPoolSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEventImplEventingThreadPoolInfo]): Future[OrgApacheSlingEventImplEventingThreadPoolInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.event.impl.EventingThreadPool"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    minPoolSize match {
      case Some(param) => queryParams += "minPoolSize" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEventImplJobsDefaultJobManager(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    queuePriority: Option[String] = None,
    queueRetries: Option[Integer] = None,
    queueRetrydelay: Option[Integer] = None,
    queueMaxparallel: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEventImplJobsDefaultJobManagerInfo]): Future[OrgApacheSlingEventImplJobsDefaultJobManagerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.event.impl.jobs.DefaultJobManager"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    queuePriority match {
      case Some(param) => queryParams += "queue.priority" -> param.toString
      case _ => queryParams
    }
    queueRetries match {
      case Some(param) => queryParams += "queue.retries" -> param.toString
      case _ => queryParams
    }
    queueRetrydelay match {
      case Some(param) => queryParams += "queue.retrydelay" -> param.toString
      case _ => queryParams
    }
    queueMaxparallel match {
      case Some(param) => queryParams += "queue.maxparallel" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEventImplJobsJcrPersistenceHandler(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jobConsumermanagerDisableDistribution: Option[Boolean] = None,
    startupDelay: Option[Integer] = None,
    cleanupPeriod: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo]): Future[OrgApacheSlingEventImplJobsJcrPersistenceHandlerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.event.impl.jobs.jcr.PersistenceHandler"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jobConsumermanagerDisableDistribution match {
      case Some(param) => queryParams += "job.consumermanager.disableDistribution" -> param.toString
      case _ => queryParams
    }
    startupDelay match {
      case Some(param) => queryParams += "startup.delay" -> param.toString
      case _ => queryParams
    }
    cleanupPeriod match {
      case Some(param) => queryParams += "cleanup.period" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEventImplJobsJobConsumerManager(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheSlingInstallerConfigurationPersist: Option[Boolean] = None,
    jobConsumermanagerWhitelist: Option[List[String]] = None,
    jobConsumermanagerBlacklist: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEventImplJobsJobConsumerManagerInfo]): Future[OrgApacheSlingEventImplJobsJobConsumerManagerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.event.impl.jobs.JobConsumerManager"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingInstallerConfigurationPersist match {
      case Some(param) => queryParams += "org.apache.sling.installer.configuration.persist" -> param.toString
      case _ => queryParams
    }
    jobConsumermanagerWhitelist match {
      case Some(param) => queryParams += "job.consumermanager.whitelist" -> param.toString
      case _ => queryParams
    }
    jobConsumermanagerBlacklist match {
      case Some(param) => queryParams += "job.consumermanager.blacklist" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingEventJobsQueueConfiguration(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    queueName: Option[String] = None,
    queueTopics: Option[List[String]] = None,
    queueType: Option[String] = None,
    queuePriority: Option[String] = None,
    queueRetries: Option[Integer] = None,
    queueRetrydelay: Option[Integer] = None,
    queueMaxparallel: Option[Number] = None,
    queueKeepJobs: Option[Boolean] = None,
    queuePreferRunOnCreationInstance: Option[Boolean] = None,
    queueThreadPoolSize: Option[Integer] = None,
    serviceRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingEventJobsQueueConfigurationInfo]): Future[OrgApacheSlingEventJobsQueueConfigurationInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.event.jobs.QueueConfiguration"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    queueName match {
      case Some(param) => queryParams += "queue.name" -> param.toString
      case _ => queryParams
    }
    queueTopics match {
      case Some(param) => queryParams += "queue.topics" -> param.toString
      case _ => queryParams
    }
    queueType match {
      case Some(param) => queryParams += "queue.type" -> param.toString
      case _ => queryParams
    }
    queuePriority match {
      case Some(param) => queryParams += "queue.priority" -> param.toString
      case _ => queryParams
    }
    queueRetries match {
      case Some(param) => queryParams += "queue.retries" -> param.toString
      case _ => queryParams
    }
    queueRetrydelay match {
      case Some(param) => queryParams += "queue.retrydelay" -> param.toString
      case _ => queryParams
    }
    queueMaxparallel match {
      case Some(param) => queryParams += "queue.maxparallel" -> param.toString
      case _ => queryParams
    }
    queueKeepJobs match {
      case Some(param) => queryParams += "queue.keepJobs" -> param.toString
      case _ => queryParams
    }
    queuePreferRunOnCreationInstance match {
      case Some(param) => queryParams += "queue.preferRunOnCreationInstance" -> param.toString
      case _ => queryParams
    }
    queueThreadPoolSize match {
      case Some(param) => queryParams += "queue.threadPoolSize" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingW(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    users: Option[List[String]] = None,
    groups: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo]): Future[OrgApacheSlingExtensionsWebconsolesecurityproviderInternalSlingWInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.extensions.webconsolesecurityprovider.internal.SlingWebConsoleSecurityProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    users match {
      case Some(param) => queryParams += "users" -> param.toString
      case _ => queryParams
    }
    groups match {
      case Some(param) => queryParams += "groups" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingFeatureflagsFeature(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    description: Option[String] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingFeatureflagsFeatureInfo]): Future[OrgApacheSlingFeatureflagsFeatureInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.featureflags.Feature"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    description match {
      case Some(param) => queryParams += "description" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingFeatureflagsImplConfiguredFeature(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    name: Option[String] = None,
    description: Option[String] = None,
    enabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo]): Future[OrgApacheSlingFeatureflagsImplConfiguredFeatureInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.featureflags.impl.ConfiguredFeature"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    description match {
      case Some(param) => queryParams += "description" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingHapiImplHApiUtilImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheSlingHapiToolsResourcetype: Option[String] = None,
    orgApacheSlingHapiToolsCollectionresourcetype: Option[String] = None,
    orgApacheSlingHapiToolsSearchpaths: Option[List[String]] = None,
    orgApacheSlingHapiToolsExternalurl: Option[String] = None,
    orgApacheSlingHapiToolsEnabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingHapiImplHApiUtilImplInfo]): Future[OrgApacheSlingHapiImplHApiUtilImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.hapi.impl.HApiUtilImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingHapiToolsResourcetype match {
      case Some(param) => queryParams += "org.apache.sling.hapi.tools.resourcetype" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingHapiToolsCollectionresourcetype match {
      case Some(param) => queryParams += "org.apache.sling.hapi.tools.collectionresourcetype" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingHapiToolsSearchpaths match {
      case Some(param) => queryParams += "org.apache.sling.hapi.tools.searchpaths" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingHapiToolsExternalurl match {
      case Some(param) => queryParams += "org.apache.sling.hapi.tools.externalurl" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingHapiToolsEnabled match {
      case Some(param) => queryParams += "org.apache.sling.hapi.tools.enabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingHcCoreImplCompositeHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcName: Option[String] = None,
    hcTags: Option[List[String]] = None,
    hcMbeanName: Option[String] = None,
    filterTags: Option[List[String]] = None,
    filterCombineTagsWithOr: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo]): Future[OrgApacheSlingHcCoreImplCompositeHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.hc.core.impl.CompositeHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcName match {
      case Some(param) => queryParams += "hc.name" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    hcMbeanName match {
      case Some(param) => queryParams += "hc.mbean.name" -> param.toString
      case _ => queryParams
    }
    filterTags match {
      case Some(param) => queryParams += "filter.tags" -> param.toString
      case _ => queryParams
    }
    filterCombineTagsWithOr match {
      case Some(param) => queryParams += "filter.combineTagsWithOr" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingHcCoreImplExecutorHealthCheckExecutorImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    timeoutInMs: Option[Integer] = None,
    longRunningFutureThresholdForCriticalMs: Option[Integer] = None,
    resultCacheTtlInMs: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo]): Future[OrgApacheSlingHcCoreImplExecutorHealthCheckExecutorImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.hc.core.impl.executor.HealthCheckExecutorImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    timeoutInMs match {
      case Some(param) => queryParams += "timeoutInMs" -> param.toString
      case _ => queryParams
    }
    longRunningFutureThresholdForCriticalMs match {
      case Some(param) => queryParams += "longRunningFutureThresholdForCriticalMs" -> param.toString
      case _ => queryParams
    }
    resultCacheTtlInMs match {
      case Some(param) => queryParams += "resultCacheTtlInMs" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingHcCoreImplJmxAttributeHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcName: Option[String] = None,
    hcTags: Option[List[String]] = None,
    hcMbeanName: Option[String] = None,
    mbeanName: Option[String] = None,
    attributeName: Option[String] = None,
    attributeValueConstraint: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo]): Future[OrgApacheSlingHcCoreImplJmxAttributeHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.hc.core.impl.JmxAttributeHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcName match {
      case Some(param) => queryParams += "hc.name" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    hcMbeanName match {
      case Some(param) => queryParams += "hc.mbean.name" -> param.toString
      case _ => queryParams
    }
    mbeanName match {
      case Some(param) => queryParams += "mbean.name" -> param.toString
      case _ => queryParams
    }
    attributeName match {
      case Some(param) => queryParams += "attribute.name" -> param.toString
      case _ => queryParams
    }
    attributeValueConstraint match {
      case Some(param) => queryParams += "attribute.value.constraint" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingHcCoreImplScriptableHealthCheck(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    hcName: Option[String] = None,
    hcTags: Option[List[String]] = None,
    hcMbeanName: Option[String] = None,
    expression: Option[String] = None,
    languageExtension: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo]): Future[OrgApacheSlingHcCoreImplScriptableHealthCheckInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.hc.core.impl.ScriptableHealthCheck"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    hcName match {
      case Some(param) => queryParams += "hc.name" -> param.toString
      case _ => queryParams
    }
    hcTags match {
      case Some(param) => queryParams += "hc.tags" -> param.toString
      case _ => queryParams
    }
    hcMbeanName match {
      case Some(param) => queryParams += "hc.mbean.name" -> param.toString
      case _ => queryParams
    }
    expression match {
      case Some(param) => queryParams += "expression" -> param.toString
      case _ => queryParams
    }
    languageExtension match {
      case Some(param) => queryParams += "language.extension" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingHcCoreImplServletHealthCheckExecutorServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    servletPath: Option[String] = None,
    disabled: Option[Boolean] = None,
    corsAccessControlAllowOrigin: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo]): Future[OrgApacheSlingHcCoreImplServletHealthCheckExecutorServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.hc.core.impl.servlet.HealthCheckExecutorServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    servletPath match {
      case Some(param) => queryParams += "servletPath" -> param.toString
      case _ => queryParams
    }
    disabled match {
      case Some(param) => queryParams += "disabled" -> param.toString
      case _ => queryParams
    }
    corsAccessControlAllowOrigin match {
      case Some(param) => queryParams += "cors.accessControlAllowOrigin" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingHcCoreImplServletResultTxtVerboseSerializer(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    totalWidth: Option[Integer] = None,
    colWidthName: Option[Integer] = None,
    colWidthResult: Option[Integer] = None,
    colWidthTiming: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo]): Future[OrgApacheSlingHcCoreImplServletResultTxtVerboseSerializerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.hc.core.impl.servlet.ResultTxtVerboseSerializer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    totalWidth match {
      case Some(param) => queryParams += "totalWidth" -> param.toString
      case _ => queryParams
    }
    colWidthName match {
      case Some(param) => queryParams += "colWidthName" -> param.toString
      case _ => queryParams
    }
    colWidthResult match {
      case Some(param) => queryParams += "colWidthResult" -> param.toString
      case _ => queryParams
    }
    colWidthTiming match {
      case Some(param) => queryParams += "colWidthTiming" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingI18nImplI18NFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    slingFilterScope: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingI18nImplI18NFilterInfo]): Future[OrgApacheSlingI18nImplI18NFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.i18n.impl.I18NFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    slingFilterScope match {
      case Some(param) => queryParams += "sling.filter.scope" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingI18nImplJcrResourceBundleProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    localeDefault: Option[String] = None,
    preloadBundles: Option[Boolean] = None,
    invalidationDelay: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo]): Future[OrgApacheSlingI18nImplJcrResourceBundleProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.i18n.impl.JcrResourceBundleProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    localeDefault match {
      case Some(param) => queryParams += "locale.default" -> param.toString
      case _ => queryParams
    }
    preloadBundles match {
      case Some(param) => queryParams += "preload.bundles" -> param.toString
      case _ => queryParams
    }
    invalidationDelay match {
      case Some(param) => queryParams += "invalidation.delay" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingInstallerProviderJcrImplJcrInstaller(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    handlerSchemes: Option[List[String]] = None,
    slingJcrinstallFolderNameRegexp: Option[String] = None,
    slingJcrinstallFolderMaxDepth: Option[Integer] = None,
    slingJcrinstallSearchPath: Option[List[String]] = None,
    slingJcrinstallNewConfigPath: Option[String] = None,
    slingJcrinstallSignalPath: Option[String] = None,
    slingJcrinstallEnableWriteback: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo]): Future[OrgApacheSlingInstallerProviderJcrImplJcrInstallerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.installer.provider.jcr.impl.JcrInstaller"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    handlerSchemes match {
      case Some(param) => queryParams += "handler.schemes" -> param.toString
      case _ => queryParams
    }
    slingJcrinstallFolderNameRegexp match {
      case Some(param) => queryParams += "sling.jcrinstall.folder.name.regexp" -> param.toString
      case _ => queryParams
    }
    slingJcrinstallFolderMaxDepth match {
      case Some(param) => queryParams += "sling.jcrinstall.folder.max.depth" -> param.toString
      case _ => queryParams
    }
    slingJcrinstallSearchPath match {
      case Some(param) => queryParams += "sling.jcrinstall.search.path" -> param.toString
      case _ => queryParams
    }
    slingJcrinstallNewConfigPath match {
      case Some(param) => queryParams += "sling.jcrinstall.new.config.path" -> param.toString
      case _ => queryParams
    }
    slingJcrinstallSignalPath match {
      case Some(param) => queryParams += "sling.jcrinstall.signal.path" -> param.toString
      case _ => queryParams
    }
    slingJcrinstallEnableWriteback match {
      case Some(param) => queryParams += "sling.jcrinstall.enable.writeback" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrBaseInternalLoginAdminWhitelist(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    whitelistBypass: Option[Boolean] = None,
    whitelistBundlesRegexp: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo]): Future[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.base.internal.LoginAdminWhitelist"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    whitelistBypass match {
      case Some(param) => queryParams += "whitelist.bypass" -> param.toString
      case _ => queryParams
    }
    whitelistBundlesRegexp match {
      case Some(param) => queryParams += "whitelist.bundles.regexp" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrBaseInternalLoginAdminWhitelistFragment(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    whitelistName: Option[String] = None,
    whitelistBundles: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo]): Future[OrgApacheSlingJcrBaseInternalLoginAdminWhitelistFragmentInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.base.internal.LoginAdminWhitelist.fragment"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    whitelistName match {
      case Some(param) => queryParams += "whitelist.name" -> param.toString
      case _ => queryParams
    }
    whitelistBundles match {
      case Some(param) => queryParams += "whitelist.bundles" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrDavexImplServletsSlingDavExServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    alias: Option[String] = None,
    davCreateAbsoluteUri: Option[Boolean] = None,
    davProtectedhandlers: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo]): Future[OrgApacheSlingJcrDavexImplServletsSlingDavExServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    alias match {
      case Some(param) => queryParams += "alias" -> param.toString
      case _ => queryParams
    }
    davCreateAbsoluteUri match {
      case Some(param) => queryParams += "dav.create-absolute-uri" -> param.toString
      case _ => queryParams
    }
    davProtectedhandlers match {
      case Some(param) => queryParams += "dav.protectedhandlers" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrJackrabbitServerJndiRegistrationSupport(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    javaNamingFactoryInitial: Option[String] = None,
    javaNamingProviderUrl: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo]): Future[OrgApacheSlingJcrJackrabbitServerJndiRegistrationSupportInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.jackrabbit.server.JndiRegistrationSupport"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    javaNamingFactoryInitial match {
      case Some(param) => queryParams += "java.naming.factory.initial" -> param.toString
      case _ => queryParams
    }
    javaNamingProviderUrl match {
      case Some(param) => queryParams += "java.naming.provider.url" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrJackrabbitServerRmiRegistrationSupport(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    port: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo]): Future[OrgApacheSlingJcrJackrabbitServerRmiRegistrationSupportInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.jackrabbit.server.RmiRegistrationSupport"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    port match {
      case Some(param) => queryParams += "port" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrRepoinitImplRepositoryInitializer(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    references: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo]): Future[OrgApacheSlingJcrRepoinitImplRepositoryInitializerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.repoinit.impl.RepositoryInitializer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    references match {
      case Some(param) => queryParams += "references" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrRepoinitRepositoryInitializer(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    references: Option[List[String]] = None,
    scripts: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo]): Future[OrgApacheSlingJcrRepoinitRepositoryInitializerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.repoinit.RepositoryInitializer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    references match {
      case Some(param) => queryParams += "references" -> param.toString
      case _ => queryParams
    }
    scripts match {
      case Some(param) => queryParams += "scripts" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    resourceResolverSearchpath: Option[List[String]] = None,
    resourceResolverManglenamespaces: Option[Boolean] = None,
    resourceResolverAllowDirect: Option[Boolean] = None,
    resourceResolverRequiredProviders: Option[List[String]] = None,
    resourceResolverRequiredProvidernames: Option[List[String]] = None,
    resourceResolverVirtual: Option[List[String]] = None,
    resourceResolverMapping: Option[List[String]] = None,
    resourceResolverMapLocation: Option[String] = None,
    resourceResolverMapObservation: Option[List[String]] = None,
    resourceResolverDefaultVanityRedirectStatus: Option[Integer] = None,
    resourceResolverEnableVanitypath: Option[Boolean] = None,
    resourceResolverVanitypathMaxEntries: Option[Integer] = None,
    resourceResolverVanitypathMaxEntriesStartup: Option[Boolean] = None,
    resourceResolverVanitypathBloomfilterMaxBytes: Option[Integer] = None,
    resourceResolverOptimizeAliasResolution: Option[Boolean] = None,
    resourceResolverVanitypathWhitelist: Option[List[String]] = None,
    resourceResolverVanitypathBlacklist: Option[List[String]] = None,
    resourceResolverVanityPrecedence: Option[Boolean] = None,
    resourceResolverProviderhandlingParanoid: Option[Boolean] = None,
    resourceResolverLogClosing: Option[Boolean] = None,
    resourceResolverLogUnclosed: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo]): Future[OrgApacheSlingJcrResourceInternalJcrResourceResolverFactoryImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.resource.internal.JcrResourceResolverFactoryImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    resourceResolverSearchpath match {
      case Some(param) => queryParams += "resource.resolver.searchpath" -> param.toString
      case _ => queryParams
    }
    resourceResolverManglenamespaces match {
      case Some(param) => queryParams += "resource.resolver.manglenamespaces" -> param.toString
      case _ => queryParams
    }
    resourceResolverAllowDirect match {
      case Some(param) => queryParams += "resource.resolver.allowDirect" -> param.toString
      case _ => queryParams
    }
    resourceResolverRequiredProviders match {
      case Some(param) => queryParams += "resource.resolver.required.providers" -> param.toString
      case _ => queryParams
    }
    resourceResolverRequiredProvidernames match {
      case Some(param) => queryParams += "resource.resolver.required.providernames" -> param.toString
      case _ => queryParams
    }
    resourceResolverVirtual match {
      case Some(param) => queryParams += "resource.resolver.virtual" -> param.toString
      case _ => queryParams
    }
    resourceResolverMapping match {
      case Some(param) => queryParams += "resource.resolver.mapping" -> param.toString
      case _ => queryParams
    }
    resourceResolverMapLocation match {
      case Some(param) => queryParams += "resource.resolver.map.location" -> param.toString
      case _ => queryParams
    }
    resourceResolverMapObservation match {
      case Some(param) => queryParams += "resource.resolver.map.observation" -> param.toString
      case _ => queryParams
    }
    resourceResolverDefaultVanityRedirectStatus match {
      case Some(param) => queryParams += "resource.resolver.default.vanity.redirect.status" -> param.toString
      case _ => queryParams
    }
    resourceResolverEnableVanitypath match {
      case Some(param) => queryParams += "resource.resolver.enable.vanitypath" -> param.toString
      case _ => queryParams
    }
    resourceResolverVanitypathMaxEntries match {
      case Some(param) => queryParams += "resource.resolver.vanitypath.maxEntries" -> param.toString
      case _ => queryParams
    }
    resourceResolverVanitypathMaxEntriesStartup match {
      case Some(param) => queryParams += "resource.resolver.vanitypath.maxEntries.startup" -> param.toString
      case _ => queryParams
    }
    resourceResolverVanitypathBloomfilterMaxBytes match {
      case Some(param) => queryParams += "resource.resolver.vanitypath.bloomfilter.maxBytes" -> param.toString
      case _ => queryParams
    }
    resourceResolverOptimizeAliasResolution match {
      case Some(param) => queryParams += "resource.resolver.optimize.alias.resolution" -> param.toString
      case _ => queryParams
    }
    resourceResolverVanitypathWhitelist match {
      case Some(param) => queryParams += "resource.resolver.vanitypath.whitelist" -> param.toString
      case _ => queryParams
    }
    resourceResolverVanitypathBlacklist match {
      case Some(param) => queryParams += "resource.resolver.vanitypath.blacklist" -> param.toString
      case _ => queryParams
    }
    resourceResolverVanityPrecedence match {
      case Some(param) => queryParams += "resource.resolver.vanity.precedence" -> param.toString
      case _ => queryParams
    }
    resourceResolverProviderhandlingParanoid match {
      case Some(param) => queryParams += "resource.resolver.providerhandling.paranoid" -> param.toString
      case _ => queryParams
    }
    resourceResolverLogClosing match {
      case Some(param) => queryParams += "resource.resolver.log.closing" -> param.toString
      case _ => queryParams
    }
    resourceResolverLogUnclosed match {
      case Some(param) => queryParams += "resource.resolver.log.unclosed" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrResourceInternalJcrSystemUserValidator(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    allowOnlySystemUser: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo]): Future[OrgApacheSlingJcrResourceInternalJcrSystemUserValidatorInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.resource.internal.JcrSystemUserValidator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    allowOnlySystemUser match {
      case Some(param) => queryParams += "allow.only.system.user" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrResourcesecurityImplResourceAccessGateFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    `path`: Option[String] = None,
    checkpathPrefix: Option[String] = None,
    jcrPath: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo]): Future[OrgApacheSlingJcrResourcesecurityImplResourceAccessGateFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.resourcesecurity.impl.ResourceAccessGateFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    checkpathPrefix match {
      case Some(param) => queryParams += "checkpath.prefix" -> param.toString
      case _ => queryParams
    }
    jcrPath match {
      case Some(param) => queryParams += "jcrPath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrWebdavImplHandlerDefaultHandlerService(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    typeCollections: Option[String] = None,
    typeNoncollections: Option[String] = None,
    typeContent: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo]): Future[OrgApacheSlingJcrWebdavImplHandlerDefaultHandlerServiceInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.webdav.impl.handler.DefaultHandlerService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    typeCollections match {
      case Some(param) => queryParams += "type.collections" -> param.toString
      case _ => queryParams
    }
    typeNoncollections match {
      case Some(param) => queryParams += "type.noncollections" -> param.toString
      case _ => queryParams
    }
    typeContent match {
      case Some(param) => queryParams += "type.content" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServic(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo]): Future[OrgApacheSlingJcrWebdavImplHandlerDirListingExportHandlerServicInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.webdav.impl.handler.DirListingExportHandlerService"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJcrWebdavImplServletsSimpleWebDavServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    davRoot: Option[String] = None,
    davCreateAbsoluteUri: Option[Boolean] = None,
    davRealm: Option[String] = None,
    collectionTypes: Option[List[String]] = None,
    filterPrefixes: Option[List[String]] = None,
    filterTypes: Option[String] = None,
    filterUris: Option[String] = None,
    typeCollections: Option[String] = None,
    typeNoncollections: Option[String] = None,
    typeContent: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo]): Future[OrgApacheSlingJcrWebdavImplServletsSimpleWebDavServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jcr.webdav.impl.servlets.SimpleWebDavServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    davRoot match {
      case Some(param) => queryParams += "dav.root" -> param.toString
      case _ => queryParams
    }
    davCreateAbsoluteUri match {
      case Some(param) => queryParams += "dav.create-absolute-uri" -> param.toString
      case _ => queryParams
    }
    davRealm match {
      case Some(param) => queryParams += "dav.realm" -> param.toString
      case _ => queryParams
    }
    collectionTypes match {
      case Some(param) => queryParams += "collection.types" -> param.toString
      case _ => queryParams
    }
    filterPrefixes match {
      case Some(param) => queryParams += "filter.prefixes" -> param.toString
      case _ => queryParams
    }
    filterTypes match {
      case Some(param) => queryParams += "filter.types" -> param.toString
      case _ => queryParams
    }
    filterUris match {
      case Some(param) => queryParams += "filter.uris" -> param.toString
      case _ => queryParams
    }
    typeCollections match {
      case Some(param) => queryParams += "type.collections" -> param.toString
      case _ => queryParams
    }
    typeNoncollections match {
      case Some(param) => queryParams += "type.noncollections" -> param.toString
      case _ => queryParams
    }
    typeContent match {
      case Some(param) => queryParams += "type.content" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingJmxProviderImplJMXResourceProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    providerRoots: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo]): Future[OrgApacheSlingJmxProviderImplJMXResourceProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.jmx.provider.impl.JMXResourceProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    providerRoots match {
      case Some(param) => queryParams += "provider.roots" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingModelsImplModelAdapterFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    osgiHttpWhiteboardListener: Option[String] = None,
    osgiHttpWhiteboardContextSelect: Option[String] = None,
    maxRecursionDepth: Option[Integer] = None,
    cleanupJobPeriod: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingModelsImplModelAdapterFactoryInfo]): Future[OrgApacheSlingModelsImplModelAdapterFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.models.impl.ModelAdapterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    osgiHttpWhiteboardListener match {
      case Some(param) => queryParams += "osgi.http.whiteboard.listener" -> param.toString
      case _ => queryParams
    }
    osgiHttpWhiteboardContextSelect match {
      case Some(param) => queryParams += "osgi.http.whiteboard.context.select" -> param.toString
      case _ => queryParams
    }
    maxRecursionDepth match {
      case Some(param) => queryParams += "max.recursion.depth" -> param.toString
      case _ => queryParams
    }
    cleanupJobPeriod match {
      case Some(param) => queryParams += "cleanup.job.period" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingModelsJacksonexporterImplResourceModuleProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    maxRecursionLevels: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo]): Future[OrgApacheSlingModelsJacksonexporterImplResourceModuleProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.models.jacksonexporter.impl.ResourceModuleProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    maxRecursionLevels match {
      case Some(param) => queryParams += "max.recursion.levels" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingResourceInventoryImplResourceInventoryPrinterFacto(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    felixInventoryPrinterName: Option[String] = None,
    felixInventoryPrinterTitle: Option[String] = None,
    `path`: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo]): Future[OrgApacheSlingResourceInventoryImplResourceInventoryPrinterFactoInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.resource.inventory.impl.ResourceInventoryPrinterFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    felixInventoryPrinterName match {
      case Some(param) => queryParams += "felix.inventory.printer.name" -> param.toString
      case _ => queryParams
    }
    felixInventoryPrinterTitle match {
      case Some(param) => queryParams += "felix.inventory.printer.title" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingResourcemergerImplMergedResourceProviderFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mergeRoot: Option[String] = None,
    mergeReadOnly: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo]): Future[OrgApacheSlingResourcemergerImplMergedResourceProviderFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.resourcemerger.impl.MergedResourceProviderFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mergeRoot match {
      case Some(param) => queryParams += "merge.root" -> param.toString
      case _ => queryParams
    }
    mergeReadOnly match {
      case Some(param) => queryParams += "merge.readOnly" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingResourcemergerPickerOverriding(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    mergeRoot: Option[String] = None,
    mergeReadOnly: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingResourcemergerPickerOverridingInfo]): Future[OrgApacheSlingResourcemergerPickerOverridingInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.resourcemerger.picker.overriding"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    mergeRoot match {
      case Some(param) => queryParams += "merge.root" -> param.toString
      case _ => queryParams
    }
    mergeReadOnly match {
      case Some(param) => queryParams += "merge.readOnly" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingScriptingCoreImplScriptCacheImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheSlingScriptingCacheSize: Option[Integer] = None,
    orgApacheSlingScriptingCacheAdditionalExtensions: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo]): Future[OrgApacheSlingScriptingCoreImplScriptCacheImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.scripting.core.impl.ScriptCacheImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingScriptingCacheSize match {
      case Some(param) => queryParams += "org.apache.sling.scripting.cache.size" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingScriptingCacheAdditionalExtensions match {
      case Some(param) => queryParams += "org.apache.sling.scripting.cache.additional_extensions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingScriptingCoreImplScriptingResourceResolverProvider(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    logStacktraceOnclose: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo]): Future[OrgApacheSlingScriptingCoreImplScriptingResourceResolverProviderInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.scripting.core.impl.ScriptingResourceResolverProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    logStacktraceOnclose match {
      case Some(param) => queryParams += "log.stacktrace.onclose" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingScriptingJavaImplJavaScriptEngineFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    javaClassdebuginfo: Option[Boolean] = None,
    javaJavaEncoding: Option[String] = None,
    javaCompilerSourceVM: Option[String] = None,
    javaCompilerTargetVM: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo]): Future[OrgApacheSlingScriptingJavaImplJavaScriptEngineFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.scripting.java.impl.JavaScriptEngineFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    javaClassdebuginfo match {
      case Some(param) => queryParams += "java.classdebuginfo" -> param.toString
      case _ => queryParams
    }
    javaJavaEncoding match {
      case Some(param) => queryParams += "java.javaEncoding" -> param.toString
      case _ => queryParams
    }
    javaCompilerSourceVM match {
      case Some(param) => queryParams += "java.compilerSourceVM" -> param.toString
      case _ => queryParams
    }
    javaCompilerTargetVM match {
      case Some(param) => queryParams += "java.compilerTargetVM" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFa(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheSlingScriptingJavascriptRhinoOptLevel: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo]): Future[OrgApacheSlingScriptingJavascriptInternalRhinoJavaScriptEngineFaInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.scripting.javascript.internal.RhinoJavaScriptEngineFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingScriptingJavascriptRhinoOptLevel match {
      case Some(param) => queryParams += "org.apache.sling.scripting.javascript.rhino.optLevel" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingScriptingJspJspScriptEngineFactory(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    jasperCompilerTargetVM: Option[String] = None,
    jasperCompilerSourceVM: Option[String] = None,
    jasperClassdebuginfo: Option[Boolean] = None,
    jasperEnablePooling: Option[Boolean] = None,
    jasperIeClassId: Option[String] = None,
    jasperGenStringAsCharArray: Option[Boolean] = None,
    jasperKeepgenerated: Option[Boolean] = None,
    jasperMappedfile: Option[Boolean] = None,
    jasperTrimSpaces: Option[Boolean] = None,
    jasperDisplaySourceFragments: Option[Boolean] = None,
    defaultIsSession: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo]): Future[OrgApacheSlingScriptingJspJspScriptEngineFactoryInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.scripting.jsp.JspScriptEngineFactory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    jasperCompilerTargetVM match {
      case Some(param) => queryParams += "jasper.compilerTargetVM" -> param.toString
      case _ => queryParams
    }
    jasperCompilerSourceVM match {
      case Some(param) => queryParams += "jasper.compilerSourceVM" -> param.toString
      case _ => queryParams
    }
    jasperClassdebuginfo match {
      case Some(param) => queryParams += "jasper.classdebuginfo" -> param.toString
      case _ => queryParams
    }
    jasperEnablePooling match {
      case Some(param) => queryParams += "jasper.enablePooling" -> param.toString
      case _ => queryParams
    }
    jasperIeClassId match {
      case Some(param) => queryParams += "jasper.ieClassId" -> param.toString
      case _ => queryParams
    }
    jasperGenStringAsCharArray match {
      case Some(param) => queryParams += "jasper.genStringAsCharArray" -> param.toString
      case _ => queryParams
    }
    jasperKeepgenerated match {
      case Some(param) => queryParams += "jasper.keepgenerated" -> param.toString
      case _ => queryParams
    }
    jasperMappedfile match {
      case Some(param) => queryParams += "jasper.mappedfile" -> param.toString
      case _ => queryParams
    }
    jasperTrimSpaces match {
      case Some(param) => queryParams += "jasper.trimSpaces" -> param.toString
      case _ => queryParams
    }
    jasperDisplaySourceFragments match {
      case Some(param) => queryParams += "jasper.displaySourceFragments" -> param.toString
      case _ => queryParams
    }
    defaultIsSession match {
      case Some(param) => queryParams += "default.is.session" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProv(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    orgApacheSlingScriptingSightlyJsBindings: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo]): Future[OrgApacheSlingScriptingSightlyJsImplJsapiSlyBindingsValuesProvInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.scripting.sightly.js.impl.jsapi.SlyBindingsValuesProvider"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    orgApacheSlingScriptingSightlyJsBindings match {
      case Some(param) => queryParams += "org.apache.sling.scripting.sightly.js.bindings" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingSecurityImplContentDispositionFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingContentDispositionPaths: Option[List[String]] = None,
    slingContentDispositionExcludedPaths: Option[List[String]] = None,
    slingContentDispositionAllPaths: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingSecurityImplContentDispositionFilterInfo]): Future[OrgApacheSlingSecurityImplContentDispositionFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.security.impl.ContentDispositionFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingContentDispositionPaths match {
      case Some(param) => queryParams += "sling.content.disposition.paths" -> param.toString
      case _ => queryParams
    }
    slingContentDispositionExcludedPaths match {
      case Some(param) => queryParams += "sling.content.disposition.excluded.paths" -> param.toString
      case _ => queryParams
    }
    slingContentDispositionAllPaths match {
      case Some(param) => queryParams += "sling.content.disposition.all.paths" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingSecurityImplReferrerFilter(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    allowEmpty: Option[Boolean] = None,
    allowHosts: Option[List[String]] = None,
    allowHostsRegexp: Option[List[String]] = None,
    filterMethods: Option[List[String]] = None,
    excludeAgentsRegexp: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingSecurityImplReferrerFilterInfo]): Future[OrgApacheSlingSecurityImplReferrerFilterInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.security.impl.ReferrerFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    allowEmpty match {
      case Some(param) => queryParams += "allow.empty" -> param.toString
      case _ => queryParams
    }
    allowHosts match {
      case Some(param) => queryParams += "allow.hosts" -> param.toString
      case _ => queryParams
    }
    allowHostsRegexp match {
      case Some(param) => queryParams += "allow.hosts.regexp" -> param.toString
      case _ => queryParams
    }
    filterMethods match {
      case Some(param) => queryParams += "filter.methods" -> param.toString
      case _ => queryParams
    }
    excludeAgentsRegexp match {
      case Some(param) => queryParams += "exclude.agents.regexp" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingServiceusermappingImplServiceUserMapperImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    userMapping: Option[List[String]] = None,
    userDefault: Option[String] = None,
    userEnableDefaultMapping: Option[Boolean] = None,
    requireValidation: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo]): Future[OrgApacheSlingServiceusermappingImplServiceUserMapperImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.serviceusermapping.impl.ServiceUserMapperImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    userMapping match {
      case Some(param) => queryParams += "user.mapping" -> param.toString
      case _ => queryParams
    }
    userDefault match {
      case Some(param) => queryParams += "user.default" -> param.toString
      case _ => queryParams
    }
    userEnableDefaultMapping match {
      case Some(param) => queryParams += "user.enable.default.mapping" -> param.toString
      case _ => queryParams
    }
    requireValidation match {
      case Some(param) => queryParams += "require.validation" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingServiceusermappingImplServiceUserMapperImplAmended(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    serviceRanking: Option[Integer] = None,
    userMapping: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo]): Future[OrgApacheSlingServiceusermappingImplServiceUserMapperImplAmendedInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.serviceusermapping.impl.ServiceUserMapperImpl.amended"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    userMapping match {
      case Some(param) => queryParams += "user.mapping" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingServletsGetDefaultGetServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    aliases: Option[List[String]] = None,
    index: Option[Boolean] = None,
    indexFiles: Option[List[String]] = None,
    enableHtml: Option[Boolean] = None,
    enableJson: Option[Boolean] = None,
    enableTxt: Option[Boolean] = None,
    enableXml: Option[Boolean] = None,
    jsonMaximumresults: Option[Integer] = None,
    ecmaSuport: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingServletsGetDefaultGetServletInfo]): Future[OrgApacheSlingServletsGetDefaultGetServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.servlets.get.DefaultGetServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    aliases match {
      case Some(param) => queryParams += "aliases" -> param.toString
      case _ => queryParams
    }
    index match {
      case Some(param) => queryParams += "index" -> param.toString
      case _ => queryParams
    }
    indexFiles match {
      case Some(param) => queryParams += "index.files" -> param.toString
      case _ => queryParams
    }
    enableHtml match {
      case Some(param) => queryParams += "enable.html" -> param.toString
      case _ => queryParams
    }
    enableJson match {
      case Some(param) => queryParams += "enable.json" -> param.toString
      case _ => queryParams
    }
    enableTxt match {
      case Some(param) => queryParams += "enable.txt" -> param.toString
      case _ => queryParams
    }
    enableXml match {
      case Some(param) => queryParams += "enable.xml" -> param.toString
      case _ => queryParams
    }
    jsonMaximumresults match {
      case Some(param) => queryParams += "json.maximumresults" -> param.toString
      case _ => queryParams
    }
    ecmaSuport match {
      case Some(param) => queryParams += "ecmaSuport" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingServletsGetImplVersionVersionInfoServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingServletSelectors: Option[List[String]] = None,
    ecmaSuport: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo]): Future[OrgApacheSlingServletsGetImplVersionVersionInfoServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.servlets.get.impl.version.VersionInfoServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingServletSelectors match {
      case Some(param) => queryParams += "sling.servlet.selectors" -> param.toString
      case _ => queryParams
    }
    ecmaSuport match {
      case Some(param) => queryParams += "ecmaSuport" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingServletsPostImplHelperChunkCleanUpTask(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    schedulerExpression: Option[String] = None,
    schedulerConcurrent: Option[Boolean] = None,
    chunkCleanupAge: Option[Integer] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo]): Future[OrgApacheSlingServletsPostImplHelperChunkCleanUpTaskInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.servlets.post.impl.helper.ChunkCleanUpTask"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    schedulerExpression match {
      case Some(param) => queryParams += "scheduler.expression" -> param.toString
      case _ => queryParams
    }
    schedulerConcurrent match {
      case Some(param) => queryParams += "scheduler.concurrent" -> param.toString
      case _ => queryParams
    }
    chunkCleanupAge match {
      case Some(param) => queryParams += "chunk.cleanup.age" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingServletsPostImplSlingPostServlet(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    servletPostDateFormats: Option[List[String]] = None,
    servletPostNodeNameHints: Option[List[String]] = None,
    servletPostNodeNameMaxLength: Option[Integer] = None,
    servletPostCheckinNewVersionableNodes: Option[Boolean] = None,
    servletPostAutoCheckout: Option[Boolean] = None,
    servletPostAutoCheckin: Option[Boolean] = None,
    servletPostIgnorePattern: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingServletsPostImplSlingPostServletInfo]): Future[OrgApacheSlingServletsPostImplSlingPostServletInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.servlets.post.impl.SlingPostServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    servletPostDateFormats match {
      case Some(param) => queryParams += "servlet.post.dateFormats" -> param.toString
      case _ => queryParams
    }
    servletPostNodeNameHints match {
      case Some(param) => queryParams += "servlet.post.nodeNameHints" -> param.toString
      case _ => queryParams
    }
    servletPostNodeNameMaxLength match {
      case Some(param) => queryParams += "servlet.post.nodeNameMaxLength" -> param.toString
      case _ => queryParams
    }
    servletPostCheckinNewVersionableNodes match {
      case Some(param) => queryParams += "servlet.post.checkinNewVersionableNodes" -> param.toString
      case _ => queryParams
    }
    servletPostAutoCheckout match {
      case Some(param) => queryParams += "servlet.post.autoCheckout" -> param.toString
      case _ => queryParams
    }
    servletPostAutoCheckin match {
      case Some(param) => queryParams += "servlet.post.autoCheckin" -> param.toString
      case _ => queryParams
    }
    servletPostIgnorePattern match {
      case Some(param) => queryParams += "servlet.post.ignorePattern" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingServletsResolverSlingServletResolver(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    servletresolverServletRoot: Option[String] = None,
    servletresolverCacheSize: Option[Integer] = None,
    servletresolverPaths: Option[List[String]] = None,
    servletresolverDefaultExtensions: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingServletsResolverSlingServletResolverInfo]): Future[OrgApacheSlingServletsResolverSlingServletResolverInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.servlets.resolver.SlingServletResolver"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    servletresolverServletRoot match {
      case Some(param) => queryParams += "servletresolver.servletRoot" -> param.toString
      case _ => queryParams
    }
    servletresolverCacheSize match {
      case Some(param) => queryParams += "servletresolver.cacheSize" -> param.toString
      case _ => queryParams
    }
    servletresolverPaths match {
      case Some(param) => queryParams += "servletresolver.paths" -> param.toString
      case _ => queryParams
    }
    servletresolverDefaultExtensions match {
      case Some(param) => queryParams += "servletresolver.defaultExtensions" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingSettingsImplSlingSettingsServiceImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    slingName: Option[String] = None,
    slingDescription: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo]): Future[OrgApacheSlingSettingsImplSlingSettingsServiceImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.settings.impl.SlingSettingsServiceImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    slingName match {
      case Some(param) => queryParams += "sling.name" -> param.toString
      case _ => queryParams
    }
    slingDescription match {
      case Some(param) => queryParams += "sling.description" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingStartupfilterImplStartupFilterImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    activeByDefault: Option[Boolean] = None,
    defaultMessage: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingStartupfilterImplStartupFilterImplInfo]): Future[OrgApacheSlingStartupfilterImplStartupFilterImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.startupfilter.impl.StartupFilterImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    activeByDefault match {
      case Some(param) => queryParams += "active.by.default" -> param.toString
      case _ => queryParams
    }
    defaultMessage match {
      case Some(param) => queryParams += "default.message" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingTenantInternalTenantProviderImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    tenantRoot: Option[String] = None,
    tenantPathMatcher: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingTenantInternalTenantProviderImplInfo]): Future[OrgApacheSlingTenantInternalTenantProviderImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.tenant.internal.TenantProviderImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    tenantRoot match {
      case Some(param) => queryParams += "tenant.root" -> param.toString
      case _ => queryParams
    }
    tenantPathMatcher match {
      case Some(param) => queryParams += "tenant.path.matcher" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingTracerInternalLogTracer(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    tracerSets: Option[List[String]] = None,
    enabled: Option[Boolean] = None,
    servletEnabled: Option[Boolean] = None,
    recordingCacheSizeInMB: Option[Integer] = None,
    recordingCacheDurationInSecs: Option[Integer] = None,
    recordingCompressionEnabled: Option[Boolean] = None,
    gzipResponse: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingTracerInternalLogTracerInfo]): Future[OrgApacheSlingTracerInternalLogTracerInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.tracer.internal.LogTracer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    tracerSets match {
      case Some(param) => queryParams += "tracerSets" -> param.toString
      case _ => queryParams
    }
    enabled match {
      case Some(param) => queryParams += "enabled" -> param.toString
      case _ => queryParams
    }
    servletEnabled match {
      case Some(param) => queryParams += "servletEnabled" -> param.toString
      case _ => queryParams
    }
    recordingCacheSizeInMB match {
      case Some(param) => queryParams += "recordingCacheSizeInMB" -> param.toString
      case _ => queryParams
    }
    recordingCacheDurationInSecs match {
      case Some(param) => queryParams += "recordingCacheDurationInSecs" -> param.toString
      case _ => queryParams
    }
    recordingCompressionEnabled match {
      case Some(param) => queryParams += "recordingCompressionEnabled" -> param.toString
      case _ => queryParams
    }
    gzipResponse match {
      case Some(param) => queryParams += "gzipResponse" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def orgApacheSlingXssImplXSSFilterImpl(post: Option[Boolean] = None,
    apply: Option[Boolean] = None,
    delete: Option[Boolean] = None,
    action: Option[String] = None,
    location: Option[String] = None,
    propertylist: Option[List[String]] = None,
    policyPath: Option[String] = None
    )(implicit reader: ClientResponseReader[OrgApacheSlingXssImplXSSFilterImplInfo]): Future[OrgApacheSlingXssImplXSSFilterImplInfo] = {
    // create path and map variables
    val path = (addFmt("/system/console/configMgr/org.apache.sling.xss.impl.XSSFilterImpl"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    post match {
      case Some(param) => queryParams += "post" -> param.toString
      case _ => queryParams
    }
    apply match {
      case Some(param) => queryParams += "apply" -> param.toString
      case _ => queryParams
    }
    delete match {
      case Some(param) => queryParams += "delete" -> param.toString
      case _ => queryParams
    }
    action match {
      case Some(param) => queryParams += "action" -> param.toString
      case _ => queryParams
    }
    location match {
      case Some(param) => queryParams += "$location" -> param.toString
      case _ => queryParams
    }
    propertylist match {
      case Some(param) => queryParams += "propertylist" -> param.toString
      case _ => queryParams
    }
    policyPath match {
      case Some(param) => queryParams += "policyPath" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
