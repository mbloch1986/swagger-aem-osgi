/* 
 * Adobe Experience Manager OSGI config (AEM) API
 *
 * Swagger AEM OSGI is an OpenAPI specification for Adobe Experience Manager (AEM) OSGI Configurations API
 *
 * OpenAPI spec version: 1.0.0-pre.0
 * Contact: opensource@shinesolutions.com
 * Generated by: https://openapi-generator.tech
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
  #[serde(rename = "solr.zk.timeout")]
  solr_zk_timeout: Option<::models::ConfigNodePropertyString>,
  #[serde(rename = "solr.commit")]
  solr_commit: Option<::models::ConfigNodePropertyString>,
  #[serde(rename = "cache.on")]
  cache_on: Option<::models::ConfigNodePropertyBoolean>,
  #[serde(rename = "concurrency.level")]
  concurrency_level: Option<::models::ConfigNodePropertyInteger>,
  #[serde(rename = "cache.start.size")]
  cache_start_size: Option<::models::ConfigNodePropertyInteger>,
  #[serde(rename = "cache.ttl")]
  cache_ttl: Option<::models::ConfigNodePropertyInteger>,
  #[serde(rename = "cache.size")]
  cache_size: Option<::models::ConfigNodePropertyInteger>
}

impl ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
  pub fn new() -> ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
    ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
      solr_zk_timeout: None,
      solr_commit: None,
      cache_on: None,
      concurrency_level: None,
      cache_start_size: None,
      cache_ttl: None,
      cache_size: None
    }
  }

  pub fn set_solr_zk_timeout(&mut self, solr_zk_timeout: ::models::ConfigNodePropertyString) {
    self.solr_zk_timeout = Some(solr_zk_timeout);
  }

  pub fn with_solr_zk_timeout(mut self, solr_zk_timeout: ::models::ConfigNodePropertyString) -> ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
    self.solr_zk_timeout = Some(solr_zk_timeout);
    self
  }

  pub fn solr_zk_timeout(&self) -> Option<&::models::ConfigNodePropertyString> {
    self.solr_zk_timeout.as_ref()
  }

  pub fn reset_solr_zk_timeout(&mut self) {
    self.solr_zk_timeout = None;
  }

  pub fn set_solr_commit(&mut self, solr_commit: ::models::ConfigNodePropertyString) {
    self.solr_commit = Some(solr_commit);
  }

  pub fn with_solr_commit(mut self, solr_commit: ::models::ConfigNodePropertyString) -> ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
    self.solr_commit = Some(solr_commit);
    self
  }

  pub fn solr_commit(&self) -> Option<&::models::ConfigNodePropertyString> {
    self.solr_commit.as_ref()
  }

  pub fn reset_solr_commit(&mut self) {
    self.solr_commit = None;
  }

  pub fn set_cache_on(&mut self, cache_on: ::models::ConfigNodePropertyBoolean) {
    self.cache_on = Some(cache_on);
  }

  pub fn with_cache_on(mut self, cache_on: ::models::ConfigNodePropertyBoolean) -> ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
    self.cache_on = Some(cache_on);
    self
  }

  pub fn cache_on(&self) -> Option<&::models::ConfigNodePropertyBoolean> {
    self.cache_on.as_ref()
  }

  pub fn reset_cache_on(&mut self) {
    self.cache_on = None;
  }

  pub fn set_concurrency_level(&mut self, concurrency_level: ::models::ConfigNodePropertyInteger) {
    self.concurrency_level = Some(concurrency_level);
  }

  pub fn with_concurrency_level(mut self, concurrency_level: ::models::ConfigNodePropertyInteger) -> ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
    self.concurrency_level = Some(concurrency_level);
    self
  }

  pub fn concurrency_level(&self) -> Option<&::models::ConfigNodePropertyInteger> {
    self.concurrency_level.as_ref()
  }

  pub fn reset_concurrency_level(&mut self) {
    self.concurrency_level = None;
  }

  pub fn set_cache_start_size(&mut self, cache_start_size: ::models::ConfigNodePropertyInteger) {
    self.cache_start_size = Some(cache_start_size);
  }

  pub fn with_cache_start_size(mut self, cache_start_size: ::models::ConfigNodePropertyInteger) -> ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
    self.cache_start_size = Some(cache_start_size);
    self
  }

  pub fn cache_start_size(&self) -> Option<&::models::ConfigNodePropertyInteger> {
    self.cache_start_size.as_ref()
  }

  pub fn reset_cache_start_size(&mut self) {
    self.cache_start_size = None;
  }

  pub fn set_cache_ttl(&mut self, cache_ttl: ::models::ConfigNodePropertyInteger) {
    self.cache_ttl = Some(cache_ttl);
  }

  pub fn with_cache_ttl(mut self, cache_ttl: ::models::ConfigNodePropertyInteger) -> ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
    self.cache_ttl = Some(cache_ttl);
    self
  }

  pub fn cache_ttl(&self) -> Option<&::models::ConfigNodePropertyInteger> {
    self.cache_ttl.as_ref()
  }

  pub fn reset_cache_ttl(&mut self) {
    self.cache_ttl = None;
  }

  pub fn set_cache_size(&mut self, cache_size: ::models::ConfigNodePropertyInteger) {
    self.cache_size = Some(cache_size);
  }

  pub fn with_cache_size(mut self, cache_size: ::models::ConfigNodePropertyInteger) -> ComAdobeCqSocialDatastoreRdbImplSocialRdbResourceProviderFactorProperties {
    self.cache_size = Some(cache_size);
    self
  }

  pub fn cache_size(&self) -> Option<&::models::ConfigNodePropertyInteger> {
    self.cache_size.as_ref()
  }

  pub fn reset_cache_size(&mut self) {
    self.cache_size = None;
  }

}



